import {
  require_download
} from "./chunk-TB66MK56.js";
import {
  require_prism
} from "./chunk-KSUWW5HD.js";
import {
  require_debounce
} from "./chunk-QODJLYYY.js";
import {
  blur,
  fade,
  fly,
  scale,
  slide
} from "./chunk-KXTFNHTZ.js";
import {
  require_build
} from "./chunk-NHW6X4X2.js";
import {
  pageHasQueries,
  routeHash,
  showQueries
} from "./chunk-AOBTX4KO.js";
import {
  writable
} from "./chunk-KFI5AWRY.js";
import {
  BUILT_IN_FORMATS,
  SUPPORTED_CURRENCIES,
  applyTitleTagReplacement,
  convertColumnToDate,
  defaultExample,
  formatAxisValue,
  formatExample,
  formatValue,
  getFormatObjectFromString,
  inferColumnTypes,
  lookupColumnFormat,
  standardizeDateColumn
} from "./chunk-E6VCLJFQ.js";
import {
  complete,
  groupBy,
  max,
  median,
  min,
  mutate,
  mutateWithSummary,
  rate,
  rename,
  replaceNully,
  sum,
  summarize,
  summarizeAt,
  tidy
} from "./chunk-R5XPNIBT.js";
import "./chunk-NVEBO3I2.js";
import {
  require_ssf
} from "./chunk-7YZCULM6.js";
import "./chunk-U7DPTAY4.js";
import {
  require_echarts_stat
} from "./chunk-OFSYPRYA.js";
import {
  init as init2,
  registerMap,
  registerTheme,
  throttle
} from "./chunk-BQXUK6CW.js";
import "./chunk-OPHXJRY6.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  add_render_callback,
  afterUpdate,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  beforeUpdate,
  bind,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_block,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  flush,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  globals,
  group_outros,
  handle_promise,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onDestroy,
  onMount,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  setContext,
  set_data_dev,
  set_input_value,
  set_store_value,
  set_style,
  set_svg_attributes,
  space,
  src_url_equal,
  subscribe,
  svg_element,
  text,
  tick,
  to_number,
  toggle_class,
  transition_in,
  transition_out,
  update_await_block_branch,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-K3QP3VJG.js";
import {
  __toESM
} from "./chunk-4EOJPDL2.js";

// ../../node_modules/@evidence-dev/core-components/dist/atoms/alert/Alert.svelte
var file = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/atoms/alert/Alert.svelte";
function add_css(target) {
  append_styles(target, "svelte-1ojq947", '.alert.svelte-1ojq947{top:3.5rem;margin-bottom:1rem;border-radius:0.25rem;--tw-bg-opacity:1;background-color:rgb(249 250 251 / var(--tw-bg-opacity));padding:0.5rem;font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-size:0.875rem;line-height:1.25rem;font-weight:500;--tw-text-opacity:1;color:rgb(31 41 55 / var(--tw-text-opacity))\n}.alert.info.svelte-1ojq947{--tw-bg-opacity:1;background-color:rgb(239 246 255 / var(--tw-bg-opacity));--tw-text-opacity:1;color:hsl(217, 98%, 33%, var(--tw-text-opacity))\n}.alert.danger.svelte-1ojq947{--tw-bg-opacity:1;background-color:rgb(253 241 241 / var(--tw-bg-opacity));--tw-text-opacity:1;color:hsl(352, 90%, 35%, var(--tw-text-opacity))\n}.alert.success.svelte-1ojq947{--tw-bg-opacity:1;background-color:rgb(240 253 244 / var(--tw-bg-opacity));--tw-text-opacity:1;color:hsl(154, 95%, 23%, var(--tw-text-opacity))\n}.alert.warning.svelte-1ojq947{--tw-bg-opacity:1;background-color:rgb(254 252 232 / var(--tw-bg-opacity));--tw-text-opacity:1;color:hsl(29, 80%, 44%, var(--tw-text-opacity))\n}.alert.svelte-1ojq947 p{margin-bottom:0px\n}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWxlcnQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRCQyxNQUFBLGVBQUEsQ0FBQSxBQUVHLEdBQUEsQ0FBQSxNQUFXLENBRVgsYUFBQSxDQUFBLElBQW1CLENBRW5CLGFBQUEsQ0FBQSxPQUFzQixDQUV0QixlQUFBLENBQUEsQ0FBa0IsQ0FFbEIsZ0JBQUEsQ0FBQSxJQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLGVBQUEsQ0FBQSxDQUF5RCxDQUV6RCxPQUFBLENBQUEsTUFBZSxDQUVmLFdBQUEsQ0FBQSxhQUFBLENBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBQSxhQUFBLENBQUEsQ0FBQSxrQkFBQSxDQUFBLENBQUEsVUFBQSxDQUFBLENBQUEsTUFBQSxDQUFBLENBQUEsZ0JBQUEsQ0FBQSxDQUFBLEtBQUEsQ0FBQSxDQUFBLFdBQUEsQ0FBQSxDQUFBLFVBQUEsQ0FBQSxDQUFBLG1CQUFBLENBQUEsQ0FBQSxnQkFBQSxDQUFBLENBQUEsaUJBQUEsQ0FBQSxDQUFBLGtCQUE0TixDQUU1TixTQUFBLENBQUEsUUFBbUIsQ0FFbkIsV0FBQSxDQUFBLE9BQW9CLENBRXBCLFdBQUEsQ0FBQSxHQUFnQixDQUVoQixpQkFBQSxDQUFBLENBQW9CLENBRXBCLEtBQUEsQ0FBQSxJQUFBLEVBQUEsQ0FBQSxFQUFBLENBQUEsRUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLGlCQUFBLENBQUEsQ0FBQTtBQUNKLENBQUEsQUFFRSxNQUFBLEtBQUEsZUFBQSxDQUFBLEFBRUUsZUFBQSxDQUFBLENBQWtCLENBRWxCLGdCQUFBLENBQUEsSUFBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxlQUFBLENBQUEsQ0FBeUQsQ0FFekQsaUJBQUEsQ0FBQSxDQUFvQixDQUVwQixLQUFBLENBQUEsSUFBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxJQUFBLGlCQUFBLENBQUEsQ0FBQTtBQUNKLENBQUEsQUFFRSxNQUFBLE9BQUEsZUFBQSxDQUFBLEFBRUUsZUFBQSxDQUFBLENBQWtCLENBRWxCLGdCQUFBLENBQUEsSUFBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxlQUFBLENBQUEsQ0FBeUQsQ0FFekQsaUJBQUEsQ0FBQSxDQUFvQixDQUVwQixLQUFBLENBQUEsSUFBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxJQUFBLGlCQUFBLENBQUEsQ0FBQTtBQUNKLENBQUEsQUFFRSxNQUFBLFFBQUEsZUFBQSxDQUFBLEFBRUUsZUFBQSxDQUFBLENBQWtCLENBRWxCLGdCQUFBLENBQUEsSUFBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxlQUFBLENBQUEsQ0FBeUQsQ0FFekQsaUJBQUEsQ0FBQSxDQUFvQixDQUVwQixLQUFBLENBQUEsSUFBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxJQUFBLGlCQUFBLENBQUEsQ0FBQTtBQUNKLENBQUEsQUFFRSxNQUFBLFFBQUEsZUFBQSxDQUFBLEFBRUUsZUFBQSxDQUFBLENBQWtCLENBRWxCLGdCQUFBLENBQUEsSUFBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxlQUFBLENBQUEsQ0FBeUQsQ0FFekQsaUJBQUEsQ0FBQSxDQUFvQixDQUVwQixLQUFBLENBQUEsSUFBQSxFQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxJQUFBLGlCQUFBLENBQUEsQ0FBQTtBQUNKLENBQUEsQUFFRSxxQkFBQSxDQUFBLEFBQUEsQ0FBQSxBQUFBLENBQUEsQUFFRSxhQUFBLENBQUEsR0FBQTtBQUNKLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQWxlcnQuc3ZlbHRlIl19 */');
}
function create_fragment(ctx) {
  let div1;
  let div0;
  let div1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, role: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div0, file, 22, 1, 598);
      attr_dev(div1, "class", div1_class_value = "alert " + /*status*/
      ctx[1] + " svelte-1ojq947");
      attr_dev(div1, "role", "alert");
      toggle_class(
        div1,
        "sticky",
        /*sticky*/
        ctx[0]
      );
      add_location(div1, file, 21, 0, 542);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*status*/
      2 && div1_class_value !== (div1_class_value = "alert " + /*status*/
      ctx2[1] + " svelte-1ojq947")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*status, sticky*/
      3) {
        toggle_class(
          div1,
          "sticky",
          /*sticky*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude = true;
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Alert", slots, ["default"]);
  let { status = "default" } = $$props;
  let { sticky = false } = $$props;
  const writable_props = ["status", "sticky"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Alert> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("status" in $$props2)
      $$invalidate(1, status = $$props2.status);
    if ("sticky" in $$props2)
      $$invalidate(0, sticky = $$props2.sticky);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ evidenceInclude, status, sticky });
  $$self.$inject_state = ($$props2) => {
    if ("status" in $$props2)
      $$invalidate(1, status = $$props2.status);
    if ("sticky" in $$props2)
      $$invalidate(0, sticky = $$props2.sticky);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sticky*/
    1) {
      $:
        if (typeof sticky === "string")
          $$invalidate(0, sticky = sticky.toLowerCase() === "true");
    }
  };
  return [sticky, status, $$scope, slots];
}
var Alert = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { status: 1, sticky: 0 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Alert",
      options,
      id: create_fragment.name
    });
  }
  get status() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sticky() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sticky(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Alert_default = Alert;

// ../../node_modules/@steeze-ui/tabler-icons/dist/index.js
var ChevronDown = { "default": { "a": { "class": "icon icon-tabler icon-tabler-chevron-down", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M6 9l6 6l6 -6" }] } };
var ChevronLeft = { "default": { "a": { "class": "icon icon-tabler icon-tabler-chevron-left", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M15 6l-6 6l6 6" }] } };
var ChevronRight = { "default": { "a": { "class": "icon icon-tabler icon-tabler-chevron-right", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M9 6l6 6l-6 6" }] } };
var ChevronUp = { "default": { "a": { "class": "icon icon-tabler icon-tabler-chevron-up", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M6 15l6 -6l6 6" }] } };
var ChevronsLeft = { "default": { "a": { "class": "icon icon-tabler icon-tabler-chevrons-left", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M11 7l-5 5l5 5" }, { "d": "M17 7l-5 5l5 5" }] } };
var ChevronsRight = { "default": { "a": { "class": "icon icon-tabler icon-tabler-chevrons-right", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M7 7l5 5l-5 5" }, { "d": "M13 7l5 5l-5 5" }] } };
var CircleCheck = { "default": { "a": { "class": "icon icon-tabler icon-tabler-circle-check", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }, { "d": "M9 12l2 2l4 -4" }] }, "filled": { "a": { "class": "icon icon-tabler icon-tabler-circle-check-filled", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M17 3.34a10 10 0 1 1 -14.995 8.984l-.005 -.324l.005 -.324a10 10 0 0 1 14.995 -8.336zm-1.293 5.953a1 1 0 0 0 -1.32 -.083l-.094 .083l-3.293 3.292l-1.293 -1.292l-.094 -.083a1 1 0 0 0 -1.403 1.403l.083 .094l2 2l.094 .083a1 1 0 0 0 1.226 0l.094 -.083l4 -4l.083 -.094a1 1 0 0 0 -.083 -1.32z", "stroke-width": "0", "fill": "currentColor" }] } };
var CircleX = { "default": { "a": { "class": "icon icon-tabler icon-tabler-circle-x", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }, { "d": "M10 10l4 4m0 -4l-4 4" }] }, "filled": { "a": { "class": "icon icon-tabler icon-tabler-circle-x-filled", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M17 3.34a10 10 0 1 1 -14.995 8.984l-.005 -.324l.005 -.324a10 10 0 0 1 14.995 -8.336zm-6.489 5.8a1 1 0 0 0 -1.218 1.567l1.292 1.293l-1.292 1.293l-.083 .094a1 1 0 0 0 1.497 1.32l1.293 -1.292l1.293 1.292l.094 .083a1 1 0 0 0 1.32 -1.497l-1.292 -1.293l1.292 -1.293l.083 -.094a1 1 0 0 0 -1.497 -1.32l-1.293 1.292l-1.293 -1.292l-.094 -.083z", "stroke-width": "0", "fill": "currentColor" }] } };
var Clipboard = { "default": { "a": { "class": "icon icon-tabler icon-tabler-clipboard", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" }, { "d": "M9 3m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v0a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z" }] } };
var DotsVertical = { "default": { "a": { "class": "icon icon-tabler icon-tabler-dots-vertical", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" }, { "d": "M12 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" }, { "d": "M12 5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" }] } };
var ExternalLink = { "default": { "a": { "class": "icon icon-tabler icon-tabler-external-link", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6" }, { "d": "M11 13l9 -9" }, { "d": "M15 4h5v5" }] } };
var HelpCircle = { "default": { "a": { "class": "icon icon-tabler icon-tabler-help-circle", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" }, { "d": "M12 16v.01" }, { "d": "M12 13a2 2 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483" }] }, "filled": { "a": { "class": "icon icon-tabler icon-tabler-help-circle-filled", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M12 2c5.523 0 10 4.477 10 10a10 10 0 0 1 -19.995 .324l-.005 -.324l.004 -.28c.148 -5.393 4.566 -9.72 9.996 -9.72zm0 13a1 1 0 0 0 -.993 .883l-.007 .117l.007 .127a1 1 0 0 0 1.986 0l.007 -.117l-.007 -.127a1 1 0 0 0 -.993 -.883zm1.368 -6.673a2.98 2.98 0 0 0 -3.631 .728a1 1 0 0 0 1.44 1.383l.171 -.18a.98 .98 0 0 1 1.11 -.15a1 1 0 0 1 -.34 1.886l-.232 .012a1 1 0 0 0 .111 1.994a3 3 0 0 0 1.371 -5.673z", "stroke-width": "0", "fill": "currentColor" }] } };
var Home = { "default": { "a": { "class": "icon icon-tabler icon-tabler-home", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M5 12l-2 0l9 -9l9 9l-2 0" }, { "d": "M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" }, { "d": "M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" }] } };
var InfoCircle = { "default": { "a": { "class": "icon icon-tabler icon-tabler-info-circle", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" }, { "d": "M12 9h.01" }, { "d": "M11 12h1v4h1" }] }, "filled": { "a": { "class": "icon icon-tabler icon-tabler-info-circle-filled", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M12 2c5.523 0 10 4.477 10 10a10 10 0 0 1 -19.995 .324l-.005 -.324l.004 -.28c.148 -5.393 4.566 -9.72 9.996 -9.72zm0 9h-1l-.117 .007a1 1 0 0 0 0 1.986l.117 .007v3l.007 .117a1 1 0 0 0 .876 .876l.117 .007h1l.117 -.007a1 1 0 0 0 .876 -.876l.007 -.117l-.007 -.117a1 1 0 0 0 -.764 -.857l-.112 -.02l-.117 -.006v-3l-.007 -.117a1 1 0 0 0 -.876 -.876l-.117 -.007zm.01 -3l-.127 .007a1 1 0 0 0 0 1.986l.117 .007l.127 -.007a1 1 0 0 0 0 -1.986l-.117 -.007z", "stroke-width": "0", "fill": "currentColor" }] } };
var Search = { "default": { "a": { "class": "icon icon-tabler icon-tabler-search", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" }, { "d": "M21 21l-6 -6" }] } };
var Settings = { "default": { "a": { "class": "icon icon-tabler icon-tabler-settings", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z" }, { "d": "M9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0" }] }, "filled": { "a": { "class": "icon icon-tabler icon-tabler-settings-filled", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M14.647 4.081a.724 .724 0 0 0 1.08 .448c2.439 -1.485 5.23 1.305 3.745 3.744a.724 .724 0 0 0 .447 1.08c2.775 .673 2.775 4.62 0 5.294a.724 .724 0 0 0 -.448 1.08c1.485 2.439 -1.305 5.23 -3.744 3.745a.724 .724 0 0 0 -1.08 .447c-.673 2.775 -4.62 2.775 -5.294 0a.724 .724 0 0 0 -1.08 -.448c-2.439 1.485 -5.23 -1.305 -3.745 -3.744a.724 .724 0 0 0 -.447 -1.08c-2.775 -.673 -2.775 -4.62 0 -5.294a.724 .724 0 0 0 .448 -1.08c-1.485 -2.439 1.305 -5.23 3.744 -3.745a.722 .722 0 0 0 1.08 -.447c.673 -2.775 4.62 -2.775 5.294 0zm-2.647 4.919a3 3 0 1 0 0 6a3 3 0 0 0 0 -6z", "stroke-width": "0", "fill": "currentColor" }] } };
var X = { "default": { "a": { "class": "icon icon-tabler icon-tabler-x", "width": "24", "height": "24", "viewBox": "0 0 24 24", "stroke-width": "2", "stroke": "currentColor", "fill": "none", "stroke-linecap": "round", "stroke-linejoin": "round" }, "path": [{ "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" }, { "d": "M18 6l-12 12" }, { "d": "M6 6l12 12" }] } };

// ../../node_modules/@evidence-dev/core-components/node_modules/@steeze-ui/svelte-icon/dist/Icon.svelte
var file2 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/node_modules/@steeze-ui/svelte-icon/dist/Icon.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file2, 19, 2, 482);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2)
        set_data_dev(
          t,
          /*title*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(19:1) {#if title}",
    ctx
  });
  return block;
}
function create_each_block_5(ctx) {
  let path;
  let path_levels = [
    /*a*/
    ctx[6]
  ];
  let path_data = {};
  for (let i = 0; i < path_levels.length; i += 1) {
    path_data = assign(path_data, path_levels[i]);
  }
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {});
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(path, path_data);
      add_location(path, file2, 23, 2, 546);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(path, path_data = get_spread_update(path_levels, [dirty & /*icon*/
      4 && /*a*/
      ctx2[6]]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_5.name,
    type: "each",
    source: "(23:1) {#each icon?.path ?? [] as a}",
    ctx
  });
  return block;
}
function create_each_block_4(ctx) {
  let rect;
  let rect_levels = [
    /*a*/
    ctx[6]
  ];
  let rect_data = {};
  for (let i = 0; i < rect_levels.length; i += 1) {
    rect_data = assign(rect_data, rect_levels[i]);
  }
  const block = {
    c: function create() {
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {});
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(rect, rect_data);
      add_location(rect, file2, 26, 2, 604);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(rect, rect_data = get_spread_update(rect_levels, [dirty & /*icon*/
      4 && /*a*/
      ctx2[6]]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(rect);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_4.name,
    type: "each",
    source: "(26:1) {#each icon?.rect ?? [] as a}",
    ctx
  });
  return block;
}
function create_each_block_3(ctx) {
  let circle;
  let circle_levels = [
    /*a*/
    ctx[6]
  ];
  let circle_data = {};
  for (let i = 0; i < circle_levels.length; i += 1) {
    circle_data = assign(circle_data, circle_levels[i]);
  }
  const block = {
    c: function create() {
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {});
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(circle, circle_data);
      add_location(circle, file2, 29, 2, 664);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(circle, circle_data = get_spread_update(circle_levels, [dirty & /*icon*/
      4 && /*a*/
      ctx2[6]]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(29:1) {#each icon?.circle ?? [] as a}",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let polygon;
  let polygon_levels = [
    /*a*/
    ctx[6]
  ];
  let polygon_data = {};
  for (let i = 0; i < polygon_levels.length; i += 1) {
    polygon_data = assign(polygon_data, polygon_levels[i]);
  }
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {});
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(polygon, polygon_data);
      add_location(polygon, file2, 32, 2, 727);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(polygon, polygon_data = get_spread_update(polygon_levels, [dirty & /*icon*/
      4 && /*a*/
      ctx2[6]]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(32:1) {#each icon?.polygon ?? [] as a}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let polyline;
  let polyline_levels = [
    /*a*/
    ctx[6]
  ];
  let polyline_data = {};
  for (let i = 0; i < polyline_levels.length; i += 1) {
    polyline_data = assign(polyline_data, polyline_levels[i]);
  }
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {});
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(polyline, polyline_data);
      add_location(polyline, file2, 35, 2, 792);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(polyline, polyline_data = get_spread_update(polyline_levels, [dirty & /*icon*/
      4 && /*a*/
      ctx2[6]]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(35:1) {#each icon?.polyline ?? [] as a}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let line;
  let line_levels = [
    /*a*/
    ctx[6]
  ];
  let line_data = {};
  for (let i = 0; i < line_levels.length; i += 1) {
    line_data = assign(line_data, line_levels[i]);
  }
  const block = {
    c: function create() {
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {});
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(line, line_data);
      add_location(line, file2, 38, 2, 854);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(line, line_data = get_spread_update(line_levels, [dirty & /*icon*/
      4 && /*a*/
      ctx2[6]]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(38:1) {#each icon?.line ?? [] as a}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  var _a, _b, _c, _d, _e, _f, _g;
  let svg;
  let if_block_anchor;
  let each0_anchor;
  let each1_anchor;
  let each2_anchor;
  let each3_anchor;
  let each4_anchor;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block(ctx)
  );
  let each_value_5 = (
    /*icon*/
    ((_a = ctx[2]) == null ? void 0 : _a.path) ?? []
  );
  validate_each_argument(each_value_5);
  let each_blocks_5 = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks_5[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  let each_value_4 = (
    /*icon*/
    ((_b = ctx[2]) == null ? void 0 : _b.rect) ?? []
  );
  validate_each_argument(each_value_4);
  let each_blocks_4 = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks_4[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  let each_value_3 = (
    /*icon*/
    ((_c = ctx[2]) == null ? void 0 : _c.circle) ?? []
  );
  validate_each_argument(each_value_3);
  let each_blocks_3 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_3[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_2 = (
    /*icon*/
    ((_d = ctx[2]) == null ? void 0 : _d.polygon) ?? []
  );
  validate_each_argument(each_value_2);
  let each_blocks_2 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value_1 = (
    /*icon*/
    ((_e = ctx[2]) == null ? void 0 : _e.polyline) ?? []
  );
  validate_each_argument(each_value_1);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = (
    /*icon*/
    ((_f = ctx[2]) == null ? void 0 : _f.line) ?? []
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let svg_levels = [
    /*icon*/
    (_g = ctx[2]) == null ? void 0 : _g.a,
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks_5.length; i += 1) {
        each_blocks_5[i].c();
      }
      each0_anchor = empty();
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        each_blocks_4[i].c();
      }
      each1_anchor = empty();
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        each_blocks_3[i].c();
      }
      each2_anchor = empty();
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].c();
      }
      each3_anchor = empty();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      each4_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, width: true, height: true });
      var svg_nodes = children(svg);
      if (if_block)
        if_block.l(svg_nodes);
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks_5.length; i += 1) {
        each_blocks_5[i].l(svg_nodes);
      }
      each0_anchor = empty();
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        each_blocks_4[i].l(svg_nodes);
      }
      each1_anchor = empty();
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        each_blocks_3[i].l(svg_nodes);
      }
      each2_anchor = empty();
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].l(svg_nodes);
      }
      each3_anchor = empty();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(svg_nodes);
      }
      each4_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(svg_nodes);
      }
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(svg, svg_data);
      add_location(svg, file2, 17, 0, 369);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_hydration_dev(svg, if_block_anchor);
      for (let i = 0; i < each_blocks_5.length; i += 1) {
        each_blocks_5[i].m(svg, null);
      }
      append_hydration_dev(svg, each0_anchor);
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        each_blocks_4[i].m(svg, null);
      }
      append_hydration_dev(svg, each1_anchor);
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        each_blocks_3[i].m(svg, null);
      }
      append_hydration_dev(svg, each2_anchor);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].m(svg, null);
      }
      append_hydration_dev(svg, each3_anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(svg, null);
      }
      append_hydration_dev(svg, each4_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(svg, null);
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(svg, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*icon*/
      4) {
        each_value_5 = /*icon*/
        ((_a2 = ctx2[2]) == null ? void 0 : _a2.path) ?? [];
        validate_each_argument(each_value_5);
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx2, each_value_5, i);
          if (each_blocks_5[i]) {
            each_blocks_5[i].p(child_ctx, dirty);
          } else {
            each_blocks_5[i] = create_each_block_5(child_ctx);
            each_blocks_5[i].c();
            each_blocks_5[i].m(svg, each0_anchor);
          }
        }
        for (; i < each_blocks_5.length; i += 1) {
          each_blocks_5[i].d(1);
        }
        each_blocks_5.length = each_value_5.length;
      }
      if (dirty & /*icon*/
      4) {
        each_value_4 = /*icon*/
        ((_b2 = ctx2[2]) == null ? void 0 : _b2.rect) ?? [];
        validate_each_argument(each_value_4);
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i);
          if (each_blocks_4[i]) {
            each_blocks_4[i].p(child_ctx, dirty);
          } else {
            each_blocks_4[i] = create_each_block_4(child_ctx);
            each_blocks_4[i].c();
            each_blocks_4[i].m(svg, each1_anchor);
          }
        }
        for (; i < each_blocks_4.length; i += 1) {
          each_blocks_4[i].d(1);
        }
        each_blocks_4.length = each_value_4.length;
      }
      if (dirty & /*icon*/
      4) {
        each_value_3 = /*icon*/
        ((_c2 = ctx2[2]) == null ? void 0 : _c2.circle) ?? [];
        validate_each_argument(each_value_3);
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_3[i]) {
            each_blocks_3[i].p(child_ctx, dirty);
          } else {
            each_blocks_3[i] = create_each_block_3(child_ctx);
            each_blocks_3[i].c();
            each_blocks_3[i].m(svg, each2_anchor);
          }
        }
        for (; i < each_blocks_3.length; i += 1) {
          each_blocks_3[i].d(1);
        }
        each_blocks_3.length = each_value_3.length;
      }
      if (dirty & /*icon*/
      4) {
        each_value_2 = /*icon*/
        ((_d2 = ctx2[2]) == null ? void 0 : _d2.polygon) ?? [];
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_2[i]) {
            each_blocks_2[i].p(child_ctx, dirty);
          } else {
            each_blocks_2[i] = create_each_block_2(child_ctx);
            each_blocks_2[i].c();
            each_blocks_2[i].m(svg, each3_anchor);
          }
        }
        for (; i < each_blocks_2.length; i += 1) {
          each_blocks_2[i].d(1);
        }
        each_blocks_2.length = each_value_2.length;
      }
      if (dirty & /*icon*/
      4) {
        each_value_1 = /*icon*/
        ((_e2 = ctx2[2]) == null ? void 0 : _e2.polyline) ?? [];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(svg, each4_anchor);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*icon*/
      4) {
        each_value = /*icon*/
        ((_f2 = ctx2[2]) == null ? void 0 : _f2.line) ?? [];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(svg, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*icon*/
        4 && /*icon*/
        ((_g2 = ctx2[2]) == null ? void 0 : _g2.a),
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks_5, detaching);
      destroy_each(each_blocks_4, detaching);
      destroy_each(each_blocks_3, detaching);
      destroy_each(each_blocks_2, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let icon;
  const omit_props_names = ["src", "size", "theme", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icon", slots, []);
  let { src } = $$props;
  let { size = "100%" } = $$props;
  let { theme = "default" } = $$props;
  let { title = void 0 } = $$props;
  if (size !== "100%") {
    if (size.slice(-1) != "x" && size.slice(-1) != "m" && size.slice(-1) != "%") {
      try {
        size = parseInt(size) + "px";
      } catch (error) {
        size = "100%";
      }
    }
  }
  $$self.$$.on_mount.push(function() {
    if (src === void 0 && !("src" in $$props || $$self.$$.bound[$$self.$$.props["src"]])) {
      console.warn("<Icon> was created without expected prop 'src'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("src" in $$new_props)
      $$invalidate(4, src = $$new_props.src);
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("theme" in $$new_props)
      $$invalidate(5, theme = $$new_props.theme);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ src, size, theme, title, icon });
  $$self.$inject_state = ($$new_props) => {
    if ("src" in $$props)
      $$invalidate(4, src = $$new_props.src);
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("theme" in $$props)
      $$invalidate(5, theme = $$new_props.theme);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("icon" in $$props)
      $$invalidate(2, icon = $$new_props.icon);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*src, theme*/
    48) {
      $:
        $$invalidate(2, icon = (src == null ? void 0 : src[theme]) ?? (src == null ? void 0 : src["default"]));
    }
  };
  return [size, title, icon, $$restProps, src, theme];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { src: 4, size: 0, theme: 5, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment2.name
    });
  }
  get src() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icon_default = Icon;

// ../../node_modules/@evidence-dev/core-components/dist/atoms/copy-button/CopyButton.svelte
var file3 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/atoms/copy-button/CopyButton.svelte";
function create_if_block2(ctx) {
  let p;
  let t;
  let p_transition;
  let current;
  const block = {
    c: function create() {
      p = element("p");
      t = text("Copied to clipboard");
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      t = claim_text(p_nodes, "Copied to clipboard");
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "class", "absolute -bottom-14 right-0 text-sm bg-white/80 w-[17ch] text-center font-sans p-2 border border-gray-950 rounded");
      add_location(p, file3, 16, 2, 387);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, fade, { duration: 250 }, true);
        p_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      if (!p_transition)
        p_transition = create_bidirectional_transition(p, fade, { duration: 250 }, false);
      p_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (detaching && p_transition)
        p_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(16:1) {#if copied}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div;
  let t;
  let button;
  let icon;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*copied*/
    ctx[0] && create_if_block2(ctx)
  );
  icon = new Icon_default({
    props: { src: Clipboard, class: "w-4 h-4" },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      t = claim_space(div_nodes);
      button = claim_element(div_nodes, "BUTTON", { class: true, title: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "bg-white/80 border border-gray-950 rounded p-2 hover:bg-gray-200/80 active:bg-gray-400/80");
      attr_dev(button, "title", "Copy to Clipboard");
      add_location(button, file3, 23, 1, 596);
      attr_dev(div, "class", "relative");
      add_location(div, file3, 14, 0, 348);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_hydration_dev(div, t);
      append_hydration_dev(div, button);
      mount_component(icon, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*copy*/
          ctx[1],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*copied*/
        ctx2[0]
      ) {
        if (if_block) {
          if (dirty & /*copied*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CopyButton", slots, []);
  let { textToCopy = "" } = $$props;
  let copied = false;
  const copy = () => {
    navigator.clipboard.writeText(textToCopy);
    $$invalidate(0, copied = true);
    setTimeout(() => $$invalidate(0, copied = false), 1e3);
  };
  const writable_props = ["textToCopy"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CopyButton> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("textToCopy" in $$props2)
      $$invalidate(2, textToCopy = $$props2.textToCopy);
  };
  $$self.$capture_state = () => ({
    fade,
    Clipboard,
    Icon: Icon_default,
    textToCopy,
    copied,
    copy
  });
  $$self.$inject_state = ($$props2) => {
    if ("textToCopy" in $$props2)
      $$invalidate(2, textToCopy = $$props2.textToCopy);
    if ("copied" in $$props2)
      $$invalidate(0, copied = $$props2.copied);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [copied, copy, textToCopy];
}
var CopyButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { textToCopy: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CopyButton",
      options,
      id: create_fragment3.name
    });
  }
  get textToCopy() {
    throw new Error("<CopyButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textToCopy(value) {
    throw new Error("<CopyButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CopyButton_default = CopyButton;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ContentsList.svelte
var file4 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ContentsList.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1d905x0", "a.svelte-1d905x0{display:block;-webkit-padding-after:0.6em;padding-block-end:0.6em;-webkit-padding-before:0em;padding-block-start:0em;font-size:0.7em;text-decoration:none;color:var(--grey-800);transition-property:border color;transition-duration:600ms;font-family:var(--ui-font-family-compact)}a.svelte-1d905x0:hover{color:var(--blue-600);transition-property:color border;transition-duration:600ms}a.h2.svelte-1d905x0{padding-left:0.8em;border-left:1px solid var(--grey-200)}a.h2.svelte-1d905x0:hover{border-left:1px solid var(--blue-200)}a.h1.svelte-1d905x0{-webkit-margin-before:0.6em;margin-block-start:0.6em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udGVudHNMaXN0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE0QkMsQ0FBQSxlQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsS0FBYyxDQUNkLHFCQUFBLENBQUEsS0FBNEIsQ0FDcEIsaUJBQUEsQ0FBQSxLQUF3QixDQUNoQyxzQkFBQSxDQUFBLEdBQTJCLENBQ25CLG1CQUFBLENBQUEsR0FBd0IsQ0FDaEMsU0FBQSxDQUFBLEtBQWdCLENBQ2hCLGVBQUEsQ0FBQSxJQUFxQixDQUNyQixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLG1CQUFBLENBQUEsTUFBQSxDQUFBLEtBQWlDLENBQ2pDLG1CQUFBLENBQUEsS0FBMEIsQ0FDMUIsV0FBQSxDQUFBLElBQUEsd0JBQUEsQ0FBMEMsQUFDM0MsQ0FBQSxBQUVBLGdCQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixtQkFBQSxDQUFBLEtBQUEsQ0FBQSxNQUFpQyxDQUNqQyxtQkFBQSxDQUFBLEtBQTBCLEFBQzNCLENBQUEsQUFFQSxDQUFBLEdBQUEsZUFBQSxDQUFBLEFBRUMsWUFBQSxDQUFBLEtBQW1CLENBQ25CLFdBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQyxBQUN2QyxDQUFBLEFBRUEsQ0FBQSxrQkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLFdBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQyxBQUN2QyxDQUFBLEFBRUEsQ0FBQSxHQUFBLGVBQUEsQ0FBQSxBQUNDLHFCQUFBLENBQUEsS0FBNEIsQ0FDcEIsa0JBQUEsQ0FBQSxLQUF5QixBQUNsQyxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNvbnRlbnRzTGlzdC5zdmVsdGUiXX0= */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  child_ctx[3] = i;
  return child_ctx;
}
function create_if_block3(ctx) {
  let each_1_anchor;
  let each_value = (
    /*headers*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*encodeURIComponent, headers*/
      1) {
        each_value = /*headers*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(17:0) {#if headers && headers.length > 1}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let a;
  let t0_value = (
    /*header*/
    ctx[1].innerText + ""
  );
  let t0;
  let t1;
  let a_href_value;
  let a_class_value;
  const block = {
    c: function create() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      t0 = claim_text(a_nodes, t0_value);
      t1 = claim_space(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = "#" + encodeURIComponent(
        /*header*/
        ctx[1].innerText + /*i*/
        ctx[3]
      ));
      attr_dev(a, "class", a_class_value = null_to_empty(
        /*header*/
        ctx[1].nodeName == "H1" ? "h1" : "h2"
      ) + " svelte-1d905x0");
      add_location(a, file4, 18, 2, 457);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t0);
      append_hydration_dev(a, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*headers*/
      1 && t0_value !== (t0_value = /*header*/
      ctx2[1].innerText + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*headers*/
      1 && a_href_value !== (a_href_value = "#" + encodeURIComponent(
        /*header*/
        ctx2[1].innerText + /*i*/
        ctx2[3]
      ))) {
        attr_dev(a, "href", a_href_value);
      }
      if (dirty & /*headers*/
      1 && a_class_value !== (a_class_value = null_to_empty(
        /*header*/
        ctx2[1].nodeName == "H1" ? "h1" : "h2"
      ) + " svelte-1d905x0")) {
        attr_dev(a, "class", a_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(18:1) {#each headers as header, i}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let if_block_anchor;
  let if_block = (
    /*headers*/
    ctx[0] && /*headers*/
    ctx[0].length > 1 && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*headers*/
        ctx2[0] && /*headers*/
        ctx2[0].length > 1
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude2 = true;
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContentsList", slots, []);
  let headers;
  onMount(() => {
    $$invalidate(0, headers = document.querySelector("article").querySelectorAll("h1, h2"));
    headers.forEach((header, i) => {
      header.id = encodeURIComponent(header.innerText + i);
    });
  });
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ContentsList> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({ evidenceInclude: evidenceInclude2, onMount, headers });
  $$self.$inject_state = ($$props2) => {
    if ("headers" in $$props2)
      $$invalidate(0, headers = $$props2.headers);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [headers];
}
var ContentsList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {}, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContentsList",
      options,
      id: create_fragment4.name
    });
  }
};
var ContentsList_default = ContentsList;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/QueryStatus.svelte
import { invalidate } from "$app/navigation";
import { page } from "$app/stores";

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/delay.js
var delay = (ms) => new Promise((res) => setTimeout(res, ms));

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryToast.svelte
var file5 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryToast.svelte";
function add_css3(target) {
  append_styles(target, "svelte-5dxn6h", "#toast.svelte-5dxn6h{border-radius:4px;padding:0.3em 0.75em;margin:1em 0;box-shadow:0 1px 3px rgba(0, 0, 0, 0.6);box-shadow:0 1px 2px rgba(0, 0, 0, 0.12);font-size:0.7em;font-family:var(--monospace-font-family);display:flex;justify-content:space-between}div.running.svelte-5dxn6h{border:1px solid var(--grey-400);background-color:white;color:var(--grey-999);transition:all 400ms}div.error.svelte-5dxn6h{border:1px solid var(--red-500);background-color:var(--red-100);color:var(--red-999);transition:all 400ms}div.done.svelte-5dxn6h{border:1px solid var(--green-500);background-color:var(--green-100);color:var(--green-999);transition:all 400ms}span.svelte-5dxn6h{cursor:pointer}span.queryID.svelte-5dxn6h{font-weight:bold}@media print{#toast.svelte-5dxn6h{display:none}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUXVlcnlUb2FzdC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBc0NDLE1BQUEsY0FBQSxDQUFBLEFBQ0MsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLE9BQUEsQ0FBQSxLQUFBLENBQUEsTUFBcUIsQ0FDckIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxDQUFhLENBR2IsVUFBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUF3QyxDQUN4QyxVQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQXlDLENBQ3pDLFNBQUEsQ0FBQSxLQUFnQixDQUNoQixXQUFBLENBQUEsSUFBQSx1QkFBQSxDQUF5QyxDQUN6QyxPQUFBLENBQUEsSUFBYSxDQUNiLGVBQUEsQ0FBQSxhQUE4QixBQUUvQixDQUFBLEFBRUEsR0FBQSxRQUFBLGNBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxnQkFBQSxDQUFBLEtBQXVCLENBQ3ZCLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsVUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFxQixBQUN0QixDQUFBLEFBRUEsR0FBQSxNQUFBLGNBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsU0FBQSxDQUFnQyxDQUNoQyxnQkFBQSxDQUFBLElBQUEsU0FBQSxDQUFnQyxDQUNoQyxLQUFBLENBQUEsSUFBQSxTQUFBLENBQXFCLENBQ3JCLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBcUIsQUFDdEIsQ0FBQSxBQUVBLEdBQUEsS0FBQSxjQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFdBQUEsQ0FBa0MsQ0FDbEMsZ0JBQUEsQ0FBQSxJQUFBLFdBQUEsQ0FBa0MsQ0FDbEMsS0FBQSxDQUFBLElBQUEsV0FBQSxDQUF1QixDQUN2QixVQUFBLENBQUEsR0FBQSxDQUFBLEtBQXFCLEFBQ3RCLENBQUEsQUFFQSxJQUFBLGNBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxPQUFlLEFBQ2hCLENBQUEsQUFFQSxJQUFBLFFBQUEsY0FBQSxDQUFBLEFBQ0MsV0FBQSxDQUFBLElBQWlCLEFBQ2xCLENBQUEsQUFFQSxPQUFBLEtBQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSxjQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFDRCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlF1ZXJ5VG9hc3Quc3ZlbHRlIl19 */");
}
function create_if_block4(ctx) {
  let div;
  let span0;
  let t0_value = (
    /*status*/
    ctx[0].id + ""
  );
  let t0;
  let t1;
  let span1;
  let t2_value = (
    /*status*/
    ctx[0].status + ""
  );
  let t2;
  let div_intro;
  let div_outro;
  let current;
  const block = {
    c: function create() {
      div = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true, class: true });
      var div_nodes = children(div);
      span0 = claim_element(div_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      span1 = claim_element(div_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, t2_value);
      span1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "queryID svelte-5dxn6h");
      add_location(span0, file5, 28, 2, 676);
      attr_dev(span1, "class", "status svelte-5dxn6h");
      add_location(span1, file5, 31, 2, 726);
      attr_dev(div, "id", "toast");
      attr_dev(div, "class", "svelte-5dxn6h");
      toggle_class(
        div,
        "running",
        /*status*/
        ctx[0].status === "running" || /*status*/
        ctx[0].status === "not run"
      );
      toggle_class(
        div,
        "error",
        /*status*/
        ctx[0].status === "error"
      );
      toggle_class(
        div,
        "done",
        /*status*/
        ctx[0].status === "done" || /*status*/
        ctx[0].status === "from cache"
      );
      add_location(div, file5, 20, 1, 379);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, span1);
      append_hydration_dev(span1, t2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*status*/
      1) && t0_value !== (t0_value = /*status*/
      ctx2[0].id + ""))
        set_data_dev(t0, t0_value);
      if ((!current || dirty & /*status*/
      1) && t2_value !== (t2_value = /*status*/
      ctx2[0].status + ""))
        set_data_dev(t2, t2_value);
      if (!current || dirty & /*status*/
      1) {
        toggle_class(
          div,
          "running",
          /*status*/
          ctx2[0].status === "running" || /*status*/
          ctx2[0].status === "not run"
        );
      }
      if (!current || dirty & /*status*/
      1) {
        toggle_class(
          div,
          "error",
          /*status*/
          ctx2[0].status === "error"
        );
      }
      if (!current || dirty & /*status*/
      1) {
        toggle_class(
          div,
          "done",
          /*status*/
          ctx2[0].status === "done" || /*status*/
          ctx2[0].status === "from cache"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(div, scale, {});
        div_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, fly, {
          x: 1e3,
          duration: 1e3,
          delay: 0,
          opacity: 0.8
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (detaching && div_outro)
        div_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(20:0) {#if visible}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let if_block = (
    /*visible*/
    ctx[1] && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*visible*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*visible*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      transition_in(if_block);
    },
    o: function outro(local) {
      transition_out(if_block);
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude3 = true;
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("QueryToast", slots, []);
  let { status } = $$props;
  let visible = true;
  onMount(async () => {
    await delay(5e3);
    $$invalidate(1, visible = false);
  });
  $$self.$$.on_mount.push(function() {
    if (status === void 0 && !("status" in $$props || $$self.$$.bound[$$self.$$.props["status"]])) {
      console.warn("<QueryToast> was created without expected prop 'status'");
    }
  });
  const writable_props = ["status"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<QueryToast> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("status" in $$props2)
      $$invalidate(0, status = $$props2.status);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude3,
    delay,
    onMount,
    scale,
    fly,
    status,
    visible
  });
  $$self.$inject_state = ($$props2) => {
    if ("status" in $$props2)
      $$invalidate(0, status = $$props2.status);
    if ("visible" in $$props2)
      $$invalidate(1, visible = $$props2.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [status, visible];
}
var QueryToast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { status: 0 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "QueryToast",
      options,
      id: create_fragment5.name
    });
  }
  get status() {
    throw new Error("<QueryToast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error("<QueryToast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var QueryToast_default = QueryToast;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/QueryStatus.svelte
var { Error: Error_1 } = globals;
var file6 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/QueryStatus.svelte";
function add_css4(target) {
  append_styles(target, "svelte-1923owq", "div.container.svelte-1923owq{z-index:1;position:fixed;right:0;bottom:0;margin:1.5em 2.5em;width:20em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUXVlcnlTdGF0dXMuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWdGQyxHQUFBLFVBQUEsZUFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLENBQVUsQ0FDVixRQUFBLENBQUEsS0FBZSxDQUNmLEtBQUEsQ0FBQSxDQUFRLENBQ1IsTUFBQSxDQUFBLENBQVMsQ0FDVCxNQUFBLENBQUEsS0FBQSxDQUFBLEtBQW1CLENBQ25CLEtBQUEsQ0FBQSxJQUFXLEFBQ1osQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJRdWVyeVN0YXR1cy5zdmVsdGUiXX0= */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  child_ctx[10] = list;
  child_ctx[11] = i;
  return child_ctx;
}
function create_each_block3(ctx) {
  let querytoast;
  let updating_status;
  let current;
  function querytoast_status_binding(value) {
    ctx[3](
      value,
      /*status*/
      ctx[9],
      /*each_value*/
      ctx[10],
      /*status_index*/
      ctx[11]
    );
  }
  let querytoast_props = {};
  if (
    /*status*/
    ctx[9] !== void 0
  ) {
    querytoast_props.status = /*status*/
    ctx[9];
  }
  querytoast = new QueryToast_default({ props: querytoast_props, $$inline: true });
  binding_callbacks.push(() => bind(
    querytoast,
    "status",
    querytoast_status_binding,
    /*status*/
    ctx[9]
  ));
  const block = {
    c: function create() {
      create_component(querytoast.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(querytoast.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(querytoast, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const querytoast_changes = {};
      if (!updating_status && dirty & /*activeStatuses*/
      1) {
        updating_status = true;
        querytoast_changes.status = /*status*/
        ctx[9];
        add_flush_callback(() => updating_status = false);
      }
      querytoast.$set(querytoast_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(querytoast.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(querytoast.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(querytoast, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(75:1) {#each activeStatuses as status}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let div;
  let current;
  let each_value = (
    /*activeStatuses*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "container svelte-1923owq");
      add_location(div, file6, 73, 0, 2006);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*activeStatuses*/
      1) {
        each_value = /*activeStatuses*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude4 = true;
function instance6($$self, $$props, $$invalidate) {
  let activeStatuses;
  let $routeHash;
  let $page;
  validate_store(routeHash, "routeHash");
  component_subscribe($$self, routeHash, ($$value) => $$invalidate(5, $routeHash = $$value));
  validate_store(page, "page");
  component_subscribe($$self, page, ($$value) => $$invalidate(6, $page = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("QueryStatus", slots, []);
  let { endpoint = "" } = $$props;
  let statuses = [];
  let previousStatuses = [];
  async function getStatus() {
    if (endpoint == "") {
      return [];
    }
    let statusEndpoint = `/api/status${$page.route.id}`.replace(/\/$/, "");
    const res = await fetch(statusEndpoint);
    const { status } = await res.json();
    if (res.ok) {
      return status;
    } else {
      throw new Error(status);
    }
  }
  async function checkStatusAndInvalidate() {
    $$invalidate(2, statuses = await getStatus());
    if (previousStatuses.length !== 0 && statuses.length != previousStatuses.length) {
      await invalidate((url) => url.pathname === `/api/${endpoint}.json`);
    }
    if (statuses.length > 0) {
      for (let i = 0; i < statuses.length; i++) {
        const query = statuses[i];
        if (query.status === "not run") {
          await invalidate((url) => url.pathname === `/api/${endpoint}.json`);
          await invalidate((url) => url.pathname === window.location.pathname);
          await delay(1e3);
        }
      }
      activeStatuses.push(...statuses);
    }
    previousStatuses = statuses;
  }
  onMount(() => {
    $$invalidate(1, endpoint = $routeHash);
    let keep_running = true;
    const loop = async () => {
      while (keep_running) {
        await checkStatusAndInvalidate();
        await delay(100);
      }
    };
    loop();
    return () => keep_running = false;
  });
  const writable_props = ["endpoint"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<QueryStatus> was created with unknown prop '${key}'`);
  });
  function querytoast_status_binding(value, status, each_value, status_index) {
    each_value[status_index] = value;
    $$invalidate(0, activeStatuses), $$invalidate(2, statuses);
  }
  $$self.$$set = ($$props2) => {
    if ("endpoint" in $$props2)
      $$invalidate(1, endpoint = $$props2.endpoint);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude4,
    invalidate,
    page,
    onMount,
    QueryToast: QueryToast_default,
    delay,
    routeHash,
    endpoint,
    statuses,
    previousStatuses,
    getStatus,
    checkStatusAndInvalidate,
    activeStatuses,
    $routeHash,
    $page
  });
  $$self.$inject_state = ($$props2) => {
    if ("endpoint" in $$props2)
      $$invalidate(1, endpoint = $$props2.endpoint);
    if ("statuses" in $$props2)
      $$invalidate(2, statuses = $$props2.statuses);
    if ("previousStatuses" in $$props2)
      previousStatuses = $$props2.previousStatuses;
    if ("activeStatuses" in $$props2)
      $$invalidate(0, activeStatuses = $$props2.activeStatuses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*statuses*/
    4) {
      $:
        $$invalidate(0, activeStatuses = statuses.filter((d) => d.status != "not run" && d.status != "from cache"));
    }
  };
  return [activeStatuses, endpoint, statuses, querytoast_status_binding];
}
var QueryStatus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { endpoint: 1 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "QueryStatus",
      options,
      id: create_fragment6.name
    });
  }
  get endpoint() {
    throw new Error_1("<QueryStatus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set endpoint(value) {
    throw new Error_1("<QueryStatus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var QueryStatus_default = QueryStatus;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/TableOfContents.svelte
import { navigating, page as page2 } from "$app/stores";
var file7 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/TableOfContents.svelte";
function add_css5(target) {
  append_styles(target, "svelte-ejh1vu", "div.container.svelte-ejh1vu{position:sticky;top:var(--header-height);height:70vh;overflow-y:auto}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGVPZkNvbnRlbnRzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnQkMsR0FBQSxVQUFBLGNBQUEsQ0FBQSxBQUNDLFFBQUEsQ0FBQSxNQUFnQixDQUNoQixHQUFBLENBQUEsSUFBQSxlQUFBLENBQXlCLENBQ3pCLE1BQUEsQ0FBQSxJQUFZLENBQ1osVUFBQSxDQUFBLElBQWdCLEFBQ2pCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVGFibGVPZkNvbnRlbnRzLnN2ZWx0ZSJdfQ== */");
}
function create_if_block5(ctx) {
  let contentslist;
  let current;
  contentslist = new ContentsList_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(contentslist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(contentslist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(contentslist, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contentslist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contentslist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(contentslist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(11:1) {#if !$navigating && $page.url.pathname !== '/settings'}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let div;
  let current;
  let if_block = !/*$navigating*/
  ctx[0] && /*$page*/
  ctx[1].url.pathname !== "/settings" && create_if_block5(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "container svelte-ejh1vu");
      add_location(div, file7, 9, 0, 195);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!/*$navigating*/
      ctx2[0] && /*$page*/
      ctx2[1].url.pathname !== "/settings") {
        if (if_block) {
          if (dirty & /*$navigating, $page*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude5 = true;
function instance7($$self, $$props, $$invalidate) {
  let $navigating;
  let $page;
  validate_store(navigating, "navigating");
  component_subscribe($$self, navigating, ($$value) => $$invalidate(0, $navigating = $$value));
  validate_store(page2, "page");
  component_subscribe($$self, page2, ($$value) => $$invalidate(1, $page = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableOfContents", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TableOfContents> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude5,
    ContentsList: ContentsList_default,
    navigating,
    page: page2,
    $navigating,
    $page
  });
  return [$navigating, $page];
}
var TableOfContents = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {}, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableOfContents",
      options,
      id: create_fragment7.name
    });
  }
};
var TableOfContents_default = TableOfContents;

// ../../node_modules/@evidence-dev/component-utilities/src/colours.js
var colours = {
  blue100: "hsla(202, 100%, 95%, 1)",
  blue200: "hsla(204, 100%, 85%, 1)",
  blue300: "hsla(206, 95%, 72%, 1)",
  blue400: "hsla(208, 90%, 63%, 1)",
  blue500: "hsla(210, 85%, 54%, 1)",
  blue600: "hsla(212, 96%, 44%, 1)",
  blue700: "hsla(214, 98%, 38%, 1)",
  blue800: "hsla(217, 98%, 33%, 1)",
  blue900: "hsla(220, 99%, 24%, 1)",
  blue999: "hsla(222, 100%, 18%, 1)",
  bluelink: "hsla(205, 62%, 38%, 1)",
  green100: "hsla(167, 100%, 94%, 1)",
  green200: "hsla(166, 100%, 87%, 1)",
  green300: "hsla(163, 93%, 76%, 1)",
  green400: "hsla(161, 90%, 63%, 1)",
  green500: "hsla(159, 88%, 44%, 1)",
  green600: "hsla(158, 91%, 35%, 1)",
  green700: "hsla(156, 93%, 28%, 1)",
  green800: "hsla(154, 95%, 23%, 1)",
  green900: "hsla(152, 100%, 18%, 1)",
  green999: "hsla(150, 100%, 14%, 1)",
  grey100: "hsla(217, 33%, 97%, 1)",
  grey200: "hsla(215, 15%, 91%, 1)",
  grey300: "hsla(211, 16%, 82%, 1)",
  grey400: "hsla(212, 13%, 65%, 1)",
  grey500: "hsla(212, 10%, 53%, 1)",
  grey600: "hsla(212, 12%, 43%, 1)",
  grey700: "hsla(210, 14%, 37%, 1)",
  grey800: "hsla(210, 18%, 30%, 1)",
  grey900: "hsla(210, 20%, 25%, 1)",
  grey999: "hsla(211, 24%, 16%, 1)",
  yellow100: "hsl(49, 100%, 96%, 1)",
  yellow200: "hsl(48, 100%, 88%, 1)",
  yellow300: "hsl(48, 95%, 76%, 1)",
  yellow400: "hsl(48, 94%, 68%, 1)",
  yellow500: "hsl(44, 92%, 63%, 1)",
  yellow600: "hsl(42, 87%, 55%, 1)",
  yellow700: "hsl(36, 77%, 49%, 1)",
  yellow800: "hsl(29, 80%, 44%, 1)",
  yellow900: "hsl(22, 82%, 39%, 1)",
  yellow999: "hsl(15, 86%, 30%, 1)"
};
var colour = [
  "hsla(207, 65%, 39%, 1)",
  // Navy
  "hsla(195, 49%, 51%, 1)",
  // Teal
  "hsla(207, 69%, 79%, 1)",
  // Light Blue
  "hsla(202, 28%, 65%, 1)",
  // Grey
  "hsla(179, 37%, 65%, 1)",
  // Light Green
  "hsla(40, 30%, 75%, 1)",
  // Tan
  "hsla(38, 89%, 62%, 1)",
  // Yellow
  "hsla(342, 40%, 40%, 1)",
  // Maroon
  "hsla(207, 86%, 70%, 1)",
  // Blue
  "hsla(160, 40%, 46%, 1)"
  // Green
  //greyscale
  //'#71777d', '#7e848a', '#8c9196', '#9a9fa3', '#a8acb0', '#b7babd', '#c5c8ca', '#d4d6d7', '#e3e4e5', '#f3f3f3'
];

// ../../node_modules/@evidence-dev/component-utilities/src/echarts.js
var import_debounce = __toESM(require_debounce());
var echarts_default = (node, option) => {
  registerTheme("evidence-light", {
    grid: {
      left: "0%",
      right: "4%",
      bottom: "0%",
      top: "15%",
      containLabel: true
    },
    color: [
      "hsla(207, 65%, 39%, 1)",
      // Navy
      "hsla(195, 49%, 51%, 1)",
      // Teal
      "hsla(207, 69%, 79%, 1)",
      // Light Blue
      "hsla(202, 28%, 65%, 1)",
      // Grey
      "hsla(179, 37%, 65%, 1)",
      // Light Green
      "hsla(40, 30%, 75%, 1)",
      // Tan
      "hsla(38, 89%, 62%, 1)",
      // Yellow
      "hsla(342, 40%, 40%, 1)",
      // Maroon
      "hsla(207, 86%, 70%, 1)",
      // Blue
      "hsla(160, 40%, 46%, 1)",
      // Green
      // Grey Scale
      "#71777d",
      "#7e848a",
      "#8c9196",
      "#9a9fa3",
      "#a8acb0",
      "#b7babd",
      "#c5c8ca",
      "#d4d6d7",
      "#e3e4e5",
      "#f3f3f3"
    ],
    backgroundColor: "rgba(255, 255, 255, 0)",
    textStyle: {
      fontFamily: "sans-serif"
    },
    title: {
      padding: 0,
      itemGap: 7,
      textStyle: {
        fontSize: 14,
        color: colours.grey700
      },
      subtextStyle: {
        fontSize: 13,
        color: colours.grey600,
        overflow: "break"
      },
      top: "0%"
    },
    line: {
      itemStyle: {
        borderWidth: 0
      },
      lineStyle: {
        width: 2,
        join: "round"
      },
      symbolSize: 0,
      symbol: "circle",
      smooth: false
    },
    radar: {
      itemStyle: {
        borderWidth: 0
      },
      lineStyle: {
        width: 2
      },
      symbolSize: 0,
      symbol: "circle",
      smooth: false
    },
    bar: {
      itemStyle: {
        barBorderWidth: 1,
        barBorderColor: "#cccccc"
      }
    },
    pie: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    scatter: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    boxplot: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    parallel: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    sankey: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    funnel: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    gauge: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    candlestick: {
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderWidth: 1
      }
    },
    graph: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      },
      lineStyle: {
        width: 1,
        color: "#aaaaaa"
      },
      symbolSize: 0,
      symbol: "circle",
      smooth: false,
      color: [
        "#923d59",
        "#488f96",
        "#518eca",
        "#b3a9a0",
        "#ffc857",
        "#495867",
        "#bfdbf7",
        "#bc4749",
        "#eeebd0"
      ],
      label: {
        color: "#f2f2f2"
      }
    },
    map: {
      itemStyle: {
        areaColor: "#eee",
        borderColor: "#444",
        borderWidth: 0.5
      },
      label: {
        color: "#000"
      },
      emphasis: {
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)",
          borderColor: "#444",
          borderWidth: 1
        },
        label: {
          color: "rgb(100,0,0)"
        }
      }
    },
    geo: {
      itemStyle: {
        areaColor: "#eee",
        borderColor: "#444",
        borderWidth: 0.5
      },
      label: {
        color: "#000"
      },
      emphasis: {
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)",
          borderColor: "#444",
          borderWidth: 1
        },
        label: {
          color: "rgb(100,0,0)"
        }
      }
    },
    categoryAxis: {
      axisLine: {
        show: true,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: false,
        lineStyle: {
          color: colours.grey500
        },
        length: 3,
        alignWithLabel: true
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: false,
        lineStyle: {
          color: [colours.grey200]
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    valueAxis: {
      axisLine: {
        show: false,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: false,
        lineStyle: {
          color: colours.grey500
        },
        length: 2
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: [colours.grey200],
          width: 1
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    logAxis: {
      axisLine: {
        show: false,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: false,
        lineStyle: {
          color: colours.grey500
        },
        length: 2
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: [colours.grey200]
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    timeAxis: {
      axisLine: {
        show: true,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: true,
        lineStyle: {
          color: colours.grey500
        },
        length: 3
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: false,
        lineStyle: {
          color: [colours.grey200]
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    toolbox: {
      iconStyle: {
        borderColor: "#999999"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#459cde"
        }
      }
    },
    legend: {
      textStyle: {
        padding: [0, 0, 0, -7],
        color: colours.grey500
      },
      // "padding": [15,0,0,0],
      icon: "circle",
      pageIcons: {
        horizontal: [
          "M 17 3 h 2 c 0.386 0 0.738 0.223 0.904 0.572 s 0.115 0.762 -0.13 1.062 L 11.292 15 l 8.482 10.367 c 0.245 0.299 0.295 0.712 0.13 1.062 S 19.386 27 19 27 h -2 c -0.3 0 -0.584 -0.135 -0.774 -0.367 l -9 -11 c -0.301 -0.369 -0.301 -0.898 0 -1.267 l 9 -11 C 16.416 3.135 16.7 3 17 3 Z",
          "M 12 27 h -2 c -0.386 0 -0.738 -0.223 -0.904 -0.572 s -0.115 -0.762 0.13 -1.062 L 17.708 15 L 9.226 4.633 c -0.245 -0.299 -0.295 -0.712 -0.13 -1.062 S 9.614 3 10 3 h 2 c 0.3 0 0.584 0.135 0.774 0.367 l 9 11 c 0.301 0.369 0.301 0.898 0 1.267 l -9 11 C 12.584 26.865 12.3 27 12 27 Z"
        ]
      },
      pageIconColor: colours.grey600,
      pageIconSize: 12,
      pageTextStyle: {
        color: "grey"
      },
      pageButtonItemGap: -2,
      animationDurationUpdate: 300
    },
    tooltip: {
      axisPointer: {
        lineStyle: {
          color: "#cccccc",
          width: 1
        },
        crossStyle: {
          color: "#cccccc",
          width: 1
        }
      }
    },
    timeline: {
      lineStyle: {
        color: "#e3e3e3",
        width: 2
      },
      itemStyle: {
        color: "#d6d6d6",
        borderWidth: 1
      },
      controlStyle: {
        color: "#bfbfbf",
        borderColor: "#bfbfbf",
        borderWidth: 1
      },
      checkpointStyle: {
        color: "#8f8f8f",
        borderColor: "#ffffff"
      },
      label: {
        color: "#c9c9c9"
      },
      emphasis: {
        itemStyle: {
          color: "#9c9c9c"
        },
        controlStyle: {
          color: "#bfbfbf",
          borderColor: "#bfbfbf",
          borderWidth: 1
        },
        label: {
          color: "#c9c9c9"
        }
      }
    },
    visualMap: {
      color: ["#c41621", "#e39588", "#f5ed98"]
    },
    dataZoom: {
      handleSize: "undefined%",
      textStyle: {}
    },
    markPoint: {
      label: {
        color: "#f2f2f2"
      },
      emphasis: {
        label: {
          color: "#f2f2f2"
        }
      }
    }
  });
  const chart = init2(node, "evidence-light", { renderer: "svg" });
  chart.setOption(option);
  const dispatch = option.dispatch;
  chart.on("click", function(params) {
    dispatch("click", params);
  });
  let resizeObserver;
  const containerElement = document.querySelector("div.content > article");
  const onWindowResize = (0, import_debounce.default)(() => {
    chart.resize({
      animation: {
        duration: 500
      }
    });
    updateLabelWidths();
  }, 100);
  const updateLabelWidths = () => {
    const prevOption = chart.getOption();
    if (!prevOption)
      return;
    if (prevOption.showAllXAxisLabels) {
      const distinctXValues = new Set(prevOption.series.flatMap((s) => {
        var _a;
        return (_a = s.data) == null ? void 0 : _a.map((d) => d[0]);
      }));
      const modConst = 4 / 5;
      const clientWidth = (node == null ? void 0 : node.clientWidth) ?? 0;
      const newOption = {
        xAxis: {
          axisLabel: {
            interval: 0,
            overflow: "truncate",
            width: clientWidth * modConst / distinctXValues.size
          }
        }
      };
      chart.setOption(newOption);
    }
  };
  if (window.ResizeObserver && containerElement) {
    resizeObserver = new ResizeObserver(onWindowResize);
    resizeObserver.observe(containerElement);
  } else {
    window.addEventListener("resize", onWindowResize);
  }
  onWindowResize();
  return {
    update(option2) {
      chart.setOption(option2, true, true);
      updateLabelWidths();
    },
    destroy() {
      if (resizeObserver) {
        resizeObserver.unobserve(containerElement);
      } else {
        window.removeEventListener("resize", onWindowResize);
      }
      chart.dispose();
    }
  };
};

// ../../node_modules/@evidence-dev/component-utilities/src/echartsCanvasDownload.js
var import_downloadjs = __toESM(require_download());
var echartsCanvasDownload_default = (node, option) => {
  registerTheme("evidence-light", {
    grid: {
      left: "0%",
      right: "4%",
      bottom: "0%",
      top: "15%",
      containLabel: true
    },
    color: [
      "hsla(207, 65%, 39%, 1)",
      // Navy
      "hsla(195, 49%, 51%, 1)",
      // Teal
      "hsla(207, 69%, 79%, 1)",
      // Light Blue
      "hsla(202, 28%, 65%, 1)",
      // Grey
      "hsla(179, 37%, 65%, 1)",
      // Light Green
      "hsla(40, 30%, 75%, 1)",
      // Tan
      "hsla(38, 89%, 62%, 1)",
      // Yellow
      "hsla(342, 40%, 40%, 1)",
      // Maroon
      "hsla(207, 86%, 70%, 1)",
      // Blue
      "hsla(160, 40%, 46%, 1)",
      // Green
      // Grey Scale
      "#71777d",
      "#7e848a",
      "#8c9196",
      "#9a9fa3",
      "#a8acb0",
      "#b7babd",
      "#c5c8ca",
      "#d4d6d7",
      "#e3e4e5",
      "#f3f3f3"
    ],
    backgroundColor: "rgba(255, 255, 255, 0)",
    textStyle: {
      fontFamily: "sans-serif"
    },
    title: {
      padding: 0,
      itemGap: 7,
      textStyle: {
        fontSize: 14,
        color: colours.grey700
      },
      subtextStyle: {
        fontSize: 13,
        color: colours.grey600,
        overflow: "break"
      },
      top: "0%"
    },
    line: {
      itemStyle: {
        borderWidth: 0
      },
      lineStyle: {
        width: 2,
        join: "round"
      },
      symbolSize: 0,
      symbol: "circle",
      smooth: false
    },
    radar: {
      itemStyle: {
        borderWidth: 0
      },
      lineStyle: {
        width: 2
      },
      symbolSize: 0,
      symbol: "circle",
      smooth: false
    },
    bar: {
      itemStyle: {
        barBorderWidth: 1,
        barBorderColor: "#cccccc"
      }
    },
    pie: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    scatter: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    boxplot: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    parallel: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    sankey: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    funnel: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    gauge: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    candlestick: {
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderWidth: 1
      }
    },
    graph: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      },
      lineStyle: {
        width: 1,
        color: "#aaaaaa"
      },
      symbolSize: 0,
      symbol: "circle",
      smooth: false,
      color: [
        "#923d59",
        "#488f96",
        "#518eca",
        "#b3a9a0",
        "#ffc857",
        "#495867",
        "#bfdbf7",
        "#bc4749",
        "#eeebd0"
      ],
      label: {
        color: "#f2f2f2"
      }
    },
    map: {
      itemStyle: {
        areaColor: "#eee",
        borderColor: "#444",
        borderWidth: 0.5
      },
      label: {
        color: "#000"
      },
      emphasis: {
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)",
          borderColor: "#444",
          borderWidth: 1
        },
        label: {
          color: "rgb(100,0,0)"
        }
      }
    },
    geo: {
      itemStyle: {
        areaColor: "#eee",
        borderColor: "#444",
        borderWidth: 0.5
      },
      label: {
        color: "#000"
      },
      emphasis: {
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)",
          borderColor: "#444",
          borderWidth: 1
        },
        label: {
          color: "rgb(100,0,0)"
        }
      }
    },
    categoryAxis: {
      axisLine: {
        show: true,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: false,
        lineStyle: {
          color: colours.grey500
        },
        length: 3,
        alignWithLabel: true
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: false,
        lineStyle: {
          color: [colours.grey200]
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    valueAxis: {
      axisLine: {
        show: false,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: false,
        lineStyle: {
          color: colours.grey500
        },
        length: 2
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: [colours.grey200],
          width: 1
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    logAxis: {
      axisLine: {
        show: false,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: false,
        lineStyle: {
          color: colours.grey500
        },
        length: 2
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: [colours.grey200]
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    timeAxis: {
      axisLine: {
        show: true,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: true,
        lineStyle: {
          color: colours.grey500
        },
        length: 3
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: false,
        lineStyle: {
          color: [colours.grey200]
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    toolbox: {
      iconStyle: {
        borderColor: "#999999"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#459cde"
        }
      }
    },
    legend: {
      textStyle: {
        padding: [0, 0, 0, -7],
        color: colours.grey500
      },
      // "padding": [15,0,0,0],
      icon: "circle",
      pageIcons: {
        horizontal: [
          "M 17 3 h 2 c 0.386 0 0.738 0.223 0.904 0.572 s 0.115 0.762 -0.13 1.062 L 11.292 15 l 8.482 10.367 c 0.245 0.299 0.295 0.712 0.13 1.062 S 19.386 27 19 27 h -2 c -0.3 0 -0.584 -0.135 -0.774 -0.367 l -9 -11 c -0.301 -0.369 -0.301 -0.898 0 -1.267 l 9 -11 C 16.416 3.135 16.7 3 17 3 Z",
          "M 12 27 h -2 c -0.386 0 -0.738 -0.223 -0.904 -0.572 s -0.115 -0.762 0.13 -1.062 L 17.708 15 L 9.226 4.633 c -0.245 -0.299 -0.295 -0.712 -0.13 -1.062 S 9.614 3 10 3 h 2 c 0.3 0 0.584 0.135 0.774 0.367 l 9 11 c 0.301 0.369 0.301 0.898 0 1.267 l -9 11 C 12.584 26.865 12.3 27 12 27 Z"
        ]
      },
      pageIconColor: colours.grey600,
      pageIconSize: 12,
      pageTextStyle: {
        color: "grey"
      },
      pageButtonItemGap: -2,
      animationDurationUpdate: 300
    },
    tooltip: {
      axisPointer: {
        lineStyle: {
          color: "#cccccc",
          width: 1
        },
        crossStyle: {
          color: "#cccccc",
          width: 1
        }
      }
    },
    timeline: {
      lineStyle: {
        color: "#e3e3e3",
        width: 2
      },
      itemStyle: {
        color: "#d6d6d6",
        borderWidth: 1
      },
      controlStyle: {
        color: "#bfbfbf",
        borderColor: "#bfbfbf",
        borderWidth: 1
      },
      checkpointStyle: {
        color: "#8f8f8f",
        borderColor: "#ffffff"
      },
      label: {
        color: "#c9c9c9"
      },
      emphasis: {
        itemStyle: {
          color: "#9c9c9c"
        },
        controlStyle: {
          color: "#bfbfbf",
          borderColor: "#bfbfbf",
          borderWidth: 1
        },
        label: {
          color: "#c9c9c9"
        }
      }
    },
    visualMap: {
      color: ["#c41621", "#e39588", "#f5ed98"]
    },
    dataZoom: {
      handleSize: "undefined%",
      textStyle: {}
    },
    markPoint: {
      label: {
        color: "#f2f2f2"
      },
      emphasis: {
        label: {
          color: "#f2f2f2"
        }
      }
    }
  });
  const chart = init2(node, "evidence-light", { renderer: "canvas" });
  option.animation = false;
  chart.setOption(option);
  let src = chart.getConnectedDataURL({
    type: "png",
    pixelRatio: 3,
    backgroundColor: "white",
    excludeComponents: ["toolbox"]
  });
  (0, import_downloadjs.default)(src, "evidence-chart.png");
  chart.dispose();
  return {
    destroy() {
      chart.dispose();
    }
  };
};

// ../../node_modules/@evidence-dev/component-utilities/src/echartsCopy.js
var echartsCopy_default = (node, option) => {
  registerTheme("evidence-light", {
    grid: {
      left: "0%",
      right: "4%",
      bottom: "0%",
      top: "15%",
      containLabel: true
    },
    color: [
      "hsla(207, 65%, 39%, 1)",
      // Navy
      "hsla(195, 49%, 51%, 1)",
      // Teal
      "hsla(207, 69%, 79%, 1)",
      // Light Blue
      "hsla(202, 28%, 65%, 1)",
      // Grey
      "hsla(179, 37%, 65%, 1)",
      // Light Green
      "hsla(40, 30%, 75%, 1)",
      // Tan
      "hsla(38, 89%, 62%, 1)",
      // Yellow
      "hsla(342, 40%, 40%, 1)",
      // Maroon
      "hsla(207, 86%, 70%, 1)",
      // Blue
      "hsla(160, 40%, 46%, 1)",
      // Green
      // Grey Scale
      "#71777d",
      "#7e848a",
      "#8c9196",
      "#9a9fa3",
      "#a8acb0",
      "#b7babd",
      "#c5c8ca",
      "#d4d6d7",
      "#e3e4e5",
      "#f3f3f3"
    ],
    backgroundColor: "rgba(255, 255, 255, 0)",
    textStyle: {
      fontFamily: "sans-serif"
    },
    title: {
      padding: 0,
      itemGap: 7,
      textStyle: {
        fontSize: 14,
        color: colours.grey700
      },
      subtextStyle: {
        fontSize: 13,
        color: colours.grey600,
        overflow: "break"
      },
      top: "0%"
    },
    line: {
      itemStyle: {
        borderWidth: 0
      },
      lineStyle: {
        width: 2,
        join: "round"
      },
      symbolSize: 0,
      symbol: "circle",
      smooth: false
    },
    radar: {
      itemStyle: {
        borderWidth: 0
      },
      lineStyle: {
        width: 2
      },
      symbolSize: 0,
      symbol: "circle",
      smooth: false
    },
    bar: {
      itemStyle: {
        barBorderWidth: 1,
        barBorderColor: "#cccccc"
      }
    },
    pie: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    scatter: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    boxplot: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    parallel: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    sankey: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    funnel: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    gauge: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      }
    },
    candlestick: {
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderWidth: 1
      }
    },
    graph: {
      itemStyle: {
        borderWidth: 0,
        borderColor: "#cccccc"
      },
      lineStyle: {
        width: 1,
        color: "#aaaaaa"
      },
      symbolSize: 0,
      symbol: "circle",
      smooth: false,
      color: [
        "#923d59",
        "#488f96",
        "#518eca",
        "#b3a9a0",
        "#ffc857",
        "#495867",
        "#bfdbf7",
        "#bc4749",
        "#eeebd0"
      ],
      label: {
        color: "#f2f2f2"
      }
    },
    map: {
      itemStyle: {
        areaColor: "#eee",
        borderColor: "#444",
        borderWidth: 0.5
      },
      label: {
        color: "#000"
      },
      emphasis: {
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)",
          borderColor: "#444",
          borderWidth: 1
        },
        label: {
          color: "rgb(100,0,0)"
        }
      }
    },
    geo: {
      itemStyle: {
        areaColor: "#eee",
        borderColor: "#444",
        borderWidth: 0.5
      },
      label: {
        color: "#000"
      },
      emphasis: {
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)",
          borderColor: "#444",
          borderWidth: 1
        },
        label: {
          color: "rgb(100,0,0)"
        }
      }
    },
    categoryAxis: {
      axisLine: {
        show: true,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: false,
        lineStyle: {
          color: colours.grey500
        },
        length: 3,
        alignWithLabel: true
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: false,
        lineStyle: {
          color: [colours.grey200]
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    valueAxis: {
      axisLine: {
        show: false,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: false,
        lineStyle: {
          color: colours.grey500
        },
        length: 2
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: [colours.grey200],
          width: 1
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    logAxis: {
      axisLine: {
        show: false,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: false,
        lineStyle: {
          color: colours.grey500
        },
        length: 2
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: [colours.grey200]
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    timeAxis: {
      axisLine: {
        show: true,
        lineStyle: {
          color: colours.grey500
        }
      },
      axisTick: {
        show: true,
        lineStyle: {
          color: colours.grey500
        },
        length: 3
      },
      axisLabel: {
        show: true,
        color: colours.grey500
      },
      splitLine: {
        show: false,
        lineStyle: {
          color: [colours.grey200]
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
        }
      }
    },
    toolbox: {
      iconStyle: {
        borderColor: "#999999"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#459cde"
        }
      }
    },
    legend: {
      textStyle: {
        padding: [0, 0, 0, -7],
        color: colours.grey500
      },
      // "padding": [15,0,0,0],
      icon: "circle",
      pageIcons: {
        horizontal: [
          "M 17 3 h 2 c 0.386 0 0.738 0.223 0.904 0.572 s 0.115 0.762 -0.13 1.062 L 11.292 15 l 8.482 10.367 c 0.245 0.299 0.295 0.712 0.13 1.062 S 19.386 27 19 27 h -2 c -0.3 0 -0.584 -0.135 -0.774 -0.367 l -9 -11 c -0.301 -0.369 -0.301 -0.898 0 -1.267 l 9 -11 C 16.416 3.135 16.7 3 17 3 Z",
          "M 12 27 h -2 c -0.386 0 -0.738 -0.223 -0.904 -0.572 s -0.115 -0.762 0.13 -1.062 L 17.708 15 L 9.226 4.633 c -0.245 -0.299 -0.295 -0.712 -0.13 -1.062 S 9.614 3 10 3 h 2 c 0.3 0 0.584 0.135 0.774 0.367 l 9 11 c 0.301 0.369 0.301 0.898 0 1.267 l -9 11 C 12.584 26.865 12.3 27 12 27 Z"
        ]
      },
      pageIconColor: colours.grey600,
      pageIconSize: 12,
      pageTextStyle: {
        color: "grey"
      },
      pageButtonItemGap: -2,
      animationDurationUpdate: 300
    },
    tooltip: {
      axisPointer: {
        lineStyle: {
          color: "#cccccc",
          width: 1
        },
        crossStyle: {
          color: "#cccccc",
          width: 1
        }
      }
    },
    timeline: {
      lineStyle: {
        color: "#e3e3e3",
        width: 2
      },
      itemStyle: {
        color: "#d6d6d6",
        borderWidth: 1
      },
      controlStyle: {
        color: "#bfbfbf",
        borderColor: "#bfbfbf",
        borderWidth: 1
      },
      checkpointStyle: {
        color: "#8f8f8f",
        borderColor: "#ffffff"
      },
      label: {
        color: "#c9c9c9"
      },
      emphasis: {
        itemStyle: {
          color: "#9c9c9c"
        },
        controlStyle: {
          color: "#bfbfbf",
          borderColor: "#bfbfbf",
          borderWidth: 1
        },
        label: {
          color: "#c9c9c9"
        }
      }
    },
    visualMap: {
      color: ["#c41621", "#e39588", "#f5ed98"]
    },
    dataZoom: {
      handleSize: "undefined%",
      textStyle: {}
    },
    markPoint: {
      label: {
        color: "#f2f2f2"
      },
      emphasis: {
        label: {
          color: "#f2f2f2"
        }
      }
    }
  });
  const { config, ratio } = option;
  const chart = init2(node, "evidence-light", { renderer: "canvas" });
  config.animation = false;
  chart.setOption(config);
  let src = chart.getConnectedDataURL({
    type: "jpeg",
    pixelRatio: ratio,
    backgroundColor: "#fff",
    excludeComponents: ["toolbox"]
  });
  node.innerHTML = `<img src=${src} width="100%" style="
        position: absolute; 
        top: 0;
        user-select: all;
        -webkit-user-select: all;
        -moz-user-select: all;
        -ms-user-select: all;
    " />`;
};

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/EchartsCopyTarget.svelte
var file8 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/viz/EchartsCopyTarget.svelte";
function create_if_block6(ctx) {
  let div;
  let eChartsCopy_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "chart");
      set_style(
        div,
        "height",
        /*height*/
        ctx[1]
      );
      set_style(
        div,
        "width",
        /*width*/
        ctx[2]
      );
      set_style(div, "margin-left", "0");
      set_style(div, "margin-top", "15px");
      set_style(div, "margin-bottom", "10px");
      set_style(div, "overflow", "visible");
      set_style(div, "break-inside", "avoid");
      add_location(div, file8, 15, 1, 346);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(eChartsCopy_action = echartsCopy_default.call(null, div, {
          config: (
            /*config*/
            ctx[0]
          ),
          ratio: (
            /*printing*/
            ctx[4] ? 4 : 2
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*height*/
      2) {
        set_style(
          div,
          "height",
          /*height*/
          ctx2[1]
        );
      }
      if (dirty & /*width*/
      4) {
        set_style(
          div,
          "width",
          /*width*/
          ctx2[2]
        );
      }
      if (eChartsCopy_action && is_function(eChartsCopy_action.update) && dirty & /*config, printing*/
      17)
        eChartsCopy_action.update.call(null, {
          config: (
            /*config*/
            ctx2[0]
          ),
          ratio: (
            /*printing*/
            ctx2[4] ? 4 : 2
          )
        });
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(15:0) {#if copying || printing}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let if_block_anchor;
  let if_block = (
    /*copying*/
    (ctx[3] || /*printing*/
    ctx[4]) && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*copying*/
        ctx2[3] || /*printing*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude6 = true;
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EchartsCopyTarget", slots, []);
  let { config = void 0 } = $$props;
  let { height = "291px" } = $$props;
  let { width = "100%" } = $$props;
  let { copying = false } = $$props;
  let { printing = false } = $$props;
  const writable_props = ["config", "height", "width", "copying", "printing"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EchartsCopyTarget> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("copying" in $$props2)
      $$invalidate(3, copying = $$props2.copying);
    if ("printing" in $$props2)
      $$invalidate(4, printing = $$props2.printing);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude6,
    eChartsCopy: echartsCopy_default,
    config,
    height,
    width,
    copying,
    printing
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("copying" in $$props2)
      $$invalidate(3, copying = $$props2.copying);
    if ("printing" in $$props2)
      $$invalidate(4, printing = $$props2.printing);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [config, height, width, copying, printing];
}
var EchartsCopyTarget = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      config: 0,
      height: 1,
      width: 2,
      copying: 3,
      printing: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EchartsCopyTarget",
      options,
      id: create_fragment8.name
    });
  }
  get config() {
    throw new Error("<EchartsCopyTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<EchartsCopyTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<EchartsCopyTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<EchartsCopyTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<EchartsCopyTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<EchartsCopyTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copying() {
    throw new Error("<EchartsCopyTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copying(value) {
    throw new Error("<EchartsCopyTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get printing() {
    throw new Error("<EchartsCopyTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set printing(value) {
    throw new Error("<EchartsCopyTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EchartsCopyTarget_default = EchartsCopyTarget;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/DownloadData.svelte
var import_export_to_csv = __toESM(require_build());
var file9 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/DownloadData.svelte";
function add_css6(target) {
  append_styles(target, "svelte-8m52nx", "button.svelte-8m52nx svg{stroke:var(--grey-400);margin-top:auto;margin-bottom:auto;transition:stroke 200ms}button.svelte-8m52nx{display:flex;cursor:pointer;font-family:var(--ui-font-family);font-size:1em;color:var(--grey-400);justify-items:flex-end;align-items:baseline;background-color:transparent;border:none;padding:0;margin:0 5px;gap:3px;transition:color 200ms;-moz-user-select:none;-webkit-user-select:none;-o-user-select:none;user-select:none}button.svelte-8m52nx:hover{color:var(--blue-600);transition:color 200ms}button.svelte-8m52nx:hover svg{stroke:var(--blue-600);transition:stroke 200ms}@media(max-width: 600px){button.svelte-8m52nx{display:none}}@media print{button.svelte-8m52nx{display:none}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG93bmxvYWREYXRhLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF1REMsb0JBQUEsQ0FBQSxBQUFBLEdBQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLElBQUEsVUFBQSxDQUF1QixDQUN2QixVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsYUFBQSxDQUFBLElBQW1CLENBQ25CLFVBQUEsQ0FBQSxNQUFBLENBQUEsS0FBd0IsQUFDekIsQ0FBQSxBQUVBLE1BQUEsY0FBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQ0FDYixNQUFBLENBQUEsT0FBZSxDQUNmLFdBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQWtDLENBQ2xDLFNBQUEsQ0FBQSxHQUFjLENBQ2QsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixhQUFBLENBQUEsUUFBdUIsQ0FDdkIsV0FBQSxDQUFBLFFBQXFCLENBQ3JCLGdCQUFBLENBQUEsV0FBNkIsQ0FDN0IsTUFBQSxDQUFBLElBQVksQ0FDWixPQUFBLENBQUEsQ0FBVSxDQUNWLE1BQUEsQ0FBQSxDQUFBLENBQUEsR0FBYSxDQUNiLEdBQUEsQ0FBQSxHQUFRLENBQ1IsVUFBQSxDQUFBLEtBQUEsQ0FBQSxLQUF1QixDQUN2QixnQkFBQSxDQUFBLElBQXNCLENBQ3RCLG1CQUFBLENBQUEsSUFBeUIsQ0FDekIsY0FBQSxDQUFBLElBQW9CLENBQ3BCLFdBQUEsQ0FBQSxJQUFpQixBQUNsQixDQUFBLEFBRUEsb0JBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFVBQUEsQ0FBQSxLQUFBLENBQUEsS0FBdUIsQUFDeEIsQ0FBQSxBQUVBLG9CQUFBLE1BQUEsQ0FBQSxBQUFBLEdBQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLElBQUEsVUFBQSxDQUF1QixDQUN2QixVQUFBLENBQUEsTUFBQSxDQUFBLEtBQXdCLEFBQ3pCLENBQUEsQUFFQSxNQUFBLEFBQUEsWUFBQSxLQUFBLENBQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSxjQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFDRCxDQUFBLEFBRUEsT0FBQSxLQUFBLEFBQUEsQ0FBQSxBQUNDLE1BQUEsY0FBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQUFDZCxDQUFBLEFBQ0QsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJEb3dubG9hZERhdGEuc3ZlbHRlIl19 */");
}
function create_if_block7(ctx) {
  let div;
  let button;
  let span;
  let t0;
  let t1;
  let button_class_value;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      div = element("div");
      button = element("button");
      span = element("span");
      t0 = text(
        /*text*/
        ctx[1]
      );
      t1 = space();
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", {});
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*text*/
        ctx[1]
      );
      span_nodes.forEach(detach_dev);
      t1 = claim_space(button_nodes);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file9, 37, 3, 874);
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-label",
        /*text*/
        ctx[1]
      );
      attr_dev(button, "class", button_class_value = null_to_empty(
        /*$$props*/
        ctx[4].class
      ) + " svelte-8m52nx");
      add_location(button, file9, 36, 2, 778);
      add_location(div, file9, 35, 1, 728);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      append_hydration_dev(button, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(button, t1);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*downloadData*/
              ctx[3](
                /*data*/
                ctx[0]
              )
            ))
              ctx[3](
                /*data*/
                ctx[0]
              ).apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*text*/
      2)
        set_data_dev(
          t0,
          /*text*/
          ctx[1]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*text*/
      2) {
        attr_dev(
          button,
          "aria-label",
          /*text*/
          ctx[1]
        );
      }
      if (!current || dirty & /*$$props*/
      16 && button_class_value !== (button_class_value = null_to_empty(
        /*$$props*/
        ctx[4].class
      ) + " svelte-8m52nx")) {
        attr_dev(button, "class", button_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, fade, { duration: 200 }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, { duration: 200 }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(35:0) {#if display}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 15v4c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2v-4M17 9l-5 5-5-5M12 12.8V2.5");
      add_location(path, file9, 47, 6, 1073);
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "stroke-width", "2");
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      add_location(svg, file9, 39, 4, 908);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(39:9)      ",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*display*/
    ctx[2] && create_if_block7(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*display*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*display*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude7 = true;
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DownloadData", slots, ["default"]);
  let { data } = $$props;
  let { queryID } = $$props;
  let { text: text2 = "Download" } = $$props;
  let { display } = $$props;
  let { downloadData = (data2) => {
    const options = {
      fieldSeparator: ",",
      quoteStrings: '"',
      decimalSeparator: ".",
      showLabels: true,
      showTitle: false,
      filename: queryID ?? "evidence_download",
      useTextFile: false,
      useBom: true,
      useKeysAsHeaders: true
    };
    const data_copy = JSON.parse(JSON.stringify(data2));
    const csvExporter = new import_export_to_csv.ExportToCsv(options);
    csvExporter.generateCsv(data_copy);
  } } = $$props;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<DownloadData> was created without expected prop 'data'");
    }
    if (queryID === void 0 && !("queryID" in $$props || $$self.$$.bound[$$self.$$.props["queryID"]])) {
      console.warn("<DownloadData> was created without expected prop 'queryID'");
    }
    if (display === void 0 && !("display" in $$props || $$self.$$.bound[$$self.$$.props["display"]])) {
      console.warn("<DownloadData> was created without expected prop 'display'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("data" in $$new_props)
      $$invalidate(0, data = $$new_props.data);
    if ("queryID" in $$new_props)
      $$invalidate(5, queryID = $$new_props.queryID);
    if ("text" in $$new_props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("display" in $$new_props)
      $$invalidate(2, display = $$new_props.display);
    if ("downloadData" in $$new_props)
      $$invalidate(3, downloadData = $$new_props.downloadData);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude7,
    ExportToCsv: import_export_to_csv.ExportToCsv,
    fade,
    data,
    queryID,
    text: text2,
    display,
    downloadData
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("data" in $$props)
      $$invalidate(0, data = $$new_props.data);
    if ("queryID" in $$props)
      $$invalidate(5, queryID = $$new_props.queryID);
    if ("text" in $$props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("display" in $$props)
      $$invalidate(2, display = $$new_props.display);
    if ("downloadData" in $$props)
      $$invalidate(3, downloadData = $$new_props.downloadData);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [data, text2, display, downloadData, $$props, queryID, $$scope, slots];
}
var DownloadData = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance9,
      create_fragment9,
      safe_not_equal,
      {
        data: 0,
        queryID: 5,
        text: 1,
        display: 2,
        downloadData: 3
      },
      add_css6
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DownloadData",
      options,
      id: create_fragment9.name
    });
  }
  get data() {
    throw new Error("<DownloadData>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<DownloadData>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryID() {
    throw new Error("<DownloadData>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryID(value) {
    throw new Error("<DownloadData>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<DownloadData>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<DownloadData>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get display() {
    throw new Error("<DownloadData>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set display(value) {
    throw new Error("<DownloadData>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get downloadData() {
    throw new Error("<DownloadData>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set downloadData(value) {
    throw new Error("<DownloadData>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DownloadData_default = DownloadData;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/ECharts.svelte
var file10 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/viz/ECharts.svelte";
function add_css7(target) {
  append_styles(target, "svelte-11eedjq", "@media print{.chart.svelte-11eedjq{-moz-column-break-inside:avoid;break-inside:avoid}.chart-container.svelte-11eedjq{padding:0}}.chart.svelte-11eedjq{-moz-user-select:none;-webkit-user-select:none;-o-user-select:none;user-select:none}.chart-footer.svelte-11eedjq{display:flex;justify-content:flex-end;align-items:center;margin:3px 12px;font-size:12px;height:9px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRUNoYXJ0cy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUhDLE9BQUEsS0FBQSxBQUFBLENBQUEsQUFDQyxNQUFBLGVBQUEsQ0FBQSxBQUNDLHdCQUFBLENBQUEsS0FBK0IsQ0FDMUIsWUFBQSxDQUFBLEtBQW1CLEFBQ3pCLENBQUEsQUFFQSxnQkFBQSxlQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsQ0FBVSxBQUNYLENBQUEsQUFDRCxDQUFBLEFBQ0EsTUFBQSxlQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQXNCLENBQ3RCLG1CQUFBLENBQUEsSUFBeUIsQ0FDekIsY0FBQSxDQUFBLElBQW9CLENBQ3BCLFdBQUEsQ0FBQSxJQUFpQixBQUNsQixDQUFBLEFBRUEsYUFBQSxlQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxDQUNiLGVBQUEsQ0FBQSxRQUF5QixDQUN6QixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxJQUFnQixDQUNoQixTQUFBLENBQUEsSUFBZSxDQUNmLE1BQUEsQ0FBQSxHQUFXLEFBQ1osQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJFQ2hhcnRzLnN2ZWx0ZSJdfQ== */");
}
function create_if_block_2(ctx) {
  let div;
  let echarts_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "chart svelte-11eedjq");
      set_style(
        div,
        "height",
        /*height*/
        ctx[1]
      );
      set_style(
        div,
        "width",
        /*width*/
        ctx[2]
      );
      set_style(div, "margin-left", "0");
      set_style(div, "margin-top", "15px");
      set_style(div, "margin-bottom", "10px");
      set_style(div, "overflow", "visible");
      set_style(
        div,
        "display",
        /*copying*/
        ctx[5] ? "none" : "inherit"
      );
      add_location(div, file10, 47, 2, 1150);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(echarts_action = echarts_default.call(null, div, {
          .../*config*/
          ctx[0],
          .../*$$restProps*/
          ctx[9],
          dispatch: (
            /*dispatch*/
            ctx[8]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*height*/
      2) {
        set_style(
          div,
          "height",
          /*height*/
          ctx2[1]
        );
      }
      if (dirty & /*width*/
      4) {
        set_style(
          div,
          "width",
          /*width*/
          ctx2[2]
        );
      }
      if (dirty & /*copying*/
      32) {
        set_style(
          div,
          "display",
          /*copying*/
          ctx2[5] ? "none" : "inherit"
        );
      }
      if (echarts_action && is_function(echarts_action.update) && dirty & /*config, $$restProps*/
      513)
        echarts_action.update.call(null, {
          .../*config*/
          ctx2[0],
          .../*$$restProps*/
          ctx2[9],
          dispatch: (
            /*dispatch*/
            ctx2[8]
          )
        });
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(47:1) {#if !printing}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let svg;
  let rect;
  let circle;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      circle = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      add_location(rect, file10, 86, 5, 2020);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "8.5");
      attr_dev(circle, "r", "1.5");
      add_location(circle, file10, 86, 55, 2070);
      attr_dev(path, "d", "M20.4 14.5L16 10 4 20");
      add_location(path, file10, 86, 91, 2106);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "stroke", "#000");
      attr_dev(svg, "stroke-width", "2");
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      add_location(svg, file10, 76, 3, 1806);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(66:2) <DownloadData    text=\\"Save image\\"    class=\\"download-button\\"    downloadData={() => {     downloadChart = true;     setTimeout(() => {      downloadChart = false;     }, 0);    }}    display={hovering}   >',
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let downloaddata;
  let current;
  downloaddata = new DownloadData_default({
    props: {
      text: "Download data",
      data: (
        /*data*/
        ctx[3]
      ),
      class: "download-button",
      display: (
        /*hovering*/
        ctx[7]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(downloaddata.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(downloaddata.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(downloaddata, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const downloaddata_changes = {};
      if (dirty & /*data*/
      8)
        downloaddata_changes.data = /*data*/
        ctx2[3];
      if (dirty & /*hovering*/
      128)
        downloaddata_changes.display = /*hovering*/
        ctx2[7];
      downloaddata.$set(downloaddata_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(downloaddata.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(downloaddata.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(downloaddata, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(92:2) {#if data}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let div;
  let echartsCanvasDownload_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "chart svelte-11eedjq");
      set_style(div, "display", "none");
      set_style(div, "visibility", "visible");
      set_style(
        div,
        "height",
        /*height*/
        ctx[1]
      );
      set_style(div, "width", "666px");
      set_style(div, "margin-left", "0");
      set_style(div, "margin-top", "15px");
      set_style(div, "margin-bottom", "15px");
      set_style(div, "overflow", "visible");
      add_location(div, file10, 98, 1, 2327);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(echartsCanvasDownload_action = echartsCanvasDownload_default.call(
          null,
          div,
          /*config*/
          ctx[0]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*height*/
      2) {
        set_style(
          div,
          "height",
          /*height*/
          ctx2[1]
        );
      }
      if (echartsCanvasDownload_action && is_function(echartsCanvasDownload_action.update) && dirty & /*config*/
      1)
        echartsCanvasDownload_action.update.call(
          null,
          /*config*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(98:0) {#if downloadChart}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let div1;
  let t0;
  let echartscopytarget;
  let t1;
  let div0;
  let downloaddata;
  let t2;
  let t3;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !/*printing*/
  ctx[6] && create_if_block_2(ctx);
  echartscopytarget = new EchartsCopyTarget_default({
    props: {
      config: (
        /*config*/
        ctx[0]
      ),
      height: (
        /*height*/
        ctx[1]
      ),
      width: (
        /*width*/
        ctx[2]
      ),
      copying: (
        /*copying*/
        ctx[5]
      ),
      printing: (
        /*printing*/
        ctx[6]
      )
    },
    $$inline: true
  });
  downloaddata = new DownloadData_default({
    props: {
      text: "Save image",
      class: "download-button",
      downloadData: (
        /*func*/
        ctx[15]
      ),
      display: (
        /*hovering*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block1 = (
    /*data*/
    ctx[3] && create_if_block_1(ctx)
  );
  let if_block2 = (
    /*downloadChart*/
    ctx[4] && create_if_block8(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(echartscopytarget.$$.fragment);
      t1 = space();
      div0 = element("div");
      create_component(downloaddata.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      claim_component(echartscopytarget.$$.fragment, div1_nodes);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(downloaddata.$$.fragment, div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "chart-footer svelte-11eedjq");
      add_location(div0, file10, 64, 1, 1567);
      attr_dev(div1, "class", "chart-container svelte-11eedjq");
      add_location(div1, file10, 41, 0, 1016);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      mount_component(echartscopytarget, div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      mount_component(downloaddata, div0, null);
      append_hydration_dev(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      insert_hydration_dev(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "copy",
            /*copy_handler*/
            ctx[10],
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "beforeprint",
            /*beforeprint_handler*/
            ctx[11],
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "afterprint",
            /*afterprint_handler*/
            ctx[12],
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "export-beforeprint",
            /*export_beforeprint_handler*/
            ctx[13],
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "export-afterprint",
            /*export_afterprint_handler*/
            ctx[14],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[16],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[17],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*printing*/
      ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const echartscopytarget_changes = {};
      if (dirty & /*config*/
      1)
        echartscopytarget_changes.config = /*config*/
        ctx2[0];
      if (dirty & /*height*/
      2)
        echartscopytarget_changes.height = /*height*/
        ctx2[1];
      if (dirty & /*width*/
      4)
        echartscopytarget_changes.width = /*width*/
        ctx2[2];
      if (dirty & /*copying*/
      32)
        echartscopytarget_changes.copying = /*copying*/
        ctx2[5];
      if (dirty & /*printing*/
      64)
        echartscopytarget_changes.printing = /*printing*/
        ctx2[6];
      echartscopytarget.$set(echartscopytarget_changes);
      const downloaddata_changes = {};
      if (dirty & /*downloadChart*/
      16)
        downloaddata_changes.downloadData = /*func*/
        ctx2[15];
      if (dirty & /*hovering*/
      128)
        downloaddata_changes.display = /*hovering*/
        ctx2[7];
      if (dirty & /*$$scope*/
      262144) {
        downloaddata_changes.$$scope = { dirty, ctx: ctx2 };
      }
      downloaddata.$set(downloaddata_changes);
      if (
        /*data*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*data*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*downloadChart*/
        ctx2[4]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block8(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(echartscopytarget.$$.fragment, local);
      transition_in(downloaddata.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(echartscopytarget.$$.fragment, local);
      transition_out(downloaddata.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      destroy_component(echartscopytarget);
      destroy_component(downloaddata);
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach_dev(t3);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude8 = true;
function instance10($$self, $$props, $$invalidate) {
  const omit_props_names = ["config", "height", "width", "data"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ECharts", slots, []);
  let { config = void 0 } = $$props;
  let { height = "291px" } = $$props;
  let { width = "100%" } = $$props;
  let { data } = $$props;
  const dispatch = createEventDispatcher();
  let downloadChart = false;
  let copying = false;
  let printing = false;
  let hovering = false;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ECharts> was created without expected prop 'data'");
    }
  });
  const copy_handler = () => {
    $$invalidate(5, copying = true);
    flush();
    setTimeout(
      () => {
        $$invalidate(5, copying = false);
      },
      0
    );
  };
  const beforeprint_handler = () => $$invalidate(6, printing = true);
  const afterprint_handler = () => $$invalidate(6, printing = false);
  const export_beforeprint_handler = () => $$invalidate(6, printing = true);
  const export_afterprint_handler = () => $$invalidate(6, printing = false);
  const func3 = () => {
    $$invalidate(4, downloadChart = true);
    setTimeout(
      () => {
        $$invalidate(4, downloadChart = false);
      },
      0
    );
  };
  const mouseenter_handler = () => $$invalidate(7, hovering = true);
  const mouseleave_handler = () => $$invalidate(7, hovering = false);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("config" in $$new_props)
      $$invalidate(0, config = $$new_props.config);
    if ("height" in $$new_props)
      $$invalidate(1, height = $$new_props.height);
    if ("width" in $$new_props)
      $$invalidate(2, width = $$new_props.width);
    if ("data" in $$new_props)
      $$invalidate(3, data = $$new_props.data);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude8,
    echarts: echarts_default,
    echartsCanvasDownload: echartsCanvasDownload_default,
    EchartsCopyTarget: EchartsCopyTarget_default,
    DownloadData: DownloadData_default,
    flush,
    createEventDispatcher,
    config,
    height,
    width,
    data,
    dispatch,
    downloadChart,
    copying,
    printing,
    hovering
  });
  $$self.$inject_state = ($$new_props) => {
    if ("config" in $$props)
      $$invalidate(0, config = $$new_props.config);
    if ("height" in $$props)
      $$invalidate(1, height = $$new_props.height);
    if ("width" in $$props)
      $$invalidate(2, width = $$new_props.width);
    if ("data" in $$props)
      $$invalidate(3, data = $$new_props.data);
    if ("downloadChart" in $$props)
      $$invalidate(4, downloadChart = $$new_props.downloadChart);
    if ("copying" in $$props)
      $$invalidate(5, copying = $$new_props.copying);
    if ("printing" in $$props)
      $$invalidate(6, printing = $$new_props.printing);
    if ("hovering" in $$props)
      $$invalidate(7, hovering = $$new_props.hovering);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    config,
    height,
    width,
    data,
    downloadChart,
    copying,
    printing,
    hovering,
    dispatch,
    $$restProps,
    copy_handler,
    beforeprint_handler,
    afterprint_handler,
    export_beforeprint_handler,
    export_afterprint_handler,
    func3,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ECharts = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { config: 0, height: 1, width: 2, data: 3 }, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ECharts",
      options,
      id: create_fragment10.name
    });
  }
  get config() {
    throw new Error("<ECharts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<ECharts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<ECharts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<ECharts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<ECharts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<ECharts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<ECharts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ECharts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ECharts_default = ECharts;

// ../../node_modules/@evidence-dev/component-utilities/src/formatTitle.js
function formatTitle(column, columnFormat) {
  let result = applyTitleTagReplacement(column, columnFormat);
  let acronyms = ["id", "gdp"];
  let lowercase = ["of", "the", "and", "in", "on"];
  function toTitleCase(str) {
    return str.replace(/\S*/g, function(txt) {
      if (!acronyms.includes(txt) && !lowercase.includes(txt)) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      } else if (acronyms.includes(txt)) {
        return txt.toUpperCase();
      } else {
        return txt.toLowerCase();
      }
    });
  }
  result = toTitleCase(result.replace(/_/g, " "));
  return result;
}

// ../../node_modules/@evidence-dev/component-utilities/src/getColumnEvidenceType.js
function getColumnEvidenceType(data, column) {
  let item;
  if (data) {
    if (Array.isArray(data) && data.length > 0) {
      item = data[0];
    } else {
      item = data;
    }
    if (item && item["_evidenceColumnTypes"]) {
      let columnTypes = item["_evidenceColumnTypes"];
      return columnTypes.find((item2) => {
        var _a;
        return ((_a = item2.name) == null ? void 0 : _a.toLowerCase()) === (column == null ? void 0 : column.toLowerCase());
      });
    } else {
      let columnTypes = inferColumnTypes(data);
      return columnTypes.find((item2) => {
        var _a;
        return ((_a = item2.name) == null ? void 0 : _a.toLowerCase()) === (column == null ? void 0 : column.toLowerCase());
      });
    }
  }
  return null;
}

// ../../node_modules/@evidence-dev/component-utilities/src/getColumnExtents.js
function getColumnUnitSummary(data, columnName) {
  let seriesSummary;
  let seriesExtents = tidy(
    data,
    summarize({ min: min(columnName), max: max(columnName), median: median(columnName) })
  )[0];
  let { maxDecimals, unitType } = summarizeUnits(data.map((row) => row[columnName]));
  seriesSummary = {
    min: seriesExtents.min,
    max: seriesExtents.max,
    median: seriesExtents.median,
    maxDecimals,
    unitType
  };
  return seriesSummary;
}
function getColumnExtentsLegacy(data, column) {
  var domainData = tidy(data, summarize({ min: min(column), max: max(column) }));
  let minValue = domainData[0].min;
  let maxValue = domainData[0].max;
  return [minValue, maxValue];
}
function summarizeUnits(series) {
  var _a;
  let undefinedCount = 0;
  let nullCount = 0;
  let stringCount = 0;
  let numberCount = 0;
  let dateCount = 0;
  let objectCount = 0;
  let maxDecimals = 0;
  if (series === void 0 || series === null || series.length === 0) {
    return {
      maxDecimals: 0,
      unitType: "unknown"
    };
  } else {
    for (let i = 0; i < series.length; i++) {
      let nextElement = series[i];
      switch (typeof nextElement) {
        case "undefined":
          undefinedCount++;
          break;
        case "null":
          nullCount++;
          break;
        case "number": {
          numberCount++;
          let thisDecimalPlaces = (_a = nextElement.toString().split(".")[1]) == null ? void 0 : _a.length;
          if (thisDecimalPlaces && thisDecimalPlaces > maxDecimals) {
            maxDecimals = thisDecimalPlaces;
          }
          break;
        }
        case "string":
          stringCount++;
          break;
        case "object":
          if (nextElement instanceof Date) {
            dateCount++;
          } else if (nextElement === null) {
            nullCount++;
          } else {
            objectCount++;
          }
          break;
        case "date":
          dateCount++;
          break;
        case "function":
        default:
          break;
      }
    }
    let unitType = void 0;
    let emptyValueCount = undefinedCount + nullCount;
    if (numberCount + emptyValueCount === series.length) {
      unitType = "number";
    } else if (stringCount + emptyValueCount === series.length) {
      unitType = "string";
    } else if (dateCount + emptyValueCount === series.length) {
      unitType = "date";
    } else if (objectCount + emptyValueCount === series.length) {
      unitType = "object";
    } else {
      unitType = "unknown";
    }
    return {
      maxDecimals,
      unitType
    };
  }
}

// ../../node_modules/@evidence-dev/component-utilities/src/getColumnSummary.js
function getColumnSummary(data, returnType = "object") {
  var colName;
  var colType;
  var evidenceColumnType;
  var colFormat;
  let columnUnitSummary;
  let columnSummary = [];
  var colExtentsLegacy;
  if (returnType === "object") {
    for (const [key] of Object.entries(data[0])) {
      colName = key;
      evidenceColumnType = getColumnEvidenceType(data, colName);
      colType = evidenceColumnType.evidenceType;
      columnUnitSummary = getColumnUnitSummary(data, colName);
      colFormat = lookupColumnFormat(key, evidenceColumnType, columnUnitSummary);
      colExtentsLegacy = getColumnExtentsLegacy(data, colName);
      let thisCol = {
        [colName]: {
          title: formatTitle(colName, colFormat),
          type: colType,
          evidenceColumnType,
          format: colFormat,
          columnUnitSummary,
          extentsLegacy: colExtentsLegacy
        }
      };
      columnSummary = { ...columnSummary, ...thisCol };
    }
  } else {
    for (const [key] of Object.entries(data[0])) {
      colName = key;
      evidenceColumnType = getColumnEvidenceType(data, colName);
      colType = evidenceColumnType.evidenceType;
      columnUnitSummary = getColumnUnitSummary(data, colName);
      colFormat = lookupColumnFormat(key, evidenceColumnType, columnUnitSummary);
      colExtentsLegacy = getColumnExtentsLegacy(data, colName);
      columnSummary.push({
        id: colName,
        title: formatTitle(colName, colFormat),
        type: colType,
        evidenceColumnType,
        format: colFormat,
        columnUnitSummary,
        extentsLegacy: colExtentsLegacy
      });
    }
  }
  return columnSummary;
}

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/diagrams/SankeyDiagram.svelte
var { Object: Object_1 } = globals;
function create_fragment11(ctx) {
  let echarts;
  let current;
  echarts = new ECharts_default({
    props: {
      config: (
        /*config*/
        ctx[2]
      ),
      width: (
        /*width*/
        ctx[0]
      ),
      height: (
        /*height*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(echarts.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(echarts.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(echarts, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const echarts_changes = {};
      if (dirty[0] & /*config*/
      4)
        echarts_changes.config = /*config*/
        ctx2[2];
      if (dirty[0] & /*width*/
      1)
        echarts_changes.width = /*width*/
        ctx2[0];
      if (dirty[0] & /*height*/
      2)
        echarts_changes.height = /*height*/
        ctx2[1];
      echarts.$set(echarts_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(echarts.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(echarts.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(echarts, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude9 = true;
function instance11($$self, $$props, $$invalidate) {
  let config;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SankeyDiagram", slots, []);
  let { data = void 0 } = $$props;
  let { sourceCol = "source" } = $$props;
  let { targetCol = "target" } = $$props;
  let { valueCol = "value" } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { legend = false } = $$props;
  let { label = true } = $$props;
  let { outlineColor = void 0 } = $$props;
  let { outlineWidth = void 0 } = $$props;
  let { nodeAlign = "justify" } = $$props;
  let { nodeGap = 10 } = $$props;
  let { nodeWidth = 20 } = $$props;
  let { orient = "horizontal" } = $$props;
  let { sort = false } = $$props;
  let names = [];
  let links;
  data.map((link) => names.push(link[sourceCol], link[targetCol]));
  const nameData = [...new Set(names)].map((node, index) => ({
    name: node,
    itemStyle: { color: colour[index % colour.length] }
  }));
  let chartAreaHeight;
  let hasTitle;
  let hasSubtitle;
  let hasLegend;
  let titleFontSize;
  let subtitleFontSize;
  let titleBoxPadding;
  let titleBoxHeight;
  let chartAreaPaddingTop;
  let chartAreaPaddingBottom;
  let legendHeight;
  let legendPaddingTop;
  let legendTop;
  let chartTop;
  let chartBottom;
  let chartContainerHeight;
  let height = "400px";
  let width = "100%";
  let columnSummary;
  let columnNames;
  let sourceFormat;
  let targetFormat;
  let valueFormat;
  chartAreaHeight = 300;
  hasTitle = title ? true : false;
  hasSubtitle = subtitle ? true : false;
  hasLegend = legend;
  titleFontSize = 15;
  subtitleFontSize = 13;
  titleBoxPadding = 10 * hasSubtitle;
  titleBoxHeight = hasTitle * titleFontSize + hasSubtitle * subtitleFontSize + titleBoxPadding * Math.max(hasTitle, hasSubtitle);
  chartAreaPaddingTop = 10;
  chartAreaPaddingBottom = 8;
  legendHeight = 15;
  legendHeight = legendHeight * hasLegend;
  legendPaddingTop = 7;
  legendPaddingTop = legendPaddingTop * Math.max(hasTitle, hasSubtitle);
  legendTop = titleBoxHeight + legendPaddingTop;
  chartTop = legendTop + legendHeight + chartAreaPaddingTop;
  chartBottom = chartAreaPaddingBottom;
  chartContainerHeight = chartAreaHeight + chartTop + chartBottom;
  height = chartContainerHeight + "px";
  width = "100%";
  columnSummary = getColumnSummary(data);
  columnNames = Object.keys(columnSummary);
  sourceFormat = columnSummary[columnNames[0]].format;
  targetFormat = columnSummary[columnNames[1]].format;
  valueFormat = columnSummary[columnNames[2]].format;
  let seriesConfig;
  const writable_props = [
    "data",
    "sourceCol",
    "targetCol",
    "valueCol",
    "title",
    "subtitle",
    "legend",
    "label",
    "outlineColor",
    "outlineWidth",
    "nodeAlign",
    "nodeGap",
    "nodeWidth",
    "orient",
    "sort"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SankeyDiagram> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("sourceCol" in $$props2)
      $$invalidate(4, sourceCol = $$props2.sourceCol);
    if ("targetCol" in $$props2)
      $$invalidate(5, targetCol = $$props2.targetCol);
    if ("valueCol" in $$props2)
      $$invalidate(6, valueCol = $$props2.valueCol);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(8, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(9, legend = $$props2.legend);
    if ("label" in $$props2)
      $$invalidate(10, label = $$props2.label);
    if ("outlineColor" in $$props2)
      $$invalidate(11, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(12, outlineWidth = $$props2.outlineWidth);
    if ("nodeAlign" in $$props2)
      $$invalidate(13, nodeAlign = $$props2.nodeAlign);
    if ("nodeGap" in $$props2)
      $$invalidate(14, nodeGap = $$props2.nodeGap);
    if ("nodeWidth" in $$props2)
      $$invalidate(15, nodeWidth = $$props2.nodeWidth);
    if ("orient" in $$props2)
      $$invalidate(16, orient = $$props2.orient);
    if ("sort" in $$props2)
      $$invalidate(17, sort = $$props2.sort);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude9,
    ECharts: ECharts_default,
    colours,
    formatValue,
    colour,
    formatTitle,
    getColumnSummary,
    data,
    sourceCol,
    targetCol,
    valueCol,
    title,
    subtitle,
    legend,
    label,
    outlineColor,
    outlineWidth,
    nodeAlign,
    nodeGap,
    nodeWidth,
    orient,
    sort,
    names,
    links,
    nameData,
    chartAreaHeight,
    hasTitle,
    hasSubtitle,
    hasLegend,
    titleFontSize,
    subtitleFontSize,
    titleBoxPadding,
    titleBoxHeight,
    chartAreaPaddingTop,
    chartAreaPaddingBottom,
    legendHeight,
    legendPaddingTop,
    legendTop,
    chartTop,
    chartBottom,
    chartContainerHeight,
    height,
    width,
    columnSummary,
    columnNames,
    sourceFormat,
    targetFormat,
    valueFormat,
    seriesConfig,
    config
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("sourceCol" in $$props2)
      $$invalidate(4, sourceCol = $$props2.sourceCol);
    if ("targetCol" in $$props2)
      $$invalidate(5, targetCol = $$props2.targetCol);
    if ("valueCol" in $$props2)
      $$invalidate(6, valueCol = $$props2.valueCol);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(8, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(9, legend = $$props2.legend);
    if ("label" in $$props2)
      $$invalidate(10, label = $$props2.label);
    if ("outlineColor" in $$props2)
      $$invalidate(11, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(12, outlineWidth = $$props2.outlineWidth);
    if ("nodeAlign" in $$props2)
      $$invalidate(13, nodeAlign = $$props2.nodeAlign);
    if ("nodeGap" in $$props2)
      $$invalidate(14, nodeGap = $$props2.nodeGap);
    if ("nodeWidth" in $$props2)
      $$invalidate(15, nodeWidth = $$props2.nodeWidth);
    if ("orient" in $$props2)
      $$invalidate(16, orient = $$props2.orient);
    if ("sort" in $$props2)
      $$invalidate(17, sort = $$props2.sort);
    if ("names" in $$props2)
      names = $$props2.names;
    if ("links" in $$props2)
      $$invalidate(18, links = $$props2.links);
    if ("chartAreaHeight" in $$props2)
      chartAreaHeight = $$props2.chartAreaHeight;
    if ("hasTitle" in $$props2)
      hasTitle = $$props2.hasTitle;
    if ("hasSubtitle" in $$props2)
      hasSubtitle = $$props2.hasSubtitle;
    if ("hasLegend" in $$props2)
      hasLegend = $$props2.hasLegend;
    if ("titleFontSize" in $$props2)
      titleFontSize = $$props2.titleFontSize;
    if ("subtitleFontSize" in $$props2)
      subtitleFontSize = $$props2.subtitleFontSize;
    if ("titleBoxPadding" in $$props2)
      titleBoxPadding = $$props2.titleBoxPadding;
    if ("titleBoxHeight" in $$props2)
      titleBoxHeight = $$props2.titleBoxHeight;
    if ("chartAreaPaddingTop" in $$props2)
      chartAreaPaddingTop = $$props2.chartAreaPaddingTop;
    if ("chartAreaPaddingBottom" in $$props2)
      chartAreaPaddingBottom = $$props2.chartAreaPaddingBottom;
    if ("legendHeight" in $$props2)
      legendHeight = $$props2.legendHeight;
    if ("legendPaddingTop" in $$props2)
      legendPaddingTop = $$props2.legendPaddingTop;
    if ("legendTop" in $$props2)
      $$invalidate(19, legendTop = $$props2.legendTop);
    if ("chartTop" in $$props2)
      chartTop = $$props2.chartTop;
    if ("chartBottom" in $$props2)
      chartBottom = $$props2.chartBottom;
    if ("chartContainerHeight" in $$props2)
      chartContainerHeight = $$props2.chartContainerHeight;
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("columnSummary" in $$props2)
      columnSummary = $$props2.columnSummary;
    if ("columnNames" in $$props2)
      columnNames = $$props2.columnNames;
    if ("sourceFormat" in $$props2)
      $$invalidate(20, sourceFormat = $$props2.sourceFormat);
    if ("targetFormat" in $$props2)
      $$invalidate(21, targetFormat = $$props2.targetFormat);
    if ("valueFormat" in $$props2)
      $$invalidate(22, valueFormat = $$props2.valueFormat);
    if ("seriesConfig" in $$props2)
      $$invalidate(23, seriesConfig = $$props2.seriesConfig);
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*data, sourceCol, targetCol, valueCol*/
    120) {
      $:
        $$invalidate(18, links = data.map((link) => {
          return {
            source: link[sourceCol],
            target: link[targetCol],
            value: link[valueCol]
          };
        }));
    }
    if ($$self.$$.dirty[0] & /*sort, orient, nodeGap, nodeWidth, nodeAlign, label, outlineColor, outlineWidth, sourceCol, sourceFormat, targetFormat, valueFormat, links*/
    7863312) {
      $:
        $$invalidate(23, seriesConfig = {
          type: "sankey",
          layout: "none",
          layoutIterations: sort === "true" ? 1 : 0,
          // Preserve data order in layout
          left: "10%",
          top: orient === "vertical" ? 80 : 60,
          bottom: orient === "vertical" ? 0 : 10,
          width: "70%",
          nodeGap,
          nodeWidth,
          nodeAlign,
          orient,
          emphasis: { focus: "adjacency" },
          label: {
            show: label,
            position: orient === "vertical" ? "top" : "right",
            fontSize: orient === "vertical" ? 10.5 : 12,
            formatter(params) {
              return `${formatTitle(params.data.name)}`;
            }
          },
          itemStyle: {
            borderColor: outlineColor,
            borderWidth: outlineWidth
          },
          tooltip: {
            formatter(params) {
              return params.data.name ? `<b>${formatTitle(params.data.name)}</b>` : `<b>${formatTitle(params.data[sourceCol], sourceFormat)}</b>  <b>${formatTitle(params.data.target, targetFormat)}</b><br>${formatValue(params.data.value, valueFormat)}`;
            },
            padding: 6,
            borderRadius: 4,
            borderWidth: 1,
            borderColor: colours.grey400,
            backgroundColor: "white",
            extraCssText: "box-shadow: 0 3px 6px rgba(0,0,0,.15); box-shadow: 0 2px 4px rgba(0,0,0,.12); z-index: 1;",
            textStyle: {
              color: colours.grey900,
              fontSize: 12,
              fontWeight: 400
            },
            order: "valueDesc"
          },
          data: nameData,
          links
        });
    }
    if ($$self.$$.dirty[0] & /*title, subtitle, width, legend, legendTop, seriesConfig*/
    8913793) {
      $:
        $$invalidate(2, config = {
          title: {
            text: title,
            subtext: subtitle,
            subtextStyle: { width }
          },
          tooltip: { trigger: "item" },
          legend: {
            show: legend,
            type: "scroll",
            top: legendTop,
            padding: [0, 0, 0, 0]
          },
          series: [seriesConfig]
        });
    }
  };
  return [
    width,
    height,
    config,
    data,
    sourceCol,
    targetCol,
    valueCol,
    title,
    subtitle,
    legend,
    label,
    outlineColor,
    outlineWidth,
    nodeAlign,
    nodeGap,
    nodeWidth,
    orient,
    sort,
    links,
    legendTop,
    sourceFormat,
    targetFormat,
    valueFormat,
    seriesConfig
  ];
}
var SankeyDiagram = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        data: 3,
        sourceCol: 4,
        targetCol: 5,
        valueCol: 6,
        title: 7,
        subtitle: 8,
        legend: 9,
        label: 10,
        outlineColor: 11,
        outlineWidth: 12,
        nodeAlign: 13,
        nodeGap: 14,
        nodeWidth: 15,
        orient: 16,
        sort: 17
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SankeyDiagram",
      options,
      id: create_fragment11.name
    });
  }
  get data() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceCol() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceCol(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetCol() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetCol(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueCol() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueCol(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineColor() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineColor(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineWidth() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineWidth(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeAlign() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeAlign(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeGap() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeGap(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeWidth() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeWidth(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orient() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orient(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sort() {
    throw new Error("<SankeyDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sort(value) {
    throw new Error("<SankeyDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SankeyDiagram_default = SankeyDiagram;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/diagrams/VennDiagram.svelte
var file11 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/diagrams/VennDiagram.svelte";
function add_css8(target) {
  append_styles(target, "svelte-1qwuwh0", "svg.main.svelte-1qwuwh0{height:16em;width:16em}text.svelte-1qwuwh0{font:0.7em var(--monospace-font-family);stroke:none}circle.svelte-1qwuwh0{pointer-events:all;fill-opacity:0.1}.a.svelte-1qwuwh0{stroke:var(--blue-500);fill:var(--blue-500)}.b.svelte-1qwuwh0{stroke:var(--green-500);fill:var(--green-500)}.c.svelte-1qwuwh0{fill:#8b5cf6;stroke:#8b5cf6}.label-a.svelte-1qwuwh0{fill:var(--blue-800)}.label-b.svelte-1qwuwh0{fill:var(--green-800)}.label-c.svelte-1qwuwh0{fill:#8b5cf6}div.container.svelte-1qwuwh0{display:flex;margin:1.5em 0;align-items:center;justify-items:flex-end}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmVubkRpYWdyYW0uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXNHQyxHQUFBLEtBQUEsZUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLElBQVksQ0FDWixLQUFBLENBQUEsSUFBVyxBQUNaLENBQUEsQUFFQSxJQUFBLGVBQUEsQ0FBQSxBQUNDLElBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSx1QkFBQSxDQUF3QyxDQUN4QyxNQUFBLENBQUEsSUFBWSxBQUNiLENBQUEsQUFFQSxNQUFBLGVBQUEsQ0FBQSxBQUNDLGNBQUEsQ0FBQSxHQUFtQixDQUNuQixZQUFBLENBQUEsR0FBaUIsQUFDbEIsQ0FBQSxBQUVBLEVBQUEsZUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLElBQUEsVUFBQSxDQUF1QixDQUN2QixJQUFBLENBQUEsSUFBQSxVQUFBLENBQXFCLEFBQ3RCLENBQUEsQUFFQSxFQUFBLGVBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxJQUFBLFdBQUEsQ0FBd0IsQ0FDeEIsSUFBQSxDQUFBLElBQUEsV0FBQSxDQUFzQixBQUN2QixDQUFBLEFBRUEsRUFBQSxlQUFBLENBQUEsQUFFQyxJQUFBLENBQUEsT0FBYSxDQUNiLE1BQUEsQ0FBQSxPQUFlLEFBTWhCLENBQUEsQUFFQSxRQUFBLGVBQUEsQ0FBQSxBQUNDLElBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBcUIsQUFDdEIsQ0FBQSxBQUVBLFFBQUEsZUFBQSxDQUFBLEFBQ0MsSUFBQSxDQUFBLElBQUEsV0FBQSxDQUFzQixBQUN2QixDQUFBLEFBRUEsUUFBQSxlQUFBLENBQUEsQUFDQyxJQUFBLENBQUEsT0FBYSxBQUVkLENBQUEsQUFFQSxHQUFBLFVBQUEsZUFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQ0FDYixNQUFBLENBQUEsS0FBQSxDQUFBLENBQWUsQ0FDZixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsYUFBQSxDQUFBLFFBQXVCLEFBQ3hCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVmVubkRpYWdyYW0uc3ZlbHRlIl19 */");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function create_each_block_12(ctx) {
  let circle;
  let circle_class_value;
  let circle_cx_value;
  let circle_cy_value;
  let circle_r_value;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", { class: true, cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "class", circle_class_value = null_to_empty(
        /*circle*/
        ctx[14].class
      ) + " svelte-1qwuwh0");
      attr_dev(circle, "cx", circle_cx_value = /*circle*/
      ctx[14].x);
      attr_dev(circle, "cy", circle_cy_value = /*circle*/
      ctx[14].y);
      attr_dev(circle, "r", circle_r_value = /*radius*/
      ctx[3] + "%");
      add_location(circle, file11, 71, 3, 1963);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(71:2) {#each circles as circle}",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let text_1;
  let t_value = (
    /*intersect*/
    ctx[11].value + ""
  );
  let t;
  let text_1_x_value;
  let text_1_y_value;
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      text_1 = claim_svg_element(nodes, "text", {
        x: true,
        y: true,
        "dominant-baseline": true,
        "text-anchor": true,
        class: true
      });
      var text_1_nodes = children(text_1);
      t = claim_text(text_1_nodes, t_value);
      text_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "x", text_1_x_value = /*intersect*/
      ctx[11].x + "%");
      attr_dev(text_1, "y", text_1_y_value = /*intersect*/
      ctx[11].y + "%");
      attr_dev(text_1, "dominant-baseline", "middle");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "class", "svelte-1qwuwh0");
      add_location(text_1, file11, 75, 3, 2114);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, text_1, anchor);
      append_hydration_dev(text_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*intercets*/
      4 && t_value !== (t_value = /*intersect*/
      ctx2[11].value + ""))
        set_data_dev(t, t_value);
      if (dirty & /*intercets*/
      4 && text_1_x_value !== (text_1_x_value = /*intersect*/
      ctx2[11].x + "%")) {
        attr_dev(text_1, "x", text_1_x_value);
      }
      if (dirty & /*intercets*/
      4 && text_1_y_value !== (text_1_y_value = /*intersect*/
      ctx2[11].y + "%")) {
        attr_dev(text_1, "y", text_1_y_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(text_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(75:2) {#each intercets as intersect}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  var _a, _b, _c;
  let div;
  let svg;
  let each0_anchor;
  let text0;
  let t0_value = (
    /*labels*/
    (ctx[0][0] ?? "") + ""
  );
  let t0;
  let text1;
  let t1_value = (
    /*amounts*/
    (((_a = ctx[1][0]) == null ? void 0 : _a.toLocaleString("en-gb")) ?? "") + ""
  );
  let t1;
  let text2;
  let t2_value = (
    /*labels*/
    (ctx[0][2] ?? "") + ""
  );
  let t2;
  let text3;
  let t3_value = (
    /*amounts*/
    (((_b = ctx[1][2]) == null ? void 0 : _b.toLocaleString("en-gb")) ?? "") + ""
  );
  let t3;
  let text4;
  let t4_value = (
    /*labels*/
    (ctx[0][1] ?? "") + ""
  );
  let t4;
  let text5;
  let t5_value = (
    /*amounts*/
    (((_c = ctx[1][1]) == null ? void 0 : _c.toLocaleString("en-gb")) ?? "") + ""
  );
  let t5;
  let each_value_1 = (
    /*circles*/
    ctx[4]
  );
  validate_each_argument(each_value_1);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  let each_value = (
    /*intercets*/
    ctx[2]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      each0_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      text0 = svg_element("text");
      t0 = text(t0_value);
      text1 = svg_element("text");
      t1 = text(t1_value);
      text2 = svg_element("text");
      t2 = text(t2_value);
      text3 = svg_element("text");
      t3 = text(t3_value);
      text4 = svg_element("text");
      t4 = text(t4_value);
      text5 = svg_element("text");
      t5 = text(t5_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      svg = claim_svg_element(div_nodes, "svg", { class: true });
      var svg_nodes = children(svg);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(svg_nodes);
      }
      each0_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(svg_nodes);
      }
      text0 = claim_svg_element(svg_nodes, "text", {
        x: true,
        y: true,
        "dominant-baseline": true,
        class: true
      });
      var text0_nodes = children(text0);
      t0 = claim_text(text0_nodes, t0_value);
      text0_nodes.forEach(detach_dev);
      text1 = claim_svg_element(svg_nodes, "text", {
        x: true,
        y: true,
        "dominant-baseline": true,
        class: true
      });
      var text1_nodes = children(text1);
      t1 = claim_text(text1_nodes, t1_value);
      text1_nodes.forEach(detach_dev);
      text2 = claim_svg_element(svg_nodes, "text", { x: true, y: true, class: true });
      var text2_nodes = children(text2);
      t2 = claim_text(text2_nodes, t2_value);
      text2_nodes.forEach(detach_dev);
      text3 = claim_svg_element(svg_nodes, "text", { x: true, y: true, class: true });
      var text3_nodes = children(text3);
      t3 = claim_text(text3_nodes, t3_value);
      text3_nodes.forEach(detach_dev);
      text4 = claim_svg_element(svg_nodes, "text", {
        x: true,
        y: true,
        "text-anchor": true,
        class: true
      });
      var text4_nodes = children(text4);
      t4 = claim_text(text4_nodes, t4_value);
      text4_nodes.forEach(detach_dev);
      text5 = claim_svg_element(svg_nodes, "text", {
        x: true,
        y: true,
        "text-anchor": true,
        class: true
      });
      var text5_nodes = children(text5);
      t5 = claim_text(text5_nodes, t5_value);
      text5_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text0, "x", "0%");
      attr_dev(text0, "y", "1%");
      attr_dev(text0, "dominant-baseline", "hanging");
      attr_dev(text0, "class", "label-a svelte-1qwuwh0");
      add_location(text0, file11, 86, 2, 2304);
      attr_dev(text1, "x", "0%");
      attr_dev(text1, "y", "6%");
      attr_dev(text1, "dominant-baseline", "hanging");
      attr_dev(text1, "class", "label-a svelte-1qwuwh0");
      add_location(text1, file11, 87, 2, 2395);
      attr_dev(text2, "x", "0%");
      attr_dev(text2, "y", "94%");
      attr_dev(text2, "class", "label-b svelte-1qwuwh0");
      add_location(text2, file11, 91, 2, 2520);
      attr_dev(text3, "x", "0%");
      attr_dev(text3, "y", "99%");
      attr_dev(text3, "class", "label-b svelte-1qwuwh0");
      add_location(text3, file11, 92, 2, 2584);
      attr_dev(text4, "x", "100%");
      attr_dev(text4, "y", "94%");
      attr_dev(text4, "text-anchor", "end");
      attr_dev(text4, "class", "label-c svelte-1qwuwh0");
      add_location(text4, file11, 94, 2, 2675);
      attr_dev(text5, "x", "100%");
      attr_dev(text5, "y", "99%");
      attr_dev(text5, "text-anchor", "end");
      attr_dev(text5, "class", "label-c svelte-1qwuwh0");
      add_location(text5, file11, 95, 2, 2759);
      attr_dev(svg, "class", "main svelte-1qwuwh0");
      add_location(svg, file11, 68, 1, 1894);
      attr_dev(div, "class", "container svelte-1qwuwh0");
      add_location(div, file11, 67, 0, 1869);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, svg);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(svg, null);
      }
      append_hydration_dev(svg, each0_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(svg, null);
      }
      append_hydration_dev(svg, text0);
      append_hydration_dev(text0, t0);
      append_hydration_dev(svg, text1);
      append_hydration_dev(text1, t1);
      append_hydration_dev(svg, text2);
      append_hydration_dev(text2, t2);
      append_hydration_dev(svg, text3);
      append_hydration_dev(text3, t3);
      append_hydration_dev(svg, text4);
      append_hydration_dev(text4, t4);
      append_hydration_dev(svg, text5);
      append_hydration_dev(text5, t5);
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2, _c2;
      if (dirty & /*circles, radius*/
      24) {
        each_value_1 = /*circles*/
        ctx2[4];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_12(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(svg, each0_anchor);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*intercets*/
      4) {
        each_value = /*intercets*/
        ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(svg, text0);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*labels*/
      1 && t0_value !== (t0_value = /*labels*/
      (ctx2[0][0] ?? "") + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*amounts*/
      2 && t1_value !== (t1_value = /*amounts*/
      (((_a2 = ctx2[1][0]) == null ? void 0 : _a2.toLocaleString("en-gb")) ?? "") + ""))
        set_data_dev(t1, t1_value);
      if (dirty & /*labels*/
      1 && t2_value !== (t2_value = /*labels*/
      (ctx2[0][2] ?? "") + ""))
        set_data_dev(t2, t2_value);
      if (dirty & /*amounts*/
      2 && t3_value !== (t3_value = /*amounts*/
      (((_b2 = ctx2[1][2]) == null ? void 0 : _b2.toLocaleString("en-gb")) ?? "") + ""))
        set_data_dev(t3, t3_value);
      if (dirty & /*labels*/
      1 && t4_value !== (t4_value = /*labels*/
      (ctx2[0][1] ?? "") + ""))
        set_data_dev(t4, t4_value);
      if (dirty & /*amounts*/
      2 && t5_value !== (t5_value = /*amounts*/
      (((_c2 = ctx2[1][1]) == null ? void 0 : _c2.toLocaleString("en-gb")) ?? "") + ""))
        set_data_dev(t5, t5_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude10 = true;
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VennDiagram", slots, []);
  let radius = 25;
  let { overlaps = ["A", "AB", "BC", "AC", "ABC"] } = $$props;
  let { labels = ["ACRONYM CO", "GRID REIT", "First Malaysian"] } = $$props;
  let { amounts = [1232430, 254856548, 36524982] } = $$props;
  let side = radius;
  let height = Math.sqrt(3) / 2 * side;
  let origin = { x: 50 - side / 2, y: 50 + height / 2 };
  let apothem = height / 3;
  let distanceToLabels = (height + radius + Math.sin(30 * Math.PI / 180) * radius) / 3;
  let circles = [
    {
      x: "50%",
      y: 50 - height / 2 + "%",
      class: "a"
    },
    {
      x: 50 - side / 2 + "%",
      y: 50 + height / 2 + "%",
      class: "b"
    },
    {
      x: 50 + side / 2 + "%",
      y: 50 + height / 2 + "%",
      class: "c"
    }
  ];
  let intercets;
  const writable_props = ["overlaps", "labels", "amounts"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VennDiagram> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("overlaps" in $$props2)
      $$invalidate(5, overlaps = $$props2.overlaps);
    if ("labels" in $$props2)
      $$invalidate(0, labels = $$props2.labels);
    if ("amounts" in $$props2)
      $$invalidate(1, amounts = $$props2.amounts);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude10,
    radius,
    overlaps,
    labels,
    amounts,
    side,
    height,
    origin,
    apothem,
    distanceToLabels,
    circles,
    intercets
  });
  $$self.$inject_state = ($$props2) => {
    if ("radius" in $$props2)
      $$invalidate(3, radius = $$props2.radius);
    if ("overlaps" in $$props2)
      $$invalidate(5, overlaps = $$props2.overlaps);
    if ("labels" in $$props2)
      $$invalidate(0, labels = $$props2.labels);
    if ("amounts" in $$props2)
      $$invalidate(1, amounts = $$props2.amounts);
    if ("side" in $$props2)
      side = $$props2.side;
    if ("height" in $$props2)
      height = $$props2.height;
    if ("origin" in $$props2)
      $$invalidate(8, origin = $$props2.origin);
    if ("apothem" in $$props2)
      $$invalidate(9, apothem = $$props2.apothem);
    if ("distanceToLabels" in $$props2)
      $$invalidate(10, distanceToLabels = $$props2.distanceToLabels);
    if ("circles" in $$props2)
      $$invalidate(4, circles = $$props2.circles);
    if ("intercets" in $$props2)
      $$invalidate(2, intercets = $$props2.intercets);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b, _c, _d, _e;
    if ($$self.$$.dirty & /*overlaps*/
    32) {
      $:
        distanceToLabels, $$invalidate(2, intercets = [
          // A only
          {
            x: 50,
            y: origin.y - 2 * apothem - distanceToLabels,
            value: ((_a = overlaps[0]) == null ? void 0 : _a.toLocaleString("en-GB", { style: "percent" })) ?? ""
          },
          // ABC
          {
            x: 50,
            y: origin.y - apothem,
            value: ((_b = overlaps[4]) == null ? void 0 : _b.toLocaleString("en-GB", { style: "percent" })) ?? ""
          },
          {
            x: 50 - distanceToLabels * Math.cos(30 * Math.PI / 180),
            y: origin.y - apothem - distanceToLabels * Math.sin(30 * Math.PI / 180),
            value: ((_c = overlaps[3]) == null ? void 0 : _c.toLocaleString("en-GB", { style: "percent" })) ?? ""
          },
          {
            x: 50 + distanceToLabels * Math.cos(30 * Math.PI / 180),
            y: origin.y - apothem - distanceToLabels * Math.sin(30 * Math.PI / 180),
            value: ((_d = overlaps[1]) == null ? void 0 : _d.toLocaleString("en-GB", { style: "percent" })) ?? ""
          },
          {
            x: 50,
            y: origin.y - apothem + distanceToLabels,
            value: ((_e = overlaps[2]) == null ? void 0 : _e.toLocaleString("en-GB", { style: "percent" })) ?? ""
          }
        ]);
    }
  };
  return [labels, amounts, intercets, radius, circles, overlaps];
}
var VennDiagram = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { overlaps: 5, labels: 0, amounts: 1 }, add_css8);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VennDiagram",
      options,
      id: create_fragment12.name
    });
  }
  get overlaps() {
    throw new Error("<VennDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlaps(value) {
    throw new Error("<VennDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labels() {
    throw new Error("<VennDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labels(value) {
    throw new Error("<VennDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get amounts() {
    throw new Error("<VennDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set amounts(value) {
    throw new Error("<VennDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VennDiagram_default = VennDiagram;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Accordion.svelte
var file12 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Accordion.svelte";
function create_fragment13(ctx) {
  let div1;
  let div0;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "overflow-hidden divide-y rounded");
      add_location(div0, file12, 18, 1, 436);
      attr_dev(div1, "class", "my-6 divide-y border border-neutral-200 rounded");
      add_location(div1, file12, 17, 0, 373);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude11 = true;
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  const activeItem = writable(-1);
  function setActiveItem(index) {
    activeItem.update((current) => current === index ? -1 : index);
  }
  setContext("accordion", { setActiveItem, activeItem });
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Accordion> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude11,
    setContext,
    writable,
    activeItem,
    setActiveItem
  });
  return [$$scope, slots];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment13.name
    });
  }
};
var Accordion_default = Accordion;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/AccordionItem.svelte
var file13 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/AccordionItem.svelte";
function create_else_block(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: ChevronDown,
      class: "text-gray-600 w-6 h-6"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(43:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: ChevronUp,
      class: "text-gray-600 w-6 h-6"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(41:2) {#if toggled}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let div2;
  let button;
  let h3;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block;
  let t2;
  let div1;
  let div0;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block9, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*toggled*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      div2 = element("div");
      button = element("button");
      h3 = element("h3");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      if_block.c();
      t2 = space();
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      button = claim_element(div2_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      h3 = claim_element(button_nodes, "H3", { class: true });
      var h3_nodes = children(h3);
      t0 = claim_text(
        h3_nodes,
        /*title*/
        ctx[0]
      );
      h3_nodes.forEach(detach_dev);
      t1 = claim_space(button_nodes);
      if_block.l(button_nodes);
      button_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h3, "class", "text-lg my-3");
      add_location(h3, file13, 39, 2, 1061);
      attr_dev(button, "class", "flex justify-between items-center w-full box-border px-4 bg-white border-none cursor-pointer transition ease-in-out duration-300 hover:bg-gray-100 focus:outline-none");
      add_location(button, file13, 35, 1, 815);
      attr_dev(div0, "class", "p-5");
      add_location(div0, file13, 51, 2, 1398);
      attr_dev(div1, "class", "text-base overflow-auto transition-all duration-300 ease-in-out");
      set_style(
        div1,
        "height",
        /*height*/
        ctx[4] + "px"
      );
      add_location(div1, file13, 46, 1, 1263);
      attr_dev(div2, "class", "accordion-item");
      add_location(div2, file13, 34, 0, 768);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, button);
      append_hydration_dev(button, h3);
      append_hydration_dev(h3, t0);
      append_hydration_dev(button, t1);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[10](div1);
      ctx[11](div2);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[9],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      1)
        set_data_dev(
          t0,
          /*title*/
          ctx2[0]
        );
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*height*/
      16) {
        set_style(
          div1,
          "height",
          /*height*/
          ctx2[4] + "px"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[10](null);
      ctx[11](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude12 = true;
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["default"]);
  let { title = "" } = $$props;
  const accordionContext = getContext("accordion");
  let index;
  let node;
  let content;
  let height = 0;
  let toggled = false;
  accordionContext.activeItem.subscribe((val) => {
    $$invalidate(5, toggled = val === index);
    if (toggled) {
      $$invalidate(4, height = content.scrollHeight);
    } else {
      $$invalidate(4, height = 0);
    }
  });
  onMount(() => {
    const accordionItems = Array.from(document.querySelectorAll(".accordion-item"));
    $$invalidate(1, index = accordionItems.indexOf(node));
  });
  const writable_props = ["title"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AccordionItem> was created with unknown prop '${key}'`);
  });
  const click_handler = () => accordionContext.setActiveItem(index);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      content = $$value;
      $$invalidate(3, content);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      node = $$value;
      $$invalidate(2, node);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude12,
    getContext,
    onMount,
    ChevronDown,
    ChevronUp,
    Icon: Icon_default,
    title,
    accordionContext,
    index,
    node,
    content,
    height,
    toggled
  });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("index" in $$props2)
      $$invalidate(1, index = $$props2.index);
    if ("node" in $$props2)
      $$invalidate(2, node = $$props2.node);
    if ("content" in $$props2)
      $$invalidate(3, content = $$props2.content);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("toggled" in $$props2)
      $$invalidate(5, toggled = $$props2.toggled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    title,
    index,
    node,
    content,
    height,
    toggled,
    accordionContext,
    $$scope,
    slots,
    click_handler,
    div1_binding,
    div2_binding
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { title: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment14.name
    });
  }
  get title() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/LinkButton.svelte
var file14 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/LinkButton.svelte";
function create_fragment15(ctx) {
  let a;
  let div;
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      a = element("a");
      div = element("div");
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      div = claim_element(a_nodes, "DIV", {});
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file14, 13, 2, 382);
      add_location(div, file14, 12, 1, 374);
      attr_dev(
        a,
        "href",
        /*url*/
        ctx[0]
      );
      attr_dev(a, "class", "font-ui font-normal text-base no-underline border mt-5 rounded-lg py-2 px-3 inline-block transition hover:ease-in hover:border-blue-200 hover:bg-blue-100 hover:no-underline hover:text-gray-800 focus:text-gray-900 focus:border-blue-200");
      add_location(a, file14, 8, 0, 112);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, div);
      append_hydration_dev(div, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*url*/
      1) {
        attr_dev(
          a,
          "href",
          /*url*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude13 = true;
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LinkButton", slots, ["default"]);
  let { url } = $$props;
  $$self.$$.on_mount.push(function() {
    if (url === void 0 && !("url" in $$props || $$self.$$.bound[$$self.$$.props["url"]])) {
      console.warn("<LinkButton> was created without expected prop 'url'");
    }
  });
  const writable_props = ["url"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LinkButton> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("url" in $$props2)
      $$invalidate(0, url = $$props2.url);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ evidenceInclude: evidenceInclude13, url });
  $$self.$inject_state = ($$props2) => {
    if ("url" in $$props2)
      $$invalidate(0, url = $$props2.url);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [url, $$scope, slots];
}
var LinkButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { url: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LinkButton",
      options,
      id: create_fragment15.name
    });
  }
  get url() {
    throw new Error("<LinkButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<LinkButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LinkButton_default = LinkButton;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/BigLink.svelte
var file15 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/BigLink.svelte";
function add_css9(target) {
  append_styles(target, "svelte-1xrw3u0", "div.svelte-1xrw3u0{border:1px solid var(--grey-200);border-radius:6px;padding:0.3em 0.6em;font-family:var(--ui-font-family);font-size:0.8em;margin-top:1em;margin-bottom:1.25em;cursor:pointer;transition:all 400ms}a.svelte-1xrw3u0{text-decoration:none;color:var(--blue-600)}a.svelte-1xrw3u0:hover{text-decoration:none;color:var(--blue-700)}div.svelte-1xrw3u0:hover{border:1px solid var(--grey-300);transition:all 400ms;box-shadow:0 5px 5px 2px hsl(0deg 0% 97%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmlnTGluay5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBaUJDLEdBQUEsZUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLGFBQUEsQ0FBQSxHQUFrQixDQUNsQixPQUFBLENBQUEsS0FBQSxDQUFBLEtBQW9CLENBQ3BCLFdBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQWtDLENBQ2xDLFNBQUEsQ0FBQSxLQUFnQixDQUNoQixVQUFBLENBQUEsR0FBZSxDQUNmLGFBQUEsQ0FBQSxNQUFxQixDQUNyQixNQUFBLENBQUEsT0FBZSxDQUNmLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBcUIsQUFDdEIsQ0FBQSxBQUVBLENBQUEsZUFBQSxDQUFBLEFBQ0MsZUFBQSxDQUFBLElBQXFCLENBQ3JCLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLGdCQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsZUFBQSxDQUFBLElBQXFCLENBQ3JCLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLGtCQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBcUIsQ0FDckIsVUFBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxJQUFBLElBQUEsQ0FBQSxFQUFBLENBQUEsR0FBQSxDQUEwQyxBQUMzQyxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJpZ0xpbmsuc3ZlbHRlIl19 */");
}
function create_fragment16(ctx) {
  let a;
  let div;
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      a = element("a");
      div = element("div");
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      div = claim_element(a_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file15, 10, 2, 133);
      attr_dev(div, "class", "svelte-1xrw3u0");
      add_location(div, file15, 9, 1, 125);
      attr_dev(
        a,
        "href",
        /*href*/
        ctx[0]
      );
      attr_dev(a, "class", "svelte-1xrw3u0");
      add_location(a, file15, 8, 0, 113);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, div);
      append_hydration_dev(div, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*href*/
      1) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude14 = true;
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BigLink", slots, ["default"]);
  let { href } = $$props;
  $$self.$$.on_mount.push(function() {
    if (href === void 0 && !("href" in $$props || $$self.$$.bound[$$self.$$.props["href"]])) {
      console.warn("<BigLink> was created without expected prop 'href'");
    }
  });
  const writable_props = ["href"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BigLink> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("href" in $$props2)
      $$invalidate(0, href = $$props2.href);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ evidenceInclude: evidenceInclude14, href });
  $$self.$inject_state = ($$props2) => {
    if ("href" in $$props2)
      $$invalidate(0, href = $$props2.href);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [href, $$scope, slots];
}
var BigLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { href: 0 }, add_css9);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BigLink",
      options,
      id: create_fragment16.name
    });
  }
  get href() {
    throw new Error("<BigLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<BigLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BigLink_default = BigLink;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/BreadCrumbs.svelte
import { page as page3 } from "$app/stores";
var file16 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/BreadCrumbs.svelte";
function add_css10(target) {
  append_styles(target, "svelte-1jq84bz", "div.main.svelte-1jq84bz{padding:0 0.5em 0 1.5em;box-sizing:border-box;width:100%;white-space:nowrap;-ms-overflow-style:none;scrollbar-width:none}span.svelte-1jq84bz{font-size:small;font-family:var(--ui-font-family-compact);-webkit-font-smoothing:antialiased;color:var(--grey-700)}a.svelte-1jq84bz{text-transform:capitalize;text-decoration:none;color:var(--grey-700)}a.svelte-1jq84bz:hover{color:var(--grey-999);transition:all 0.2s}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnJlYWRDcnVtYnMuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWdHQyxHQUFBLEtBQUEsZUFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLENBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxDQUFBLEtBQXdCLENBQ3hCLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixLQUFBLENBQUEsSUFBVyxDQUNYLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixrQkFBQSxDQUFBLElBQXdCLENBQ3hCLGVBQUEsQ0FBQSxJQUFxQixBQUN0QixDQUFBLEFBRUEsSUFBQSxlQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsS0FBZ0IsQ0FDaEIsV0FBQSxDQUFBLElBQUEsd0JBQUEsQ0FBMEMsQ0FDMUMsc0JBQUEsQ0FBQSxXQUFtQyxDQUNuQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEsQUFFQSxDQUFBLGVBQUEsQ0FBQSxBQUNDLGNBQUEsQ0FBQSxVQUEwQixDQUMxQixlQUFBLENBQUEsSUFBcUIsQ0FDckIsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBLEFBQ0EsZ0JBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFVBQUEsQ0FBQSxHQUFBLENBQUEsSUFBb0IsQUFDckIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJCcmVhZENydW1icy5zdmVsdGUiXX0= */");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_else_block2(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*crumbs*/
    ctx[1]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*crumbs, Home*/
      2) {
        each_value = /*crumbs*/
        ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(78:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let a;
  let icon;
  let t;
  let current;
  icon = new Icon_default({
    props: {
      src: Home,
      class: "h-4 w-4 inline-block stroke-1"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      a = element("a");
      create_component(icon.$$.fragment);
      t = text(" Home");
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      claim_component(icon.$$.fragment, a_nodes);
      t = claim_text(a_nodes, " Home");
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", "/");
      attr_dev(a, "class", "inline-flex gap-1 items-center svelte-1jq84bz");
      add_location(a, file16, 74, 3, 1906);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      mount_component(icon, a, null);
      append_hydration_dev(a, t);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(74:2) {#if $page.url.pathname.startsWith('/settings') || $page.url.pathname === '/'}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let a;
  let current_block_type_index;
  let if_block;
  let t;
  let a_href_value;
  let current;
  const if_block_creators = [create_if_block_22, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*crumb*/
      ctx2[6].title === "Home"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      a = element("a");
      if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      if_block.l(a_nodes);
      t = claim_space(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = /*crumb*/
      ctx[6].href);
      attr_dev(a, "class", "inline-flex gap-1 items-center svelte-1jq84bz");
      add_location(a, file16, 82, 5, 2167);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      append_hydration_dev(a, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(a, t);
      }
      if (!current || dirty & /*crumbs*/
      2 && a_href_value !== (a_href_value = /*crumb*/
      ctx2[6].href)) {
        attr_dev(a, "href", a_href_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(82:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let t0;
  let a;
  let t1_value = (
    /*crumb*/
    ctx[6].title + ""
  );
  let t1;
  let a_href_value;
  const block = {
    c: function create() {
      t0 = text("/");
      a = element("a");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, "/");
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      t1 = claim_text(a_nodes, t1_value);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = /*crumb*/
      ctx[6].href);
      attr_dev(a, "class", "svelte-1jq84bz");
      add_location(a, file16, 80, 22, 2111);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*crumbs*/
      2 && t1_value !== (t1_value = /*crumb*/
      ctx2[6].title + ""))
        set_data_dev(t1, t1_value);
      if (dirty & /*crumbs*/
      2 && a_href_value !== (a_href_value = /*crumb*/
      ctx2[6].href)) {
        attr_dev(a, "href", a_href_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(a);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(80:4) {#if i > 0}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let t_value = (
    /*crumb*/
    ctx[6].title + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*crumbs*/
      2 && t_value !== (t_value = /*crumb*/
      ctx2[6].title + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(86:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: Home,
      class: "h-4 w-4 inline-block stroke-1"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(84:6) {#if crumb.title === 'Home'}",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_12, create_else_block_1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*i*/
      ctx2[8] > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(79:3) {#each crumbs as crumb, i}",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let div;
  let span;
  let show_if;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block10, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*$page*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!/*$page*/
      (ctx2[0].url.pathname.startsWith("/settings") || /*$page*/
      ctx2[0].url.pathname === "/");
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "h-8 inline-flex items-center svelte-1jq84bz");
      add_location(span, file16, 72, 1, 1778);
      attr_dev(div, "class", "main truncate min-[850px]:max-w-[calc(100vw-18rem-16px-56px)] max-[850px]:max-w-[calc(100vw-1em-32px-56px)] svelte-1jq84bz");
      add_location(div, file16, 69, 0, 1653);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      if_blocks[current_block_type_index].m(span, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span, null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude15 = true;
function instance17($$self, $$props, $$invalidate) {
  let pathArray;
  let crumbs;
  let $page;
  validate_store(page3, "page");
  component_subscribe($$self, page3, ($$value) => $$invalidate(0, $page = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadCrumbs", slots, []);
  let { fileTree } = $$props;
  const checkUrl = function(href, fileTree2) {
    let found = false;
    function checkChildren(node) {
      if (node.href === href || href.startsWith(node.href) && node.isTemplated) {
        found = true;
      } else if (node.children) {
        node.children.forEach((child) => {
          checkChildren(child);
        });
      }
    }
    checkChildren(fileTree2);
    return found;
  };
  const buildCrumbs = function(pathArray2) {
    let crumbs2 = [{ href: "/", title: "Home" }];
    pathArray2.forEach((path, i) => {
      if (path != "") {
        let crumb = {
          href: "/" + pathArray2.slice(0, i + 1).join("/"),
          title: decodeURIComponent(path.replace(/_/g, " ").replace(/-/g, " "))
        };
        crumbs2.push(crumb);
      }
    });
    if (crumbs2.length > 3) {
      let upOne = crumbs2.slice(-3)[0].href;
      crumbs2.splice(1, crumbs2.length - 3, { href: upOne, title: "..." });
    }
    crumbs2.forEach((path) => {
      if (!checkUrl(path.href, fileTree)) {
        path.href = "javascript:void(0)";
      }
    });
    return crumbs2;
  };
  $$self.$$.on_mount.push(function() {
    if (fileTree === void 0 && !("fileTree" in $$props || $$self.$$.bound[$$self.$$.props["fileTree"]])) {
      console.warn("<BreadCrumbs> was created without expected prop 'fileTree'");
    }
  });
  const writable_props = ["fileTree"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BreadCrumbs> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("fileTree" in $$props2)
      $$invalidate(2, fileTree = $$props2.fileTree);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude15,
    page: page3,
    Icon: Icon_default,
    Home,
    fileTree,
    checkUrl,
    buildCrumbs,
    pathArray,
    crumbs,
    $page
  });
  $$self.$inject_state = ($$props2) => {
    if ("fileTree" in $$props2)
      $$invalidate(2, fileTree = $$props2.fileTree);
    if ("pathArray" in $$props2)
      $$invalidate(3, pathArray = $$props2.pathArray);
    if ("crumbs" in $$props2)
      $$invalidate(1, crumbs = $$props2.crumbs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$page*/
    1) {
      $:
        $$invalidate(3, pathArray = $page.url.pathname.split("/").slice(1));
    }
    if ($$self.$$.dirty & /*pathArray*/
    8) {
      $:
        $$invalidate(1, crumbs = buildCrumbs(pathArray));
    }
  };
  return [$page, crumbs, fileTree, pathArray];
}
var BreadCrumbs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { fileTree: 2 }, add_css10);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadCrumbs",
      options,
      id: create_fragment17.name
    });
  }
  get fileTree() {
    throw new Error("<BreadCrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fileTree(value) {
    throw new Error("<BreadCrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadCrumbs_default = BreadCrumbs;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/ChevronToggle.svelte
var file17 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/ChevronToggle.svelte";
function add_css11(target) {
  append_styles(target, "svelte-lqleyo", "svg.svelte-lqleyo.svelte-lqleyo{display:inline-block;vertical-align:middle;transition:transform 0.15s ease-in}span.svelte-lqleyo.svelte-lqleyo{margin:auto 0 auto 0}[aria-expanded='true'].svelte-lqleyo svg.svelte-lqleyo{transform:rotate(0.25turn)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hldnJvblRvZ2dsZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBcUJDLEdBQUEsNEJBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxZQUFxQixDQUNyQixjQUFBLENBQUEsTUFBc0IsQ0FDdEIsVUFBQSxDQUFBLFNBQUEsQ0FBQSxLQUFBLENBQUEsT0FBbUMsQUFDcEMsQ0FBQSxBQUVBLElBQUEsNEJBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxDQUFxQixBQUN0QixDQUFBLEFBRUEsQ0FBQSxhQUFBLENBQUEsTUFBQSxlQUFBLENBQUEsR0FBQSxjQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsT0FBQSxRQUFBLENBQTJCLEFBQzVCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ2hldnJvblRvZ2dsZS5zdmVsdGUiXX0= */");
}
function create_fragment18(ctx) {
  let span;
  let svg;
  let path;
  const block = {
    c: function create() {
      span = element("span");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { "aria-expanded": true, class: true });
      var span_nodes = children(span);
      svg = claim_svg_element(span_nodes, "svg", {
        viewBox: true,
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, "fill-rule": true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        path,
        "fill",
        /*color*/
        ctx[1]
      );
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "d", "M6.22 3.22a.75.75 0 011.06 0l4.25 4.25a.75.75 0 010 1.06l-4.25 4.25a.75.75 0 01-1.06-1.06L9.94 8 6.22 4.28a.75.75 0 010-1.06z");
      add_location(path, file17, 12, 3, 265);
      attr_dev(svg, "viewBox", "0 0 16 16");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[2]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[2]
      );
      attr_dev(svg, "class", "svelte-lqleyo");
      add_location(svg, file17, 11, 1, 210);
      attr_dev(
        span,
        "aria-expanded",
        /*toggled*/
        ctx[0]
      );
      attr_dev(span, "class", "svelte-lqleyo");
      add_location(span, file17, 10, 0, 178);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, svg);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*color*/
      2) {
        attr_dev(
          path,
          "fill",
          /*color*/
          ctx2[1]
        );
      }
      if (dirty & /*size*/
      4) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[2]
        );
      }
      if (dirty & /*size*/
      4) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[2]
        );
      }
      if (dirty & /*toggled*/
      1) {
        attr_dev(
          span,
          "aria-expanded",
          /*toggled*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude16 = true;
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronToggle", slots, []);
  let { toggled = false } = $$props;
  let { color = "#2d2d2d" } = $$props;
  let { size = 10 } = $$props;
  const writable_props = ["toggled", "color", "size"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChevronToggle> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("toggled" in $$props2)
      $$invalidate(0, toggled = $$props2.toggled);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("size" in $$props2)
      $$invalidate(2, size = $$props2.size);
  };
  $$self.$capture_state = () => ({ evidenceInclude: evidenceInclude16, toggled, color, size });
  $$self.$inject_state = ($$props2) => {
    if ("toggled" in $$props2)
      $$invalidate(0, toggled = $$props2.toggled);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("size" in $$props2)
      $$invalidate(2, size = $$props2.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [toggled, color, size];
}
var ChevronToggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { toggled: 0, color: 1, size: 2 }, add_css11);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronToggle",
      options,
      id: create_fragment18.name
    });
  }
  get toggled() {
    throw new Error("<ChevronToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggled(value) {
    throw new Error("<ChevronToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ChevronToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ChevronToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ChevronToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronToggle_default = ChevronToggle;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/CopyIcon.svelte
var file18 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/CopyIcon.svelte";
function create_if_block11(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[0]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file18, 24, 12, 574);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      1)
        set_data_dev(
          t,
          /*title*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(25:1) {#if title}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[0] && create_if_block11(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { width: "100%" },
    { height: "100%" },
    { preserveAspectRatio: "xMidYMid meet" },
    /*attributes*/
    ctx[1],
    /*$$restProps*/
    ctx[2]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        width: true,
        height: true,
        preserveAspectRatio: true
      });
      var svg_nodes = children(svg);
      if (if_block)
        if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z");
      add_location(path0, file18, 25, 1, 603);
      attr_dev(path1, "d", "M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z");
      add_location(path1, file18, 27, 3, 710);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file18, 14, 0, 376);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block11(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { width: "100%" },
        { height: "100%" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*attributes*/
        2 && /*attributes*/
        ctx2[1],
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude17 = true;
function instance19($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CopyIcon", slots, []);
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("title" in $$new_props)
      $$invalidate(0, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude17,
    title,
    labelled,
    attributes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("title" in $$props)
      $$invalidate(0, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(3, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(1, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(1, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [title, attributes, $$restProps, labelled];
}
var CopyIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { title: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CopyIcon",
      options,
      id: create_fragment19.name
    });
  }
  get title() {
    throw new Error("<CopyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CopyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CopyIcon_default = CopyIcon;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/CopySuccessIcon.svelte
var file19 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/CopySuccessIcon.svelte";
function create_fragment20(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        viewBox: true,
        fill: true,
        width: true,
        height: true,
        preserveAspectRatio: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z");
      add_location(path, file19, 16, 1, 264);
      attr_dev(svg, "class", "copyButtonSuccessIcon");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(
        svg,
        "fill",
        /*color*/
        ctx[0]
      );
      attr_dev(svg, "width", "100%");
      attr_dev(svg, "height", "100%");
      attr_dev(svg, "preserveAspectRatio", "xMidYMid meet");
      add_location(svg, file19, 8, 0, 124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*color*/
      1) {
        attr_dev(
          svg,
          "fill",
          /*color*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude18 = true;
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CopySuccessIcon", slots, []);
  let { color = "green" } = $$props;
  const writable_props = ["color"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CopySuccessIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
  };
  $$self.$capture_state = () => ({ evidenceInclude: evidenceInclude18, color });
  $$self.$inject_state = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [color];
}
var CopySuccessIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { color: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CopySuccessIcon",
      options,
      id: create_fragment20.name
    });
  }
  get color() {
    throw new Error("<CopySuccessIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<CopySuccessIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CopySuccessIcon_default = CopySuccessIcon;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/CodeBlock.svelte
var file20 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/CodeBlock.svelte";
function add_css12(target) {
  append_styles(target, "svelte-14fd7zh", ":root{--scrollbar-track-color:transparent;--scrollbar-color:rgba(0, 0, 0, 0.2);--scrollbar-active-color:rgba(0, 0, 0, 0.4);--scrollbar-size:0.75rem;--scrollbar-minlength:1.5rem}pre.svelte-14fd7zh.svelte-14fd7zh{background:var(--grey-100);border:1px solid var(--grey-200);border-radius:5px;display:flex;flex-direction:row;align-items:flex-start;justify-content:space-between}pre.svelte-14fd7zh code.svelte-14fd7zh::-webkit-scrollbar{height:var(--scrollbar-size);width:var(--scrollbar-size)}pre.svelte-14fd7zh code.svelte-14fd7zh::-webkit-scrollbar-track{background-color:var(--scrollbar-track-color)}pre.svelte-14fd7zh code.svelte-14fd7zh::-webkit-scrollbar-thumb{background-color:var(--scrollbar-color);border-radius:7px;background-clip:padding-box}pre.svelte-14fd7zh code.svelte-14fd7zh::-webkit-scrollbar-thumb:hover{background-color:var(--scrollbar-active-color)}pre.svelte-14fd7zh code.svelte-14fd7zh::-webkit-scrollbar-thumb:vertical{min-height:var(--scrollbar-minlength);border:3px solid transparent}pre.svelte-14fd7zh code.svelte-14fd7zh::-webkit-scrollbar-thumb:horizontal{min-width:var(--scrollbar-minlength);border:3px solid transparent}pre.svelte-14fd7zh code.svelte-14fd7zh{overflow:auto;position:relative;display:block;background:none;border:none;padding:0.8em 0.8em;color:var(--grey-900);scrollbar-width:thin;scrollbar-color:var(--scrollbar-color) var(--scrollbar-track-color)}pre.svelte-14fd7zh button.container.svelte-14fd7zh{opacity:0;transition:all 200ms ease-in-out;box-sizing:border-box;background-color:var(--grey-100);border-radius:4px 4px 4px 4px;border:1px solid var(--grey-300);padding:0.25em 0.35em 0.25em 0.35em;color:var(--grey-300);cursor:pointer;user-select:none;-webkit-user-select:none;-moz-user-select:none;margin:0.5em;display:flex;z-index:20;align-items:center;justify-content:center}pre.svelte-14fd7zh:hover button.container.svelte-14fd7zh{opacity:1;transition:all 200ms ease-in-out;box-sizing:border-box;background-color:var(--grey-100);border-radius:4px 4px 4px 4px;border:1px solid var(--grey-300);padding:0.25em 0.35em 0.25em 0.35em;color:var(--grey-300);cursor:pointer;user-select:none;-webkit-user-select:none;-moz-user-select:none;margin:0.5em;display:flex;align-items:center;justify-content:center}pre.svelte-14fd7zh button.container.svelte-14fd7zh:hover{border-color:var(--grey-500);background-color:var(--grey-100);color:var(--grey-500);transition:all 200ms ease-in-out}pre.svelte-14fd7zh button.container.copied.svelte-14fd7zh{border-color:var(--grey-500);background-color:var(--grey-100);color:var(--green-500);transition:all 200ms ease-in-out}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29kZUJsb2NrLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFzREMsS0FBQSxBQUFBLENBQUEsQUFDQyx1QkFBQSxDQUFBLFdBQW9DLENBQ3BDLGlCQUFBLENBQUEsa0JBQXFDLENBQ3JDLHdCQUFBLENBQUEsa0JBQTRDLENBQzVDLGdCQUFBLENBQUEsT0FBeUIsQ0FDekIscUJBQUEsQ0FBQSxNQUE2QixBQUM5QixDQUFBLEFBQ0EsR0FBQSw4QkFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQUEsVUFBQSxDQUEyQixDQUMzQixNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLE9BQUEsQ0FBQSxJQUFhLENBQ2IsY0FBQSxDQUFBLEdBQW1CLENBQ25CLFdBQUEsQ0FBQSxVQUF1QixDQUN2QixlQUFBLENBQUEsYUFBOEIsQUFDL0IsQ0FBQSxBQUNBLGtCQUFBLENBQUEsbUJBQUEsbUJBQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBNkIsQ0FDN0IsS0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBNEIsQUFDN0IsQ0FBQSxBQUNBLGtCQUFBLENBQUEsbUJBQUEseUJBQUEsQUFBQSxDQUFBLEFBQ0MsZ0JBQUEsQ0FBQSxJQUFBLHVCQUFBLENBQThDLEFBQy9DLENBQUEsQUFDQSxrQkFBQSxDQUFBLG1CQUFBLHlCQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxpQkFBQSxDQUF3QyxDQUN4QyxhQUFBLENBQUEsR0FBa0IsQ0FDbEIsZUFBQSxDQUFBLFdBQTRCLEFBQzdCLENBQUEsQUFDQSxrQkFBQSxDQUFBLG1CQUFBLHlCQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsZ0JBQUEsQ0FBQSxJQUFBLHdCQUFBLENBQStDLEFBQ2hELENBQUEsQUFDQSxrQkFBQSxDQUFBLG1CQUFBLHlCQUFBLFNBQUEsQUFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQUEscUJBQUEsQ0FBc0MsQ0FDdEMsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsV0FBNkIsQUFDOUIsQ0FBQSxBQUNBLGtCQUFBLENBQUEsbUJBQUEseUJBQUEsV0FBQSxBQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsSUFBQSxxQkFBQSxDQUFxQyxDQUNyQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUE2QixBQUM5QixDQUFBLEFBQ0Esa0JBQUEsQ0FBQSxJQUFBLGVBQUEsQ0FBQSxBQUNDLFFBQUEsQ0FBQSxJQUFjLENBQ2QsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLE9BQUEsQ0FBQSxLQUFjLENBQ2QsVUFBQSxDQUFBLElBQWdCLENBQ2hCLE1BQUEsQ0FBQSxJQUFZLENBQ1osT0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFvQixDQUNwQixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGVBQUEsQ0FBQSxJQUFxQixDQUNyQixlQUFBLENBQUEsSUFBQSxpQkFBQSxDQUFBLENBQUEsSUFBQSx1QkFBQSxDQUFvRSxBQUNyRSxDQUFBLEFBRUEsa0JBQUEsQ0FBQSxNQUFBLFVBQUEsZUFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLENBQVUsQ0FDVixVQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUFpQyxDQUNqQyxVQUFBLENBQUEsVUFBc0IsQ0FDdEIsZ0JBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsYUFBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQThCLENBQzlCLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxPQUFBLENBQUEsTUFBQSxDQUFBLE1BQUEsQ0FBQSxNQUFBLENBQUEsTUFBb0MsQ0FDcEMsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixNQUFBLENBQUEsT0FBZSxDQUNmLFdBQUEsQ0FBQSxJQUFpQixDQUNqQixtQkFBQSxDQUFBLElBQXlCLENBQ3pCLGdCQUFBLENBQUEsSUFBc0IsQ0FDdEIsTUFBQSxDQUFBLEtBQWEsQ0FDYixPQUFBLENBQUEsSUFBYSxDQUNiLE9BQUEsQ0FBQSxFQUFXLENBQ1gsV0FBQSxDQUFBLE1BQW1CLENBQ25CLGVBQUEsQ0FBQSxNQUF1QixBQUN4QixDQUFBLEFBRUEsa0JBQUEsTUFBQSxDQUFBLE1BQUEsVUFBQSxlQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsQ0FBVSxDQUNWLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLFdBQWlDLENBQ2pDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxhQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBOEIsQ0FDOUIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxNQUFBLENBQUEsTUFBQSxDQUFBLE1BQUEsQ0FBQSxNQUFvQyxDQUNwQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLE1BQUEsQ0FBQSxPQUFlLENBQ2YsV0FBQSxDQUFBLElBQWlCLENBQ2pCLG1CQUFBLENBQUEsSUFBeUIsQ0FDekIsZ0JBQUEsQ0FBQSxJQUFzQixDQUN0QixNQUFBLENBQUEsS0FBYSxDQUNiLE9BQUEsQ0FBQSxJQUFhLENBQ2IsV0FBQSxDQUFBLE1BQW1CLENBQ25CLGVBQUEsQ0FBQSxNQUF1QixBQUN4QixDQUFBLEFBRUEsa0JBQUEsQ0FBQSxNQUFBLHlCQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsWUFBQSxDQUFBLElBQUEsVUFBQSxDQUE2QixDQUM3QixnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLFdBQWlDLEFBQ2xDLENBQUEsQUFFQSxrQkFBQSxDQUFBLE1BQUEsVUFBQSxPQUFBLGVBQUEsQ0FBQSxBQUNDLFlBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBNkIsQ0FDN0IsZ0JBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsS0FBQSxDQUFBLElBQUEsV0FBQSxDQUF1QixDQUN2QixVQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUFpQyxBQUNsQyxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNvZGVCbG9jay5zdmVsdGUiXX0= */");
}
function create_if_block_13(ctx) {
  let button;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_23, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*copied*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      button = element("button");
      t0 = text("\n					");
      if_block.c();
      t1 = text("\n		");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, "\n					");
      if_block.l(button_nodes);
      t1 = claim_text(button_nodes, "\n		");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "container absolute right-0 top-0 h-8 w-8 svelte-14fd7zh");
      toggle_class(
        button,
        "copied",
        /*copied*/
        ctx[2]
      );
      add_location(button, file20, 29, 3, 629);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t0);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration_dev(button, t1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[6],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(button, t1);
      }
      if (!current || dirty & /*copied*/
      4) {
        toggle_class(
          button,
          "copied",
          /*copied*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(29:2) {#if copyToClipboard}",
    ctx
  });
  return block;
}
function create_else_block_12(ctx) {
  let copy_1;
  let current;
  copy_1 = new CopyIcon_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(copy_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(copy_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(copy_1, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(copy_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(copy_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(copy_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(41:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_23(ctx) {
  let success;
  let current;
  success = new CopySuccessIcon_default({
    props: { color: "var(--green-500)" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(success.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(success.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(success, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(success.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(success.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(success, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(39:5) {#if copied}",
    ctx
  });
  return block;
}
function create_else_block3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(49:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*source*/
        ctx[0]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*source*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*source*/
      1)
        set_data_dev(
          t,
          /*source*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(48:3) {#if source}",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let pre;
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let code;
  let current_block_type_index;
  let if_block1;
  let t4;
  let t5;
  let current;
  let if_block0 = (
    /*copyToClipboard*/
    ctx[1] && create_if_block_13(ctx)
  );
  const if_block_creators = [create_if_block12, create_else_block3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*source*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      pre = element("pre");
      t0 = text("	");
      div = element("div");
      t1 = text("\n		");
      if (if_block0)
        if_block0.c();
      t2 = text("\n		");
      t3 = text("\n");
      code = element("code");
      if_block1.c();
      t4 = text("\n");
      t5 = text("		\n");
      this.h();
    },
    l: function claim(nodes) {
      pre = claim_element(nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      t0 = claim_text(pre_nodes, "	");
      div = claim_element(pre_nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "\n		");
      if (if_block0)
        if_block0.l(div_nodes);
      t2 = claim_text(div_nodes, "\n		");
      div_nodes.forEach(detach_dev);
      t3 = claim_text(pre_nodes, "\n");
      code = claim_element(pre_nodes, "CODE", { class: true });
      var code_nodes = children(code);
      if_block1.l(code_nodes);
      t4 = claim_text(code_nodes, "\n");
      code_nodes.forEach(detach_dev);
      t5 = claim_text(pre_nodes, "		\n");
      pre_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "absolute");
      set_style(div, "height", "100%");
      set_style(div, "width", "100%");
      add_location(div, file20, 27, 1, 548);
      attr_dev(code, "class", "svelte-14fd7zh");
      add_location(code, file20, 46, 0, 940);
      attr_dev(pre, "class", "my-5 relative svelte-14fd7zh");
      add_location(pre, file20, 26, 0, 519);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, pre, anchor);
      append_hydration_dev(pre, t0);
      append_hydration_dev(pre, div);
      append_hydration_dev(div, t1);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t2);
      append_hydration_dev(pre, t3);
      append_hydration_dev(pre, code);
      if_blocks[current_block_type_index].m(code, null);
      append_hydration_dev(code, t4);
      append_hydration_dev(pre, t5);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*copyToClipboard*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*copyToClipboard*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(code, t4);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(pre);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude19 = true;
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeBlock", slots, ["default"]);
  let { source } = $$props;
  let { copyToClipboard = false } = $$props;
  let copied = false;
  const toggleCopied = function() {
    $$invalidate(2, copied = false);
  };
  async function copy() {
    try {
      await navigator.clipboard.writeText(source);
      $$invalidate(2, copied = true);
      setTimeout(toggleCopied, 1500);
    } catch {
    }
  }
  $$self.$$.on_mount.push(function() {
    if (source === void 0 && !("source" in $$props || $$self.$$.bound[$$self.$$.props["source"]])) {
      console.warn("<CodeBlock> was created without expected prop 'source'");
    }
  });
  const writable_props = ["source", "copyToClipboard"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CodeBlock> was created with unknown prop '${key}'`);
  });
  const click_handler = () => {
    if (source !== void 0) {
      copy(source);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("source" in $$props2)
      $$invalidate(0, source = $$props2.source);
    if ("copyToClipboard" in $$props2)
      $$invalidate(1, copyToClipboard = $$props2.copyToClipboard);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude19,
    source,
    copyToClipboard,
    Copy: CopyIcon_default,
    Success: CopySuccessIcon_default,
    copied,
    toggleCopied,
    copy
  });
  $$self.$inject_state = ($$props2) => {
    if ("source" in $$props2)
      $$invalidate(0, source = $$props2.source);
    if ("copyToClipboard" in $$props2)
      $$invalidate(1, copyToClipboard = $$props2.copyToClipboard);
    if ("copied" in $$props2)
      $$invalidate(2, copied = $$props2.copied);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [source, copyToClipboard, copied, copy, $$scope, slots, click_handler];
}
var CodeBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { source: 0, copyToClipboard: 1 }, add_css12);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeBlock",
      options,
      id: create_fragment21.name
    });
  }
  get source() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copyToClipboard() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copyToClipboard(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeBlock_default = CodeBlock;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/CollapsibleSection.svelte
import { page as page4 } from "$app/stores";
var file21 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/CollapsibleSection.svelte";
function add_css13(target) {
  append_styles(target, "svelte-1ouveag", "a.svelte-1ouveag.svelte-1ouveag{text-transform:capitalize;display:inline-block;text-decoration:none;font-family:var(--ui-font-family);-webkit-font-smoothing:antialiased;font-size:15px;color:var(--grey-700);cursor:pointer;width:100%}a.svelte-1ouveag .content-item.svelte-1ouveag{color:var(--grey-500)}.folder.svelte-1ouveag.svelte-1ouveag{width:100%;padding:0.2rem 1rem 0.2rem 1.2rem;display:grid;grid-template-columns:1.2rem auto;margin:0;padding:0;gap:0}.folder.svelte-1ouveag .folder-label.svelte-1ouveag{padding:0.2rem 1rem 0.2rem 0rem}.folder-label.svelte-1ouveag.svelte-1ouveag{text-decoration:none;font-family:var(--ui-font-family);-webkit-font-smoothing:antialiased;font-size:15px;cursor:pointer;text-transform:capitalize;color:var(--grey-700);display:flex;align-items:center}.folder.svelte-1ouveag:hover .folder-label.svelte-1ouveag{color:var(--grey-900)}.folder.svelte-1ouveag:hover .collapse-icon.svelte-1ouveag{stroke:var(--grey-900)}.nolink.svelte-1ouveag.svelte-1ouveag{-webkit-user-select:none;-moz-user-select:none;user-select:none}.content-item.svelte-1ouveag.svelte-1ouveag{padding:0.2rem 1rem 0.2rem 2.25rem}button.svelte-1ouveag.svelte-1ouveag{border:none;background:none;color:inherit;font-size:1em;cursor:pointer;padding-right:0rem;padding-left:0.3rem;line-height:1.6;margin:0}button.expandable.svelte-1ouveag.svelte-1ouveag{width:1.2rem;height:100%;display:flex;align-items:center;justify-content:center;padding-right:0;padding-left:0}svg.svelte-1ouveag.svelte-1ouveag{transition:transform 0.15s ease-in;stroke:var(--grey-700)}svg.folder-selected.svelte-1ouveag.svelte-1ouveag{stroke:var(--grey-999);stroke-width:5}svg.selected.svelte-1ouveag.svelte-1ouveag{stroke:var(--blue-600);stroke-width:5}[aria-expanded='true'].svelte-1ouveag svg.svelte-1ouveag{transform:rotate(0.25turn)}.selected.content-item.svelte-1ouveag.svelte-1ouveag{color:var(--blue-600);font-weight:500}.folder-selected.svelte-1ouveag.svelte-1ouveag{color:var(--grey-999);font-weight:500}.folder.folder-selected.svelte-1ouveag:hover .folder-label.svelte-1ouveag{color:var(--blue-800)}.folder.folder-selected.svelte-1ouveag:hover .collapse-icon.svelte-1ouveag{stroke:var(--blue-800)}.content-item.svelte-1ouveag.svelte-1ouveag:hover{color:var(--grey-900)}.content-item.selected.svelte-1ouveag.svelte-1ouveag:hover{color:var(--blue-800)}.selected.svelte-1ouveag.svelte-1ouveag{color:var(--blue-600);font-weight:500}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29sbGFwc2libGVTZWN0aW9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF5RkMsQ0FBQSw4QkFBQSxDQUFBLEFBQ0MsY0FBQSxDQUFBLFVBQTBCLENBQzFCLE9BQUEsQ0FBQSxZQUFxQixDQUNyQixlQUFBLENBQUEsSUFBcUIsQ0FDckIsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsc0JBQUEsQ0FBQSxXQUFtQyxDQUNuQyxTQUFBLENBQUEsSUFBZSxDQUNmLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsTUFBQSxDQUFBLE9BQWUsQ0FDZixLQUFBLENBQUEsSUFBVyxBQUNaLENBQUEsQUFFQSxnQkFBQSxDQUFBLGFBQUEsZUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBLEFBRUEsT0FBQSw4QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQVcsQ0FDWCxPQUFBLENBQUEsTUFBQSxDQUFBLElBQUEsQ0FBQSxNQUFBLENBQUEsTUFBa0MsQ0FDbEMsT0FBQSxDQUFBLElBQWEsQ0FDYixxQkFBQSxDQUFBLE1BQUEsQ0FBQSxJQUFrQyxDQUNsQyxNQUFBLENBQUEsQ0FBUyxDQUNULE9BQUEsQ0FBQSxDQUFVLENBQ1YsR0FBQSxDQUFBLENBQU0sQUFDUCxDQUFBLEFBRUEsc0JBQUEsQ0FBQSxhQUFBLGVBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxNQUFBLENBQUEsSUFBQSxDQUFBLE1BQUEsQ0FBQSxJQUFnQyxBQUNqQyxDQUFBLEFBRUEsYUFBQSw4QkFBQSxDQUFBLEFBQ0MsZUFBQSxDQUFBLElBQXFCLENBQ3JCLFdBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQWtDLENBQ2xDLHNCQUFBLENBQUEsV0FBbUMsQ0FDbkMsU0FBQSxDQUFBLElBQWUsQ0FDZixNQUFBLENBQUEsT0FBZSxDQUNmLGNBQUEsQ0FBQSxVQUEwQixDQUMxQixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLE9BQUEsQ0FBQSxJQUFhLENBQ2IsV0FBQSxDQUFBLE1BQW1CLEFBQ3BCLENBQUEsQUFFQSxzQkFBQSxNQUFBLENBQUEsYUFBQSxlQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEsQUFFQSxzQkFBQSxNQUFBLENBQUEsY0FBQSxlQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsSUFBQSxVQUFBLENBQXVCLEFBQ3hCLENBQUEsQUFFQSxPQUFBLDhCQUFBLENBQUEsQUFDQyxtQkFBQSxDQUFBLElBQXlCLENBQ3pCLGdCQUFBLENBQUEsSUFBc0IsQ0FDakIsV0FBQSxDQUFBLElBQWlCLEFBQ3ZCLENBQUEsQUFFQSxhQUFBLDhCQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsTUFBQSxDQUFBLElBQUEsQ0FBQSxNQUFBLENBQUEsT0FBbUMsQUFDcEMsQ0FBQSxBQUVBLE1BQUEsOEJBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxJQUFZLENBQ1osVUFBQSxDQUFBLElBQWdCLENBQ2hCLEtBQUEsQ0FBQSxPQUFjLENBQ2QsU0FBQSxDQUFBLEdBQWMsQ0FDZCxNQUFBLENBQUEsT0FBZSxDQUNmLGFBQUEsQ0FBQSxJQUFtQixDQUNuQixZQUFBLENBQUEsTUFBb0IsQ0FDcEIsV0FBQSxDQUFBLEdBQWdCLENBQ2hCLE1BQUEsQ0FBQSxDQUFTLEFBQ1YsQ0FBQSxBQUVBLE1BQUEsV0FBQSw4QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLE1BQWEsQ0FDYixNQUFBLENBQUEsSUFBWSxDQUNaLE9BQUEsQ0FBQSxJQUFhLENBQ2IsV0FBQSxDQUFBLE1BQW1CLENBQ25CLGVBQUEsQ0FBQSxNQUF1QixDQUN2QixhQUFBLENBQUEsQ0FBZ0IsQ0FDaEIsWUFBQSxDQUFBLENBQWUsQUFDaEIsQ0FBQSxBQUVBLEdBQUEsOEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxTQUFBLENBQUEsS0FBQSxDQUFBLE9BQW1DLENBQ25DLE1BQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBdUIsQUFDeEIsQ0FBQSxBQUVBLEdBQUEsZ0JBQUEsOEJBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBdUIsQ0FDdkIsWUFBQSxDQUFBLENBQWUsQUFDaEIsQ0FBQSxBQUVBLEdBQUEsU0FBQSw4QkFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLElBQUEsVUFBQSxDQUF1QixDQUN2QixZQUFBLENBQUEsQ0FBZSxBQUNoQixDQUFBLEFBRUEsQ0FBQSxhQUFBLENBQUEsTUFBQSxnQkFBQSxDQUFBLEdBQUEsZUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLE9BQUEsUUFBQSxDQUEyQixBQUM1QixDQUFBLEFBRUEsU0FBQSxhQUFBLDhCQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFdBQUEsQ0FBQSxHQUFnQixBQUNqQixDQUFBLEFBRUEsZ0JBQUEsOEJBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsV0FBQSxDQUFBLEdBQWdCLEFBQ2pCLENBQUEsQUFFQSxPQUFBLCtCQUFBLE1BQUEsQ0FBQSxhQUFBLGVBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLE9BQUEsK0JBQUEsTUFBQSxDQUFBLGNBQUEsZUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLElBQUEsVUFBQSxDQUF1QixBQUN4QixDQUFBLEFBRUEsMkNBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEsQUFFQSxhQUFBLHVDQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBLEFBRUEsU0FBQSw4QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixXQUFBLENBQUEsR0FBZ0IsQUFDakIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDb2xsYXBzaWJsZVNlY3Rpb24uc3ZlbHRlIl19 */");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_else_block4(ctx) {
  let button;
  let t_value = (
    /*folder*/
    ctx[0].label + ""
  );
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, "aria-expanded": true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "folder-label nolink svelte-1ouveag");
      attr_dev(
        button,
        "aria-expanded",
        /*expanded*/
        ctx[1]
      );
      toggle_class(button, "folder-selected", "/" + /*$page*/
      ctx[2].url.pathname.split("/")[1] === /*folder*/
      ctx[0].href);
      add_location(button, file21, 62, 3, 1442);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[6],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*folder*/
      1 && t_value !== (t_value = /*folder*/
      ctx2[0].label + ""))
        set_data_dev(t, t_value);
      if (dirty & /*expanded*/
      2) {
        attr_dev(
          button,
          "aria-expanded",
          /*expanded*/
          ctx2[1]
        );
      }
      if (dirty & /*$page, folder*/
      5) {
        toggle_class(button, "folder-selected", "/" + /*$page*/
        ctx2[2].url.pathname.split("/")[1] === /*folder*/
        ctx2[0].href);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(62:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let a;
  let div;
  let t_value = (
    /*folder*/
    ctx[0].label + ""
  );
  let t;
  let a_href_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      a = element("a");
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        href: true,
        "aria-expanded": true,
        class: true
      });
      var a_nodes = children(a);
      div = claim_element(a_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "folder-label svelte-1ouveag");
      toggle_class(
        div,
        "selected",
        /*$page*/
        ctx[2].url.pathname === /*folder*/
        ctx[0].href
      );
      toggle_class(div, "folder-selected", "/" + /*$page*/
      ctx[2].url.pathname.split("/")[1] === /*folder*/
      ctx[0].href);
      add_location(div, file21, 53, 4, 1212);
      attr_dev(a, "href", a_href_value = /*folder*/
      ctx[0].href);
      attr_dev(
        a,
        "aria-expanded",
        /*expanded*/
        ctx[1]
      );
      attr_dev(a, "class", "svelte-1ouveag");
      add_location(a, file21, 52, 3, 1142);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, div);
      append_hydration_dev(div, t);
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*toggle*/
          ctx[3],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*folder*/
      1 && t_value !== (t_value = /*folder*/
      ctx2[0].label + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$page, folder*/
      5) {
        toggle_class(
          div,
          "selected",
          /*$page*/
          ctx2[2].url.pathname === /*folder*/
          ctx2[0].href
        );
      }
      if (dirty & /*$page, folder*/
      5) {
        toggle_class(div, "folder-selected", "/" + /*$page*/
        ctx2[2].url.pathname.split("/")[1] === /*folder*/
        ctx2[0].href);
      }
      if (dirty & /*folder*/
      1 && a_href_value !== (a_href_value = /*folder*/
      ctx2[0].href)) {
        attr_dev(a, "href", a_href_value);
      }
      if (dirty & /*expanded*/
      2) {
        attr_dev(
          a,
          "aria-expanded",
          /*expanded*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(52:2) {#if folder.href}",
    ctx
  });
  return block;
}
function create_if_block13(ctx) {
  let div;
  let div_hidden_value;
  let div_transition;
  let current;
  let each_value = (
    /*folder*/
    ctx[0].children
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      div.hidden = div_hidden_value = !/*expanded*/
      ctx[1];
      add_location(div, file21, 74, 2, 1710);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*folder, toggle, $page*/
      13) {
        each_value = /*folder*/
        ctx2[0].children;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*expanded*/
      2 && div_hidden_value !== (div_hidden_value = !/*expanded*/
      ctx2[1])) {
        prop_dev(div, "hidden", div_hidden_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, true);
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, {}, false);
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(74:1) {#if expanded}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let a;
  let div;
  let t0_value = (
    /*child*/
    ctx[7].label + ""
  );
  let t0;
  let t1;
  let a_href_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      a = element("a");
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      div = claim_element(a_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, t0_value);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "content-item svelte-1ouveag");
      toggle_class(
        div,
        "selected",
        /*$page*/
        ctx[2].url.pathname === /*child*/
        ctx[7].href
      );
      add_location(div, file21, 78, 6, 1875);
      attr_dev(a, "href", a_href_value = /*child*/
      ctx[7].href);
      attr_dev(a, "class", "svelte-1ouveag");
      add_location(a, file21, 77, 5, 1829);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, div);
      append_hydration_dev(div, t0);
      append_hydration_dev(a, t1);
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*toggle*/
          ctx[3],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*folder*/
      1 && t0_value !== (t0_value = /*child*/
      ctx2[7].label + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*$page, folder*/
      5) {
        toggle_class(
          div,
          "selected",
          /*$page*/
          ctx2[2].url.pathname === /*child*/
          ctx2[7].href
        );
      }
      if (dirty & /*folder*/
      1 && a_href_value !== (a_href_value = /*child*/
      ctx2[7].href)) {
        attr_dev(a, "href", a_href_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(77:4) {#if child.href && child.label}",
    ctx
  });
  return block;
}
function create_each_block6(ctx) {
  let if_block_anchor;
  let if_block = (
    /*child*/
    ctx[7].href && /*child*/
    ctx[7].label && create_if_block_14(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*child*/
        ctx2[7].href && /*child*/
        ctx2[7].label
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_14(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(76:3) {#each folder.children as child}",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let div1;
  let div0;
  let button;
  let svg;
  let path;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*folder*/
      ctx2[0].href
    )
      return create_if_block_24;
    return create_else_block4;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*expanded*/
    ctx[1] && create_if_block13(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      button = element("button");
      svg = svg_element("svg");
      path = svg_element("path");
      t0 = space();
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button = claim_element(div0_nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        "aria-expanded": true
      });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", {
        class: true,
        style: true,
        width: true,
        height: true,
        fill: true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        "stroke-width": true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      t0 = claim_space(div0_nodes);
      if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 5l7 7-7 7");
      add_location(path, file21, 48, 4, 1071);
      attr_dev(svg, "class", "collapse-icon svelte-1ouveag");
      attr_dev(svg, "style", "tran");
      attr_dev(svg, "width", "9");
      attr_dev(svg, "height", "9");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "stroke-width", "3");
      attr_dev(svg, "viewBox", "0 0 24 24");
      toggle_class(
        svg,
        "selected",
        /*$page*/
        ctx[2].url.pathname === /*folder*/
        ctx[0].href
      );
      toggle_class(svg, "folder-selected", "/" + /*$page*/
      ctx[2].url.pathname.split("/")[1] === /*folder*/
      ctx[0].href);
      add_location(svg, file21, 35, 3, 730);
      attr_dev(button, "class", "expandable svelte-1ouveag");
      attr_dev(button, "aria-label", "expand-menu-button");
      attr_dev(
        button,
        "aria-expanded",
        /*expanded*/
        ctx[1]
      );
      add_location(button, file21, 29, 2, 587);
      attr_dev(div0, "class", "folder svelte-1ouveag");
      toggle_class(
        div0,
        "selected",
        /*$page*/
        ctx[2].url.pathname === /*folder*/
        ctx[0].href
      );
      toggle_class(div0, "folder-selected", "/" + /*$page*/
      ctx[2].url.pathname.split("/")[1] === /*folder*/
      ctx[0].href);
      add_location(div0, file21, 24, 1, 425);
      attr_dev(div1, "class", "collapsible");
      add_location(div1, file21, 23, 0, 398);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, button);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, path);
      append_hydration_dev(div0, t0);
      if_block0.m(div0, null);
      append_hydration_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*$page, folder*/
      5) {
        toggle_class(
          svg,
          "selected",
          /*$page*/
          ctx2[2].url.pathname === /*folder*/
          ctx2[0].href
        );
      }
      if (!current || dirty & /*$page, folder*/
      5) {
        toggle_class(svg, "folder-selected", "/" + /*$page*/
        ctx2[2].url.pathname.split("/")[1] === /*folder*/
        ctx2[0].href);
      }
      if (!current || dirty & /*expanded*/
      2) {
        attr_dev(
          button,
          "aria-expanded",
          /*expanded*/
          ctx2[1]
        );
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if (!current || dirty & /*$page, folder*/
      5) {
        toggle_class(
          div0,
          "selected",
          /*$page*/
          ctx2[2].url.pathname === /*folder*/
          ctx2[0].href
        );
      }
      if (!current || dirty & /*$page, folder*/
      5) {
        toggle_class(div0, "folder-selected", "/" + /*$page*/
        ctx2[2].url.pathname.split("/")[1] === /*folder*/
        ctx2[0].href);
      }
      if (
        /*expanded*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*expanded*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block13(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude20 = true;
function instance22($$self, $$props, $$invalidate) {
  let $page;
  validate_store(page4, "page");
  component_subscribe($$self, page4, ($$value) => $$invalidate(2, $page = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CollapsibleSection", slots, []);
  let { folder } = $$props;
  let { open } = $$props;
  let expanded = false;
  function toggle() {
    if ($page.url.pathname.split("/")[1] != folder.href) {
      $$invalidate(4, open = !open);
      $$invalidate(1, expanded = true);
    } else {
      $$invalidate(1, expanded = !expanded);
    }
  }
  $$self.$$.on_mount.push(function() {
    if (folder === void 0 && !("folder" in $$props || $$self.$$.bound[$$self.$$.props["folder"]])) {
      console.warn("<CollapsibleSection> was created without expected prop 'folder'");
    }
    if (open === void 0 && !("open" in $$props || $$self.$$.bound[$$self.$$.props["open"]])) {
      console.warn("<CollapsibleSection> was created without expected prop 'open'");
    }
  });
  const writable_props = ["folder", "open"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CollapsibleSection> was created with unknown prop '${key}'`);
  });
  const click_handler = () => $$invalidate(1, expanded = !expanded);
  const click_handler_1 = () => $$invalidate(1, expanded = !expanded);
  $$self.$$set = ($$props2) => {
    if ("folder" in $$props2)
      $$invalidate(0, folder = $$props2.folder);
    if ("open" in $$props2)
      $$invalidate(4, open = $$props2.open);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude20,
    page: page4,
    slide,
    folder,
    open,
    expanded,
    toggle,
    $page
  });
  $$self.$inject_state = ($$props2) => {
    if ("folder" in $$props2)
      $$invalidate(0, folder = $$props2.folder);
    if ("open" in $$props2)
      $$invalidate(4, open = $$props2.open);
    if ("expanded" in $$props2)
      $$invalidate(1, expanded = $$props2.expanded);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [folder, expanded, $page, toggle, open, click_handler, click_handler_1];
}
var CollapsibleSection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { folder: 0, open: 4 }, add_css13);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CollapsibleSection",
      options,
      id: create_fragment22.name
    });
  }
  get folder() {
    throw new Error("<CollapsibleSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set folder(value) {
    throw new Error("<CollapsibleSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<CollapsibleSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<CollapsibleSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CollapsibleSection_default = CollapsibleSection;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Details.svelte
var file22 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Details.svelte";
function add_css14(target) {
  append_styles(target, "svelte-yaigam", ".marker.svelte-yaigam{border-left:5px solid transparent;border-right:5px solid transparent;border-top:9px solid var(--grey-800);margin-right:8px;transform:rotate(-90deg);transition:transform 0.2s ease}.rotate-marker.svelte-yaigam{transform:rotate(0deg)}button.svelte-yaigam{display:flex;align-items:center;cursor:pointer}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGV0YWlscy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBd0JDLE9BQUEsY0FBQSxDQUFBLEFBQ0MsV0FBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsV0FBa0MsQ0FDbEMsWUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsV0FBbUMsQ0FDbkMsVUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXFDLENBQ3JDLFlBQUEsQ0FBQSxHQUFpQixDQUNqQixTQUFBLENBQUEsT0FBQSxNQUFBLENBQXlCLENBQ3pCLFVBQUEsQ0FBQSxTQUFBLENBQUEsSUFBQSxDQUFBLElBQStCLEFBQ2hDLENBQUEsQUFFQSxjQUFBLGNBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxPQUFBLElBQUEsQ0FBdUIsQUFDeEIsQ0FBQSxBQUVBLE1BQUEsY0FBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQ0FDYixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsTUFBQSxDQUFBLE9BQWUsQUFDaEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJEZXRhaWxzLnN2ZWx0ZSJdfQ== */");
}
function create_if_block14(ctx) {
  let div;
  let div_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "ml-3 pt-3 mb-6 text-base");
      add_location(div, file22, 17, 2, 417);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, true);
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, {}, false);
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(17:1) {#if open}",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let div;
  let button;
  let span;
  let span_class_value;
  let t0;
  let t1;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*open*/
    ctx[0] && create_if_block14(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      button = element("button");
      span = element("span");
      t0 = space();
      t1 = text(
        /*title*/
        ctx[1]
      );
      t2 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      t0 = claim_space(button_nodes);
      t1 = claim_text(
        button_nodes,
        /*title*/
        ctx[1]
      );
      button_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = null_to_empty(
        /*open*/
        ctx[0] ? "marker rotate-marker" : "marker"
      ) + " svelte-yaigam");
      add_location(span, file22, 12, 2, 323);
      attr_dev(button, "class", "italic text-base text-grey-800 cursor-pointer svelte-yaigam");
      add_location(button, file22, 11, 1, 226);
      attr_dev(div, "class", "mb-4 mt-3 ml-1");
      add_location(div, file22, 10, 0, 196);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      append_hydration_dev(button, span);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[4],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*open*/
      1 && span_class_value !== (span_class_value = null_to_empty(
        /*open*/
        ctx2[0] ? "marker rotate-marker" : "marker"
      ) + " svelte-yaigam")) {
        attr_dev(span, "class", span_class_value);
      }
      if (!current || dirty & /*title*/
      2)
        set_data_dev(
          t1,
          /*title*/
          ctx2[1]
        );
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude21 = true;
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Details", slots, ["default"]);
  let { title = "Details" } = $$props;
  let { open = false } = $$props;
  const writable_props = ["title", "open"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Details> was created with unknown prop '${key}'`);
  });
  const click_handler = () => $$invalidate(0, open = !open);
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ evidenceInclude: evidenceInclude21, title, open, slide });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [open, title, $$scope, slots, click_handler];
}
var Details = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { title: 1, open: 0 }, add_css14);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Details",
      options,
      id: create_fragment23.name
    });
  }
  get title() {
    throw new Error("<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Details>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Details>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Details_default = Details;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/EmailSignup.svelte
var file23 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/EmailSignup.svelte";
function add_css15(target) {
  append_styles(target, "svelte-yisu6m", "div.svelte-yisu6m{height:1.8em}p.svelte-yisu6m{font-family:var(--ui-font-family);color:#7d7d7d;font-size:0.75em}input.button.svelte-yisu6m{background-color:transparent;font-family:var(--ui-font-family);color:#7d7d7d;font-weight:bold;margin-left:0px;border:1px solid lightgrey;border-radius:0 4px 4px 0;height:100%;-webkit-appearance:none;-moz-appearance:none}form.svelte-yisu6m{display:inline-block;padding:0 0 0 0;height:1.5em}input.svelte-yisu6m{box-sizing:border-box;border-radius:4px 0 0 4px;border:1px solid lightgrey;border-right:none;padding:0.25em 0.25em 0.25em 0.25em;margin-right:0;height:100%;color:#7d7d7d;-webkit-appearance:none;-moz-appearance:none}input.svelte-yisu6m:required{box-shadow:none}input.svelte-yisu6m:focus{outline:none}input.svelte-yisu6m{vertical-align:middle}@media(max-width: 600px){div.svelte-yisu6m{text-align:center}input.svelte-yisu6m{padding:0.75em 0.5em 0.75em 0.5em;font-size:16px}input.email.svelte-yisu6m{width:50%}input.button.svelte-yisu6m{font-weight:normal;line-height:0}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRW1haWxTaWdudXAuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRDQyxHQUFBLGNBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxLQUFhLEFBQ2QsQ0FBQSxBQUVBLENBQUEsY0FBQSxDQUFBLEFBQ0MsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsS0FBQSxDQUFBLE9BQWMsQ0FDZCxTQUFBLENBQUEsTUFBaUIsQUFDbEIsQ0FBQSxBQUVBLEtBQUEsT0FBQSxjQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLFdBQTZCLENBQzdCLFdBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQWtDLENBQ2xDLEtBQUEsQ0FBQSxPQUFjLENBQ2QsV0FBQSxDQUFBLElBQWlCLENBQ2pCLFdBQUEsQ0FBQSxHQUFnQixDQUNoQixNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxTQUEyQixDQUMzQixhQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBMEIsQ0FDMUIsTUFBQSxDQUFBLElBQVksQ0FDWixrQkFBQSxDQUFBLElBQXdCLENBQ3hCLGVBQUEsQ0FBQSxJQUFxQixBQUN0QixDQUFBLEFBRUEsSUFBQSxjQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsWUFBcUIsQ0FDckIsT0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWdCLENBQ2hCLE1BQUEsQ0FBQSxLQUFhLEFBQ2QsQ0FBQSxBQUVBLEtBQUEsY0FBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLFVBQXNCLENBQ3RCLGFBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxHQUEwQixDQUMxQixNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxTQUEyQixDQUMzQixZQUFBLENBQUEsSUFBa0IsQ0FDbEIsT0FBQSxDQUFBLE1BQUEsQ0FBQSxNQUFBLENBQUEsTUFBQSxDQUFBLE1BQW9DLENBQ3BDLFlBQUEsQ0FBQSxDQUFlLENBQ2YsTUFBQSxDQUFBLElBQVksQ0FDWixLQUFBLENBQUEsT0FBYyxDQUNkLGtCQUFBLENBQUEsSUFBd0IsQ0FDeEIsZUFBQSxDQUFBLElBQXFCLEFBQ3RCLENBQUEsQUFFQSxtQkFBQSxTQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBRUEsbUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFFQSxLQUFBLGNBQUEsQ0FBQSxBQUNDLGNBQUEsQ0FBQSxNQUFzQixBQUN2QixDQUFBLEFBRUEsTUFBQSxBQUFBLFlBQUEsS0FBQSxDQUFBLEFBQUEsQ0FBQSxBQUNDLEdBQUEsY0FBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLE1BQWtCLEFBQ25CLENBQUEsQUFFQSxLQUFBLGNBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxNQUFBLENBQUEsS0FBQSxDQUFBLE1BQUEsQ0FBQSxLQUFrQyxDQUNsQyxTQUFBLENBQUEsSUFBZSxBQUNoQixDQUFBLEFBRUEsS0FBQSxNQUFBLGNBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxHQUFVLEFBQ1gsQ0FBQSxBQUVBLEtBQUEsT0FBQSxjQUFBLENBQUEsQUFDQyxXQUFBLENBQUEsTUFBbUIsQ0FDbkIsV0FBQSxDQUFBLENBQWMsQUFDZixDQUFBLEFBQ0QsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJFbWFpbFNpZ251cC5zdmVsdGUiXX0= */");
}
function create_else_block5(ctx) {
  let p;
  let t;
  let p_transition;
  let current;
  const block = {
    c: function create() {
      p = element("p");
      t = text("Thanks for subscribing. We'll be in touch.");
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      t = claim_text(p_nodes, "Thanks for subscribing. We'll be in touch.");
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "class", "svelte-yisu6m");
      add_location(p, file23, 39, 2, 801);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!p_transition)
            p_transition = create_bidirectional_transition(p, blur, {}, true);
          p_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, blur, {}, false);
        p_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (detaching && p_transition)
        p_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(39:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let form;
  let input0;
  let input1;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      form = element("form");
      input0 = element("input");
      input1 = element("input");
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", {
        id: true,
        "accept-charset": true,
        class: true
      });
      var form_nodes = children(form);
      input0 = claim_element(form_nodes, "INPUT", {
        type: true,
        name: true,
        placeholder: true,
        minlength: true,
        class: true
      });
      input1 = claim_element(form_nodes, "INPUT", { type: true, class: true });
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input0, "type", "email");
      attr_dev(input0, "name", "email");
      input0.required = "true";
      attr_dev(input0, "placeholder", "Email");
      attr_dev(input0, "minlength", "1");
      attr_dev(input0, "class", "email svelte-yisu6m");
      add_location(input0, file23, 28, 3, 572);
      attr_dev(input1, "type", "submit");
      attr_dev(input1, "class", "button svelte-yisu6m");
      input1.value = "Get Updates";
      add_location(input1, file23, 36, 5, 721);
      attr_dev(form, "id", "email-submit");
      attr_dev(form, "accept-charset", "UTF-8");
      attr_dev(form, "class", "svelte-yisu6m");
      add_location(form, file23, 27, 2, 487);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      append_hydration_dev(form, input0);
      set_input_value(
        input0,
        /*email*/
        ctx[0]
      );
      append_hydration_dev(form, input1);
      if (!mounted) {
        dispose = [
          listen_dev(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[3]
          ),
          listen_dev(form, "submit", prevent_default(
            /*submit*/
            ctx[2]
          ), false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*email*/
      1 && input0.value !== /*email*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*email*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(27:1) {#if !submitted}",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  const if_block_creators = [create_if_block15, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*submitted*/
    ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-yisu6m");
      add_location(div, file23, 25, 0, 461);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i: function intro(local) {
      transition_in(if_block);
    },
    o: function outro(local) {
      transition_out(if_block);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude22 = true;
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EmailSignup", slots, []);
  let email = null;
  let submitted = false;
  const submit = function() {
    $$invalidate(1, submitted = true);
  };
  onMount(() => {
    formcarry({
      form: "zbtQ8WaxJk",
      element: "#email-submit"
    });
  });
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EmailSignup> was created with unknown prop '${key}'`);
  });
  function input0_input_handler() {
    email = this.value;
    $$invalidate(0, email);
  }
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude22,
    blur,
    onMount,
    email,
    submitted,
    submit
  });
  $$self.$inject_state = ($$props2) => {
    if ("email" in $$props2)
      $$invalidate(0, email = $$props2.email);
    if ("submitted" in $$props2)
      $$invalidate(1, submitted = $$props2.submitted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [email, submitted, submit, input0_input_handler];
}
var EmailSignup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {}, add_css15);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EmailSignup",
      options,
      id: create_fragment24.name
    });
  }
};
var EmailSignup_default = EmailSignup;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Hamburger.svelte
var file24 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Hamburger.svelte";
function add_css16(target) {
  append_styles(target, "svelte-1bvl7wg", "svg.svelte-1bvl7wg.svelte-1bvl7wg{min-height:24px}svg.svelte-1bvl7wg line.svelte-1bvl7wg{stroke:var(--grey-600);stroke-width:3}button.svelte-1bvl7wg.svelte-1bvl7wg{align-items:center;z-index:10;margin-top:1em;margin-bottom:1em;margin-left:1em;margin-right:0;border:none;padding:0px;text-align:center;text-decoration:none;font-size:16px;background-color:hsla(217, 33%, 97%, 0);display:flex}svg.svelte-1bvl7wg.svelte-1bvl7wg{transform:scale(0.85)}@media(min-width: 850px){button.svelte-1bvl7wg.svelte-1bvl7wg{display:none}}@media print{button.svelte-1bvl7wg.svelte-1bvl7wg{display:none}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGFtYnVyZ2VyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpQkMsR0FBQSw4QkFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQWdCLEFBQ2pCLENBQUEsQUFFQSxrQkFBQSxDQUFBLElBQUEsZUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLElBQUEsVUFBQSxDQUF1QixDQUN2QixZQUFBLENBQUEsQ0FBZSxBQUNoQixDQUFBLEFBRUEsTUFBQSw4QkFBQSxDQUFBLEFBQ0MsV0FBQSxDQUFBLE1BQW1CLENBQ25CLE9BQUEsQ0FBQSxFQUFXLENBQ1gsVUFBQSxDQUFBLEdBQWUsQ0FDZixhQUFBLENBQUEsR0FBa0IsQ0FDbEIsV0FBQSxDQUFBLEdBQWdCLENBQ2hCLFlBQUEsQ0FBQSxDQUFlLENBQ2YsTUFBQSxDQUFBLElBQVksQ0FDWixPQUFBLENBQUEsR0FBWSxDQUNaLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixlQUFBLENBQUEsSUFBcUIsQ0FDckIsU0FBQSxDQUFBLElBQWUsQ0FDZixnQkFBQSxDQUFBLEtBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUF3QyxDQUN4QyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFFQSxHQUFBLDhCQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsTUFBQSxJQUFBLENBQXNCLEFBQ3ZCLENBQUEsQUFFQSxNQUFBLEFBQUEsWUFBQSxLQUFBLENBQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSw4QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQUFDZCxDQUFBLEFBQ0QsQ0FBQSxBQUVBLE9BQUEsS0FBQSxBQUFBLENBQUEsQUFDQyxNQUFBLDhCQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFDRCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkhhbWJ1cmdlci5zdmVsdGUiXX0= */");
}
function create_fragment25(ctx) {
  let button;
  let svg;
  let line0;
  let line1;
  let line2;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { "aria-label": true, class: true });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", { width: true, height: true, class: true });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", {
        id: true,
        x1: true,
        y1: true,
        x2: true,
        y2: true,
        class: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", {
        id: true,
        x1: true,
        y1: true,
        x2: true,
        y2: true,
        class: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", {
        id: true,
        x1: true,
        y1: true,
        x2: true,
        y2: true,
        class: true
      });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "id", "top");
      attr_dev(line0, "x1", "0");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "32");
      attr_dev(line0, "y2", "2");
      attr_dev(line0, "class", "svelte-1bvl7wg");
      add_location(line0, file24, 10, 2, 233);
      attr_dev(line1, "id", "middle");
      attr_dev(line1, "x1", "0");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "32");
      attr_dev(line1, "y2", "12");
      attr_dev(line1, "class", "svelte-1bvl7wg");
      add_location(line1, file24, 11, 2, 282);
      attr_dev(line2, "id", "bottom");
      attr_dev(line2, "x1", "0");
      attr_dev(line2, "y1", "22");
      attr_dev(line2, "x2", "32");
      attr_dev(line2, "y2", "22");
      attr_dev(line2, "class", "svelte-1bvl7wg");
      add_location(line2, file24, 12, 2, 336);
      attr_dev(svg, "width", "32");
      attr_dev(svg, "height", "24");
      attr_dev(svg, "class", "svelte-1bvl7wg");
      add_location(svg, file24, 9, 1, 202);
      attr_dev(button, "aria-label", "hamburger menu");
      attr_dev(button, "class", "svelte-1bvl7wg");
      toggle_class(
        button,
        "open",
        /*open*/
        ctx[0]
      );
      add_location(button, file24, 8, 0, 121);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[1],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*open*/
      1) {
        toggle_class(
          button,
          "open",
          /*open*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude23 = true;
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Hamburger", slots, []);
  let { open = false } = $$props;
  const writable_props = ["open"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Hamburger> was created with unknown prop '${key}'`);
  });
  const click_handler = () => $$invalidate(0, open = !open);
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
  };
  $$self.$capture_state = () => ({ evidenceInclude: evidenceInclude23, open });
  $$self.$inject_state = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [open, click_handler];
}
var Hamburger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { open: 0 }, add_css16);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Hamburger",
      options,
      id: create_fragment25.name
    });
  }
  get open() {
    throw new Error("<Hamburger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Hamburger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Hamburger_default = Hamburger;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/PageMenu.svelte
import { dev } from "$app/environment";

// ../../node_modules/@evidence-dev/component-utilities/src/clickOutside.js
function clickoutside(node, params) {
  const { enabled: initialEnabled, callback } = params;
  const handleOutsideClick = ({ target }) => {
    if (!node.contains(target))
      callback(node);
  };
  function update({ enabled }) {
    if (enabled) {
      window.addEventListener("click", handleOutsideClick);
    } else {
      window.removeEventListener("click", handleOutsideClick);
    }
  }
  update({ enabled: initialEnabled });
  return {
    update,
    destroy() {
      window.removeEventListener("click", handleOutsideClick);
    }
  };
}

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/PageMenu.svelte
var file25 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/PageMenu.svelte";
function add_css17(target) {
  append_styles(target, "svelte-vbhk6a", ".dropdown.svelte-vbhk6a{position:relative;display:inline-block}button.svelte-vbhk6a{background-color:unset;padding:0;cursor:pointer;border:none;line-height:normal}button.menu.svelte-vbhk6a{margin:16px;font-size:unset}ul.svelte-vbhk6a{position:absolute;top:100%;right:10px;min-width:170px;box-shadow:0px 0px 8px 0px rgba(0, 0, 0, 0.2);padding:8px 0 8px 0;border-radius:5px;z-index:1;background-color:white}li.svelte-vbhk6a{list-style-type:none;cursor:pointer;font-family:var(--ui-font-family);font-size:0.7em;color:var(--grey-900);margin:0}li.svelte-vbhk6a:hover{background-color:var(--grey-200)}a.svelte-vbhk6a{text-decoration:none;color:var(--grey-900);display:flex;justify-content:space-between;padding:10px 12px;line-height:normal;box-sizing:border-box;font-size:14px;align-items:center}button.dropdown.svelte-vbhk6a{font-family:var(--ui-font-family);font-size:14px;color:var(--grey-900);text-align:left;box-sizing:border-box;width:100%;padding:10px 12px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFnZU1lbnUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW9GQyxTQUFBLGNBQUEsQ0FBQSxBQUNDLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixPQUFBLENBQUEsWUFBcUIsQUFDdEIsQ0FBQSxBQUVBLE1BQUEsY0FBQSxDQUFBLEFBQ0MsZ0JBQUEsQ0FBQSxLQUF1QixDQUN2QixPQUFBLENBQUEsQ0FBVSxDQUNWLE1BQUEsQ0FBQSxPQUFlLENBQ2YsTUFBQSxDQUFBLElBQVksQ0FDWixXQUFBLENBQUEsTUFBbUIsQUFDcEIsQ0FBQSxBQUVBLE1BQUEsS0FBQSxjQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsSUFBWSxDQUNaLFNBQUEsQ0FBQSxLQUFnQixBQUNqQixDQUFBLEFBRUEsRUFBQSxjQUFBLENBQUEsQUFDQyxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsR0FBQSxDQUFBLElBQVMsQ0FDVCxLQUFBLENBQUEsSUFBVyxDQUNYLFNBQUEsQ0FBQSxLQUFnQixDQUNoQixVQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUE4QyxDQUM5QyxPQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBb0IsQ0FDcEIsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLE9BQUEsQ0FBQSxDQUFVLENBQ1YsZ0JBQUEsQ0FBQSxLQUF1QixBQUN4QixDQUFBLEFBRUEsRUFBQSxjQUFBLENBQUEsQUFDQyxlQUFBLENBQUEsSUFBcUIsQ0FDckIsTUFBQSxDQUFBLE9BQWUsQ0FDZixXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxDQUNsQyxTQUFBLENBQUEsS0FBZ0IsQ0FDaEIsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixNQUFBLENBQUEsQ0FBUyxBQUNWLENBQUEsQUFFQSxnQkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLEFBQ2xDLENBQUEsQUFFQSxDQUFBLGNBQUEsQ0FBQSxBQUNDLGVBQUEsQ0FBQSxJQUFxQixDQUNyQixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLE9BQUEsQ0FBQSxJQUFhLENBQ2IsZUFBQSxDQUFBLGFBQThCLENBQzlCLE9BQUEsQ0FBQSxJQUFBLENBQUEsSUFBa0IsQ0FDbEIsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixTQUFBLENBQUEsSUFBZSxDQUNmLFdBQUEsQ0FBQSxNQUFtQixBQUNwQixDQUFBLEFBRUEsTUFBQSxTQUFBLGNBQUEsQ0FBQSxBQUNDLFdBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQWtDLENBQ2xDLFNBQUEsQ0FBQSxJQUFlLENBQ2YsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsVUFBQSxDQUFBLFVBQXNCLENBQ3RCLEtBQUEsQ0FBQSxJQUFXLENBQ1gsT0FBQSxDQUFBLElBQUEsQ0FBQSxJQUFrQixBQUNuQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlBhZ2VNZW51LnN2ZWx0ZSJdfQ== */");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_if_block16(ctx) {
  let ul;
  let current;
  let each_value = (
    /*options*/
    ctx[3]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { class: true, id: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", "dropdown-items svelte-vbhk6a");
      attr_dev(ul, "id", "dropdown-items");
      add_location(ul, file25, 50, 2, 1697);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*toggleQueries, $showQueries, $pageHasQueries, options, print, ExternalLink, dev*/
      62) {
        each_value = /*options*/
        ctx2[3];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(50:1) {#if showDropdown}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let li;
  let show_if;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_25, create_if_block_5, create_if_block_6, create_else_block_13];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*option*/
      ctx2[10].label === "Show / Hide Queries"
    )
      return 0;
    if (
      /*option*/
      ctx2[10].label === "Export PDF"
    )
      return 1;
    if (
      /*option*/
      ctx2[10].url.includes("http")
    )
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      if_block.l(li_nodes);
      t = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", "svelte-vbhk6a");
      add_location(li, file25, 53, 5, 1808);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      append_hydration_dev(li, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(53:4) {#if dev || option.prod}",
    ctx
  });
  return block;
}
function create_else_block_13(ctx) {
  let a;
  let t_value = (
    /*option*/
    ctx[10].label + ""
  );
  let t;
  let a_href_value;
  const block = {
    c: function create() {
      a = element("a");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, target: true, class: true });
      var a_nodes = children(a);
      t = claim_text(a_nodes, t_value);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = /*option*/
      ctx[10].url);
      attr_dev(a, "target", "_self");
      attr_dev(a, "class", "svelte-vbhk6a");
      add_location(a, file25, 74, 7, 2560);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_13.name,
    type: "else",
    source: "(74:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let a;
  let t0_value = (
    /*option*/
    ctx[10].label + ""
  );
  let t0;
  let t1;
  let icon;
  let a_href_value;
  let current;
  icon = new Icon_default({
    props: { src: ExternalLink, class: "h-3 w-3" },
    $$inline: true
  });
  const block = {
    c: function create() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        href: true,
        target: true,
        rel: true,
        class: true
      });
      var a_nodes = children(a);
      t0 = claim_text(a_nodes, t0_value);
      t1 = claim_space(a_nodes);
      claim_component(icon.$$.fragment, a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = /*option*/
      ctx[10].url);
      attr_dev(a, "target", "_blank");
      attr_dev(a, "rel", "noreferrer");
      attr_dev(a, "class", "svelte-vbhk6a");
      add_location(a, file25, 69, 7, 2397);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t0);
      append_hydration_dev(a, t1);
      mount_component(icon, a, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(69:44) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let button;
  let t_value = (
    /*option*/
    ctx[10].label + ""
  );
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "dropdown first svelte-vbhk6a");
      add_location(button, file25, 67, 7, 2273);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*print*/
          ctx[4],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(67:46) ",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$pageHasQueries*/
    ctx[1] && create_if_block_3(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*$pageHasQueries*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(55:6) {#if option.label === 'Show / Hide Queries'}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$showQueries*/
      ctx2[2]
    )
      return create_if_block_4;
    return create_else_block6;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(56:7) {#if $pageHasQueries}",
    ctx
  });
  return block;
}
function create_else_block6(ctx) {
  let button;
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text("Show Queries");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, "aria-label": true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, "Show Queries");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "dropdown svelte-vbhk6a");
      attr_dev(button, "aria-label", "show-queries");
      add_location(button, file25, 61, 9, 2073);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*toggleQueries*/
          ctx[5],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(61:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let button;
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text("Hide Queries");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, "aria-label": true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, "Hide Queries");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "dropdown svelte-vbhk6a");
      attr_dev(button, "aria-label", "hide-queries");
      add_location(button, file25, 57, 9, 1929);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*toggleQueries*/
          ctx[5],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(57:8) {#if $showQueries}",
    ctx
  });
  return block;
}
function create_each_block7(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (dev || /*option*/
  ctx[10].prod) && create_if_block_15(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dev || /*option*/
      ctx2[10].prod)
        if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(52:3) {#each options as option}",
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let div;
  let button;
  let icon;
  let t;
  let clickOutside_action;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: {
      src: DotsVertical,
      class: "text-gray-600 w-6 h-6"
    },
    $$inline: true
  });
  let if_block = (
    /*showDropdown*/
    ctx[0] && create_if_block16(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      button = element("button");
      create_component(icon.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", {
        type: true,
        class: true,
        "aria-label": true
      });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "menu svelte-vbhk6a");
      attr_dev(button, "aria-label", "page menu button");
      add_location(button, file25, 46, 1, 1512);
      add_location(div, file25, 45, 0, 1420);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      mount_component(icon, button, null);
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*toggleDropdown*/
            ctx[6],
            false,
            false,
            false
          ),
          action_destroyer(clickOutside_action = clickoutside.call(null, div, {
            enabled: (
              /*showDropdown*/
              ctx[0]
            ),
            callback: (
              /*clickOutside_function*/
              ctx[7]
            )
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*showDropdown*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*showDropdown*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (clickOutside_action && is_function(clickOutside_action.update) && dirty & /*showDropdown*/
      1)
        clickOutside_action.update.call(null, {
          enabled: (
            /*showDropdown*/
            ctx2[0]
          ),
          callback: (
            /*clickOutside_function*/
            ctx2[7]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(icon);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude24 = true;
function instance26($$self, $$props, $$invalidate) {
  let $pageHasQueries;
  let $showQueries;
  validate_store(pageHasQueries, "pageHasQueries");
  component_subscribe($$self, pageHasQueries, ($$value) => $$invalidate(1, $pageHasQueries = $$value));
  validate_store(showQueries, "showQueries");
  component_subscribe($$self, showQueries, ($$value) => $$invalidate(2, $showQueries = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PageMenu", slots, []);
  let options = [
    { label: "Show / Hide Queries", prod: true },
    { label: "Export PDF", prod: true },
    {
      label: "Connect Data Source",
      url: "/settings/#connect-database",
      prod: false
    },
    {
      label: "Deploy Project",
      url: "/settings/#deploy",
      prod: false
    },
    {
      label: "Project Settings",
      url: "/settings",
      prod: false
    },
    {
      label: "Docs",
      url: "https://docs.evidence.dev",
      prod: false
    },
    {
      label: "Get Help on Slack",
      url: "https://join.slack.com/t/evidencedev/shared_invite/zt-uda6wp6a-hP6Qyz0LUOddwpXW5qG03Q",
      prod: false
    }
  ];
  const beforeprint = new Event("export-beforeprint");
  const afterprint = new Event("export-afterprint");
  function print() {
    $$invalidate(0, showDropdown = false);
    window.dispatchEvent(beforeprint);
    setTimeout(() => window.print(), 0);
    setTimeout(() => window.dispatchEvent(afterprint), 0);
  }
  function toggleQueries() {
    showQueries.update((value) => !value);
  }
  let showDropdown = false;
  function toggleDropdown() {
    $$invalidate(0, showDropdown = !showDropdown);
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PageMenu> was created with unknown prop '${key}'`);
  });
  const clickOutside_function = () => $$invalidate(0, showDropdown = false);
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude24,
    dev,
    Icon: Icon_default,
    DotsVertical,
    ExternalLink,
    clickOutside: clickoutside,
    showQueries,
    pageHasQueries,
    options,
    beforeprint,
    afterprint,
    print,
    toggleQueries,
    showDropdown,
    toggleDropdown,
    $pageHasQueries,
    $showQueries
  });
  $$self.$inject_state = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(3, options = $$props2.options);
    if ("showDropdown" in $$props2)
      $$invalidate(0, showDropdown = $$props2.showDropdown);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    showDropdown,
    $pageHasQueries,
    $showQueries,
    options,
    print,
    toggleQueries,
    toggleDropdown,
    clickOutside_function
  ];
}
var PageMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, {}, add_css17);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PageMenu",
      options,
      id: create_fragment26.name
    });
  }
};
var PageMenu_default = PageMenu;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Header.svelte
import { page as page5 } from "$app/stores";
var file26 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Header.svelte";
function add_css18(target) {
  append_styles(target, "svelte-u50pu4", "header.svelte-u50pu4{grid-area:header;height:var(--header-height);width:100%}div.header-container.svelte-u50pu4{height:var(--header-height);box-sizing:border-box;display:flex;justify-items:right;align-items:center}@media print{header.svelte-u50pu4{display:none}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF3QkMsTUFBQSxjQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsTUFBaUIsQ0FDakIsTUFBQSxDQUFBLElBQUEsZUFBQSxDQUE0QixDQUM1QixLQUFBLENBQUEsSUFBVyxBQUNaLENBQUEsQUFFQSxHQUFBLGlCQUFBLGNBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxJQUFBLGVBQUEsQ0FBNEIsQ0FDNUIsVUFBQSxDQUFBLFVBQXNCLENBQ3RCLE9BQUEsQ0FBQSxJQUFhLENBQ2IsYUFBQSxDQUFBLEtBQW9CLENBQ3BCLFdBQUEsQ0FBQSxNQUFtQixBQUNwQixDQUFBLEFBRUEsT0FBQSxLQUFBLEFBQUEsQ0FBQSxBQUNDLE1BQUEsY0FBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQUFDZCxDQUFBLEFBQ0QsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJIZWFkZXIuc3ZlbHRlIl19 */");
}
function create_if_block17(ctx) {
  let pagemenu;
  let current;
  pagemenu = new PageMenu_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(pagemenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(pagemenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(pagemenu, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pagemenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pagemenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(pagemenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(18:2) {#if !$page.url.pathname.includes('/settings')}",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let header;
  let div;
  let hamburger;
  let updating_open;
  let t0;
  let breadcrumbs;
  let t1;
  let show_if = !/*$page*/
  ctx[2].url.pathname.includes("/settings");
  let current;
  function hamburger_open_binding(value) {
    ctx[3](value);
  }
  let hamburger_props = {};
  if (
    /*open*/
    ctx[0] !== void 0
  ) {
    hamburger_props.open = /*open*/
    ctx[0];
  }
  hamburger = new Hamburger_default({ props: hamburger_props, $$inline: true });
  binding_callbacks.push(() => bind(
    hamburger,
    "open",
    hamburger_open_binding,
    /*open*/
    ctx[0]
  ));
  breadcrumbs = new BreadCrumbs_default({
    props: { fileTree: (
      /*fileTree*/
      ctx[1]
    ) },
    $$inline: true
  });
  let if_block = show_if && create_if_block17(ctx);
  const block = {
    c: function create() {
      header = element("header");
      div = element("div");
      create_component(hamburger.$$.fragment);
      t0 = space();
      create_component(breadcrumbs.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      div = claim_element(header_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(hamburger.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      claim_component(breadcrumbs.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "header-container svelte-u50pu4");
      add_location(div, file26, 14, 1, 327);
      attr_dev(header, "class", "svelte-u50pu4");
      add_location(header, file26, 13, 0, 317);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      append_hydration_dev(header, div);
      mount_component(hamburger, div, null);
      append_hydration_dev(div, t0);
      mount_component(breadcrumbs, div, null);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hamburger_changes = {};
      if (!updating_open && dirty & /*open*/
      1) {
        updating_open = true;
        hamburger_changes.open = /*open*/
        ctx2[0];
        add_flush_callback(() => updating_open = false);
      }
      hamburger.$set(hamburger_changes);
      const breadcrumbs_changes = {};
      if (dirty & /*fileTree*/
      2)
        breadcrumbs_changes.fileTree = /*fileTree*/
        ctx2[1];
      breadcrumbs.$set(breadcrumbs_changes);
      if (dirty & /*$page*/
      4)
        show_if = !/*$page*/
        ctx2[2].url.pathname.includes("/settings");
      if (show_if) {
        if (if_block) {
          if (dirty & /*$page*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block17(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hamburger.$$.fragment, local);
      transition_in(breadcrumbs.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(hamburger.$$.fragment, local);
      transition_out(breadcrumbs.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
      destroy_component(hamburger);
      destroy_component(breadcrumbs);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude25 = true;
function instance27($$self, $$props, $$invalidate) {
  let $page;
  validate_store(page5, "page");
  component_subscribe($$self, page5, ($$value) => $$invalidate(2, $page = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, []);
  let { fileTree } = $$props;
  let { open = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (fileTree === void 0 && !("fileTree" in $$props || $$self.$$.bound[$$self.$$.props["fileTree"]])) {
      console.warn("<Header> was created without expected prop 'fileTree'");
    }
  });
  const writable_props = ["fileTree", "open"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Header> was created with unknown prop '${key}'`);
  });
  function hamburger_open_binding(value) {
    open = value;
    $$invalidate(0, open);
  }
  $$self.$$set = ($$props2) => {
    if ("fileTree" in $$props2)
      $$invalidate(1, fileTree = $$props2.fileTree);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude25,
    BreadCrumbs: BreadCrumbs_default,
    Hamburger: Hamburger_default,
    PageMenu: PageMenu_default,
    fileTree,
    page: page5,
    open,
    $page
  });
  $$self.$inject_state = ($$props2) => {
    if ("fileTree" in $$props2)
      $$invalidate(1, fileTree = $$props2.fileTree);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [open, fileTree, $page, hamburger_open_binding];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { fileTree: 1, open: 0 }, add_css18);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment27.name
    });
  }
  get fileTree() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fileTree(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Header_default = Header;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/LoadingIndicator.svelte
var file27 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/LoadingIndicator.svelte";
function add_css19(target) {
  append_styles(target, "svelte-6wdpco", ".progress-container.svelte-6wdpco{position:absolute;top:0;left:0;width:100%;height:3px;z-index:999}.progress.svelte-6wdpco{position:absolute;left:0;top:0;height:100%;background-image:-webkit-linear-gradient(315deg, var(--blue-600) 0%, var(--green-600) 75%);transition:width 0.4s}.fade.svelte-6wdpco{position:fixed;width:100%;height:100%;background-color:rgba(255, 255, 255, 0.3);pointer-events:none;z-index:998;animation:svelte-6wdpco-fade 0.4s}@keyframes svelte-6wdpco-fade{from{opacity:0}to{opacity:1}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGluZ0luZGljYXRvci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBOEJDLG1CQUFBLGNBQUEsQ0FBQSxBQUNDLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixHQUFBLENBQUEsQ0FBTSxDQUNOLElBQUEsQ0FBQSxDQUFPLENBQ1AsS0FBQSxDQUFBLElBQVcsQ0FDWCxNQUFBLENBQUEsR0FBVyxDQUNYLE9BQUEsQ0FBQSxHQUFZLEFBQ2IsQ0FBQSxBQUNBLFNBQUEsY0FBQSxDQUFBLEFBQ0MsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLElBQUEsQ0FBQSxDQUFPLENBQ1AsR0FBQSxDQUFBLENBQU0sQ0FDTixNQUFBLENBQUEsSUFBWSxDQUNaLGdCQUFBLENBQUEsd0JBQUEsTUFBQSxDQUFBLENBQUEsSUFBQSxVQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsQ0FBQSxJQUFBLFdBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBMkYsQ0FDM0YsVUFBQSxDQUFBLEtBQUEsQ0FBQSxJQUFzQixBQUN2QixDQUFBLEFBQ0EsS0FBQSxjQUFBLENBQUEsQUFDQyxRQUFBLENBQUEsS0FBZSxDQUNmLEtBQUEsQ0FBQSxJQUFXLENBQ1gsTUFBQSxDQUFBLElBQVksQ0FDWixnQkFBQSxDQUFBLEtBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUEwQyxDQUMxQyxjQUFBLENBQUEsSUFBb0IsQ0FDcEIsT0FBQSxDQUFBLEdBQVksQ0FDWixTQUFBLENBQUEsa0JBQUEsQ0FBQSxJQUFvQixBQUNyQixDQUFBLEFBQ0EsV0FBQSxrQkFBQSxDQUFBLEFBQ0MsSUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsQ0FBVSxBQUNYLENBQUEsQUFDQSxFQUFBLEFBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxDQUFVLEFBQ1gsQ0FBQSxBQUNELENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTG9hZGluZ0luZGljYXRvci5zdmVsdGUiXX0= */");
}
function create_if_block_16(ctx) {
  let div1;
  let div0;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "progress svelte-6wdpco");
      set_style(
        div0,
        "width",
        /*p*/
        ctx[0] * 100 + "%"
      );
      add_location(div0, file27, 21, 2, 404);
      attr_dev(div1, "class", "progress-container svelte-6wdpco");
      add_location(div1, file27, 20, 1, 369);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*p*/
      1) {
        set_style(
          div0,
          "width",
          /*p*/
          ctx2[0] * 100 + "%"
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(20:0) {#if visible}",
    ctx
  });
  return block;
}
function create_if_block18(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "fade svelte-6wdpco");
      add_location(div, file27, 26, 1, 486);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(26:0) {#if p >= 0.4}",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let t;
  let if_block1_anchor;
  let if_block0 = (
    /*visible*/
    ctx[1] && create_if_block_16(ctx)
  );
  let if_block1 = (
    /*p*/
    ctx[0] >= 0.4 && create_if_block18(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*visible*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_16(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*p*/
        ctx2[0] >= 0.4
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block18(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude26 = true;
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LoadingIndicator", slots, []);
  let p = 0;
  let visible = false;
  onMount(() => {
    $$invalidate(1, visible = true);
    function next() {
      $$invalidate(0, p += 0.1);
      const remaining = 1 - p;
      if (remaining > 0.15)
        setTimeout(next, 500 / remaining);
    }
    setTimeout(next, 250);
  });
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LoadingIndicator> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({ evidenceInclude: evidenceInclude26, onMount, p, visible });
  $$self.$inject_state = ($$props2) => {
    if ("p" in $$props2)
      $$invalidate(0, p = $$props2.p);
    if ("visible" in $$props2)
      $$invalidate(1, visible = $$props2.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [p, visible];
}
var LoadingIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {}, add_css19);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LoadingIndicator",
      options,
      id: create_fragment28.name
    });
  }
};
var LoadingIndicator_default = LoadingIndicator;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Logo.svelte
var file28 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Logo.svelte";
function add_css20(target) {
  append_styles(target, "svelte-id1tfs", "a.svelte-id1tfs{background:-webkit-linear-gradient(315deg, #046ade 0%, #08a86d 75%);text-decoration:none;-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;font-size:1em;font-weight:bold;font-family:var(--ui-font-family)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9nby5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBV0MsQ0FBQSxjQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsd0JBQUEsTUFBQSxDQUFBLENBQUEsT0FBQSxDQUFBLEVBQUEsQ0FBQSxDQUFBLE9BQUEsQ0FBQSxHQUFBLENBQW9FLENBQ3BFLGVBQUEsQ0FBQSxJQUFxQixDQUNyQix1QkFBQSxDQUFBLElBQTZCLENBQzdCLGVBQUEsQ0FBQSxJQUFxQixDQUNyQix1QkFBQSxDQUFBLFdBQW9DLENBQ3BDLFNBQUEsQ0FBQSxHQUFjLENBQ2QsV0FBQSxDQUFBLElBQWlCLENBQ2pCLFdBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQWtDLEFBQ25DLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTG9nby5zdmVsdGUiXX0= */");
}
function create_fragment29(ctx) {
  let a;
  let t;
  const block = {
    c: function create() {
      a = element("a");
      t = text(
        /*organization*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      t = claim_text(
        a_nodes,
        /*organization*/
        ctx[0]
      );
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", "/");
      attr_dev(a, "class", "svelte-id1tfs");
      add_location(a, file28, 8, 0, 138);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*organization*/
      1)
        set_data_dev(
          t,
          /*organization*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude27 = true;
function instance29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Logo", slots, []);
  let { organization = "evidence.dev" } = $$props;
  const writable_props = ["organization"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Logo> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("organization" in $$props2)
      $$invalidate(0, organization = $$props2.organization);
  };
  $$self.$capture_state = () => ({ evidenceInclude: evidenceInclude27, organization });
  $$self.$inject_state = ($$props2) => {
    if ("organization" in $$props2)
      $$invalidate(0, organization = $$props2.organization);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [organization];
}
var Logo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, { organization: 0 }, add_css20);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Logo",
      options,
      id: create_fragment29.name
    });
  }
  get organization() {
    throw new Error("<Logo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set organization(value) {
    throw new Error("<Logo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Logo_default = Logo;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Modal.svelte
var file29 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Modal.svelte";
function create_if_block19(ctx) {
  let div4;
  let div0;
  let t0;
  let div3;
  let div1;
  let show_if_1 = (
    /*title*/
    ctx[1].trim() != ""
  );
  let t1;
  let show_if = (
    /*title*/
    ctx[1].trim() == ""
  );
  let div1_class_value;
  let t2;
  let div2;
  let t3;
  let t4;
  let div2_class_value;
  let current;
  let if_block0 = show_if_1 && create_if_block_26(ctx);
  let if_block1 = show_if && create_if_block_17(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      div4 = element("div");
      div0 = element("div");
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div2 = element("div");
      t3 = text(
        /*innerText*/
        ctx[3]
      );
      t4 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div0 = claim_element(div4_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      t3 = claim_text(
        div2_nodes,
        /*innerText*/
        ctx[3]
      );
      t4 = claim_space(div2_nodes);
      if (default_slot)
        default_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "fixed inset-0 bg-gray-900 opacity-50");
      add_location(div0, file29, 23, 2, 756);
      attr_dev(div1, "class", div1_class_value = "relative flex justify-between items-center " + /*title*/
      (ctx[1].trim() != "" ? " bg-gray-100 py-4 px-10 text-xl font-bold break-normal text-center" : ""));
      add_location(div1, file29, 25, 3, 910);
      attr_dev(div2, "class", div2_class_value = "h-auto max-h-96 overflow-y-auto px-10 " + /*title*/
      (ctx[1].trim() != "" ? "my-4" : "my-6") + " text-base break-normal");
      add_location(div2, file29, 48, 3, 1625);
      attr_dev(div3, "class", "bg-white w-4/5 max-w-lg mx-auto rounded-lg shadow-xl z-50 overflow-y-auto font-ui");
      add_location(div3, file29, 24, 2, 811);
      attr_dev(div4, "class", "modal z-50 fixed w-full h-full top-0 left-0 flex items-center justify-center lg:p-0");
      add_location(div4, file29, 22, 1, 656);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, div0);
      append_hydration_dev(div4, t0);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div3, t2);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, t3);
      append_hydration_dev(div2, t4);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2)
        show_if_1 = /*title*/
        ctx2[1].trim() != "";
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*title*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_26(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & /*title*/
      2)
        show_if = /*title*/
        ctx2[1].trim() == "";
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*title*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_17(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*title*/
      2 && div1_class_value !== (div1_class_value = "relative flex justify-between items-center " + /*title*/
      (ctx2[1].trim() != "" ? " bg-gray-100 py-4 px-10 text-xl font-bold break-normal text-center" : ""))) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*innerText*/
      8)
        set_data_dev(
          t3,
          /*innerText*/
          ctx2[3]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*title*/
      2 && div2_class_value !== (div2_class_value = "h-auto max-h-96 overflow-y-auto px-10 " + /*title*/
      (ctx2[1].trim() != "" ? "my-4" : "my-6") + " text-base break-normal")) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div4);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(22:0) {#if open}",
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let t0;
  let t1;
  let button;
  let icon;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: { src: X, class: "text-gray-600 w-6 h-6" },
    $$inline: true
  });
  const block = {
    c: function create() {
      t0 = text(
        /*title*/
        ctx[1]
      );
      t1 = space();
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      t0 = claim_text(
        nodes,
        /*title*/
        ctx[1]
      );
      t1 = claim_space(nodes);
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "flex items-center justify-center border-none hover:bg-gray-200");
      add_location(button, file29, 32, 5, 1129);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, button, anchor);
      mount_component(icon, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[8],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*title*/
      2)
        set_data_dev(
          t0,
          /*title*/
          ctx2[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(button);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(31:4) {#if title.trim() != ''}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let button;
  let icon;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: {
      src: X,
      class: "text-gray-600 w-6 h-6 mt-2 mr-2 hover:bg-gray-200"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "flex items-center justify-center border-none p-0.5 absolute right-0 top-0 ml-4");
      add_location(button, file29, 40, 5, 1365);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(icon, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_2*/
          ctx[9],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(40:4) {#if title.trim() == ''}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let button;
  let t0;
  let t1;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*open*/
    ctx[0] && create_if_block19(ctx)
  );
  const block = {
    c: function create() {
      button = element("button");
      t0 = text(
        /*buttonText*/
        ctx[2]
      );
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t0 = claim_text(
        button_nodes,
        /*buttonText*/
        ctx[2]
      );
      button_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "font-ui font-normal text-base no-underline border my-2 rounded-lg py-2 px-3 inline-block transition hover:ease-in hover:border-blue-200 hover:bg-blue-100 hover:no-underline hover:text-gray-800 focus:text-gray-900 focus:border-blue-200");
      add_location(button, file29, 16, 0, 340);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t0);
      insert_hydration_dev(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[7],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*buttonText*/
      4)
        set_data_dev(
          t0,
          /*buttonText*/
          ctx2[2]
        );
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (detaching)
        detach_dev(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude28 = true;
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["default"]);
  let { open = false } = $$props;
  let { title = "" } = $$props;
  let { buttonText = "" } = $$props;
  let { innerText = "" } = $$props;
  const isOpen = () => {
    $$invalidate(0, open = !open);
  };
  const writable_props = ["open", "title", "buttonText", "innerText"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Modal> was created with unknown prop '${key}'`);
  });
  const click_handler = () => isOpen();
  const click_handler_1 = () => isOpen();
  const click_handler_2 = () => isOpen();
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("buttonText" in $$props2)
      $$invalidate(2, buttonText = $$props2.buttonText);
    if ("innerText" in $$props2)
      $$invalidate(3, innerText = $$props2.innerText);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude28,
    X,
    Icon: Icon_default,
    open,
    title,
    buttonText,
    innerText,
    isOpen
  });
  $$self.$inject_state = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("buttonText" in $$props2)
      $$invalidate(2, buttonText = $$props2.buttonText);
    if ("innerText" in $$props2)
      $$invalidate(3, innerText = $$props2.innerText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    open,
    title,
    buttonText,
    innerText,
    isOpen,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      open: 0,
      title: 1,
      buttonText: 2,
      innerText: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment30.name
    });
  }
  get open() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonText() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonText(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get innerText() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set innerText(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Nav.svelte
import { page as page6 } from "$app/stores";
var file30 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Nav.svelte";
function add_css21(target) {
  append_styles(target, "svelte-ag997b", "div.nav-container.svelte-ag997b.svelte-ag997b{overflow:auto;white-space:nowrap;-ms-overflow-style:none;scrollbar-width:none}div.nav-container.svelte-ag997b a.svelte-ag997b{color:var(--grey-999);display:inline-block;text-align:center;text-decoration:none;font-family:var(--ui-font-family-compact);padding:0 1em 0 0;letter-spacing:0.05em;-webkit-font-smoothing:antialiased}.svelte-ag997b.svelte-ag997b::-webkit-scrollbar{display:none}a.svelte-ag997b.svelte-ag997b:hover{background-color:none;text-decoration:none}[aria-current].svelte-ag997b.svelte-ag997b{position:relative;display:inline-block}[aria-current].svelte-ag997b.svelte-ag997b::after{position:absolute;content:'';width:calc(100% - 1em);height:2px;background:-webkit-linear-gradient(315deg, var(--blue-600) 0%, var(--green-600) 75%);display:block;bottom:-2px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmF2LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtQkMsR0FBQSxjQUFBLDRCQUFBLENBQUEsQUFDQyxRQUFBLENBQUEsSUFBYyxDQUNkLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixrQkFBQSxDQUFBLElBQXdCLENBQ3hCLGVBQUEsQ0FBQSxJQUFxQixBQUN0QixDQUFBLEFBRUEsR0FBQSw0QkFBQSxDQUFBLENBQUEsY0FBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixPQUFBLENBQUEsWUFBcUIsQ0FDckIsVUFBQSxDQUFBLE1BQWtCLENBQ2xCLGVBQUEsQ0FBQSxJQUFxQixDQUNyQixXQUFBLENBQUEsSUFBQSx3QkFBQSxDQUEwQyxDQUMxQyxPQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBa0IsQ0FDbEIsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLHNCQUFBLENBQUEsV0FBbUMsQUFDcEMsQ0FBQSw0QkFDQSxtQkFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFFQSw2QkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBc0IsQ0FDdEIsZUFBQSxDQUFBLElBQXFCLEFBQ3RCLENBQUEsQUFFQSxDQUFBLFlBQUEsQ0FBQSw0QkFBQSxDQUFBLEFBQ0MsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLE9BQUEsQ0FBQSxZQUFxQixBQUN0QixDQUFBLEFBRUEsQ0FBQSxZQUFBLDZCQUFBLE9BQUEsQUFBQSxDQUFBLEFBQ0MsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLE9BQUEsQ0FBQSxFQUFXLENBQ1gsS0FBQSxDQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQXVCLENBQ3ZCLE1BQUEsQ0FBQSxHQUFXLENBQ1gsVUFBQSxDQUFBLHdCQUFBLE1BQUEsQ0FBQSxDQUFBLElBQUEsVUFBQSxDQUFBLENBQUEsRUFBQSxDQUFBLENBQUEsSUFBQSxXQUFBLENBQUEsQ0FBQSxHQUFBLENBQXFGLENBQ3JGLE9BQUEsQ0FBQSxLQUFjLENBQ2QsTUFBQSxDQUFBLElBQVksQUFDYixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk5hdi5zdmVsdGUiXX0= */");
}
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block8(ctx) {
  let a;
  let t_value = (
    /*section*/
    ctx[3].label + ""
  );
  let t;
  let a_aria_current_value;
  let a_href_value;
  const block = {
    c: function create() {
      a = element("a");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        "aria-current": true,
        href: true,
        class: true
      });
      var a_nodes = children(a);
      t = claim_text(a_nodes, t_value);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "aria-current", a_aria_current_value = /*currentSection*/
      ctx[1] === /*section*/
      ctx[3].href ? "page" : void 0);
      attr_dev(a, "href", a_href_value = /*section*/
      ctx[3].href);
      attr_dev(a, "class", "svelte-ag997b");
      add_location(a, file30, 12, 2, 307);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*sections*/
      1 && t_value !== (t_value = /*section*/
      ctx2[3].label + ""))
        set_data_dev(t, t_value);
      if (dirty & /*currentSection, sections*/
      3 && a_aria_current_value !== (a_aria_current_value = /*currentSection*/
      ctx2[1] === /*section*/
      ctx2[3].href ? "page" : void 0)) {
        attr_dev(a, "aria-current", a_aria_current_value);
      }
      if (dirty & /*sections*/
      1 && a_href_value !== (a_href_value = /*section*/
      ctx2[3].href)) {
        attr_dev(a, "href", a_href_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block8.name,
    type: "each",
    source: "(12:1) {#each sections as section}",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let div;
  let each_value = (
    /*sections*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block8(get_each_context8(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "nav-container svelte-ag997b");
      add_location(div, file30, 10, 0, 248);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*currentSection, sections, undefined*/
      3) {
        each_value = /*sections*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude29 = true;
function instance31($$self, $$props, $$invalidate) {
  let currentSection;
  let $page;
  validate_store(page6, "page");
  component_subscribe($$self, page6, ($$value) => $$invalidate(2, $page = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Nav", slots, []);
  let { sections = [{ href: "/", label: "Home" }] } = $$props;
  const writable_props = ["sections"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Nav> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("sections" in $$props2)
      $$invalidate(0, sections = $$props2.sections);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude29,
    page: page6,
    sections,
    currentSection,
    $page
  });
  $$self.$inject_state = ($$props2) => {
    if ("sections" in $$props2)
      $$invalidate(0, sections = $$props2.sections);
    if ("currentSection" in $$props2)
      $$invalidate(1, currentSection = $$props2.currentSection);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$page*/
    4) {
      $:
        $$invalidate(1, currentSection = "/" + $page.url.pathname.split("/")[1]);
    }
  };
  return [sections, currentSection, $page];
}
var Nav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, { sections: 0 }, add_css21);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nav",
      options,
      id: create_fragment31.name
    });
  }
  get sections() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sections(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Nav_default = Nav;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Portal.svelte
var { Error: Error_12 } = globals;
var file31 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Portal.svelte";
function create_fragment32(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      div.hidden = true;
      add_location(div, file31, 88, 0, 2395);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal.call(
          null,
          div,
          /*target*/
          ctx[0]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*target*/
      1)
        portal_action.update.call(
          null,
          /*target*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude30 = true;
function portal(el, { target = "body", prepend = false }) {
  let targetEl;
  const placeholder = document.createElement("div");
  placeholder.style.display = "none";
  placeholder.style.position = "absolute";
  el.parentElement.insertBefore(placeholder, el);
  const update = async (args) => {
    const { target: newTarget } = args ?? { target: null };
    target = newTarget;
    if (typeof target === "string") {
      targetEl = document.querySelector(target);
      if (targetEl === null) {
        await tick();
        targetEl = document.querySelector(target);
      }
      if (targetEl === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetEl = target;
    } else if (target === null) {
      placeholder.parentElement.insertBefore(el, placeholder);
      el.hidden = false;
      return;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    if (prepend) {
      targetEl.prepend(el);
    } else {
      targetEl.appendChild(el);
    }
    el.hidden = false;
  };
  function destroy() {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  update(target);
  return { update, destroy };
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let { target = "body" } = $$props;
  const writable_props = ["target"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Portal> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ evidenceInclude: evidenceInclude30, tick, portal, target });
  $$self.$inject_state = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [target, $$scope, slots];
}
var Portal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { target: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal",
      options,
      id: create_fragment32.name
    });
  }
  get target() {
    throw new Error_12("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error_12("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Portal_default = Portal;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewer.svelte
import { dev as dev2 } from "$app/environment";

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewerSupport/QueryDataTable.svelte
var { Object: Object_12 } = globals;
var file32 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewerSupport/QueryDataTable.svelte";
function add_css22(target) {
  append_styles(target, "svelte-un48bn", "div.pagination.svelte-un48bn.svelte-un48bn{padding:0px 5px;align-content:center;border-bottom:1px solid var(--grey-200);height:1.25em;background-color:white;display:flex;flex-direction:row;justify-content:space-between;align-items:center}.slider.svelte-un48bn.svelte-un48bn{-webkit-appearance:none;width:75%;height:10px;margin:0 0;background:var(--blue-100);outline:none;opacity:0.7;transition:opacity 0.2s;border-radius:10px;display:inline-block;cursor:pointer}.slider.svelte-un48bn.svelte-un48bn:hover{opacity:1}.slider.svelte-un48bn.svelte-un48bn::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:10px;height:10px;background:var(--blue-500);cursor:pointer;border-radius:10px}.slider.svelte-un48bn.svelte-un48bn::-moz-range-thumb{width:10px;height:10px;background:var(--blue-500);cursor:pointer}span.svelte-un48bn.svelte-un48bn{font-family:var(--ui-font-family-compact);-webkit-font-smoothing:antialiased;font-size:calc(1em - 6px);float:right}:root{--scrollbar-track-color:transparent;--scrollbar-color:rgba(0, 0, 0, 0.2);--scrollbar-active-color:rgba(0, 0, 0, 0.4);--scrollbar-size:0.75rem;--scrollbar-minlength:1.5rem}.container.svelte-un48bn.svelte-un48bn{width:100%;overflow-x:auto;border-bottom:1px solid var(--grey-200);scrollbar-width:thin;scrollbar-color:var(--scrollbar-color) var(--scrollbar-track-color);background-color:white}.container.svelte-un48bn.svelte-un48bn::-webkit-scrollbar{height:var(--scrollbar-size);width:var(--scrollbar-size)}.container.svelte-un48bn.svelte-un48bn::-webkit-scrollbar-track{background-color:var(--scrollbar-track-color)}.container.svelte-un48bn.svelte-un48bn::-webkit-scrollbar-thumb{background-color:var(--scrollbar-color);border-radius:7px;background-clip:padding-box}.container.svelte-un48bn.svelte-un48bn::-webkit-scrollbar-thumb:hover{background-color:var(--scrollbar-active-color)}.container.svelte-un48bn.svelte-un48bn::-webkit-scrollbar-thumb:vertical{min-height:var(--scrollbar-minlength);border:3px solid transparent}.container.svelte-un48bn.svelte-un48bn::-webkit-scrollbar-thumb:horizontal{min-width:var(--scrollbar-minlength);border:3px solid transparent}.results-pane.svelte-un48bn .download-button{margin-top:10px}table.svelte-un48bn.svelte-un48bn{width:100%;font-size:calc(1em - 7px);border-collapse:collapse;font-family:var(--ui-font-family);font-variant-numeric:tabular-nums}th.svelte-un48bn.svelte-un48bn{font-weight:bold;padding:0px 8px}td.svelte-un48bn.svelte-un48bn{padding:2px 8px;overflow:hidden;text-overflow:ellipsis}td.svelte-un48bn div.svelte-un48bn{width:100px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.other.svelte-un48bn.svelte-un48bn{text-align:left}.string.svelte-un48bn.svelte-un48bn{text-align:left}.date.svelte-un48bn.svelte-un48bn{text-align:left}.number.svelte-un48bn.svelte-un48bn{text-align:right}.boolean.svelte-un48bn.svelte-un48bn{text-align:left}.null.svelte-un48bn.svelte-un48bn{color:var(--grey-300)}.index.svelte-un48bn.svelte-un48bn{color:var(--grey-300);text-align:left;max-width:-moz-min-content;max-width:min-content}th.type-indicator.svelte-un48bn.svelte-un48bn{color:var(--grey-400);font-weight:normal;font-style:italic}tr.type-indicator.svelte-un48bn.svelte-un48bn{border-bottom:1px solid var(--grey-100)}.footer.svelte-un48bn.svelte-un48bn{display:flex;justify-content:flex-end;font-size:12px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUXVlcnlEYXRhVGFibGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRKQyxHQUFBLFdBQUEsNEJBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxHQUFBLENBQUEsR0FBZ0IsQ0FDaEIsYUFBQSxDQUFBLE1BQXFCLENBQ3JCLGFBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUF3QyxDQUN4QyxNQUFBLENBQUEsTUFBYyxDQUNkLGdCQUFBLENBQUEsS0FBdUIsQ0FDdkIsT0FBQSxDQUFBLElBQWEsQ0FDYixjQUFBLENBQUEsR0FBbUIsQ0FDbkIsZUFBQSxDQUFBLGFBQThCLENBQzlCLFdBQUEsQ0FBQSxNQUFtQixBQUNwQixDQUFBLEFBRUEsT0FBQSw0QkFBQSxDQUFBLEFBQ0Msa0JBQUEsQ0FBQSxJQUF3QixDQUN4QixLQUFBLENBQUEsR0FBVSxDQUNWLE1BQUEsQ0FBQSxJQUFZLENBQ1osTUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFXLENBQ1gsVUFBQSxDQUFBLElBQUEsVUFBQSxDQUEyQixDQUMzQixPQUFBLENBQUEsSUFBYSxDQUNiLE9BQUEsQ0FBQSxHQUFZLENBQ1osVUFBQSxDQUFBLE9BQUEsQ0FBQSxJQUF3QixDQUN4QixhQUFBLENBQUEsSUFBbUIsQ0FDbkIsT0FBQSxDQUFBLFlBQXFCLENBQ3JCLE1BQUEsQ0FBQSxPQUFlLEFBQ2hCLENBQUEsQUFFQSxtQ0FBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxDQUFVLEFBQ1gsQ0FBQSxBQUVBLG1DQUFBLHNCQUFBLEFBQUEsQ0FBQSxBQUNDLGtCQUFBLENBQUEsSUFBd0IsQ0FDeEIsVUFBQSxDQUFBLElBQWdCLENBQ2hCLEtBQUEsQ0FBQSxJQUFXLENBQ1gsTUFBQSxDQUFBLElBQVksQ0FDWixVQUFBLENBQUEsSUFBQSxVQUFBLENBQTJCLENBQzNCLE1BQUEsQ0FBQSxPQUFlLENBQ2YsYUFBQSxDQUFBLElBQW1CLEFBQ3BCLENBQUEsQUFFQSxtQ0FBQSxrQkFBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBVyxDQUNYLE1BQUEsQ0FBQSxJQUFZLENBQ1osVUFBQSxDQUFBLElBQUEsVUFBQSxDQUEyQixDQUMzQixNQUFBLENBQUEsT0FBZSxBQUNoQixDQUFBLEFBRUEsSUFBQSw0QkFBQSxDQUFBLEFBQ0MsV0FBQSxDQUFBLElBQUEsd0JBQUEsQ0FBMEMsQ0FDMUMsc0JBQUEsQ0FBQSxXQUFtQyxDQUNuQyxTQUFBLENBQUEsS0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBMEIsQ0FDMUIsS0FBQSxDQUFBLEtBQVksQUFDYixDQUFBLEFBRUEsS0FBQSxBQUFBLENBQUEsQUFDQyx1QkFBQSxDQUFBLFdBQW9DLENBQ3BDLGlCQUFBLENBQUEsa0JBQXFDLENBQ3JDLHdCQUFBLENBQUEsa0JBQTRDLENBQzVDLGdCQUFBLENBQUEsT0FBeUIsQ0FDekIscUJBQUEsQ0FBQSxNQUE2QixBQUM5QixDQUFBLEFBRUEsVUFBQSw0QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQVcsQ0FDWCxVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsYUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXdDLENBQ3hDLGVBQUEsQ0FBQSxJQUFxQixDQUNyQixlQUFBLENBQUEsSUFBQSxpQkFBQSxDQUFBLENBQUEsSUFBQSx1QkFBQSxDQUFvRSxDQUNwRSxnQkFBQSxDQUFBLEtBQXVCLEFBQ3hCLENBQUEsQUFFQSxzQ0FBQSxtQkFBQSxBQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsSUFBQSxnQkFBQSxDQUE2QixDQUM3QixLQUFBLENBQUEsSUFBQSxnQkFBQSxDQUE0QixBQUM3QixDQUFBLEFBQ0Esc0NBQUEseUJBQUEsQUFBQSxDQUFBLEFBQ0MsZ0JBQUEsQ0FBQSxJQUFBLHVCQUFBLENBQThDLEFBQy9DLENBQUEsQUFDQSxzQ0FBQSx5QkFBQSxBQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsaUJBQUEsQ0FBd0MsQ0FDeEMsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLGVBQUEsQ0FBQSxXQUE0QixBQUM3QixDQUFBLEFBQ0Esc0NBQUEseUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsd0JBQUEsQ0FBK0MsQUFDaEQsQ0FBQSxBQUNBLHNDQUFBLHlCQUFBLFNBQUEsQUFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQUEscUJBQUEsQ0FBc0MsQ0FDdEMsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsV0FBNkIsQUFDOUIsQ0FBQSxBQUNBLHNDQUFBLHlCQUFBLFdBQUEsQUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLElBQUEscUJBQUEsQ0FBcUMsQ0FDckMsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsV0FBNkIsQUFDOUIsQ0FBQSxBQUVBLDJCQUFBLENBQUEsQUFBQSxnQkFBQSxBQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBZ0IsQUFDakIsQ0FBQSxBQUVBLEtBQUEsNEJBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFXLENBQ1gsU0FBQSxDQUFBLEtBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQTBCLENBQzFCLGVBQUEsQ0FBQSxRQUF5QixDQUN6QixXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxDQUNsQyxvQkFBQSxDQUFBLFlBQWtDLEFBQ25DLENBQUEsQUFFQSxFQUFBLDRCQUFBLENBQUEsQUFDQyxXQUFBLENBQUEsSUFBaUIsQ0FFakIsT0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFnQixBQUNqQixDQUFBLEFBRUEsRUFBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFnQixDQUNoQixRQUFBLENBQUEsTUFBZ0IsQ0FDaEIsYUFBQSxDQUFBLFFBQXVCLEFBQ3hCLENBQUEsQUFFQSxnQkFBQSxDQUFBLEdBQUEsY0FBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLEtBQVksQ0FDWixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsUUFBQSxDQUFBLE1BQWdCLENBQ2hCLGFBQUEsQ0FBQSxRQUF1QixBQUN4QixDQUFBLEFBRUEsTUFBQSw0QkFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQWdCLEFBQ2pCLENBQUEsQUFFQSxPQUFBLDRCQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBZ0IsQUFDakIsQ0FBQSxBQUVBLEtBQUEsNEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBRUEsT0FBQSw0QkFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLEtBQWlCLEFBQ2xCLENBQUEsQUFFQSxRQUFBLDRCQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBZ0IsQUFDakIsQ0FBQSxBQUVBLEtBQUEsNEJBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLE1BQUEsNEJBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsVUFBQSxDQUFBLElBQWdCLENBQ2hCLFNBQUEsQ0FBQSxnQkFBMkIsQ0FDM0IsU0FBQSxDQUFBLFdBQXNCLEFBQ3ZCLENBQUEsQUFFQSxFQUFBLGVBQUEsNEJBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFVBQUEsQ0FBQSxNQUFrQixBQUNuQixDQUFBLEFBRUEsRUFBQSxlQUFBLDRCQUFBLENBQUEsQUFDQyxhQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBd0MsQUFDekMsQ0FBQSxBQUVBLE9BQUEsNEJBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxJQUFhLENBQ2IsZUFBQSxDQUFBLFFBQXlCLENBQ3pCLFNBQUEsQ0FBQSxJQUFlLEFBQ2hCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUXVlcnlEYXRhVGFibGUuc3ZlbHRlIl19 */");
}
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  child_ctx[15] = i;
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[18] = i;
  return child_ctx;
}
function get_each_context_22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function get_each_context_32(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_each_block_32(ctx) {
  let th;
  let t_value = (
    /*column*/
    ctx[19].id + ""
  );
  let t;
  let th_class_value;
  let th_evidencetype_value;
  let th_evidencetypefidelity_value;
  const block = {
    c: function create() {
      th = element("th");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {
        class: true,
        style: true,
        evidencetype: true,
        evidencetypefidelity: true
      });
      var th_nodes = children(th);
      t = claim_text(th_nodes, t_value);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b;
      attr_dev(th, "class", th_class_value = null_to_empty(
        /*column*/
        ctx[19].type
      ) + " svelte-un48bn");
      set_style(
        th,
        "width",
        /*columnWidths*/
        ctx[6] + "%"
      );
      attr_dev(th, "evidencetype", th_evidencetype_value = /*column*/
      ((_a = ctx[19].evidenceColumnType) == null ? void 0 : _a.evidenceType) || "unavailable");
      attr_dev(th, "evidencetypefidelity", th_evidencetypefidelity_value = /*column*/
      ((_b = ctx[19].evidenceColumnType) == null ? void 0 : _b.typeFidelity) || "unavailable");
      add_location(th, file32, 59, 6, 1543);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, t);
    },
    p: function update(ctx2, dirty) {
      var _a, _b;
      if (dirty & /*columnSummary*/
      8 && t_value !== (t_value = /*column*/
      ctx2[19].id + ""))
        set_data_dev(t, t_value);
      if (dirty & /*columnSummary*/
      8 && th_class_value !== (th_class_value = null_to_empty(
        /*column*/
        ctx2[19].type
      ) + " svelte-un48bn")) {
        attr_dev(th, "class", th_class_value);
      }
      if (dirty & /*columnWidths*/
      64) {
        set_style(
          th,
          "width",
          /*columnWidths*/
          ctx2[6] + "%"
        );
      }
      if (dirty & /*columnSummary*/
      8 && th_evidencetype_value !== (th_evidencetype_value = /*column*/
      ((_a = ctx2[19].evidenceColumnType) == null ? void 0 : _a.evidenceType) || "unavailable")) {
        attr_dev(th, "evidencetype", th_evidencetype_value);
      }
      if (dirty & /*columnSummary*/
      8 && th_evidencetypefidelity_value !== (th_evidencetypefidelity_value = /*column*/
      ((_b = ctx2[19].evidenceColumnType) == null ? void 0 : _b.typeFidelity) || "unavailable")) {
        attr_dev(th, "evidencetypefidelity", th_evidencetypefidelity_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_32.name,
    type: "each",
    source: "(59:5) {#each columnSummary as column}",
    ctx
  });
  return block;
}
function create_each_block_22(ctx) {
  let th;
  let t_value = (
    /*column*/
    ctx[19].type + ""
  );
  let t;
  let th_class_value;
  let th_evidencetype_value;
  let th_evidencetypefidelity_value;
  const block = {
    c: function create() {
      th = element("th");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {
        class: true,
        style: true,
        evidencetype: true,
        evidencetypefidelity: true
      });
      var th_nodes = children(th);
      t = claim_text(th_nodes, t_value);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b;
      attr_dev(th, "class", th_class_value = /*column*/
      ctx[19].type + " type-indicator svelte-un48bn");
      set_style(
        th,
        "width",
        /*columnWidths*/
        ctx[6] + "%"
      );
      attr_dev(th, "evidencetype", th_evidencetype_value = /*column*/
      ((_a = ctx[19].evidenceColumnType) == null ? void 0 : _a.evidenceType) || "unavailable");
      attr_dev(th, "evidencetypefidelity", th_evidencetypefidelity_value = /*column*/
      ((_b = ctx[19].evidenceColumnType) == null ? void 0 : _b.typeFidelity) || "unavailable");
      add_location(th, file32, 72, 6, 1979);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, t);
    },
    p: function update(ctx2, dirty) {
      var _a, _b;
      if (dirty & /*columnSummary*/
      8 && t_value !== (t_value = /*column*/
      ctx2[19].type + ""))
        set_data_dev(t, t_value);
      if (dirty & /*columnSummary*/
      8 && th_class_value !== (th_class_value = /*column*/
      ctx2[19].type + " type-indicator svelte-un48bn")) {
        attr_dev(th, "class", th_class_value);
      }
      if (dirty & /*columnWidths*/
      64) {
        set_style(
          th,
          "width",
          /*columnWidths*/
          ctx2[6] + "%"
        );
      }
      if (dirty & /*columnSummary*/
      8 && th_evidencetype_value !== (th_evidencetype_value = /*column*/
      ((_a = ctx2[19].evidenceColumnType) == null ? void 0 : _a.evidenceType) || "unavailable")) {
        attr_dev(th, "evidencetype", th_evidencetype_value);
      }
      if (dirty & /*columnSummary*/
      8 && th_evidencetypefidelity_value !== (th_evidencetypefidelity_value = /*column*/
      ((_b = ctx2[19].evidenceColumnType) == null ? void 0 : _b.typeFidelity) || "unavailable")) {
        attr_dev(th, "evidencetypefidelity", th_evidencetypefidelity_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_22.name,
    type: "each",
    source: "(72:5) {#each columnSummary as column}",
    ctx
  });
  return block;
}
function create_else_block_14(ctx) {
  let t_value = (
    /*index*/
    (ctx[2] + /*i*/
    ctx[15] + 1).toLocaleString() + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*index*/
      4 && t_value !== (t_value = /*index*/
      (ctx2[2] + /*i*/
      ctx2[15] + 1).toLocaleString() + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_14.name,
    type: "else",
    source: "(91:7) {:else}",
    ctx
  });
  return block;
}
function create_if_block_62(ctx) {
  let t_value = (
    /*index*/
    (ctx[2] + /*i*/
    ctx[15] + 1).toLocaleString() + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*index*/
      4 && t_value !== (t_value = /*index*/
      (ctx2[2] + /*i*/
      ctx2[15] + 1).toLocaleString() + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_62.name,
    type: "if",
    source: "(88:7) {#if i === 0}",
    ctx
  });
  return block;
}
function create_else_block7(ctx) {
  let td;
  let t_value = (
    /*cell*/
    (ctx[16] || "") + ""
  );
  let t;
  const block = {
    c: function create() {
      td = element("td");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true, style: true });
      var td_nodes = children(td);
      t = claim_text(td_nodes, t_value);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", "other svelte-un48bn");
      set_style(
        td,
        "width",
        /*columnWidths*/
        ctx[6] + "%"
      );
      add_location(td, file32, 130, 8, 3920);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*dataPage*/
      32 && t_value !== (t_value = /*cell*/
      (ctx2[16] || "") + ""))
        set_data_dev(t, t_value);
      if (dirty & /*columnWidths*/
      64) {
        set_style(
          td,
          "width",
          /*columnWidths*/
          ctx2[6] + "%"
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(130:7) {:else}",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let td;
  let div;
  let t_value = (
    /*cell*/
    (ctx[16] ?? "") + ""
  );
  let t;
  let td_title_value;
  const block = {
    c: function create() {
      td = element("td");
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true, style: true, title: true });
      var td_nodes = children(td);
      div = claim_element(td_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-un48bn");
      add_location(div, file32, 125, 9, 3837);
      attr_dev(td, "class", "boolean svelte-un48bn");
      set_style(
        td,
        "width",
        /*columnWidths*/
        ctx[6] + "%"
      );
      attr_dev(td, "title", td_title_value = /*cell*/
      ctx[16]);
      add_location(td, file32, 124, 8, 3764);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, div);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*dataPage*/
      32 && t_value !== (t_value = /*cell*/
      (ctx2[16] ?? "") + ""))
        set_data_dev(t, t_value);
      if (dirty & /*columnWidths*/
      64) {
        set_style(
          td,
          "width",
          /*columnWidths*/
          ctx2[6] + "%"
        );
      }
      if (dirty & /*dataPage*/
      32 && td_title_value !== (td_title_value = /*cell*/
      ctx2[16])) {
        attr_dev(td, "title", td_title_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(124:53) ",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let td;
  let div;
  let t_value = (
    /*cell*/
    (ctx[16] || "") + ""
  );
  let t;
  let td_title_value;
  const block = {
    c: function create() {
      td = element("td");
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true, style: true, title: true });
      var td_nodes = children(td);
      div = claim_element(td_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-un48bn");
      add_location(div, file32, 119, 9, 3642);
      attr_dev(td, "class", "string svelte-un48bn");
      set_style(
        td,
        "width",
        /*columnWidths*/
        ctx[6] + "%"
      );
      attr_dev(td, "title", td_title_value = /*cell*/
      ctx[16]);
      add_location(td, file32, 118, 8, 3570);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, div);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*dataPage*/
      32 && t_value !== (t_value = /*cell*/
      (ctx2[16] || "") + ""))
        set_data_dev(t, t_value);
      if (dirty & /*columnWidths*/
      64) {
        set_style(
          td,
          "width",
          /*columnWidths*/
          ctx2[6] + "%"
        );
      }
      if (dirty & /*dataPage*/
      32 && td_title_value !== (td_title_value = /*cell*/
      ctx2[16])) {
        attr_dev(td, "title", td_title_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(118:52) ",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let td;
  let div;
  let t_value = formatValue(
    /*cell*/
    ctx[16],
    /*columnSummary*/
    ctx[3][
      /*j*/
      ctx[18]
    ].format,
    /*columnSummary*/
    ctx[3][
      /*j*/
      ctx[18]
    ].columnUnitSummary
  ) + "";
  let t;
  let td_title_value;
  const block = {
    c: function create() {
      td = element("td");
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true, style: true, title: true });
      var td_nodes = children(td);
      div = claim_element(td_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-un48bn");
      add_location(div, file32, 113, 9, 3382);
      attr_dev(td, "class", "string svelte-un48bn");
      set_style(
        td,
        "width",
        /*columnWidths*/
        ctx[6] + "%"
      );
      attr_dev(td, "title", td_title_value = formatValue(
        /*cell*/
        ctx[16],
        /*columnSummary*/
        ctx[3][
          /*j*/
          ctx[18]
        ].format,
        /*columnSummary*/
        ctx[3][
          /*j*/
          ctx[18]
        ].columnUnitSummary
      ));
      add_location(td, file32, 104, 8, 3159);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, div);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*dataPage, columnSummary*/
      40 && t_value !== (t_value = formatValue(
        /*cell*/
        ctx2[16],
        /*columnSummary*/
        ctx2[3][
          /*j*/
          ctx2[18]
        ].format,
        /*columnSummary*/
        ctx2[3][
          /*j*/
          ctx2[18]
        ].columnUnitSummary
      ) + ""))
        set_data_dev(t, t_value);
      if (dirty & /*columnWidths*/
      64) {
        set_style(
          td,
          "width",
          /*columnWidths*/
          ctx2[6] + "%"
        );
      }
      if (dirty & /*dataPage, columnSummary*/
      40 && td_title_value !== (td_title_value = formatValue(
        /*cell*/
        ctx2[16],
        /*columnSummary*/
        ctx2[3][
          /*j*/
          ctx2[18]
        ].format,
        /*columnSummary*/
        ctx2[3][
          /*j*/
          ctx2[18]
        ].columnUnitSummary
      ))) {
        attr_dev(td, "title", td_title_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(104:50) ",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let td;
  let t_value = formatValue(
    /*cell*/
    ctx[16],
    /*columnSummary*/
    ctx[3][
      /*j*/
      ctx[18]
    ].format,
    /*columnSummary*/
    ctx[3][
      /*j*/
      ctx[18]
    ].columnUnitSummary
  ) + "";
  let t;
  const block = {
    c: function create() {
      td = element("td");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true, style: true });
      var td_nodes = children(td);
      t = claim_text(td_nodes, t_value);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", "number svelte-un48bn");
      set_style(
        td,
        "width",
        /*columnWidths*/
        ctx[6] + "%"
      );
      add_location(td, file32, 100, 8, 2945);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*dataPage, columnSummary*/
      40 && t_value !== (t_value = formatValue(
        /*cell*/
        ctx2[16],
        /*columnSummary*/
        ctx2[3][
          /*j*/
          ctx2[18]
        ].format,
        /*columnSummary*/
        ctx2[3][
          /*j*/
          ctx2[18]
        ].columnUnitSummary
      ) + ""))
        set_data_dev(t, t_value);
      if (dirty & /*columnWidths*/
      64) {
        set_style(
          td,
          "width",
          /*columnWidths*/
          ctx2[6] + "%"
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(100:52) ",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let td;
  let t_value = "";
  let t;
  let td_class_value;
  const block = {
    c: function create() {
      td = element("td");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true, style: true });
      var td_nodes = children(td);
      t = claim_text(td_nodes, t_value);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", td_class_value = "null " + /*columnSummary*/
      ctx[3][
        /*j*/
        ctx[18]
      ].type + " svelte-un48bn");
      set_style(
        td,
        "width",
        /*columnWidths*/
        ctx[6] + "%"
      );
      add_location(td, file32, 96, 8, 2783);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*columnSummary*/
      8 && td_class_value !== (td_class_value = "null " + /*columnSummary*/
      ctx2[3][
        /*j*/
        ctx2[18]
      ].type + " svelte-un48bn")) {
        attr_dev(td, "class", td_class_value);
      }
      if (dirty & /*columnWidths*/
      64) {
        set_style(
          td,
          "width",
          /*columnWidths*/
          ctx2[6] + "%"
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(96:7) {#if cell == null}",
    ctx
  });
  return block;
}
function create_each_block_13(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*cell*/
      ctx2[16] == null
    )
      return create_if_block_18;
    if (
      /*columnSummary*/
      ctx2[3][
        /*j*/
        ctx2[18]
      ].type === "number"
    )
      return create_if_block_27;
    if (
      /*columnSummary*/
      ctx2[3][
        /*j*/
        ctx2[18]
      ].type === "date"
    )
      return create_if_block_32;
    if (
      /*columnSummary*/
      ctx2[3][
        /*j*/
        ctx2[18]
      ].type === "string"
    )
      return create_if_block_42;
    if (
      /*columnSummary*/
      ctx2[3][
        /*j*/
        ctx2[18]
      ].type === "boolean"
    )
      return create_if_block_52;
    return create_else_block7;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_13.name,
    type: "each",
    source: "(95:6) {#each Object.values(row) as cell, j}",
    ctx
  });
  return block;
}
function create_each_block9(ctx) {
  let tr;
  let td;
  let t0;
  let t1;
  function select_block_type(ctx2, dirty) {
    if (
      /*i*/
      ctx2[15] === 0
    )
      return create_if_block_62;
    return create_else_block_14;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  let each_value_1 = Object.values(
    /*row*/
    ctx[13]
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      tr = element("tr");
      td = element("td");
      if_block.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      td = claim_element(tr_nodes, "TD", { class: true, style: true });
      var td_nodes = children(td);
      if_block.l(td_nodes);
      td_nodes.forEach(detach_dev);
      t0 = claim_space(tr_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t1 = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", "index svelte-un48bn");
      set_style(td, "width", "10%");
      add_location(td, file32, 86, 6, 2393);
      add_location(tr, file32, 85, 5, 2382);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      append_hydration_dev(tr, td);
      if_block.m(td, null);
      append_hydration_dev(tr, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tr, null);
      }
      append_hydration_dev(tr, t1);
    },
    p: function update(ctx2, dirty) {
      if_block.p(ctx2, dirty);
      if (dirty & /*columnSummary, columnWidths, Object, dataPage, formatValue*/
      104) {
        each_value_1 = Object.values(
          /*row*/
          ctx2[13]
        );
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_13(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, t1);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block9.name,
    type: "each",
    source: "(85:4) {#each dataPage as row, i}",
    ctx
  });
  return block;
}
function create_if_block20(ctx) {
  let div;
  let input;
  let t0;
  let span;
  let t1_value = (
    /*index*/
    (ctx[2] + /*size*/
    ctx[7]).toLocaleString() + ""
  );
  let t1;
  let t2;
  let t3_value = (
    /*max*/
    (ctx[4] + /*size*/
    ctx[7]).toLocaleString() + ""
  );
  let t3;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = text(" of ");
      t3 = text(t3_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", {
        type: true,
        max: true,
        step: true,
        class: true
      });
      t0 = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, t1_value);
      t2 = claim_text(span_nodes, " of ");
      t3 = claim_text(span_nodes, t3_value);
      span_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "range");
      attr_dev(
        input,
        "max",
        /*max*/
        ctx[4]
      );
      attr_dev(input, "step", "1");
      attr_dev(input, "class", "slider svelte-un48bn");
      add_location(input, file32, 143, 3, 4133);
      attr_dev(span, "class", "svelte-un48bn");
      add_location(span, file32, 144, 3, 4225);
      attr_dev(div, "class", "pagination svelte-un48bn");
      add_location(div, file32, 142, 2, 4105);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      set_input_value(
        input,
        /*index*/
        ctx[2]
      );
      append_hydration_dev(div, t0);
      append_hydration_dev(div, span);
      append_hydration_dev(span, t1);
      append_hydration_dev(span, t2);
      append_hydration_dev(span, t3);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[10]
          ),
          listen_dev(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[10]
          ),
          listen_dev(
            input,
            "input",
            /*slice*/
            ctx[8],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*max*/
      16) {
        attr_dev(
          input,
          "max",
          /*max*/
          ctx2[4]
        );
      }
      if (dirty & /*index*/
      4) {
        set_input_value(
          input,
          /*index*/
          ctx2[2]
        );
      }
      if (dirty & /*index*/
      4 && t1_value !== (t1_value = /*index*/
      (ctx2[2] + /*size*/
      ctx2[7]).toLocaleString() + ""))
        set_data_dev(t1, t1_value);
      if (dirty & /*max*/
      16 && t3_value !== (t3_value = /*max*/
      (ctx2[4] + /*size*/
      ctx2[7]).toLocaleString() + ""))
        set_data_dev(t3, t3_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(142:1) {#if max > 0}",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let div2;
  let div0;
  let table;
  let thead;
  let tr0;
  let th0;
  let t0;
  let t1;
  let tr1;
  let t2;
  let tr2;
  let th1;
  let t3;
  let t4;
  let tr3;
  let t5;
  let tbody;
  let table_intro;
  let t6;
  let t7;
  let div1;
  let downloaddata;
  let div2_transition;
  let current;
  let mounted;
  let dispose;
  let each_value_3 = (
    /*columnSummary*/
    ctx[3]
  );
  validate_each_argument(each_value_3);
  let each_blocks_2 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_2[i] = create_each_block_32(get_each_context_32(ctx, each_value_3, i));
  }
  let each_value_2 = (
    /*columnSummary*/
    ctx[3]
  );
  validate_each_argument(each_value_2);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_22(get_each_context_22(ctx, each_value_2, i));
  }
  let each_value = (
    /*dataPage*/
    ctx[5]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block9(get_each_context9(ctx, each_value, i));
  }
  let if_block = (
    /*max*/
    ctx[4] > 0 && create_if_block20(ctx)
  );
  downloaddata = new DownloadData_default({
    props: {
      class: "download-button",
      data: (
        /*data*/
        ctx[1]
      ),
      queryID: (
        /*queryID*/
        ctx[0]
      ),
      display: true
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      table = element("table");
      thead = element("thead");
      tr0 = element("tr");
      th0 = element("th");
      t0 = space();
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].c();
      }
      t1 = space();
      tr1 = element("tr");
      t2 = space();
      tr2 = element("tr");
      th1 = element("th");
      t3 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t4 = space();
      tr3 = element("tr");
      t5 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t6 = space();
      if (if_block)
        if_block.c();
      t7 = space();
      div1 = element("div");
      create_component(downloaddata.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      table = claim_element(div0_nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", {});
      var thead_nodes = children(thead);
      tr0 = claim_element(thead_nodes, "TR", {});
      var tr0_nodes = children(tr0);
      th0 = claim_element(tr0_nodes, "TH", { class: true, style: true });
      children(th0).forEach(detach_dev);
      t0 = claim_space(tr0_nodes);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].l(tr0_nodes);
      }
      t1 = claim_space(tr0_nodes);
      tr0_nodes.forEach(detach_dev);
      tr1 = claim_element(thead_nodes, "TR", {});
      children(tr1).forEach(detach_dev);
      t2 = claim_space(thead_nodes);
      tr2 = claim_element(thead_nodes, "TR", { class: true });
      var tr2_nodes = children(tr2);
      th1 = claim_element(tr2_nodes, "TH", { class: true, style: true });
      children(th1).forEach(detach_dev);
      t3 = claim_space(tr2_nodes);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(tr2_nodes);
      }
      t4 = claim_space(tr2_nodes);
      tr2_nodes.forEach(detach_dev);
      tr3 = claim_element(thead_nodes, "TR", {});
      children(tr3).forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t5 = claim_space(table_nodes);
      tbody = claim_element(table_nodes, "TBODY", {});
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t6 = claim_space(div2_nodes);
      if (if_block)
        if_block.l(div2_nodes);
      t7 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(downloaddata.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th0, "class", "index svelte-un48bn");
      set_style(th0, "width", "10%");
      add_location(th0, file32, 57, 5, 1461);
      add_location(tr0, file32, 56, 4, 1451);
      add_location(tr1, file32, 68, 9, 1838);
      attr_dev(th1, "class", "index type-indicator svelte-un48bn");
      set_style(th1, "width", "10%");
      add_location(th1, file32, 70, 5, 1882);
      attr_dev(tr2, "class", "type-indicator svelte-un48bn");
      add_location(tr2, file32, 69, 4, 1849);
      add_location(tr3, file32, 81, 9, 2293);
      add_location(thead, file32, 55, 3, 1439);
      add_location(tbody, file32, 83, 3, 2315);
      attr_dev(table, "class", "svelte-un48bn");
      add_location(table, file32, 54, 2, 1420);
      attr_dev(div0, "class", "container svelte-un48bn");
      add_location(div0, file32, 53, 1, 1394);
      attr_dev(div1, "class", "footer svelte-un48bn");
      add_location(div1, file32, 150, 1, 4334);
      attr_dev(div2, "class", "results-pane svelte-un48bn");
      add_location(div2, file32, 52, 0, 1343);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, table);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, tr0);
      append_hydration_dev(tr0, th0);
      append_hydration_dev(tr0, t0);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].m(tr0, null);
      }
      append_hydration_dev(tr0, t1);
      append_hydration_dev(thead, tr1);
      append_hydration_dev(thead, t2);
      append_hydration_dev(thead, tr2);
      append_hydration_dev(tr2, th1);
      append_hydration_dev(tr2, t3);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(tr2, null);
      }
      append_hydration_dev(tr2, t4);
      append_hydration_dev(thead, tr3);
      append_hydration_dev(table, t5);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tbody, null);
      }
      append_hydration_dev(div2, t6);
      if (if_block)
        if_block.m(div2, null);
      append_hydration_dev(div2, t7);
      append_hydration_dev(div2, div1);
      mount_component(downloaddata, div1, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          tbody,
          "wheel",
          /*handleWheel*/
          ctx[9],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*columnSummary, columnWidths*/
      72) {
        each_value_3 = /*columnSummary*/
        ctx2[3];
        validate_each_argument(each_value_3);
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_32(ctx2, each_value_3, i);
          if (each_blocks_2[i]) {
            each_blocks_2[i].p(child_ctx, dirty);
          } else {
            each_blocks_2[i] = create_each_block_32(child_ctx);
            each_blocks_2[i].c();
            each_blocks_2[i].m(tr0, t1);
          }
        }
        for (; i < each_blocks_2.length; i += 1) {
          each_blocks_2[i].d(1);
        }
        each_blocks_2.length = each_value_3.length;
      }
      if (dirty & /*columnSummary, columnWidths*/
      72) {
        each_value_2 = /*columnSummary*/
        ctx2[3];
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_22(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_22(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(tr2, t4);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty & /*Object, dataPage, columnSummary, columnWidths, formatValue, index*/
      108) {
        each_value = /*dataPage*/
        ctx2[5];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block9(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (
        /*max*/
        ctx2[4] > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          if_block.m(div2, t7);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const downloaddata_changes = {};
      if (dirty & /*data*/
      2)
        downloaddata_changes.data = /*data*/
        ctx2[1];
      if (dirty & /*queryID*/
      1)
        downloaddata_changes.queryID = /*queryID*/
        ctx2[0];
      downloaddata.$set(downloaddata_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      if (!table_intro) {
        add_render_callback(() => {
          table_intro = create_in_transition(table, blur, {});
          table_intro.start();
        });
      }
      transition_in(downloaddata.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!div2_transition)
            div2_transition = create_bidirectional_transition(div2, slide, {}, true);
          div2_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(downloaddata.$$.fragment, local);
      if (local) {
        if (!div2_transition)
          div2_transition = create_bidirectional_transition(div2, slide, {}, false);
        div2_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      destroy_each(each_blocks_2, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      destroy_component(downloaddata);
      if (detaching && div2_transition)
        div2_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude31 = true;
function instance33($$self, $$props, $$invalidate) {
  let columnSummary;
  let columnWidths;
  let max2;
  let dataPage;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("QueryDataTable", slots, []);
  let { queryID } = $$props;
  let { data } = $$props;
  let index = 0;
  let size = 5;
  let updatedSlice;
  function slice() {
    updatedSlice = data.slice(index, index + size);
    $$invalidate(5, dataPage = updatedSlice);
  }
  const updateIndex = throttle(
    (event) => {
      $$invalidate(2, index = Math.min(Math.max(0, index + Math.floor(event.deltaY / Math.abs(event.deltaY))), max2));
      slice();
    },
    60
  );
  function handleWheel(event) {
    if (Math.abs(event.deltaX) >= Math.abs(event.deltaY)) {
      return;
    }
    const hasScrolledToTop = event.deltaY < 0 && index === 0;
    const hasScrolledToBottom = event.deltaY > 0 && index === max2;
    if (hasScrolledToTop || hasScrolledToBottom) {
      return;
    }
    event.preventDefault();
    updateIndex(event);
  }
  $$self.$$.on_mount.push(function() {
    if (queryID === void 0 && !("queryID" in $$props || $$self.$$.bound[$$self.$$.props["queryID"]])) {
      console.warn("<QueryDataTable> was created without expected prop 'queryID'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<QueryDataTable> was created without expected prop 'data'");
    }
  });
  const writable_props = ["queryID", "data"];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<QueryDataTable> was created with unknown prop '${key}'`);
  });
  function input_change_input_handler() {
    index = to_number(this.value);
    $$invalidate(2, index);
  }
  $$self.$$set = ($$props2) => {
    if ("queryID" in $$props2)
      $$invalidate(0, queryID = $$props2.queryID);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude31,
    blur,
    slide,
    DownloadData: DownloadData_default,
    getColumnSummary,
    formatValue,
    throttle,
    queryID,
    data,
    index,
    size,
    updatedSlice,
    slice,
    updateIndex,
    handleWheel,
    max: max2,
    dataPage,
    columnSummary,
    columnWidths
  });
  $$self.$inject_state = ($$props2) => {
    if ("queryID" in $$props2)
      $$invalidate(0, queryID = $$props2.queryID);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
    if ("index" in $$props2)
      $$invalidate(2, index = $$props2.index);
    if ("size" in $$props2)
      $$invalidate(7, size = $$props2.size);
    if ("updatedSlice" in $$props2)
      updatedSlice = $$props2.updatedSlice;
    if ("max" in $$props2)
      $$invalidate(4, max2 = $$props2.max);
    if ("dataPage" in $$props2)
      $$invalidate(5, dataPage = $$props2.dataPage);
    if ("columnSummary" in $$props2)
      $$invalidate(3, columnSummary = $$props2.columnSummary);
    if ("columnWidths" in $$props2)
      $$invalidate(6, columnWidths = $$props2.columnWidths);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    2) {
      $:
        $$invalidate(3, columnSummary = getColumnSummary(data, "array"));
    }
    if ($$self.$$.dirty & /*columnSummary*/
    8) {
      $:
        $$invalidate(6, columnWidths = 90 / (columnSummary.length + 1));
    }
    if ($$self.$$.dirty & /*data*/
    2) {
      $:
        $$invalidate(4, max2 = Math.max(data.length - size, 0));
    }
    if ($$self.$$.dirty & /*data, index*/
    6) {
      $:
        $$invalidate(5, dataPage = data.slice(index, index + size));
    }
  };
  return [
    queryID,
    data,
    index,
    columnSummary,
    max2,
    dataPage,
    columnWidths,
    size,
    slice,
    handleWheel,
    input_change_input_handler
  ];
}
var QueryDataTable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { queryID: 0, data: 1 }, add_css22);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "QueryDataTable",
      options,
      id: create_fragment33.name
    });
  }
  get queryID() {
    throw new Error("<QueryDataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryID(value) {
    throw new Error("<QueryDataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<QueryDataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<QueryDataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var QueryDataTable_default = QueryDataTable;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewerSupport/Prismjs.svelte
import "/Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewerSupport/prismtheme.css";
var import_prismjs = __toESM(require_prism());

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewerSupport/prism-sql.js
var prism_sql = {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  variable: [
    {
      pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
      greedy: true
    },
    /@[\w.$]+/
  ],
  string: {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  identifier: {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      punctuation: /^`|`$/
    }
  },
  function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
  number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  operator: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  punctuation: /[;[\]()`,.]/
};

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewerSupport/Prismjs.svelte
var file33 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewerSupport/Prismjs.svelte";
function add_css23(target) {
  append_styles(target, "svelte-11sqcxn", ":root{--scrollbar-track-color:transparent;--scrollbar-color:rgba(0, 0, 0, 0.2);--scrollbar-active-color:rgba(0, 0, 0, 0.4);--scrollbar-size:0.75rem;--scrollbar-minlength:1.5rem}pre.svelte-11sqcxn{white-space:normal;margin:0 0 0 0;display:block;scrollbar-width:thin;scrollbar-color:var(--scrollbar-color) var(--scrollbar-track-color)}pre.svelte-11sqcxn::-webkit-scrollbar{height:var(--scrollbar-size);width:var(--scrollbar-size)}pre.svelte-11sqcxn::-webkit-scrollbar-track{background-color:var(--scrollbar-track-color)}pre.svelte-11sqcxn::-webkit-scrollbar-thumb{background-color:var(--scrollbar-color);border-radius:7px;background-clip:padding-box}pre.svelte-11sqcxn::-webkit-scrollbar-thumb:hover{background-color:var(--scrollbar-active-color)}pre.svelte-11sqcxn::-webkit-scrollbar-thumb:vertical{min-height:var(--scrollbar-minlength);border:3px solid transparent}pre.svelte-11sqcxn::-webkit-scrollbar-thumb:horizontal{min-width:var(--scrollbar-minlength);border:3px solid transparent}code.svelte-11sqcxn{display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJpc21qcy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBa0JDLEtBQUEsQUFBQSxDQUFBLEFBQ0MsdUJBQUEsQ0FBQSxXQUFvQyxDQUNwQyxpQkFBQSxDQUFBLGtCQUFxQyxDQUNyQyx3QkFBQSxDQUFBLGtCQUE0QyxDQUM1QyxnQkFBQSxDQUFBLE9BQXlCLENBQ3pCLHFCQUFBLENBQUEsTUFBNkIsQUFDOUIsQ0FBQSxBQUVBLEdBQUEsZUFBQSxDQUFBLEFBQ0MsV0FBQSxDQUFBLE1BQW1CLENBQ25CLE1BQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFlLENBQ2YsT0FBQSxDQUFBLEtBQWMsQ0FDZCxlQUFBLENBQUEsSUFBcUIsQ0FDckIsZUFBQSxDQUFBLElBQUEsaUJBQUEsQ0FBQSxDQUFBLElBQUEsdUJBQUEsQ0FBb0UsQUFDckUsQ0FBQSxBQUVBLGtCQUFBLG1CQUFBLEFBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxJQUFBLGdCQUFBLENBQTZCLENBQzdCLEtBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQTRCLEFBQzdCLENBQUEsQUFDQSxrQkFBQSx5QkFBQSxBQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsdUJBQUEsQ0FBOEMsQUFDL0MsQ0FBQSxBQUNBLGtCQUFBLHlCQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxpQkFBQSxDQUF3QyxDQUN4QyxhQUFBLENBQUEsR0FBa0IsQ0FDbEIsZUFBQSxDQUFBLFdBQTRCLEFBQzdCLENBQUEsQUFDQSxrQkFBQSx5QkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSx3QkFBQSxDQUErQyxBQUNoRCxDQUFBLEFBQ0Esa0JBQUEseUJBQUEsU0FBQSxBQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBQSxxQkFBQSxDQUFzQyxDQUN0QyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUE2QixBQUM5QixDQUFBLEFBQ0Esa0JBQUEseUJBQUEsV0FBQSxBQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsSUFBQSxxQkFBQSxDQUFxQyxDQUNyQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUE2QixBQUM5QixDQUFBLEFBQ0EsSUFBQSxlQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsS0FBYyxBQUNmLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUHJpc21qcy5zdmVsdGUiXX0= */");
}
function create_fragment34(ctx) {
  let pre;
  let t0;
  let code_1;
  let raw_value = import_prismjs.default.highlight(
    /*code*/
    ctx[0],
    prism_sql
  ) + "";
  let t1;
  let pre_intro;
  const block = {
    c: function create() {
      pre = element("pre");
      t0 = text("  ");
      code_1 = element("code");
      t1 = text("\n");
      this.h();
    },
    l: function claim(nodes) {
      pre = claim_element(nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      t0 = claim_text(pre_nodes, "  ");
      code_1 = claim_element(pre_nodes, "CODE", { class: true });
      var code_1_nodes = children(code_1);
      code_1_nodes.forEach(detach_dev);
      t1 = claim_text(pre_nodes, "\n");
      pre_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(code_1, "class", "language-sql svelte-11sqcxn");
      add_location(code_1, file33, 14, 2, 278);
      attr_dev(pre, "class", "svelte-11sqcxn");
      add_location(pre, file33, 13, 0, 262);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, pre, anchor);
      append_hydration_dev(pre, t0);
      append_hydration_dev(pre, code_1);
      code_1.innerHTML = raw_value;
      append_hydration_dev(pre, t1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*code*/
      1 && raw_value !== (raw_value = import_prismjs.default.highlight(
        /*code*/
        ctx2[0],
        prism_sql
      ) + ""))
        code_1.innerHTML = raw_value;
      ;
    },
    i: function intro(local) {
      if (!pre_intro) {
        add_render_callback(() => {
          pre_intro = create_in_transition(pre, blur, {});
          pre_intro.start();
        });
      }
    },
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(pre);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude32 = true;
function instance34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Prismjs", slots, []);
  let { code = "" } = $$props;
  const writable_props = ["code"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Prismjs> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("code" in $$props2)
      $$invalidate(0, code = $$props2.code);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude32,
    blur,
    Prism: import_prismjs.default,
    prism_sql,
    code
  });
  $$self.$inject_state = ($$props2) => {
    if ("code" in $$props2)
      $$invalidate(0, code = $$props2.code);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [code];
}
var Prismjs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, { code: 0 }, add_css23);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Prismjs",
      options,
      id: create_fragment34.name
    });
  }
  get code() {
    throw new Error("<Prismjs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<Prismjs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Prismjs_default = Prismjs;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewerSupport/CompilerToggle.svelte
var file34 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewerSupport/CompilerToggle.svelte";
function add_css24(target) {
  append_styles(target, "svelte-1gqanjc", "div.toggle.svelte-1gqanjc{background-color:var(--grey-100);border-left:1px solid var(--grey-200);border-right:1px solid var(--grey-200);padding:10px 0 6px 12px;font-family:var(--ui-font-family);font-size:10px;font-weight:bold;user-select:none;-webkit-user-select:none;-moz-user-select:none}button.svelte-1gqanjc{padding:2px 4px 2px 4px;border-radius:3px;cursor:pointer;background-color:transparent;font-size:1em;font-weight:bold}button.off.svelte-1gqanjc{color:var(--grey-600);border:1px solid var(--grey-100);transition:all 400ms}button.off.svelte-1gqanjc:hover{color:var(--grey-700);border:1px solid var(--grey-300);transition:all 400ms;background-color:none}button.on.svelte-1gqanjc{color:var(--blue-700);background-color:var(--blue-100);border:1px solid var(--blue-200)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29tcGlsZXJUb2dnbGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXlCQyxHQUFBLE9BQUEsZUFBQSxDQUFBLEFBQ0MsZ0JBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsV0FBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNDLENBQ3RDLFlBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUF1QyxDQUN2QyxPQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsSUFBd0IsQ0FDeEIsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsU0FBQSxDQUFBLElBQWUsQ0FDZixXQUFBLENBQUEsSUFBaUIsQ0FDakIsV0FBQSxDQUFBLElBQWlCLENBQ2pCLG1CQUFBLENBQUEsSUFBeUIsQ0FDekIsZ0JBQUEsQ0FBQSxJQUFzQixBQUN2QixDQUFBLEFBRUEsTUFBQSxlQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBd0IsQ0FDeEIsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLE1BQUEsQ0FBQSxPQUFlLENBQ2YsZ0JBQUEsQ0FBQSxXQUE2QixDQUM3QixTQUFBLENBQUEsR0FBYyxDQUNkLFdBQUEsQ0FBQSxJQUFpQixBQUNsQixDQUFBLEFBRUEsTUFBQSxJQUFBLGVBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBcUIsQUFDdEIsQ0FBQSxBQUVBLE1BQUEsbUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxVQUFBLENBQUEsR0FBQSxDQUFBLEtBQXFCLENBQ3JCLGdCQUFBLENBQUEsSUFBc0IsQUFDdkIsQ0FBQSxBQUVBLE1BQUEsR0FBQSxlQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxBQUNsQyxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNvbXBpbGVyVG9nZ2xlLnN2ZWx0ZSJdfQ== */");
}
function create_else_block8(ctx) {
  let button0;
  let t0;
  let t1;
  let button1;
  let t2;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button0 = element("button");
      t0 = text("Compiled");
      t1 = space();
      button1 = element("button");
      t2 = text("Written");
      this.h();
    },
    l: function claim(nodes) {
      button0 = claim_element(nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t0 = claim_text(button0_nodes, "Compiled");
      button0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      t2 = claim_text(button1_nodes, "Written");
      button1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "class", "off svelte-1gqanjc");
      add_location(button0, file34, 19, 2, 420);
      attr_dev(button1, "class", "on svelte-1gqanjc");
      add_location(button1, file34, 20, 2, 486);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button0, anchor);
      append_hydration_dev(button0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, button1, anchor);
      append_hydration_dev(button1, t2);
      if (!mounted) {
        dispose = listen_dev(
          button0,
          "click",
          /*toggleCompiled*/
          ctx[1],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(button1);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(19:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let button0;
  let t0;
  let t1;
  let button1;
  let t2;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button0 = element("button");
      t0 = text("Compiled");
      t1 = space();
      button1 = element("button");
      t2 = text("Written");
      this.h();
    },
    l: function claim(nodes) {
      button0 = claim_element(nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t0 = claim_text(button0_nodes, "Compiled");
      button0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      t2 = claim_text(button1_nodes, "Written");
      button1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "class", "on svelte-1gqanjc");
      add_location(button0, file34, 16, 2, 307);
      attr_dev(button1, "class", "off svelte-1gqanjc");
      add_location(button1, file34, 17, 2, 346);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button0, anchor);
      append_hydration_dev(button0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, button1, anchor);
      append_hydration_dev(button1, t2);
      if (!mounted) {
        dispose = listen_dev(
          button1,
          "click",
          /*toggleCompiled*/
          ctx[1],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(button1);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(16:1) {#if showCompiled}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let div;
  let div_transition;
  let current;
  function select_block_type(ctx2, dirty) {
    if (
      /*showCompiled*/
      ctx2[0]
    )
      return create_if_block21;
    return create_else_block8;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "toggle svelte-1gqanjc");
      add_location(div, file34, 14, 0, 241);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_block.d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude33 = true;
function instance35($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CompilerToggle", slots, []);
  let { showCompiled } = $$props;
  const toggleCompiled = function() {
    $$invalidate(0, showCompiled = !showCompiled);
  };
  $$self.$$.on_mount.push(function() {
    if (showCompiled === void 0 && !("showCompiled" in $$props || $$self.$$.bound[$$self.$$.props["showCompiled"]])) {
      console.warn("<CompilerToggle> was created without expected prop 'showCompiled'");
    }
  });
  const writable_props = ["showCompiled"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CompilerToggle> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("showCompiled" in $$props2)
      $$invalidate(0, showCompiled = $$props2.showCompiled);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude33,
    slide,
    showCompiled,
    toggleCompiled
  });
  $$self.$inject_state = ($$props2) => {
    if ("showCompiled" in $$props2)
      $$invalidate(0, showCompiled = $$props2.showCompiled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [showCompiled, toggleCompiled];
}
var CompilerToggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, { showCompiled: 0 }, add_css24);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CompilerToggle",
      options,
      id: create_fragment35.name
    });
  }
  get showCompiled() {
    throw new Error("<CompilerToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showCompiled(value) {
    throw new Error("<CompilerToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CompilerToggle_default = CompilerToggle;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewer.svelte
import { browser } from "$app/environment";
var { Object: Object_13 } = globals;
var file35 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/QueryViewer.svelte";
function add_css25(target) {
  append_styles(target, "svelte-j54i7s", ":root{--scrollbar-track-color:transparent;--scrollbar-color:rgba(0, 0, 0, 0.2);--scrollbar-active-color:rgba(0, 0, 0, 0.4);--scrollbar-size:0.75rem;--scrollbar-minlength:1.5rem}.code-container.svelte-j54i7s{background-color:var(--grey-100);border-left:1px solid var(--grey-200);border-right:1px solid var(--grey-200);overflow-x:auto;overflow-y:hidden;padding-top:0;padding-right:12px;padding-bottom:6px;padding-left:15px;scrollbar-width:thin;scrollbar-color:var(--scrollbar-color) var(--scrollbar-track-color)}.code-container.svelte-j54i7s::-webkit-scrollbar{height:var(--scrollbar-size);width:var(--scrollbar-size)}.code-container.svelte-j54i7s::-webkit-scrollbar-track{background-color:var(--scrollbar-track-color)}.over-container.svelte-j54i7s{overflow-y:hidden;overflow-x:auto}.code-container.svelte-j54i7s::-webkit-scrollbar-thumb{background-color:var(--scrollbar-color);border-radius:7px;background-clip:padding-box}.code-container.svelte-j54i7s::-webkit-scrollbar-thumb:hover{background-color:var(--scrollbar-active-color)}.code-container.svelte-j54i7s::-webkit-scrollbar-thumb:vertical{min-height:var(--scrollbar-minlength);border:3px solid transparent}.code-container.svelte-j54i7s::-webkit-scrollbar-thumb:horizontal{min-width:var(--scrollbar-minlength);border:3px solid transparent}.status-bar.svelte-j54i7s{margin-top:0px;margin-bottom:0px;background-color:var(--grey-100);border-left:1px solid var(--grey-200);border-right:1px solid var(--grey-200);border-bottom:1px solid var(--grey-200);overflow-x:auto;overflow-y:hidden;scrollbar-width:thin;scrollbar-color:var(--scrollbar-color) var(--scrollbar-track-color)}.status-bar.svelte-j54i7s::-webkit-scrollbar{height:var(--scrollbar-size);width:var(--scrollbar-size)}.status-bar.svelte-j54i7s::-webkit-scrollbar-track{background-color:var(--scrollbar-track-color)}.status-bar.svelte-j54i7s::-webkit-scrollbar-thumb{background-color:var(--scrollbar-color);border-radius:7px;background-clip:padding-box}.status-bar.svelte-j54i7s::-webkit-scrollbar-thumb:hover{background-color:var(--scrollbar-active-color)}.status-bar.svelte-j54i7s::-webkit-scrollbar-thumb:vertical{min-height:var(--scrollbar-minlength);border:3px solid transparent}.status-bar.svelte-j54i7s::-webkit-scrollbar-thumb:horizontal{min-width:var(--scrollbar-minlength);border:3px solid transparent}.closed.svelte-j54i7s{border-bottom-left-radius:6px;border-bottom-right-radius:6px;transition:400ms;transition-delay:400ms}.open.svelte-j54i7s{border-bottom-left-radius:0px;border-bottom-right-radius:0px;transition:400ms}.status-bar.success.svelte-j54i7s{color:var(--blue-500);cursor:pointer}.status-bar.error.svelte-j54i7s{color:var(--red-600)}.credentials-link.svelte-j54i7s{color:var(--blue-500);text-decoration:none}.credentials-link.svelte-j54i7s:hover{color:var(--blue-700)}button.svelte-j54i7s{font-family:var(--ui-font-family-compact);-webkit-font-smoothing:antialiased;font-size:12px;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap;text-align:left;width:100%;background-color:var(--grey-100);border:none;border-left:1px solid var(--grey-200);border-right:1px solid var(--grey-200);margin-bottom:0px;cursor:pointer;padding:5px}button.title.svelte-j54i7s{border-top:1px solid var(--grey-200);border-top-left-radius:6px;border-top-right-radius:6px}button.results.svelte-j54i7s{padding:0.3em 0.6em;margin-top:0px;background-color:white}.container.svelte-j54i7s{margin-bottom:1.2em;margin-top:0.75em;display:flex;flex-direction:column}.container-a.svelte-j54i7s{background-color:var(--grey-100);border-top-left-radius:6px;border-top-right-radius:6px;box-sizing:border-box;display:flex;flex-direction:column}@media print{.container.svelte-j54i7s{-moz-column-break-inside:avoid;break-inside:avoid}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUXVlcnlWaWV3ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1JQyxLQUFBLEFBQUEsQ0FBQSxBQUNDLHVCQUFBLENBQUEsV0FBb0MsQ0FDcEMsaUJBQUEsQ0FBQSxrQkFBcUMsQ0FDckMsd0JBQUEsQ0FBQSxrQkFBNEMsQ0FDNUMsZ0JBQUEsQ0FBQSxPQUF5QixDQUN6QixxQkFBQSxDQUFBLE1BQTZCLEFBQzlCLENBQUEsQUFFQSxlQUFBLGNBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLFdBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQyxDQUN0QyxZQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBdUMsQ0FDdkMsVUFBQSxDQUFBLElBQWdCLENBQ2hCLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixXQUFBLENBQUEsQ0FBYyxDQUNkLGFBQUEsQ0FBQSxJQUFtQixDQUNuQixjQUFBLENBQUEsR0FBbUIsQ0FDbkIsWUFBQSxDQUFBLElBQWtCLENBQ2xCLGVBQUEsQ0FBQSxJQUFxQixDQUNyQixlQUFBLENBQUEsSUFBQSxpQkFBQSxDQUFBLENBQUEsSUFBQSx1QkFBQSxDQUFvRSxBQUNyRSxDQUFBLEFBQ0EsNkJBQUEsbUJBQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBNkIsQ0FDN0IsS0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBNEIsQUFDN0IsQ0FBQSxBQUNBLDZCQUFBLHlCQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSx1QkFBQSxDQUE4QyxBQUMvQyxDQUFBLEFBRUEsZUFBQSxjQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsTUFBa0IsQ0FDbEIsVUFBQSxDQUFBLElBQWdCLEFBQ2pCLENBQUEsQUFFQSw2QkFBQSx5QkFBQSxBQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsaUJBQUEsQ0FBd0MsQ0FDeEMsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLGVBQUEsQ0FBQSxXQUE0QixBQUM3QixDQUFBLEFBQ0EsNkJBQUEseUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsd0JBQUEsQ0FBK0MsQUFDaEQsQ0FBQSxBQUNBLDZCQUFBLHlCQUFBLFNBQUEsQUFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQUEscUJBQUEsQ0FBc0MsQ0FDdEMsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsV0FBNkIsQUFDOUIsQ0FBQSxBQUNBLDZCQUFBLHlCQUFBLFdBQUEsQUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLElBQUEscUJBQUEsQ0FBcUMsQ0FDckMsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsV0FBNkIsQUFDOUIsQ0FBQSxBQUVBLFdBQUEsY0FBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLEdBQWUsQ0FDZixhQUFBLENBQUEsR0FBa0IsQ0FDbEIsZ0JBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsV0FBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNDLENBQ3RDLFlBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUF1QyxDQUN2QyxhQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBd0MsQ0FDeEMsVUFBQSxDQUFBLElBQWdCLENBQ2hCLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixlQUFBLENBQUEsSUFBcUIsQ0FDckIsZUFBQSxDQUFBLElBQUEsaUJBQUEsQ0FBQSxDQUFBLElBQUEsdUJBQUEsQ0FBb0UsQUFDckUsQ0FBQSxBQUVBLHlCQUFBLG1CQUFBLEFBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxJQUFBLGdCQUFBLENBQTZCLENBQzdCLEtBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQTRCLEFBQzdCLENBQUEsQUFDQSx5QkFBQSx5QkFBQSxBQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsdUJBQUEsQ0FBOEMsQUFDL0MsQ0FBQSxBQUNBLHlCQUFBLHlCQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxpQkFBQSxDQUF3QyxDQUN4QyxhQUFBLENBQUEsR0FBa0IsQ0FDbEIsZUFBQSxDQUFBLFdBQTRCLEFBQzdCLENBQUEsQUFDQSx5QkFBQSx5QkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSx3QkFBQSxDQUErQyxBQUNoRCxDQUFBLEFBQ0EseUJBQUEseUJBQUEsU0FBQSxBQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBQSxxQkFBQSxDQUFzQyxDQUN0QyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUE2QixBQUM5QixDQUFBLEFBQ0EseUJBQUEseUJBQUEsV0FBQSxBQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsSUFBQSxxQkFBQSxDQUFxQyxDQUNyQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUE2QixBQUM5QixDQUFBLEFBRUEsT0FBQSxjQUFBLENBQUEsQUFDQyx5QkFBQSxDQUFBLEdBQThCLENBQzlCLDBCQUFBLENBQUEsR0FBK0IsQ0FDL0IsVUFBQSxDQUFBLEtBQWlCLENBQ2pCLGdCQUFBLENBQUEsS0FBdUIsQUFFeEIsQ0FBQSxBQUVBLEtBQUEsY0FBQSxDQUFBLEFBQ0MseUJBQUEsQ0FBQSxHQUE4QixDQUM5QiwwQkFBQSxDQUFBLEdBQStCLENBQy9CLFVBQUEsQ0FBQSxLQUFpQixBQUNsQixDQUFBLEFBRUEsV0FBQSxRQUFBLGNBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsTUFBQSxDQUFBLE9BQWUsQUFDaEIsQ0FBQSxBQUVBLFdBQUEsTUFBQSxjQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxTQUFBLENBQXFCLEFBQ3RCLENBQUEsQUFFQSxpQkFBQSxjQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGVBQUEsQ0FBQSxJQUFxQixBQUN0QixDQUFBLEFBRUEsK0JBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEsQUFFQSxNQUFBLGNBQUEsQ0FBQSxBQUNDLFdBQUEsQ0FBQSxJQUFBLHdCQUFBLENBQTBDLENBQzFDLHNCQUFBLENBQUEsV0FBbUMsQ0FDbkMsU0FBQSxDQUFBLElBQWUsQ0FDZixtQkFBQSxDQUFBLElBQXlCLENBQ3pCLGdCQUFBLENBQUEsSUFBc0IsQ0FDakIsV0FBQSxDQUFBLElBQWlCLENBQ3RCLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsS0FBQSxDQUFBLElBQVcsQ0FDWCxnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxNQUFBLENBQUEsSUFBWSxDQUNaLFdBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQyxDQUN0QyxZQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBdUMsQ0FDdkMsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLE1BQUEsQ0FBQSxPQUFlLENBQ2YsT0FBQSxDQUFBLEdBQVksQUFDYixDQUFBLEFBRUEsTUFBQSxNQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFxQyxDQUNyQyxzQkFBQSxDQUFBLEdBQTJCLENBQzNCLHVCQUFBLENBQUEsR0FBNEIsQUFDN0IsQ0FBQSxBQUVBLE1BQUEsUUFBQSxjQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsS0FBQSxDQUFBLEtBQW9CLENBQ3BCLFVBQUEsQ0FBQSxHQUFlLENBQ2YsZ0JBQUEsQ0FBQSxLQUF1QixBQUN4QixDQUFBLEFBRUEsVUFBQSxjQUFBLENBQUEsQUFDQyxhQUFBLENBQUEsS0FBb0IsQ0FDcEIsVUFBQSxDQUFBLE1BQWtCLENBQ2xCLE9BQUEsQ0FBQSxJQUFhLENBQ2IsY0FBQSxDQUFBLE1BQXNCLEFBQ3ZCLENBQUEsQUFFQSxZQUFBLGNBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLHNCQUFBLENBQUEsR0FBMkIsQ0FDM0IsdUJBQUEsQ0FBQSxHQUE0QixDQUM1QixVQUFBLENBQUEsVUFBc0IsQ0FDdEIsT0FBQSxDQUFBLElBQWEsQ0FDYixjQUFBLENBQUEsTUFBc0IsQUFDdkIsQ0FBQSxBQUdBLE9BQUEsS0FBQSxBQUFBLENBQUEsQUFDQyxVQUFBLGNBQUEsQ0FBQSxBQUNDLHdCQUFBLENBQUEsS0FBK0IsQ0FDMUIsWUFBQSxDQUFBLEtBQW1CLEFBQ3pCLENBQUEsQUFDRCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlF1ZXJ5Vmlld2VyLnN2ZWx0ZSJdfQ== */");
}
function create_if_block22(ctx) {
  let div1;
  let div0;
  let button0;
  let chevrontoggle;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let button1;
  let current_block_type_index;
  let if_block2;
  let button1_class_value;
  let t5;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  chevrontoggle = new ChevronToggle_default({
    props: { toggled: (
      /*$showSQL*/
      ctx[10]
    ) },
    $$inline: true
  });
  let if_block0 = (
    /*$showSQL*/
    ctx[10] && /*showCompilerToggle*/
    ctx[6] && create_if_block_7(ctx)
  );
  let if_block1 = (
    /*$showSQL*/
    ctx[10] && create_if_block_53(ctx)
  );
  const if_block_creators = [create_if_block_28, create_if_block_43, create_else_block_15];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*error*/
      ctx2[2]
    )
      return 0;
    if (
      /*nRecords*/
      ctx2[3] > 0
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block3 = (
    /*queryResult*/
    ctx[1].length > 0 && !/*error*/
    ctx[2] && /*$showResults*/
    ctx[9] && create_if_block_19(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      create_component(chevrontoggle.$$.fragment);
      t0 = space();
      t1 = text(
        /*queryID*/
        ctx[0]
      );
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      button1 = element("button");
      if_block2.c();
      t5 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button0 = claim_element(div0_nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button0_nodes = children(button0);
      claim_component(chevrontoggle.$$.fragment, button0_nodes);
      t0 = claim_space(button0_nodes);
      t1 = claim_text(
        button0_nodes,
        /*queryID*/
        ctx[0]
      );
      button0_nodes.forEach(detach_dev);
      t2 = claim_space(div0_nodes);
      if (if_block0)
        if_block0.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      button1 = claim_element(div1_nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button1_nodes = children(button1);
      if_block2.l(button1_nodes);
      button1_nodes.forEach(detach_dev);
      t5 = claim_space(div1_nodes);
      if (if_block3)
        if_block3.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "type", "button");
      attr_dev(button0, "aria-label", "show-sql");
      attr_dev(button0, "class", "title svelte-j54i7s");
      add_location(button0, file35, 78, 4, 2439);
      attr_dev(div0, "class", "container-a svelte-j54i7s");
      add_location(div0, file35, 77, 3, 2409);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "aria-label", "view-query");
      attr_dev(button1, "class", button1_class_value = null_to_empty("status-bar" + /*error*/
      (ctx[2] ? " error" : " success") + /*$showResults*/
      (ctx[9] ? " open" : " closed")) + " svelte-j54i7s");
      add_location(button1, file35, 98, 3, 2993);
      attr_dev(div1, "class", "container svelte-j54i7s");
      add_location(div1, file35, 76, 2, 2359);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, button0);
      mount_component(chevrontoggle, button0, null);
      append_hydration_dev(button0, t0);
      append_hydration_dev(button0, t1);
      append_hydration_dev(div0, t2);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t3);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div1, t4);
      append_hydration_dev(div1, button1);
      if_blocks[current_block_type_index].m(button1, null);
      append_hydration_dev(div1, t5);
      if (if_block3)
        if_block3.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*toggleSQL*/
            ctx[13],
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*toggleResults*/
            ctx[15],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const chevrontoggle_changes = {};
      if (dirty & /*$showSQL*/
      1024)
        chevrontoggle_changes.toggled = /*$showSQL*/
        ctx2[10];
      chevrontoggle.$set(chevrontoggle_changes);
      if (!current || dirty & /*queryID*/
      1)
        set_data_dev(
          t1,
          /*queryID*/
          ctx2[0]
        );
      if (
        /*$showSQL*/
        ctx2[10] && /*showCompilerToggle*/
        ctx2[6]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$showSQL, showCompilerToggle*/
          1088) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$showSQL*/
        ctx2[10]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$showSQL*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_53(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(button1, null);
      }
      if (!current || dirty & /*error, $showResults*/
      516 && button1_class_value !== (button1_class_value = null_to_empty("status-bar" + /*error*/
      (ctx2[2] ? " error" : " success") + /*$showResults*/
      (ctx2[9] ? " open" : " closed")) + " svelte-j54i7s")) {
        attr_dev(button1, "class", button1_class_value);
      }
      if (
        /*queryResult*/
        ctx2[1].length > 0 && !/*error*/
        ctx2[2] && /*$showResults*/
        ctx2[9]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*queryResult, error, $showResults*/
          518) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_19(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div1, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevrontoggle.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      if (local) {
        add_render_callback(() => {
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(div1, slide, {}, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(chevrontoggle.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, slide, {}, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(chevrontoggle);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_blocks[current_block_type_index].d();
      if (if_block3)
        if_block3.d();
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(75:1) {#if $showQueries}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let compilertoggle;
  let updating_showCompiled;
  let current;
  function compilertoggle_showCompiled_binding(value) {
    ctx[18](value);
  }
  let compilertoggle_props = {};
  if (
    /*showCompiled*/
    ctx[7] !== void 0
  ) {
    compilertoggle_props.showCompiled = /*showCompiled*/
    ctx[7];
  }
  compilertoggle = new CompilerToggle_default({
    props: compilertoggle_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(
    compilertoggle,
    "showCompiled",
    compilertoggle_showCompiled_binding,
    /*showCompiled*/
    ctx[7]
  ));
  const block = {
    c: function create() {
      create_component(compilertoggle.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(compilertoggle.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(compilertoggle, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const compilertoggle_changes = {};
      if (!updating_showCompiled && dirty & /*showCompiled*/
      128) {
        updating_showCompiled = true;
        compilertoggle_changes.showCompiled = /*showCompiled*/
        ctx2[7];
        add_flush_callback(() => updating_showCompiled = false);
      }
      compilertoggle.$set(compilertoggle_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(compilertoggle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(compilertoggle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(compilertoggle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(84:4) {#if $showSQL && showCompilerToggle}",
    ctx
  });
  return block;
}
function create_if_block_53(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_transition;
  let current;
  const if_block_creators = [create_if_block_63, create_else_block_22];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*showCompiled*/
      ctx2[7]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "code-container svelte-j54i7s");
      add_location(div, file35, 88, 5, 2763);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_53.name,
    type: "if",
    source: "(88:4) {#if $showSQL}",
    ctx
  });
  return block;
}
function create_else_block_22(ctx) {
  let prism;
  let current;
  prism = new Prismjs_default({
    props: { code: (
      /*inputQuery*/
      ctx[4]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(prism.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(prism.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(prism, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const prism_changes = {};
      if (dirty & /*inputQuery*/
      16)
        prism_changes.code = /*inputQuery*/
        ctx2[4];
      prism.$set(prism_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prism.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prism.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(prism, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_22.name,
    type: "else",
    source: "(92:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_63(ctx) {
  let prism;
  let current;
  prism = new Prismjs_default({
    props: { code: (
      /*compiledQuery*/
      ctx[5]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(prism.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(prism.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(prism, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const prism_changes = {};
      if (dirty & /*compiledQuery*/
      32)
        prism_changes.code = /*compiledQuery*/
        ctx2[5];
      prism.$set(prism_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prism.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prism.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(prism, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_63.name,
    type: "if",
    source: "(90:6) {#if showCompiled}",
    ctx
  });
  return block;
}
function create_else_block_15(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("ran successfully but no data was returned");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "ran successfully but no data was returned");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_15.name,
    type: "else",
    source: "(119:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let chevrontoggle;
  let t0;
  let t1_value = (
    /*nRecords*/
    ctx[3].toLocaleString() + ""
  );
  let t1;
  let t2;
  let t3_value = (
    /*nRecords*/
    ctx[3] > 1 ? "records" : "record"
  );
  let t3;
  let t4;
  let t5_value = (
    /*nProperties*/
    ctx[8].toLocaleString() + ""
  );
  let t5;
  let t6;
  let t7_value = (
    /*nProperties*/
    ctx[8] > 1 ? "properties" : "property"
  );
  let t7;
  let current;
  chevrontoggle = new ChevronToggle_default({
    props: {
      toggled: (
        /*$showResults*/
        ctx[9]
      ),
      color: "#3488e9"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chevrontoggle.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      t3 = text(t3_value);
      t4 = text(" with ");
      t5 = text(t5_value);
      t6 = space();
      t7 = text(t7_value);
    },
    l: function claim(nodes) {
      claim_component(chevrontoggle.$$.fragment, nodes);
      t0 = claim_space(nodes);
      t1 = claim_text(nodes, t1_value);
      t2 = claim_space(nodes);
      t3 = claim_text(nodes, t3_value);
      t4 = claim_text(nodes, " with ");
      t5 = claim_text(nodes, t5_value);
      t6 = claim_space(nodes);
      t7 = claim_text(nodes, t7_value);
    },
    m: function mount(target, anchor) {
      mount_component(chevrontoggle, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, t3, anchor);
      insert_hydration_dev(target, t4, anchor);
      insert_hydration_dev(target, t5, anchor);
      insert_hydration_dev(target, t6, anchor);
      insert_hydration_dev(target, t7, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chevrontoggle_changes = {};
      if (dirty & /*$showResults*/
      512)
        chevrontoggle_changes.toggled = /*$showResults*/
        ctx2[9];
      chevrontoggle.$set(chevrontoggle_changes);
      if ((!current || dirty & /*nRecords*/
      8) && t1_value !== (t1_value = /*nRecords*/
      ctx2[3].toLocaleString() + ""))
        set_data_dev(t1, t1_value);
      if ((!current || dirty & /*nRecords*/
      8) && t3_value !== (t3_value = /*nRecords*/
      ctx2[3] > 1 ? "records" : "record"))
        set_data_dev(t3, t3_value);
      if ((!current || dirty & /*nProperties*/
      256) && t5_value !== (t5_value = /*nProperties*/
      ctx2[8].toLocaleString() + ""))
        set_data_dev(t5, t5_value);
      if ((!current || dirty & /*nProperties*/
      256) && t7_value !== (t7_value = /*nProperties*/
      ctx2[8] > 1 ? "properties" : "property"))
        set_data_dev(t7, t7_value);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevrontoggle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevrontoggle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chevrontoggle, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(t2);
      if (detaching)
        detach_dev(t3);
      if (detaching)
        detach_dev(t4);
      if (detaching)
        detach_dev(t5);
      if (detaching)
        detach_dev(t6);
      if (detaching)
        detach_dev(t7);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(114:27) ",
    ctx
  });
  return block;
}
function create_if_block_28(ctx) {
  let if_block_anchor;
  function select_block_type_2(ctx2, dirty) {
    if (dev2 && /*error*/
    ctx2[2].message === "Missing database credentials")
      return create_if_block_33;
    return create_else_block9;
  }
  let current_block_type = select_block_type_2(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(107:4) {#if error}",
    ctx
  });
  return block;
}
function create_else_block9(ctx) {
  let t_value = (
    /*error*/
    ctx[2].message + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*error*/
      4 && t_value !== (t_value = /*error*/
      ctx2[2].message + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(111:5) {:else}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let t0_value = (
    /*error*/
    ctx[2].message + ""
  );
  let t0;
  let t1;
  let a;
  let t2;
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = text(".\n						");
      a = element("a");
      t2 = text("Add credentials ");
      this.h();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_text(nodes, ".\n						");
      a = claim_element(nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      t2 = claim_text(a_nodes, "Add credentials ");
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "class", "credentials-link svelte-j54i7s");
      attr_dev(a, "href", "/settings");
      add_location(a, file35, 109, 6, 3301);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*error*/
      4 && t0_value !== (t0_value = /*error*/
      ctx2[2].message + ""))
        set_data_dev(t0, t0_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(a);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(108:5) {#if dev && error.message === 'Missing database credentials'}",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let datatable;
  let current;
  datatable = new QueryDataTable_default({
    props: {
      data: (
        /*queryResult*/
        ctx[1]
      ),
      queryID: (
        /*queryID*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(datatable.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(datatable.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(datatable, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const datatable_changes = {};
      if (dirty & /*queryResult*/
      2)
        datatable_changes.data = /*queryResult*/
        ctx2[1];
      if (dirty & /*queryID*/
      1)
        datatable_changes.queryID = /*queryID*/
        ctx2[0];
      datatable.$set(datatable_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(datatable.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(datatable.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(datatable, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(124:3) {#if queryResult.length > 0 && !error && $showResults}",
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let div;
  let div_intro;
  let current;
  let if_block = (
    /*$showQueries*/
    ctx[11] && create_if_block22(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "over-container svelte-j54i7s");
      add_location(div, file35, 73, 0, 2277);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$showQueries*/
        ctx2[11]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$showQueries*/
          2048) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(div, blur, {});
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude34 = true;
function instance36($$self, $$props, $$invalidate) {
  let $showResults;
  let $showSQL;
  let $showQueries;
  validate_store(showQueries, "showQueries");
  component_subscribe($$self, showQueries, ($$value) => $$invalidate(11, $showQueries = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("QueryViewer", slots, []);
  let { queryID } = $$props;
  let { pageQueries } = $$props;
  let { queryResult } = $$props;
  let showSQL = writable(browser && (localStorage.getItem("showSQL_".concat(queryID)) === "true" || false));
  validate_store(showSQL, "showSQL");
  component_subscribe($$self, showSQL, (value) => $$invalidate(10, $showSQL = value));
  showSQL.subscribe((value) => browser && localStorage.setItem("showSQL_".concat(queryID), value));
  const toggleSQL = function() {
    set_store_value(showSQL, $showSQL = !$showSQL, $showSQL);
  };
  let showResults = writable(browser && (localStorage.getItem("showResults_".concat(queryID)) === "true" || false));
  validate_store(showResults, "showResults");
  component_subscribe($$self, showResults, (value) => $$invalidate(9, $showResults = value));
  showResults.subscribe((value) => browser && localStorage.setItem("showResults_".concat(queryID), value));
  const toggleResults = function() {
    if (!error && nRecords > 0) {
      set_store_value(showResults, $showResults = !$showResults, $showResults);
    }
  };
  let queries;
  let inputQuery;
  let compiledQuery;
  let showCompilerToggle;
  let showCompiled = true;
  let error;
  let nRecords;
  let nProperties;
  $$self.$$.on_mount.push(function() {
    if (queryID === void 0 && !("queryID" in $$props || $$self.$$.bound[$$self.$$.props["queryID"]])) {
      console.warn("<QueryViewer> was created without expected prop 'queryID'");
    }
    if (pageQueries === void 0 && !("pageQueries" in $$props || $$self.$$.bound[$$self.$$.props["pageQueries"]])) {
      console.warn("<QueryViewer> was created without expected prop 'pageQueries'");
    }
    if (queryResult === void 0 && !("queryResult" in $$props || $$self.$$.bound[$$self.$$.props["queryResult"]])) {
      console.warn("<QueryViewer> was created without expected prop 'queryResult'");
    }
  });
  const writable_props = ["queryID", "pageQueries", "queryResult"];
  Object_13.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<QueryViewer> was created with unknown prop '${key}'`);
  });
  function compilertoggle_showCompiled_binding(value) {
    showCompiled = value;
    $$invalidate(7, showCompiled);
  }
  $$self.$$set = ($$props2) => {
    if ("queryID" in $$props2)
      $$invalidate(0, queryID = $$props2.queryID);
    if ("pageQueries" in $$props2)
      $$invalidate(16, pageQueries = $$props2.pageQueries);
    if ("queryResult" in $$props2)
      $$invalidate(1, queryResult = $$props2.queryResult);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude34,
    slide,
    blur,
    dev: dev2,
    DataTable: QueryDataTable_default,
    ChevronToggle: ChevronToggle_default,
    Prism: Prismjs_default,
    showQueries,
    CompilerToggle: CompilerToggle_default,
    writable,
    browser,
    queryID,
    pageQueries,
    queryResult,
    showSQL,
    toggleSQL,
    showResults,
    toggleResults,
    queries,
    inputQuery,
    compiledQuery,
    showCompilerToggle,
    showCompiled,
    error,
    nRecords,
    nProperties,
    $showResults,
    $showSQL,
    $showQueries
  });
  $$self.$inject_state = ($$props2) => {
    if ("queryID" in $$props2)
      $$invalidate(0, queryID = $$props2.queryID);
    if ("pageQueries" in $$props2)
      $$invalidate(16, pageQueries = $$props2.pageQueries);
    if ("queryResult" in $$props2)
      $$invalidate(1, queryResult = $$props2.queryResult);
    if ("showSQL" in $$props2)
      $$invalidate(12, showSQL = $$props2.showSQL);
    if ("showResults" in $$props2)
      $$invalidate(14, showResults = $$props2.showResults);
    if ("queries" in $$props2)
      $$invalidate(17, queries = $$props2.queries);
    if ("inputQuery" in $$props2)
      $$invalidate(4, inputQuery = $$props2.inputQuery);
    if ("compiledQuery" in $$props2)
      $$invalidate(5, compiledQuery = $$props2.compiledQuery);
    if ("showCompilerToggle" in $$props2)
      $$invalidate(6, showCompilerToggle = $$props2.showCompilerToggle);
    if ("showCompiled" in $$props2)
      $$invalidate(7, showCompiled = $$props2.showCompiled);
    if ("error" in $$props2)
      $$invalidate(2, error = $$props2.error);
    if ("nRecords" in $$props2)
      $$invalidate(3, nRecords = $$props2.nRecords);
    if ("nProperties" in $$props2)
      $$invalidate(8, nProperties = $$props2.nProperties);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b;
    if ($$self.$$.dirty & /*pageQueries, queryID, queries, queryResult, error, nRecords*/
    196623) {
      $: {
        $$invalidate(17, queries = pageQueries.filter((d) => d.id === queryID));
        $$invalidate(4, inputQuery = queries[0].inputQueryString);
        $$invalidate(5, compiledQuery = queries[0].compiledQueryString);
        $$invalidate(6, showCompilerToggle = queries[0].compiled && queries[0].compileError === void 0);
        $$invalidate(2, error = (_b = (_a = queryResult[0]) == null ? void 0 : _a.error_object) == null ? void 0 : _b.error);
        $$invalidate(3, nRecords = null);
        $$invalidate(8, nProperties = null);
        if (!error) {
          $$invalidate(3, nRecords = queryResult.length);
          if (nRecords > 0) {
            $$invalidate(8, nProperties = Object.keys(queryResult[0]).length);
          }
        }
      }
    }
  };
  return [
    queryID,
    queryResult,
    error,
    nRecords,
    inputQuery,
    compiledQuery,
    showCompilerToggle,
    showCompiled,
    nProperties,
    $showResults,
    $showSQL,
    $showQueries,
    showSQL,
    toggleSQL,
    showResults,
    toggleResults,
    pageQueries,
    queries,
    compilertoggle_showCompiled_binding
  ];
}
var QueryViewer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance36,
      create_fragment36,
      safe_not_equal,
      {
        queryID: 0,
        pageQueries: 16,
        queryResult: 1
      },
      add_css25
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "QueryViewer",
      options,
      id: create_fragment36.name
    });
  }
  get queryID() {
    throw new Error("<QueryViewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryID(value) {
    throw new Error("<QueryViewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageQueries() {
    throw new Error("<QueryViewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageQueries(value) {
    throw new Error("<QueryViewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryResult() {
    throw new Error("<QueryViewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryResult(value) {
    throw new Error("<QueryViewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var QueryViewer_default = QueryViewer;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Sidebar.svelte
import { page as page7 } from "$app/stores";
import { dev as dev3 } from "$app/environment";
var file36 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Sidebar.svelte";
function add_css26(target) {
  append_styles(target, "svelte-aqeh0j", ":root{--scrollbar-track-color:transparent;--scrollbar-color:rgba(0, 0, 0, 0.2);--scrollbar-active-color:rgba(0, 0, 0, 0.4);--scrollbar-size:0.75rem;--scrollbar-minlength:1.5rem}aside.sidebar.svelte-aqeh0j.svelte-aqeh0j{grid-area:sidebar;position:relative;z-index:3;background-color:var(--grey-100);border-right:1px solid var(--grey-300)}.project-title.svelte-aqeh0j.svelte-aqeh0j{font-size:22px;margin:0 0 0.3em 0;padding-top:0.3em}button.close.svelte-aqeh0j.svelte-aqeh0j{display:none}.sticky.svelte-aqeh0j.svelte-aqeh0j{position:sticky;top:0;padding:0;height:100vh;display:grid;grid-template-columns:1fr;grid-template-rows:3rem 1fr 4rem;grid-template-areas:'header'\n			'nav'\n			'footer'}nav.svelte-aqeh0j.svelte-aqeh0j{overflow-y:scroll;overflow-x:hidden;grid-area:nav;scrollbar-width:thin;scrollbar-color:var(--scrollbar-color) var(--scrollbar-track-color)}nav.svelte-aqeh0j.svelte-aqeh0j::-webkit-scrollbar{height:var(--scrollbar-size);width:var(--scrollbar-size)}nav.svelte-aqeh0j.svelte-aqeh0j::-webkit-scrollbar-track{background-color:var(--scrollbar-track-color)}nav.svelte-aqeh0j.svelte-aqeh0j::-webkit-scrollbar-thumb{background-color:var(--scrollbar-color);border-radius:7px;background-clip:padding-box}nav.svelte-aqeh0j.svelte-aqeh0j::-webkit-scrollbar-thumb:hover{background-color:var(--scrollbar-active-color)}nav.svelte-aqeh0j.svelte-aqeh0j::-webkit-scrollbar-thumb:vertical{min-height:var(--scrollbar-minlength);border:3px solid transparent}nav.svelte-aqeh0j.svelte-aqeh0j::-webkit-scrollbar-thumb:horizontal{min-width:var(--scrollbar-minlength);border:3px solid transparent}a.svelte-aqeh0j.svelte-aqeh0j{text-transform:capitalize;color:var(--grey-700);display:inline-block;text-decoration:none;font-family:var(--ui-font-family);-webkit-font-smoothing:antialiased}nav.svelte-aqeh0j a.svelte-aqeh0j{font-size:15px;display:block;color:var(--grey-700)}nav.svelte-aqeh0j div.svelte-aqeh0j{padding:0.2rem 1rem 0.2rem 1.2rem}nav.svelte-aqeh0j div.svelte-aqeh0j:hover{color:var(--grey-900)}nav.svelte-aqeh0j a.svelte-aqeh0j:hover{background-color:none;text-decoration:none}div.selected.svelte-aqeh0j.svelte-aqeh0j{color:var(--blue-600);font-weight:500}div.selected.svelte-aqeh0j.svelte-aqeh0j:hover{color:var(--blue-800)}div.nav-header.svelte-aqeh0j.svelte-aqeh0j{padding:0.2rem 0.2rem 0 1.2rem;grid-area:header;display:flex;justify-content:space-between}.nav-header.svelte-aqeh0j.svelte-aqeh0j{overflow:hidden}div.nav-header.svelte-aqeh0j a.svelte-aqeh0j{display:block}.nav-footer.svelte-aqeh0j.svelte-aqeh0j{padding:1.2rem 1rem 1.2rem 1.2rem;box-sizing:border-box;position:absolute;bottom:0;height:100%;width:100%;border-top:1px solid var(--grey-200);grid-area:footer;display:flex;font-size:16px}.settings-link.svelte-aqeh0j.svelte-aqeh0j{display:grid;grid-template-columns:2rem auto}.settings-label.svelte-aqeh0j.svelte-aqeh0j{color:var(--grey-700)}.settings-link.svelte-aqeh0j:hover .settings-icon.svelte-aqeh0j{color:var(--grey-700)}.settings-link.svelte-aqeh0j:hover a.svelte-aqeh0j{color:var(--grey-900)}.settings-link.selected.svelte-aqeh0j a.svelte-aqeh0j{color:var(--blue-600)}.settings-link.selected.svelte-aqeh0j .settings-icon.svelte-aqeh0j{color:var(--blue-600)}.settings-link.selected.svelte-aqeh0j:hover a.svelte-aqeh0j{color:var(--blue-800)}.settings-link.selected.svelte-aqeh0j:hover .settings-icon.svelte-aqeh0j{color:var(--blue-800)}.settings-icon.svelte-aqeh0j svg{color:var(--grey-500)}.nav-footer.svelte-aqeh0j a.svelte-aqeh0j{color:var(--grey-700)}.spacer.svelte-aqeh0j.svelte-aqeh0j{display:none;height:100px;width:100%}@media(max-width: 850px){aside.sidebar.svelte-aqeh0j.svelte-aqeh0j{grid-area:none;position:fixed;height:100%;width:80%;left:-100%;transition:left 0.3s ease-in-out;background-color:hsla(217, 33%, 97%, 0.83);-webkit-backdrop-filter:blur(20px) saturate(1.8);backdrop-filter:blur(20px) saturate(1.8);border-right:1px solid var(--grey-300)}aside.open.svelte-aqeh0j.svelte-aqeh0j{left:0}div.nav-footer.svelte-aqeh0j.svelte-aqeh0j{display:none}.spacer.svelte-aqeh0j.svelte-aqeh0j{display:block}button.close.svelte-aqeh0j.svelte-aqeh0j{display:inline;background-color:transparent;border:none;padding:0.4em 0.4em;cursor:pointer;margin:0;color:var(--grey-900)}}@media print{aside.svelte-aqeh0j.svelte-aqeh0j{display:none}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2lkZWJhci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNERDLEtBQUEsQUFBQSxDQUFBLEFBQ0MsdUJBQUEsQ0FBQSxXQUFvQyxDQUNwQyxpQkFBQSxDQUFBLGtCQUFxQyxDQUNyQyx3QkFBQSxDQUFBLGtCQUE0QyxDQUM1QyxnQkFBQSxDQUFBLE9BQXlCLENBQ3pCLHFCQUFBLENBQUEsTUFBNkIsQUFDOUIsQ0FBQSxBQUVBLEtBQUEsUUFBQSw0QkFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLE9BQWtCLENBQ2xCLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixPQUFBLENBQUEsQ0FBVSxDQUNWLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLFlBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUF1QyxBQUN4QyxDQUFBLEFBRUEsY0FBQSw0QkFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLElBQWUsQ0FDZixNQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBbUIsQ0FDbkIsV0FBQSxDQUFBLEtBQWtCLEFBQ25CLENBQUEsQUFFQSxNQUFBLE1BQUEsNEJBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxJQUFhLEFBQ2QsQ0FBQSxBQUVBLE9BQUEsNEJBQUEsQ0FBQSxBQUNDLFFBQUEsQ0FBQSxNQUFnQixDQUNoQixHQUFBLENBQUEsQ0FBTSxDQUNOLE9BQUEsQ0FBQSxDQUFVLENBQ1YsTUFBQSxDQUFBLEtBQWEsQ0FDYixPQUFBLENBQUEsSUFBYSxDQUNiLHFCQUFBLENBQUEsR0FBMEIsQ0FDMUIsa0JBQUEsQ0FBQSxJQUFBLENBQUEsR0FBQSxDQUFBLElBQWlDLENBQ2pDLG1CQUFBOztXQUdTLEFBQ1YsQ0FBQSxBQUVBLEdBQUEsNEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixVQUFBLENBQUEsTUFBa0IsQ0FDbEIsU0FBQSxDQUFBLEdBQWMsQ0FDZCxlQUFBLENBQUEsSUFBcUIsQ0FDckIsZUFBQSxDQUFBLElBQUEsaUJBQUEsQ0FBQSxDQUFBLElBQUEsdUJBQUEsQ0FBb0UsQUFDckUsQ0FBQSxBQUVBLCtCQUFBLG1CQUFBLEFBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxJQUFBLGdCQUFBLENBQTZCLENBQzdCLEtBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQTRCLEFBQzdCLENBQUEsQUFDQSwrQkFBQSx5QkFBQSxBQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsdUJBQUEsQ0FBOEMsQUFDL0MsQ0FBQSxBQUNBLCtCQUFBLHlCQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxpQkFBQSxDQUF3QyxDQUN4QyxhQUFBLENBQUEsR0FBa0IsQ0FDbEIsZUFBQSxDQUFBLFdBQTRCLEFBQzdCLENBQUEsQUFDQSwrQkFBQSx5QkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSx3QkFBQSxDQUErQyxBQUNoRCxDQUFBLEFBQ0EsK0JBQUEseUJBQUEsU0FBQSxBQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBQSxxQkFBQSxDQUFzQyxDQUN0QyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUE2QixBQUM5QixDQUFBLEFBQ0EsK0JBQUEseUJBQUEsV0FBQSxBQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsSUFBQSxxQkFBQSxDQUFxQyxDQUNyQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUE2QixBQUM5QixDQUFBLEFBRUEsQ0FBQSw0QkFBQSxDQUFBLEFBQ0MsY0FBQSxDQUFBLFVBQTBCLENBQzFCLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsT0FBQSxDQUFBLFlBQXFCLENBQ3JCLGVBQUEsQ0FBQSxJQUFxQixDQUNyQixXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxDQUNsQyxzQkFBQSxDQUFBLFdBQW1DLEFBQ3BDLENBQUEsQUFFQSxpQkFBQSxDQUFBLENBQUEsY0FBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLElBQWUsQ0FDZixPQUFBLENBQUEsS0FBYyxDQUNkLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLGlCQUFBLENBQUEsR0FBQSxjQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsTUFBQSxDQUFBLElBQUEsQ0FBQSxNQUFBLENBQUEsTUFBa0MsQUFDbkMsQ0FBQSxBQUVBLGlCQUFBLENBQUEsaUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEsQUFFQSxpQkFBQSxDQUFBLGVBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQXNCLENBQ3RCLGVBQUEsQ0FBQSxJQUFxQixBQUN0QixDQUFBLEFBRUEsR0FBQSxTQUFBLDRCQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFdBQUEsQ0FBQSxHQUFnQixBQUNqQixDQUFBLEFBRUEsR0FBQSxxQ0FBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLEdBQUEsV0FBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLE1BQUEsQ0FBQSxNQUFBLENBQUEsQ0FBQSxDQUFBLE1BQStCLENBQy9CLFNBQUEsQ0FBQSxNQUFpQixDQUNqQixPQUFBLENBQUEsSUFBYSxDQUNiLGVBQUEsQ0FBQSxhQUE4QixBQUMvQixDQUFBLEFBRUEsV0FBQSw0QkFBQSxDQUFBLEFBQ0MsUUFBQSxDQUFBLE1BQWdCLEFBQ2pCLENBQUEsQUFFQSxHQUFBLHlCQUFBLENBQUEsQ0FBQSxjQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsS0FBYyxBQUNmLENBQUEsQUFFQSxXQUFBLDRCQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsTUFBQSxDQUFBLElBQUEsQ0FBQSxNQUFBLENBQUEsTUFBa0MsQ0FDbEMsVUFBQSxDQUFBLFVBQXNCLENBQ3RCLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixNQUFBLENBQUEsQ0FBUyxDQUNULE1BQUEsQ0FBQSxJQUFZLENBQ1osS0FBQSxDQUFBLElBQVcsQ0FDWCxVQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBcUMsQ0FDckMsU0FBQSxDQUFBLE1BQWlCLENBQ2pCLE9BQUEsQ0FBQSxJQUFhLENBQ2IsU0FBQSxDQUFBLElBQWUsQUFDaEIsQ0FBQSxBQUNBLGNBQUEsNEJBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxJQUFhLENBQ2IscUJBQUEsQ0FBQSxJQUFBLENBQUEsSUFBZ0MsQUFDakMsQ0FBQSxBQUVBLGVBQUEsNEJBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLDRCQUFBLE1BQUEsQ0FBQSxjQUFBLGNBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLDRCQUFBLE1BQUEsQ0FBQSxDQUFBLGNBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLGNBQUEsdUJBQUEsQ0FBQSxDQUFBLGNBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLGNBQUEsdUJBQUEsQ0FBQSxjQUFBLGNBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLGNBQUEsdUJBQUEsTUFBQSxDQUFBLENBQUEsY0FBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBLEFBRUEsY0FBQSx1QkFBQSxNQUFBLENBQUEsY0FBQSxjQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEsQUFFQSw0QkFBQSxDQUFBLEFBQUEsR0FBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEsQUFFQSx5QkFBQSxDQUFBLENBQUEsY0FBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBLEFBRUEsT0FBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQ0FDYixNQUFBLENBQUEsS0FBYSxDQUNiLEtBQUEsQ0FBQSxJQUFXLEFBQ1osQ0FBQSxBQUVBLE1BQUEsQUFBQSxZQUFBLEtBQUEsQ0FBQSxBQUFBLENBQUEsQUFDQyxLQUFBLFFBQUEsNEJBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxJQUFlLENBQ2YsUUFBQSxDQUFBLEtBQWUsQ0FDZixNQUFBLENBQUEsSUFBWSxDQUNaLEtBQUEsQ0FBQSxHQUFVLENBQ1YsSUFBQSxDQUFBLEtBQVcsQ0FDWCxVQUFBLENBQUEsSUFBQSxDQUFBLElBQUEsQ0FBQSxXQUFpQyxDQUNqQyxnQkFBQSxDQUFBLEtBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsSUFBQSxDQUEyQyxDQUMzQyx1QkFBQSxDQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsU0FBQSxHQUFBLENBQWlELENBQ2pELGVBQUEsQ0FBQSxLQUFBLElBQUEsQ0FBQSxDQUFBLFNBQUEsR0FBQSxDQUF5QyxDQUN6QyxZQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBdUMsQUFDeEMsQ0FBQSxBQUVBLEtBQUEsS0FBQSw0QkFBQSxDQUFBLEFBQ0MsSUFBQSxDQUFBLENBQU8sQUFDUixDQUFBLEFBRUEsR0FBQSxXQUFBLDRCQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFFQSxPQUFBLDRCQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsS0FBYyxBQUNmLENBQUEsQUFFQSxNQUFBLE1BQUEsNEJBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxNQUFlLENBQ2YsZ0JBQUEsQ0FBQSxXQUE2QixDQUM3QixNQUFBLENBQUEsSUFBWSxDQUNaLE9BQUEsQ0FBQSxLQUFBLENBQUEsS0FBb0IsQ0FDcEIsTUFBQSxDQUFBLE9BQWUsQ0FDZixNQUFBLENBQUEsQ0FBUyxDQUNULEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUNELENBQUEsQUFFQSxPQUFBLEtBQUEsQUFBQSxDQUFBLEFBQ0MsS0FBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQUFDZCxDQUFBLEFBQ0QsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTaWRlYmFyLnN2ZWx0ZSJdfQ== */");
}
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_if_block_29(ctx) {
  let a;
  let div;
  let t_value = (
    /*file*/
    ctx[8].label + ""
  );
  let t;
  let a_href_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      a = element("a");
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, style: true, class: true });
      var a_nodes = children(a);
      div = claim_element(a_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-aqeh0j");
      toggle_class(div, "selected", "/" + /*$page*/
      ctx[1].url.pathname.split("/")[1] === /*file*/
      ctx[8].href);
      add_location(div, file36, 34, 6, 982);
      attr_dev(a, "href", a_href_value = /*file*/
      ctx[8].href);
      attr_dev(a, "style", "");
      attr_dev(a, "class", "svelte-aqeh0j");
      add_location(a, file36, 33, 5, 914);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, div);
      append_hydration_dev(div, t);
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler_2*/
          ctx[7],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$page, firstLevelFiles*/
      6) {
        toggle_class(div, "selected", "/" + /*$page*/
        ctx2[1].url.pathname.split("/")[1] === /*file*/
        ctx2[8].href);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(33:24) ",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let collapsiblesection;
  let updating_open;
  let current;
  function collapsiblesection_open_binding(value) {
    ctx[6](value);
  }
  let collapsiblesection_props = { folder: (
    /*file*/
    ctx[8]
  ) };
  if (
    /*open*/
    ctx[0] !== void 0
  ) {
    collapsiblesection_props.open = /*open*/
    ctx[0];
  }
  collapsiblesection = new CollapsibleSection_default({
    props: collapsiblesection_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(
    collapsiblesection,
    "open",
    collapsiblesection_open_binding,
    /*open*/
    ctx[0]
  ));
  const block = {
    c: function create() {
      create_component(collapsiblesection.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(collapsiblesection.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(collapsiblesection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const collapsiblesection_changes = {};
      if (!updating_open && dirty & /*open*/
      1) {
        updating_open = true;
        collapsiblesection_changes.open = /*open*/
        ctx2[0];
        add_flush_callback(() => updating_open = false);
      }
      collapsiblesection.$set(collapsiblesection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(collapsiblesection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(collapsiblesection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(collapsiblesection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(31:4) {#if file.children.length > 0}",
    ctx
  });
  return block;
}
function create_each_block10(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_110, create_if_block_29];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*file*/
      ctx2[8].children.length > 0
    )
      return 0;
    if (
      /*file*/
      ctx2[8].href
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block10.name,
    type: "each",
    source: "(30:3) {#each firstLevelFiles as file}",
    ctx
  });
  return block;
}
function create_if_block23(ctx) {
  let div;
  let a1;
  let span;
  let icon;
  let t0;
  let a0;
  let t1;
  let current;
  icon = new Icon_default({
    props: { src: Settings, class: "w-4 h-4 p-0" },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      a1 = element("a");
      span = element("span");
      create_component(icon.$$.fragment);
      t0 = space();
      a0 = element("a");
      t1 = text("Settings");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a1 = claim_element(div_nodes, "A", { href: true, class: true });
      var a1_nodes = children(a1);
      span = claim_element(a1_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      t0 = claim_space(a1_nodes);
      a0 = claim_element(a1_nodes, "A", { class: true, href: true });
      var a0_nodes = children(a0);
      t1 = claim_text(a0_nodes, "Settings");
      a0_nodes.forEach(detach_dev);
      a1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "settings-icon flex justify-center items-center svelte-aqeh0j");
      add_location(span, file36, 49, 5, 1321);
      attr_dev(a0, "class", "settings-label svelte-aqeh0j");
      attr_dev(a0, "href", "/settings");
      add_location(a0, file36, 52, 5, 1451);
      attr_dev(a1, "href", "/settings");
      attr_dev(a1, "class", "settings-link svelte-aqeh0j");
      toggle_class(
        a1,
        "selected",
        /*$page*/
        ctx[1].url.pathname === "/settings"
      );
      add_location(a1, file36, 44, 4, 1201);
      attr_dev(div, "class", "nav-footer svelte-aqeh0j");
      add_location(div, file36, 43, 3, 1172);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a1);
      append_hydration_dev(a1, span);
      mount_component(icon, span, null);
      append_hydration_dev(a1, t0);
      append_hydration_dev(a1, a0);
      append_hydration_dev(a0, t1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*$page*/
      2) {
        toggle_class(
          a1,
          "selected",
          /*$page*/
          ctx2[1].url.pathname === "/settings"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(43:2) {#if dev}",
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let aside;
  let div2;
  let div0;
  let a;
  let h2;
  let t0;
  let t1;
  let button;
  let icon;
  let t2;
  let nav;
  let t3;
  let div1;
  let t4;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: { src: X, class: "h-9 w-9" },
    $$inline: true
  });
  let each_value = (
    /*firstLevelFiles*/
    ctx[2]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block10(get_each_context10(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block = dev3 && create_if_block23(ctx);
  const block = {
    c: function create() {
      aside = element("aside");
      div2 = element("div");
      div0 = element("div");
      a = element("a");
      h2 = element("h2");
      t0 = text("Evidence");
      t1 = space();
      button = element("button");
      create_component(icon.$$.fragment);
      t2 = space();
      nav = element("nav");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      div1 = element("div");
      t4 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true });
      var aside_nodes = children(aside);
      div2 = claim_element(aside_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      a = claim_element(div0_nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      h2 = claim_element(a_nodes, "H2", { class: true });
      var h2_nodes = children(h2);
      t0 = claim_text(h2_nodes, "Evidence");
      h2_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      t1 = claim_space(div0_nodes);
      button = claim_element(div0_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      nav = claim_element(div2_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nav_nodes);
      }
      t3 = claim_space(nav_nodes);
      div1 = claim_element(nav_nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      t4 = claim_space(div2_nodes);
      if (if_block)
        if_block.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h2, "class", "project-title svelte-aqeh0j");
      add_location(h2, file36, 23, 47, 593);
      attr_dev(a, "href", "/");
      attr_dev(a, "class", "svelte-aqeh0j");
      add_location(a, file36, 23, 3, 549);
      attr_dev(button, "class", "close svelte-aqeh0j");
      add_location(button, file36, 24, 3, 640);
      attr_dev(div0, "class", "nav-header svelte-aqeh0j");
      add_location(div0, file36, 22, 2, 521);
      attr_dev(div1, "class", "spacer svelte-aqeh0j");
      add_location(div1, file36, 40, 3, 1125);
      attr_dev(nav, "class", "svelte-aqeh0j");
      add_location(nav, file36, 28, 2, 756);
      attr_dev(div2, "class", "sticky svelte-aqeh0j");
      add_location(div2, file36, 21, 1, 498);
      attr_dev(aside, "class", "sidebar svelte-aqeh0j");
      toggle_class(
        aside,
        "open",
        /*open*/
        ctx[0]
      );
      add_location(aside, file36, 20, 0, 462);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      append_hydration_dev(aside, div2);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, a);
      append_hydration_dev(a, h2);
      append_hydration_dev(h2, t0);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div0, button);
      mount_component(icon, button, null);
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, nav);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(nav, null);
      }
      append_hydration_dev(nav, t3);
      append_hydration_dev(nav, div1);
      append_hydration_dev(div2, t4);
      if (if_block)
        if_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[4],
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[5],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*firstLevelFiles, open, $page*/
      7) {
        each_value = /*firstLevelFiles*/
        ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context10(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block10(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(nav, t3);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dev3)
        if_block.p(ctx2, dirty);
      if (!current || dirty & /*open*/
      1) {
        toggle_class(
          aside,
          "open",
          /*open*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside);
      destroy_component(icon);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude35 = true;
function instance37($$self, $$props, $$invalidate) {
  let $page;
  validate_store(page7, "page");
  component_subscribe($$self, page7, ($$value) => $$invalidate(1, $page = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Sidebar", slots, []);
  let { fileTree } = $$props;
  let { open } = $$props;
  let firstLevelFiles = fileTree == null ? void 0 : fileTree.children;
  $$self.$$.on_mount.push(function() {
    if (fileTree === void 0 && !("fileTree" in $$props || $$self.$$.bound[$$self.$$.props["fileTree"]])) {
      console.warn("<Sidebar> was created without expected prop 'fileTree'");
    }
    if (open === void 0 && !("open" in $$props || $$self.$$.bound[$$self.$$.props["open"]])) {
      console.warn("<Sidebar> was created without expected prop 'open'");
    }
  });
  const writable_props = ["fileTree", "open"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Sidebar> was created with unknown prop '${key}'`);
  });
  const click_handler = () => $$invalidate(0, open = !open);
  const click_handler_1 = () => $$invalidate(0, open = !open);
  function collapsiblesection_open_binding(value) {
    open = value;
    $$invalidate(0, open);
  }
  const click_handler_2 = () => $$invalidate(0, open = !open);
  $$self.$$set = ($$props2) => {
    if ("fileTree" in $$props2)
      $$invalidate(3, fileTree = $$props2.fileTree);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude35,
    Icon: Icon_default,
    Settings,
    X,
    page: page7,
    dev: dev3,
    CollapsibleSection: CollapsibleSection_default,
    fileTree,
    open,
    firstLevelFiles,
    $page
  });
  $$self.$inject_state = ($$props2) => {
    if ("fileTree" in $$props2)
      $$invalidate(3, fileTree = $$props2.fileTree);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("firstLevelFiles" in $$props2)
      $$invalidate(2, firstLevelFiles = $$props2.firstLevelFiles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    open,
    $page,
    firstLevelFiles,
    fileTree,
    click_handler,
    click_handler_1,
    collapsiblesection_open_binding,
    click_handler_2
  ];
}
var Sidebar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { fileTree: 3, open: 0 }, add_css26);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sidebar",
      options,
      id: create_fragment37.name
    });
  }
  get fileTree() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fileTree(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Sidebar_default = Sidebar;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/SortIcon.svelte
function create_else_block10(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: ChevronDown,
      class: "w-3 h-3 inline mb-0.5"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block10.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block24(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: ChevronUp,
      class: "w-3 h-3 inline mb-0.5"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(12:0) {#if ascending}",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block24, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*ascending*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude36 = true;
function instance38($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SortIcon", slots, []);
  let { ascending } = $$props;
  $$self.$$.on_mount.push(function() {
    if (ascending === void 0 && !("ascending" in $$props || $$self.$$.bound[$$self.$$.props["ascending"]])) {
      console.warn("<SortIcon> was created without expected prop 'ascending'");
    }
  });
  const writable_props = ["ascending"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SortIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("ascending" in $$props2)
      $$invalidate(0, ascending = $$props2.ascending);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude36,
    Icon: Icon_default,
    ChevronUp,
    ChevronDown,
    ascending
  });
  $$self.$inject_state = ($$props2) => {
    if ("ascending" in $$props2)
      $$invalidate(0, ascending = $$props2.ascending);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ascending];
}
var SortIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, { ascending: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SortIcon",
      options,
      id: create_fragment38.name
    });
  }
  get ascending() {
    throw new Error("<SortIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ascending(value) {
    throw new Error("<SortIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SortIcon_default = SortIcon;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/AuthSelect.svelte
var file37 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/AuthSelect.svelte";
function add_css27(target) {
  append_styles(target, "svelte-1ro278q", "label.svelte-1ro278q{margin-top:1rem;display:block;text-transform:uppercase;font-weight:normal;font-size:14px;font-style:normal}select.svelte-1ro278q{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0.3rem 0.6rem;width:100%;border:1px solid var(--grey-200);font-family:var(--ui-font-family);color:var(--grey-800);margin:0.5em 0 0 0;transition:all 400ms;cursor:pointer}select.svelte-1ro278q:hover{border:1px solid var(--grey-300);transition:all 400ms;box-shadow:0 5px 5px 2px hsl(0deg 0% 97%)}select.svelte-1ro278q:focus{outline:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXV0aFNlbGVjdC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBYUMsS0FBQSxlQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsT0FBQSxDQUFBLEtBQWMsQ0FDZCxjQUFBLENBQUEsU0FBeUIsQ0FDekIsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFNBQUEsQ0FBQSxJQUFlLENBQ2YsVUFBQSxDQUFBLE1BQWtCLEFBQ25CLENBQUEsQUFDQSxNQUFBLGVBQUEsQ0FBQSxBQUNDLGtCQUFBLENBQUEsSUFBd0IsQ0FDeEIsZUFBQSxDQUFBLElBQXFCLENBQ3JCLFVBQUEsQ0FBQSxJQUFnQixDQUNoQixPQUFBLENBQUEsTUFBQSxDQUFBLE1BQXNCLENBQ3RCLEtBQUEsQ0FBQSxJQUFXLENBQ1gsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLFdBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQWtDLENBQ2xDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsTUFBQSxDQUFBLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQW1CLENBQ25CLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBcUIsQ0FDckIsTUFBQSxDQUFBLE9BQWUsQUFDaEIsQ0FBQSxBQUVBLHFCQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBcUIsQ0FDckIsVUFBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxJQUFBLElBQUEsQ0FBQSxFQUFBLENBQUEsR0FBQSxDQUEwQyxBQUMzQyxDQUFBLEFBRUEscUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQXV0aFNlbGVjdC5zdmVsdGUiXX0= */");
}
function get_each_context11(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block11(ctx) {
  let option;
  let t_value = (
    /*option*/
    ctx[3].description + ""
  );
  let t;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*option*/
      ctx[3].value;
      option.value = option.__value;
      add_location(option, file37, 8, 2, 220);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*options*/
      2 && t_value !== (t_value = /*option*/
      ctx2[3].description + ""))
        set_data_dev(t, t_value);
      if (dirty & /*options*/
      2 && option_value_value !== (option_value_value = /*option*/
      ctx2[3].value)) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block11.name,
    type: "each",
    source: "(8:1) {#each options as option}",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let label;
  let t0;
  let t1;
  let select;
  let mounted;
  let dispose;
  let each_value = (
    /*options*/
    ctx[1]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block11(get_each_context11(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      label = element("label");
      t0 = text("Authentication Method");
      t1 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      t0 = claim_text(label_nodes, "Authentication Method");
      label_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      select = claim_element(nodes, "SELECT", { name: true, id: true, class: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label, "for", "auth-select");
      attr_dev(label, "class", "svelte-1ro278q");
      add_location(label, file37, 5, 0, 68);
      attr_dev(select, "name", "auth-methods");
      attr_dev(select, "id", "auth-select");
      attr_dev(select, "class", "svelte-1ro278q");
      if (
        /*selected*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[2].call(select)
        ));
      add_location(select, file37, 6, 0, 123);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, select, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(
        select,
        /*selected*/
        ctx[0]
      );
      if (!mounted) {
        dispose = listen_dev(
          select,
          "change",
          /*select_change_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*options*/
      2) {
        each_value = /*options*/
        ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context11(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block11(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selected, options*/
      3) {
        select_option(
          select,
          /*selected*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(select);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AuthSelect", slots, []);
  let { options = [] } = $$props;
  let { selected } = $$props;
  $$self.$$.on_mount.push(function() {
    if (selected === void 0 && !("selected" in $$props || $$self.$$.bound[$$self.$$.props["selected"]])) {
      console.warn("<AuthSelect> was created without expected prop 'selected'");
    }
  });
  const writable_props = ["options", "selected"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AuthSelect> was created with unknown prop '${key}'`);
  });
  function select_change_handler() {
    selected = select_value(this);
    $$invalidate(0, selected);
    $$invalidate(1, options);
  }
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  $$self.$capture_state = () => ({ options, selected });
  $$self.$inject_state = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [selected, options, select_change_handler];
}
var AuthSelect = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, { options: 1, selected: 0 }, add_css27);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AuthSelect",
      options,
      id: create_fragment39.name
    });
  }
  get options() {
    throw new Error("<AuthSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<AuthSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<AuthSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<AuthSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AuthSelect_default = AuthSelect;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/BigqueryForm.svelte
var file38 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/BigqueryForm.svelte";
function add_css28(target) {
  append_styles(target, "svelte-mqsuoi", "div.input-item.svelte-mqsuoi{font-family:var(--ui-font-family);color:var(--grey-999);font-size:16px;margin-top:1.25em;display:flex;flex-direction:row;align-items:center}input.svelte-mqsuoi{box-sizing:border-box;border-radius:4px 4px 4px 4px;border:1px solid var(--grey-300);padding:0.25em 0.25em 0.25em 0.25em;margin-left:auto;width:65%;padding:0.35em;color:var(--grey-999);-webkit-appearance:none;-moz-appearance:none;vertical-align:middle;font-size:14px}input.svelte-mqsuoi:required{box-shadow:none}input.svelte-mqsuoi:focus{outline:none}input.svelte-mqsuoi:disabled{background-color:var(--grey-100);cursor:not-allowed}label.svelte-mqsuoi{width:30%;text-transform:uppercase;font-weight:normal;font-size:14px;color:var(--grey-800)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmlncXVlcnlGb3JtLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpSEMsR0FBQSxXQUFBLGNBQUEsQ0FBQSxBQUNDLFdBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQWtDLENBQ2xDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsU0FBQSxDQUFBLElBQWUsQ0FDZixVQUFBLENBQUEsTUFBa0IsQ0FDbEIsT0FBQSxDQUFBLElBQWEsQ0FDYixjQUFBLENBQUEsR0FBbUIsQ0FDbkIsV0FBQSxDQUFBLE1BQW1CLEFBQ3BCLENBQUEsQUFFQSxLQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixhQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBOEIsQ0FDOUIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxNQUFBLENBQUEsTUFBQSxDQUFBLE1BQUEsQ0FBQSxNQUFvQyxDQUNwQyxXQUFBLENBQUEsSUFBaUIsQ0FDakIsS0FBQSxDQUFBLEdBQVUsQ0FDVixPQUFBLENBQUEsTUFBZSxDQUNmLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsa0JBQUEsQ0FBQSxJQUF3QixDQUN4QixlQUFBLENBQUEsSUFBcUIsQ0FDckIsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLEFBQ2hCLENBQUEsQUFDQSxtQkFBQSxTQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBQ0EsbUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFDQSxtQkFBQSxTQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE1BQUEsQ0FBQSxXQUFtQixBQUNwQixDQUFBLEFBRUEsS0FBQSxjQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsR0FBVSxDQUNWLGNBQUEsQ0FBQSxTQUF5QixDQUN6QixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsU0FBQSxDQUFBLElBQWUsQ0FDZixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQmlncXVlcnlGb3JtLnN2ZWx0ZSJdfQ== */");
}
function create_else_block_16(ctx) {
  let div0;
  let p;
  let t0;
  let a;
  let t1;
  let t2;
  let t3;
  let pre;
  let code;
  let t4;
  let t5;
  let div1;
  let label;
  let t6;
  let t7;
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div0 = element("div");
      p = element("p");
      t0 = text("If you have the ");
      a = element("a");
      t1 = text("gcloud CLI");
      t2 = text(" installed, you can log in to BigQuery using the following command. Evidence will use the credentials\n			stored by the gcloud CLI to connect to BigQuery.");
      t3 = space();
      pre = element("pre");
      code = element("code");
      t4 = text("gcloud auth application-default login");
      t5 = space();
      div1 = element("div");
      label = element("label");
      t6 = text("Project ID");
      t7 = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      p = claim_element(div0_nodes, "P", {});
      var p_nodes = children(p);
      t0 = claim_text(p_nodes, "If you have the ");
      a = claim_element(p_nodes, "A", { rel: true, target: true, href: true });
      var a_nodes = children(a);
      t1 = claim_text(a_nodes, "gcloud CLI");
      a_nodes.forEach(detach_dev);
      t2 = claim_text(p_nodes, " installed, you can log in to BigQuery using the following command. Evidence will use the credentials\n			stored by the gcloud CLI to connect to BigQuery.");
      p_nodes.forEach(detach_dev);
      t3 = claim_space(div0_nodes);
      pre = claim_element(div0_nodes, "PRE", {});
      var pre_nodes = children(pre);
      code = claim_element(pre_nodes, "CODE", { class: true });
      var code_nodes = children(code);
      t4 = claim_text(code_nodes, "gcloud auth application-default login");
      code_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t5 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      label = claim_element(div1_nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      t6 = claim_text(label_nodes, "Project ID");
      label_nodes.forEach(detach_dev);
      t7 = claim_space(div1_nodes);
      input = claim_element(div1_nodes, "INPUT", { type: true, id: true, class: true });
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "rel", "noreferrer");
      attr_dev(a, "target", "_blank");
      attr_dev(a, "href", "https://cloud.google.com/sdk/gcloud");
      add_location(a, file38, 98, 19, 2382);
      add_location(p, file38, 97, 2, 2359);
      attr_dev(code, "class", "block p-1");
      add_location(code, file38, 103, 7, 2652);
      add_location(pre, file38, 103, 2, 2647);
      attr_dev(div0, "class", "mt-5");
      add_location(div0, file38, 96, 1, 2338);
      attr_dev(label, "for", "project-id");
      attr_dev(label, "class", "svelte-mqsuoi");
      add_location(label, file38, 107, 2, 2764);
      attr_dev(input, "type", "text");
      attr_dev(input, "id", "project-id");
      attr_dev(input, "class", "svelte-mqsuoi");
      add_location(input, file38, 108, 2, 2811);
      attr_dev(div1, "class", "input-item svelte-mqsuoi");
      add_location(div1, file38, 106, 1, 2737);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      append_hydration_dev(div0, p);
      append_hydration_dev(p, t0);
      append_hydration_dev(p, a);
      append_hydration_dev(a, t1);
      append_hydration_dev(p, t2);
      append_hydration_dev(div0, t3);
      append_hydration_dev(div0, pre);
      append_hydration_dev(pre, code);
      append_hydration_dev(code, t4);
      insert_hydration_dev(target, t5, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, label);
      append_hydration_dev(label, t6);
      append_hydration_dev(div1, t7);
      append_hydration_dev(div1, input);
      set_input_value(
        input,
        /*credentials*/
        ctx[0].project_id
      );
      if (!mounted) {
        dispose = listen_dev(
          input,
          "input",
          /*input_input_handler*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*credentials*/
      1 && input.value !== /*credentials*/
      ctx2[0].project_id) {
        set_input_value(
          input,
          /*credentials*/
          ctx2[0].project_id
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div0);
      if (detaching)
        detach_dev(t5);
      if (detaching)
        detach_dev(div1);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_16.name,
    type: "else",
    source: "(95:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_210(ctx) {
  let div0;
  let label0;
  let t0;
  let t1;
  let input0;
  let t2;
  let div1;
  let label1;
  let t3;
  let t4;
  let input1;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div0 = element("div");
      label0 = element("label");
      t0 = text("Project ID");
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      t3 = text("Access Token");
      t4 = space();
      input1 = element("input");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      label0 = claim_element(div0_nodes, "LABEL", { for: true, class: true });
      var label0_nodes = children(label0);
      t0 = claim_text(label0_nodes, "Project ID");
      label0_nodes.forEach(detach_dev);
      t1 = claim_space(div0_nodes);
      input0 = claim_element(div0_nodes, "INPUT", { type: true, id: true, class: true });
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      label1 = claim_element(div1_nodes, "LABEL", { for: true, class: true });
      var label1_nodes = children(label1);
      t3 = claim_text(label1_nodes, "Access Token");
      label1_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      input1 = claim_element(div1_nodes, "INPUT", { type: true, id: true, class: true });
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label0, "for", "project-id");
      attr_dev(label0, "class", "svelte-mqsuoi");
      add_location(label0, file38, 87, 2, 2039);
      attr_dev(input0, "type", "text");
      attr_dev(input0, "id", "project-id");
      attr_dev(input0, "class", "svelte-mqsuoi");
      add_location(input0, file38, 88, 2, 2086);
      attr_dev(div0, "class", "input-item svelte-mqsuoi");
      add_location(div0, file38, 86, 1, 2012);
      attr_dev(label1, "for", "token");
      attr_dev(label1, "class", "svelte-mqsuoi");
      add_location(label1, file38, 91, 2, 2196);
      attr_dev(input1, "type", "text");
      attr_dev(input1, "id", "token");
      attr_dev(input1, "class", "svelte-mqsuoi");
      add_location(input1, file38, 92, 2, 2240);
      attr_dev(div1, "class", "input-item svelte-mqsuoi");
      add_location(div1, file38, 90, 1, 2169);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      append_hydration_dev(div0, label0);
      append_hydration_dev(label0, t0);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div0, input0);
      set_input_value(
        input0,
        /*credentials*/
        ctx[0].project_id
      );
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, label1);
      append_hydration_dev(label1, t3);
      append_hydration_dev(div1, t4);
      append_hydration_dev(div1, input1);
      set_input_value(
        input1,
        /*credentials*/
        ctx[0].token
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[9]
          ),
          listen_dev(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*credentials*/
      1 && input0.value !== /*credentials*/
      ctx2[0].project_id) {
        set_input_value(
          input0,
          /*credentials*/
          ctx2[0].project_id
        );
      }
      if (dirty & /*credentials*/
      1 && input1.value !== /*credentials*/
      ctx2[0].token) {
        set_input_value(
          input1,
          /*credentials*/
          ctx2[0].token
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div0);
      if (detaching)
        detach_dev(t2);
      if (detaching)
        detach_dev(div1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(86:48) ",
    ctx
  });
  return block;
}
function create_if_block25(ctx) {
  let div0;
  let label0;
  let t0;
  let t1;
  let t2;
  let div1;
  let label1;
  let t3;
  let t4;
  let input0;
  let input0_value_value;
  let t5;
  let div2;
  let label2;
  let t6;
  let t7;
  let input1;
  let input1_value_value;
  let t8;
  let div3;
  let label3;
  let t9;
  let t10;
  let input2;
  let input2_value_value;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*credentials*/
      ctx2[0].project_id
    )
      return create_if_block_111;
    return create_else_block11;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div0 = element("div");
      label0 = element("label");
      t0 = text("JSON Keyfile");
      t1 = space();
      if_block.c();
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      t3 = text("Project ID");
      t4 = space();
      input0 = element("input");
      t5 = space();
      div2 = element("div");
      label2 = element("label");
      t6 = text("Private Key");
      t7 = space();
      input1 = element("input");
      t8 = space();
      div3 = element("div");
      label3 = element("label");
      t9 = text("Client Email");
      t10 = space();
      input2 = element("input");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      label0 = claim_element(div0_nodes, "LABEL", { for: true, class: true });
      var label0_nodes = children(label0);
      t0 = claim_text(label0_nodes, "JSON Keyfile");
      label0_nodes.forEach(detach_dev);
      t1 = claim_space(div0_nodes);
      if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      label1 = claim_element(div1_nodes, "LABEL", { for: true, class: true });
      var label1_nodes = children(label1);
      t3 = claim_text(label1_nodes, "Project ID");
      label1_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      input0 = claim_element(div1_nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        class: true
      });
      div1_nodes.forEach(detach_dev);
      t5 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      label2 = claim_element(div2_nodes, "LABEL", { for: true, class: true });
      var label2_nodes = children(label2);
      t6 = claim_text(label2_nodes, "Private Key");
      label2_nodes.forEach(detach_dev);
      t7 = claim_space(div2_nodes);
      input1 = claim_element(div2_nodes, "INPUT", { type: true, id: true, class: true });
      div2_nodes.forEach(detach_dev);
      t8 = claim_space(nodes);
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      label3 = claim_element(div3_nodes, "LABEL", { for: true, class: true });
      var label3_nodes = children(label3);
      t9 = claim_text(label3_nodes, "Client Email");
      label3_nodes.forEach(detach_dev);
      t10 = claim_space(div3_nodes);
      input2 = claim_element(div3_nodes, "INPUT", { type: true, id: true, class: true });
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b, _c;
      attr_dev(label0, "for", "file-input");
      attr_dev(label0, "class", "svelte-mqsuoi");
      add_location(label0, file38, 47, 2, 1045);
      attr_dev(div0, "class", "input-item svelte-mqsuoi");
      add_location(div0, file38, 46, 1, 1018);
      attr_dev(label1, "for", "project");
      attr_dev(label1, "class", "svelte-mqsuoi");
      add_location(label1, file38, 68, 2, 1442);
      attr_dev(input0, "type", "text");
      attr_dev(input0, "id", "project");
      attr_dev(input0, "name", "project");
      input0.value = input0_value_value = /*credentials*/
      ((_a = ctx[0]) == null ? void 0 : _a.project_id) ?? " ";
      input0.disabled = true;
      attr_dev(input0, "class", "svelte-mqsuoi");
      add_location(input0, file38, 69, 2, 1486);
      attr_dev(div1, "class", "input-item svelte-mqsuoi");
      add_location(div1, file38, 67, 1, 1415);
      attr_dev(label2, "for", "private-key");
      attr_dev(label2, "class", "svelte-mqsuoi");
      add_location(label2, file38, 78, 2, 1637);
      attr_dev(input1, "type", "password");
      attr_dev(input1, "id", "private-key");
      input1.value = input1_value_value = /*credentials*/
      ((_b = ctx[0]) == null ? void 0 : _b.private_key) ?? "";
      input1.disabled = true;
      attr_dev(input1, "class", "svelte-mqsuoi");
      add_location(input1, file38, 79, 2, 1686);
      attr_dev(div2, "class", "input-item svelte-mqsuoi");
      add_location(div2, file38, 77, 1, 1610);
      attr_dev(label3, "for", "client-email");
      attr_dev(label3, "class", "svelte-mqsuoi");
      add_location(label3, file38, 82, 2, 1813);
      attr_dev(input2, "type", "text");
      attr_dev(input2, "id", "client-email");
      input2.value = input2_value_value = /*credentials*/
      ((_c = ctx[0]) == null ? void 0 : _c.client_email) ?? " ";
      input2.disabled = true;
      attr_dev(input2, "class", "svelte-mqsuoi");
      add_location(input2, file38, 83, 2, 1864);
      attr_dev(div3, "class", "input-item svelte-mqsuoi");
      add_location(div3, file38, 81, 1, 1786);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      append_hydration_dev(div0, label0);
      append_hydration_dev(label0, t0);
      append_hydration_dev(div0, t1);
      if_block.m(div0, null);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, label1);
      append_hydration_dev(label1, t3);
      append_hydration_dev(div1, t4);
      append_hydration_dev(div1, input0);
      insert_hydration_dev(target, t5, anchor);
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, label2);
      append_hydration_dev(label2, t6);
      append_hydration_dev(div2, t7);
      append_hydration_dev(div2, input1);
      insert_hydration_dev(target, t8, anchor);
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, label3);
      append_hydration_dev(label3, t9);
      append_hydration_dev(div3, t10);
      append_hydration_dev(div3, input2);
    },
    p: function update(ctx2, dirty) {
      var _a, _b, _c;
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
      if (dirty & /*credentials*/
      1 && input0_value_value !== (input0_value_value = /*credentials*/
      ((_a = ctx2[0]) == null ? void 0 : _a.project_id) ?? " ") && input0.value !== input0_value_value) {
        prop_dev(input0, "value", input0_value_value);
      }
      if (dirty & /*credentials*/
      1 && input1_value_value !== (input1_value_value = /*credentials*/
      ((_b = ctx2[0]) == null ? void 0 : _b.private_key) ?? "") && input1.value !== input1_value_value) {
        prop_dev(input1, "value", input1_value_value);
      }
      if (dirty & /*credentials*/
      1 && input2_value_value !== (input2_value_value = /*credentials*/
      ((_c = ctx2[0]) == null ? void 0 : _c.client_email) ?? " ") && input2.value !== input2_value_value) {
        prop_dev(input2, "value", input2_value_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div0);
      if_block.d();
      if (detaching)
        detach_dev(t2);
      if (detaching)
        detach_dev(div1);
      if (detaching)
        detach_dev(t5);
      if (detaching)
        detach_dev(div2);
      if (detaching)
        detach_dev(t8);
      if (detaching)
        detach_dev(div3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(46:0) {#if credentials.authenticator === 'service-account'}",
    ctx
  });
  return block;
}
function create_else_block11(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        id: true,
        type: true,
        accept: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "id", "file-input");
      attr_dev(input, "type", "file");
      attr_dev(input, "accept", "application/json");
      input.required = true;
      attr_dev(input, "class", "svelte-mqsuoi");
      add_location(input, file38, 57, 3, 1262);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[8]
          ),
          listen_dev(
            input,
            "change",
            /*handleUpload*/
            ctx[2],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(57:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        id: true,
        type: true,
        accept: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "id", "file-input");
      attr_dev(input, "type", "file");
      attr_dev(input, "accept", "application/json");
      attr_dev(input, "class", "svelte-mqsuoi");
      add_location(input, file38, 49, 3, 1126);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[7]
          ),
          listen_dev(
            input,
            "change",
            /*handleUpload*/
            ctx[2],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(49:2) {#if credentials.project_id}",
    ctx
  });
  return block;
}
function create_fragment40(ctx) {
  let authselect;
  let updating_selected;
  let t;
  let if_block_anchor;
  let current;
  function authselect_selected_binding(value) {
    ctx[6](value);
  }
  let authselect_props = { options: (
    /*options*/
    ctx[3]
  ) };
  if (
    /*credentials*/
    ctx[0].authenticator !== void 0
  ) {
    authselect_props.selected = /*credentials*/
    ctx[0].authenticator;
  }
  authselect = new AuthSelect_default({ props: authselect_props, $$inline: true });
  binding_callbacks.push(() => bind(
    authselect,
    "selected",
    authselect_selected_binding,
    /*credentials*/
    ctx[0].authenticator
  ));
  function select_block_type(ctx2, dirty) {
    if (
      /*credentials*/
      ctx2[0].authenticator === "service-account"
    )
      return create_if_block25;
    if (
      /*credentials*/
      ctx2[0].authenticator === "oauth"
    )
      return create_if_block_210;
    return create_else_block_16;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      create_component(authselect.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(authselect.$$.fragment, nodes);
      t = claim_space(nodes);
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(authselect, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const authselect_changes = {};
      if (!updating_selected && dirty & /*credentials*/
      1) {
        updating_selected = true;
        authselect_changes.selected = /*credentials*/
        ctx2[0].authenticator;
        add_flush_callback(() => updating_selected = false);
      }
      authselect.$set(authselect_changes);
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(authselect.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(authselect.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(authselect, detaching);
      if (detaching)
        detach_dev(t);
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude37 = true;
function instance40($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BigqueryForm", slots, []);
  let { credentials } = $$props;
  let { existingCredentials } = $$props;
  let { disableSave } = $$props;
  credentials = { ...existingCredentials };
  credentials.project_id = credentials.project_id ?? "";
  credentials.authenticator = credentials.authenticator ?? "service-account";
  let files;
  async function handleUpload() {
    for (const file68 of files) {
      const fileContents = await file68.text();
      $$invalidate(0, credentials = {
        ...credentials,
        ...JSON.parse(fileContents)
      });
    }
    $$invalidate(4, disableSave = false);
  }
  const options = [
    {
      value: "service-account",
      description: "Service Account (default)"
    },
    {
      value: "gcloud-cli",
      description: "GCloud CLI"
    },
    {
      value: "oauth",
      description: "OAuth Access Token"
    }
  ];
  $$self.$$.on_mount.push(function() {
    if (credentials === void 0 && !("credentials" in $$props || $$self.$$.bound[$$self.$$.props["credentials"]])) {
      console.warn("<BigqueryForm> was created without expected prop 'credentials'");
    }
    if (existingCredentials === void 0 && !("existingCredentials" in $$props || $$self.$$.bound[$$self.$$.props["existingCredentials"]])) {
      console.warn("<BigqueryForm> was created without expected prop 'existingCredentials'");
    }
    if (disableSave === void 0 && !("disableSave" in $$props || $$self.$$.bound[$$self.$$.props["disableSave"]])) {
      console.warn("<BigqueryForm> was created without expected prop 'disableSave'");
    }
  });
  const writable_props = ["credentials", "existingCredentials", "disableSave"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BigqueryForm> was created with unknown prop '${key}'`);
  });
  function authselect_selected_binding(value) {
    if ($$self.$$.not_equal(credentials.authenticator, value)) {
      credentials.authenticator = value;
      $$invalidate(0, credentials);
    }
  }
  function input_change_handler() {
    files = this.files;
    $$invalidate(1, files);
  }
  function input_change_handler_1() {
    files = this.files;
    $$invalidate(1, files);
  }
  function input0_input_handler() {
    credentials.project_id = this.value;
    $$invalidate(0, credentials);
  }
  function input1_input_handler() {
    credentials.token = this.value;
    $$invalidate(0, credentials);
  }
  function input_input_handler() {
    credentials.project_id = this.value;
    $$invalidate(0, credentials);
  }
  $$self.$$set = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(5, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(4, disableSave = $$props2.disableSave);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude37,
    AuthSelect: AuthSelect_default,
    credentials,
    existingCredentials,
    disableSave,
    files,
    handleUpload,
    options
  });
  $$self.$inject_state = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(5, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(4, disableSave = $$props2.disableSave);
    if ("files" in $$props2)
      $$invalidate(1, files = $$props2.files);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*credentials*/
    1) {
      $:
        $$invalidate(4, disableSave = !credentials.project_id);
    }
  };
  return [
    credentials,
    files,
    handleUpload,
    options,
    disableSave,
    existingCredentials,
    authselect_selected_binding,
    input_change_handler,
    input_change_handler_1,
    input0_input_handler,
    input1_input_handler,
    input_input_handler
  ];
}
var BigqueryForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance40,
      create_fragment40,
      safe_not_equal,
      {
        credentials: 0,
        existingCredentials: 5,
        disableSave: 4
      },
      add_css28
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BigqueryForm",
      options,
      id: create_fragment40.name
    });
  }
  get credentials() {
    throw new Error("<BigqueryForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set credentials(value) {
    throw new Error("<BigqueryForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get existingCredentials() {
    throw new Error("<BigqueryForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set existingCredentials(value) {
    throw new Error("<BigqueryForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableSave() {
    throw new Error("<BigqueryForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableSave(value) {
    throw new Error("<BigqueryForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BigqueryForm_default = BigqueryForm;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/CSVForm.svelte
var file39 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/CSVForm.svelte";
function add_css29(target) {
  append_styles(target, "svelte-pu5j3m", "span.additional-info-icon.svelte-pu5j3m.svelte-pu5j3m{width:18px;color:var(--grey-600);display:inline-block;vertical-align:middle;line-height:1em;cursor:help;position:relative;text-transform:none}div.input-item.svelte-pu5j3m.svelte-pu5j3m{font-family:var(--ui-font-family);color:var(--grey-999);font-size:16px;margin-top:1.25em;display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;justify-content:space-between}label.svelte-pu5j3m.svelte-pu5j3m{text-transform:uppercase;font-weight:normal;font-size:14px;color:var(--grey-800);white-space:nowrap}.additional-info-icon.svelte-pu5j3m .info-msg.svelte-pu5j3m{visibility:hidden;position:absolute;top:-5px;left:105%;white-space:nowrap;padding-left:5px;padding-right:5px;padding-top:2px;padding-bottom:1px;color:white;font-family:sans-serif;font-size:0.8em;background-color:var(--grey-900);opacity:0.85;border-radius:6px;z-index:1}.additional-info-icon.svelte-pu5j3m:hover .info-msg.svelte-pu5j3m{visibility:visible}.switch.svelte-pu5j3m.svelte-pu5j3m{position:relative;display:inline-block;width:2.8rem;height:1.75rem;margin-left:auto;margin-right:2px}.switch.svelte-pu5j3m input.svelte-pu5j3m{opacity:0;width:0;height:0}.slider.svelte-pu5j3m.svelte-pu5j3m{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;transition:0.4s;border-radius:25px}.slider.svelte-pu5j3m.svelte-pu5j3m:before{position:absolute;content:'';height:1.25rem;width:1.25rem;left:4px;bottom:4px;background-color:white;transition:0.4s;border-radius:50%;box-shadow:0px 1px 2px var(--grey-500)}input.svelte-pu5j3m:checked+.slider.svelte-pu5j3m{background-color:var(--green-500)}input.svelte-pu5j3m:checked+.slider.svelte-pu5j3m:before{transform:translateX(1.1rem)}.docs-link.svelte-pu5j3m.svelte-pu5j3m{color:var(--blue-600);text-decoration:none}.docs-link.svelte-pu5j3m.svelte-pu5j3m:hover{color:var(--blue-800)}div.code-container.svelte-pu5j3m.svelte-pu5j3m{background-color:var(--grey-100);border:1px solid var(--grey-200);overflow:auto;border-radius:4px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ1NWRm9ybS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUZDLElBQUEscUJBQUEsNEJBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFXLENBQ1gsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixPQUFBLENBQUEsWUFBcUIsQ0FDckIsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLFdBQUEsQ0FBQSxHQUFnQixDQUNoQixNQUFBLENBQUEsSUFBWSxDQUNaLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixjQUFBLENBQUEsSUFBb0IsQUFDckIsQ0FBQSxBQUVBLEdBQUEsV0FBQSw0QkFBQSxDQUFBLEFBQ0MsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixTQUFBLENBQUEsSUFBZSxDQUNmLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixPQUFBLENBQUEsSUFBYSxDQUNiLGNBQUEsQ0FBQSxHQUFtQixDQUNuQixTQUFBLENBQUEsSUFBZSxDQUNmLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixlQUFBLENBQUEsYUFBOEIsQUFDL0IsQ0FBQSxBQUVBLEtBQUEsNEJBQUEsQ0FBQSxBQUNDLGNBQUEsQ0FBQSxTQUF5QixDQUN6QixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsU0FBQSxDQUFBLElBQWUsQ0FDZixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFdBQUEsQ0FBQSxNQUFtQixBQUNwQixDQUFBLEFBRUEsbUNBQUEsQ0FBQSxTQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixRQUFBLENBQUEsUUFBa0IsQ0FDbEIsR0FBQSxDQUFBLElBQVMsQ0FDVCxJQUFBLENBQUEsSUFBVSxDQUNWLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixZQUFBLENBQUEsR0FBaUIsQ0FDakIsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLFdBQUEsQ0FBQSxHQUFnQixDQUNoQixjQUFBLENBQUEsR0FBbUIsQ0FDbkIsS0FBQSxDQUFBLEtBQVksQ0FDWixXQUFBLENBQUEsVUFBdUIsQ0FDdkIsU0FBQSxDQUFBLEtBQWdCLENBQ2hCLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxJQUFhLENBQ2IsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLE9BQUEsQ0FBQSxDQUFVLEFBQ1gsQ0FBQSxBQUVBLG1DQUFBLE1BQUEsQ0FBQSxTQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxPQUFtQixBQUNwQixDQUFBLEFBRUEsT0FBQSw0QkFBQSxDQUFBLEFBQ0MsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLE9BQUEsQ0FBQSxZQUFxQixDQUNyQixLQUFBLENBQUEsTUFBYSxDQUNiLE1BQUEsQ0FBQSxPQUFlLENBQ2YsV0FBQSxDQUFBLElBQWlCLENBQ2pCLFlBQUEsQ0FBQSxHQUFpQixBQUNsQixDQUFBLEFBRUEscUJBQUEsQ0FBQSxLQUFBLGNBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxDQUFVLENBQ1YsS0FBQSxDQUFBLENBQVEsQ0FDUixNQUFBLENBQUEsQ0FBUyxBQUNWLENBQUEsQUFFQSxPQUFBLDRCQUFBLENBQUEsQUFDQyxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsTUFBQSxDQUFBLE9BQWUsQ0FDZixHQUFBLENBQUEsQ0FBTSxDQUNOLElBQUEsQ0FBQSxDQUFPLENBQ1AsS0FBQSxDQUFBLENBQVEsQ0FDUixNQUFBLENBQUEsQ0FBUyxDQUNULGdCQUFBLENBQUEsSUFBc0IsQ0FDdEIsVUFBQSxDQUFBLElBQWdCLENBQ2hCLGFBQUEsQ0FBQSxJQUFtQixBQUNwQixDQUFBLEFBRUEsbUNBQUEsT0FBQSxBQUFBLENBQUEsQUFDQyxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsT0FBQSxDQUFBLEVBQVcsQ0FDWCxNQUFBLENBQUEsT0FBZSxDQUNmLEtBQUEsQ0FBQSxPQUFjLENBQ2QsSUFBQSxDQUFBLEdBQVMsQ0FDVCxNQUFBLENBQUEsR0FBVyxDQUNYLGdCQUFBLENBQUEsS0FBdUIsQ0FDdkIsVUFBQSxDQUFBLElBQWdCLENBQ2hCLGFBQUEsQ0FBQSxHQUFrQixDQUNsQixVQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsSUFBQSxVQUFBLENBQXVDLEFBQ3hDLENBQUEsQUFFQSxtQkFBQSxRQUFBLENBQUEsT0FBQSxjQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsV0FBQSxDQUFrQyxBQUNuQyxDQUFBLEFBRUEsbUJBQUEsUUFBQSxDQUFBLHFCQUFBLE9BQUEsQUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLFdBQUEsTUFBQSxDQUE2QixBQUM5QixDQUFBLEFBRUEsVUFBQSw0QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixlQUFBLENBQUEsSUFBcUIsQUFDdEIsQ0FBQSxBQUVBLHNDQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBLEFBRUEsR0FBQSxlQUFBLDRCQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsUUFBQSxDQUFBLElBQWMsQ0FDZCxhQUFBLENBQUEsR0FBa0IsQUFDbkIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDU1ZGb3JtLnN2ZWx0ZSJdfQ== */");
}
function create_if_block26(ctx) {
  let span1;
  let icon;
  let t0;
  let span0;
  let t1_value = (
    /*opts*/
    ctx[1][0].additionalInstructions + ""
  );
  let t1;
  let current;
  icon = new Icon_default({
    props: {
      src: InfoCircle,
      class: "h-4 -mr-1 text-gray-600"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span1 = element("span");
      create_component(icon.$$.fragment);
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      claim_component(icon.$$.fragment, span1_nodes);
      t0 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t1 = claim_text(span0_nodes, t1_value);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "info-msg svelte-pu5j3m");
      add_location(span0, file39, 71, 4, 1985);
      attr_dev(span1, "class", "additional-info-icon svelte-pu5j3m");
      add_location(span1, file39, 69, 3, 1883);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      mount_component(icon, span1, null);
      append_hydration_dev(span1, t0);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t1);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(69:2) {#if opts[0].additionalInstructions}",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let p0;
  let t0;
  let a;
  let t1;
  let t2;
  let p1;
  let t3;
  let code;
  let t4;
  let t5;
  let t6;
  let div0;
  let prism0;
  let t7;
  let p2;
  let t8;
  let t9;
  let div1;
  let prism1;
  let t10;
  let div2;
  let label0;
  let t11_value = (
    /*opts*/
    ctx[1][0].label + ""
  );
  let t11;
  let t12;
  let label0_for_value;
  let t13;
  let label1;
  let input;
  let t14;
  let span;
  let current;
  let mounted;
  let dispose;
  prism0 = new Prismjs_default({
    props: {
      language: "sql",
      code: (
        /*sourcesQuery*/
        ctx[3]
      )
    },
    $$inline: true
  });
  prism1 = new Prismjs_default({
    props: {
      language: "sql",
      code: (
        /*absoluteQuery*/
        ctx[4]
      )
    },
    $$inline: true
  });
  let if_block = (
    /*opts*/
    ctx[1][0].additionalInstructions && create_if_block26(ctx)
  );
  const block = {
    c: function create() {
      p0 = element("p");
      t0 = text("Evidence supports querying of local CSV files. CSV querying is powered by DuckDB - ");
      a = element("a");
      t1 = text("see the DuckDB docs for reference on query syntax");
      t2 = space();
      p1 = element("p");
      t3 = text("We recommend setting up a ");
      code = element("code");
      t4 = text("sources");
      t5 = text(" directory in the root of your Evidence project to store\n	CSV files. You can then query them using this syntax:");
      t6 = space();
      div0 = element("div");
      create_component(prism0.$$.fragment);
      t7 = space();
      p2 = element("p");
      t8 = text("You can also pass in an absolute filepath:");
      t9 = space();
      div1 = element("div");
      create_component(prism1.$$.fragment);
      t10 = space();
      div2 = element("div");
      label0 = element("label");
      t11 = text(t11_value);
      t12 = space();
      if (if_block)
        if_block.c();
      t13 = space();
      label1 = element("label");
      input = element("input");
      t14 = space();
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      p0 = claim_element(nodes, "P", { style: true });
      var p0_nodes = children(p0);
      t0 = claim_text(p0_nodes, "Evidence supports querying of local CSV files. CSV querying is powered by DuckDB - ");
      a = claim_element(p0_nodes, "A", {
        class: true,
        href: true,
        target: true,
        rel: true
      });
      var a_nodes = children(a);
      t1 = claim_text(a_nodes, "see the DuckDB docs for reference on query syntax");
      a_nodes.forEach(detach_dev);
      p0_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      p1 = claim_element(nodes, "P", {});
      var p1_nodes = children(p1);
      t3 = claim_text(p1_nodes, "We recommend setting up a ");
      code = claim_element(p1_nodes, "CODE", {});
      var code_nodes = children(code);
      t4 = claim_text(code_nodes, "sources");
      code_nodes.forEach(detach_dev);
      t5 = claim_text(p1_nodes, " directory in the root of your Evidence project to store\n	CSV files. You can then query them using this syntax:");
      p1_nodes.forEach(detach_dev);
      t6 = claim_space(nodes);
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(prism0.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t7 = claim_space(nodes);
      p2 = claim_element(nodes, "P", { style: true });
      var p2_nodes = children(p2);
      t8 = claim_text(p2_nodes, "You can also pass in an absolute filepath:");
      p2_nodes.forEach(detach_dev);
      t9 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(prism1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      t10 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      label0 = claim_element(div2_nodes, "LABEL", { for: true, class: true });
      var label0_nodes = children(label0);
      t11 = claim_text(label0_nodes, t11_value);
      t12 = claim_space(label0_nodes);
      if (if_block)
        if_block.l(label0_nodes);
      label0_nodes.forEach(detach_dev);
      t13 = claim_space(div2_nodes);
      label1 = claim_element(div2_nodes, "LABEL", { class: true });
      var label1_nodes = children(label1);
      input = claim_element(label1_nodes, "INPUT", { type: true, class: true });
      t14 = claim_space(label1_nodes);
      span = claim_element(label1_nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      label1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "class", "docs-link svelte-pu5j3m");
      attr_dev(a, "href", "https://duckdb.org/docs/sql/query_syntax/select");
      attr_dev(a, "target", "_blank");
      attr_dev(a, "rel", "noreferrer");
      add_location(a, file39, 44, 84, 1150);
      set_style(p0, "margin-top", "15px");
      add_location(p0, file39, 43, 0, 1036);
      add_location(code, file39, 53, 27, 1360);
      add_location(p1, file39, 52, 0, 1329);
      attr_dev(div0, "class", "code-container svelte-pu5j3m");
      add_location(div0, file39, 56, 0, 1497);
      set_style(p2, "margin-top", "15px");
      add_location(p2, file39, 60, 0, 1580);
      attr_dev(div1, "class", "code-container svelte-pu5j3m");
      add_location(div1, file39, 61, 0, 1656);
      attr_dev(label0, "for", label0_for_value = /*opts*/
      ctx[1][0].id);
      attr_dev(label0, "class", "flex items-center gap-1 svelte-pu5j3m");
      add_location(label0, file39, 66, 1, 1766);
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "class", "svelte-pu5j3m");
      add_location(input, file39, 77, 2, 2104);
      attr_dev(span, "class", "slider svelte-pu5j3m");
      add_location(span, file39, 78, 2, 2195);
      attr_dev(label1, "class", "switch svelte-pu5j3m");
      add_location(label1, file39, 76, 1, 2079);
      attr_dev(div2, "class", "input-item svelte-pu5j3m");
      add_location(div2, file39, 65, 0, 1740);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p0, anchor);
      append_hydration_dev(p0, t0);
      append_hydration_dev(p0, a);
      append_hydration_dev(a, t1);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, p1, anchor);
      append_hydration_dev(p1, t3);
      append_hydration_dev(p1, code);
      append_hydration_dev(code, t4);
      append_hydration_dev(p1, t5);
      insert_hydration_dev(target, t6, anchor);
      insert_hydration_dev(target, div0, anchor);
      mount_component(prism0, div0, null);
      insert_hydration_dev(target, t7, anchor);
      insert_hydration_dev(target, p2, anchor);
      append_hydration_dev(p2, t8);
      insert_hydration_dev(target, t9, anchor);
      insert_hydration_dev(target, div1, anchor);
      mount_component(prism1, div1, null);
      insert_hydration_dev(target, t10, anchor);
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, label0);
      append_hydration_dev(label0, t11);
      append_hydration_dev(label0, t12);
      if (if_block)
        if_block.m(label0, null);
      append_hydration_dev(div2, t13);
      append_hydration_dev(div2, label1);
      append_hydration_dev(label1, input);
      input.checked = /*credentials*/
      ctx[0][
        /*opts*/
        ctx[1][0].id
      ];
      append_hydration_dev(label1, t14);
      append_hydration_dev(label1, span);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[8]
          ),
          listen_dev(
            input,
            "change",
            /*handleCheck*/
            ctx[2],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*opts*/
        ctx2[1][0].additionalInstructions
      )
        if_block.p(ctx2, dirty);
      if (dirty & /*credentials, opts*/
      3) {
        input.checked = /*credentials*/
        ctx2[0][
          /*opts*/
          ctx2[1][0].id
        ];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prism0.$$.fragment, local);
      transition_in(prism1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(prism0.$$.fragment, local);
      transition_out(prism1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p0);
      if (detaching)
        detach_dev(t2);
      if (detaching)
        detach_dev(p1);
      if (detaching)
        detach_dev(t6);
      if (detaching)
        detach_dev(div0);
      destroy_component(prism0);
      if (detaching)
        detach_dev(t7);
      if (detaching)
        detach_dev(p2);
      if (detaching)
        detach_dev(t9);
      if (detaching)
        detach_dev(div1);
      destroy_component(prism1);
      if (detaching)
        detach_dev(t10);
      if (detaching)
        detach_dev(div2);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude38 = true;
function instance41($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CSVForm", slots, []);
  let { credentials } = $$props;
  let { existingCredentials } = $$props;
  let { gitIgnore } = $$props;
  existingCredentials.gitignoreCsv = gitIgnore ? gitIgnore.match(/.csv(?=|$)/) : false;
  let { disableSave } = $$props;
  credentials = { ...existingCredentials };
  credentials = {
    filename: ":memory:",
    gitignoreCsv: credentials.gitignoreCsv
  };
  let opts = [
    {
      id: "gitignoreCsv",
      label: "Gitignore all CSV files",
      type: "toggle",
      additionalInstructions: "If enabled, Evidence will gitignore .csv files",
      optional: false,
      override: false,
      value: credentials.gitignoreCsv ?? true
    }
  ];
  function handleCheck() {
    $$invalidate(6, disableSave = false);
  }
  let sourcesQuery = `select * from 'sources/myfile.csv'`;
  let absoluteQuery = `select * from '/Users/myname/Documents/myfile.csv'`;
  $$self.$$.on_mount.push(function() {
    if (credentials === void 0 && !("credentials" in $$props || $$self.$$.bound[$$self.$$.props["credentials"]])) {
      console.warn("<CSVForm> was created without expected prop 'credentials'");
    }
    if (existingCredentials === void 0 && !("existingCredentials" in $$props || $$self.$$.bound[$$self.$$.props["existingCredentials"]])) {
      console.warn("<CSVForm> was created without expected prop 'existingCredentials'");
    }
    if (gitIgnore === void 0 && !("gitIgnore" in $$props || $$self.$$.bound[$$self.$$.props["gitIgnore"]])) {
      console.warn("<CSVForm> was created without expected prop 'gitIgnore'");
    }
    if (disableSave === void 0 && !("disableSave" in $$props || $$self.$$.bound[$$self.$$.props["disableSave"]])) {
      console.warn("<CSVForm> was created without expected prop 'disableSave'");
    }
  });
  const writable_props = ["credentials", "existingCredentials", "gitIgnore", "disableSave"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CSVForm> was created with unknown prop '${key}'`);
  });
  function input_change_handler() {
    credentials[opts[0].id] = this.checked;
    $$invalidate(0, credentials);
  }
  $$self.$$set = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(5, existingCredentials = $$props2.existingCredentials);
    if ("gitIgnore" in $$props2)
      $$invalidate(7, gitIgnore = $$props2.gitIgnore);
    if ("disableSave" in $$props2)
      $$invalidate(6, disableSave = $$props2.disableSave);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude38,
    Icon: Icon_default,
    InfoCircle,
    Prism: Prismjs_default,
    credentials,
    existingCredentials,
    gitIgnore,
    disableSave,
    opts,
    handleCheck,
    sourcesQuery,
    absoluteQuery
  });
  $$self.$inject_state = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(5, existingCredentials = $$props2.existingCredentials);
    if ("gitIgnore" in $$props2)
      $$invalidate(7, gitIgnore = $$props2.gitIgnore);
    if ("disableSave" in $$props2)
      $$invalidate(6, disableSave = $$props2.disableSave);
    if ("opts" in $$props2)
      $$invalidate(1, opts = $$props2.opts);
    if ("sourcesQuery" in $$props2)
      $$invalidate(3, sourcesQuery = $$props2.sourcesQuery);
    if ("absoluteQuery" in $$props2)
      $$invalidate(4, absoluteQuery = $$props2.absoluteQuery);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    credentials,
    opts,
    handleCheck,
    sourcesQuery,
    absoluteQuery,
    existingCredentials,
    disableSave,
    gitIgnore,
    input_change_handler
  ];
}
var CSVForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance41,
      create_fragment41,
      safe_not_equal,
      {
        credentials: 0,
        existingCredentials: 5,
        gitIgnore: 7,
        disableSave: 6
      },
      add_css29
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CSVForm",
      options,
      id: create_fragment41.name
    });
  }
  get credentials() {
    throw new Error("<CSVForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set credentials(value) {
    throw new Error("<CSVForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get existingCredentials() {
    throw new Error("<CSVForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set existingCredentials(value) {
    throw new Error("<CSVForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gitIgnore() {
    throw new Error("<CSVForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gitIgnore(value) {
    throw new Error("<CSVForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableSave() {
    throw new Error("<CSVForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableSave(value) {
    throw new Error("<CSVForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CSVForm_default = CSVForm;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/InfoIcon.svelte
var file40 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/InfoIcon.svelte";
function add_css30(target) {
  append_styles(target, "svelte-173mpx9", "span.additional-info-icon.svelte-173mpx9.svelte-173mpx9{width:18px;color:var(--grey-600);display:inline-block;vertical-align:middle;line-height:1em;cursor:help;position:relative;text-transform:none}.additional-info-icon.svelte-173mpx9 .info-msg.svelte-173mpx9{position:absolute;top:-5px;left:105%;padding-left:5px;padding-right:5px;padding-top:2px;padding-bottom:1px;color:white;font-family:sans-serif;font-size:0.8em;background-color:var(--grey-900);opacity:0.85;border-radius:6px;z-index:1;max-width:200px;min-width:150px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5mb0ljb24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWdDQyxJQUFBLHFCQUFBLDhCQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBVyxDQUNYLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsT0FBQSxDQUFBLFlBQXFCLENBQ3JCLGNBQUEsQ0FBQSxNQUFzQixDQUN0QixXQUFBLENBQUEsR0FBZ0IsQ0FDaEIsTUFBQSxDQUFBLElBQVksQ0FDWixRQUFBLENBQUEsUUFBa0IsQ0FDbEIsY0FBQSxDQUFBLElBQW9CLEFBQ3JCLENBQUEsQUFFQSxvQ0FBQSxDQUFBLFNBQUEsZUFBQSxDQUFBLEFBQ0MsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLEdBQUEsQ0FBQSxJQUFTLENBQ1QsSUFBQSxDQUFBLElBQVUsQ0FDVixZQUFBLENBQUEsR0FBaUIsQ0FDakIsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLFdBQUEsQ0FBQSxHQUFnQixDQUNoQixjQUFBLENBQUEsR0FBbUIsQ0FDbkIsS0FBQSxDQUFBLEtBQVksQ0FDWixXQUFBLENBQUEsVUFBdUIsQ0FDdkIsU0FBQSxDQUFBLEtBQWdCLENBQ2hCLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxJQUFhLENBQ2IsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLE9BQUEsQ0FBQSxDQUFVLENBQ1YsU0FBQSxDQUFBLEtBQWdCLENBQ2hCLFNBQUEsQ0FBQSxLQUFnQixBQUNqQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkluZm9JY29uLnN2ZWx0ZSJdfQ== */");
}
function create_if_block27(ctx) {
  let span;
  let span_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "info-msg svelte-173mpx9");
      add_location(span, file40, 25, 2, 577);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, fade, {}, true);
        span_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (!span_transition)
        span_transition = create_bidirectional_transition(span, fade, {}, false);
      span_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && span_transition)
        span_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(25:1) {#if visible}",
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let span;
  let icon;
  let t;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: {
      src: InfoCircle,
      class: "h-5 text-gray-600 pb-0.5"
    },
    $$inline: true
  });
  let if_block = (
    /*visible*/
    ctx[0] && create_if_block27(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      create_component(icon.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      t = claim_space(span_nodes);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "additional-info-icon svelte-173mpx9");
      add_location(span, file40, 16, 0, 357);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(icon, span, null);
      append_hydration_dev(span, t);
      if (if_block)
        if_block.m(span, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            span,
            "focus",
            /*showMessage*/
            ctx[1],
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "blur",
            /*hideMessage*/
            ctx[2],
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "mouseenter",
            /*showMessage*/
            ctx[1],
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "mouseleave",
            /*hideMessage*/
            ctx[2],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*visible*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*visible*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block27(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      destroy_component(icon);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude39 = true;
function instance42($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InfoIcon", slots, ["default"]);
  let visible = false;
  const showMessage = () => $$invalidate(0, visible = true);
  const hideMessage = () => $$invalidate(0, visible = false);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InfoIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude39,
    Icon: Icon_default,
    InfoCircle,
    fade,
    visible,
    showMessage,
    hideMessage
  });
  $$self.$inject_state = ($$props2) => {
    if ("visible" in $$props2)
      $$invalidate(0, visible = $$props2.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [visible, showMessage, hideMessage, $$scope, slots];
}
var InfoIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {}, add_css30);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InfoIcon",
      options,
      id: create_fragment42.name
    });
  }
};
var InfoIcon_default = InfoIcon;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/GenericForm.svelte
var file41 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/GenericForm.svelte";
function add_css31(target) {
  append_styles(target, "svelte-us36jn", ".switch.svelte-us36jn.svelte-us36jn{position:relative;display:inline-block;width:2.8rem;height:1.75rem;margin-left:auto;margin-right:2px}.switch.svelte-us36jn input.svelte-us36jn{opacity:0;width:0;height:0}.slider.svelte-us36jn.svelte-us36jn{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;transition:0.4s;border-radius:25px}.slider.svelte-us36jn.svelte-us36jn:before{position:absolute;content:'';height:1.25rem;width:1.25rem;left:4px;bottom:4px;background-color:white;transition:0.4s;border-radius:50%;box-shadow:0px 1px 2px var(--grey-500)}input.svelte-us36jn:checked+.slider.svelte-us36jn{background-color:var(--green-500)}input.svelte-us36jn:checked+.slider.svelte-us36jn:before{transform:translateX(1.1rem)}div.input-item.svelte-us36jn.svelte-us36jn{font-family:var(--ui-font-family);color:var(--grey-999);font-size:16px;margin-top:1.1em;display:flex;flex-direction:row;flex-wrap:wrap;align-items:center}input.svelte-us36jn.svelte-us36jn{box-sizing:border-box;border-radius:4px 4px 4px 4px;border:1px solid var(--grey-300);padding:0.25em 0.25em 0.25em 0.25em;margin-left:auto;width:62%;padding:0.35em;color:var(--grey-999);-webkit-appearance:none;-moz-appearance:none;vertical-align:middle;font-size:14px}input.svelte-us36jn.svelte-us36jn:required{box-shadow:none}input.svelte-us36jn.svelte-us36jn:focus{outline:none}label.svelte-us36jn.svelte-us36jn{text-transform:uppercase;font-weight:normal;font-size:14px;color:var(--grey-800)}.separator.svelte-us36jn.svelte-us36jn{display:flex;align-items:center;text-align:center;-webkit-margin-before:2.5em;margin-block-start:2.5em;color:var(--grey-600);font-weight:bold}.separator.svelte-us36jn.svelte-us36jn::after{content:'';flex:1;border-bottom:1px solid var(--grey-200)}.separator.svelte-us36jn.svelte-us36jn:not(:empty)::after{margin-left:1.5em;margin-top:0.1em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2VuZXJpY0Zvcm0uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJIQyxPQUFBLDRCQUFBLENBQUEsQUFDQyxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsT0FBQSxDQUFBLFlBQXFCLENBQ3JCLEtBQUEsQ0FBQSxNQUFhLENBQ2IsTUFBQSxDQUFBLE9BQWUsQ0FDZixXQUFBLENBQUEsSUFBaUIsQ0FDakIsWUFBQSxDQUFBLEdBQWlCLEFBQ2xCLENBQUEsQUFFQSxxQkFBQSxDQUFBLEtBQUEsY0FBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLENBQVUsQ0FDVixLQUFBLENBQUEsQ0FBUSxDQUNSLE1BQUEsQ0FBQSxDQUFTLEFBQ1YsQ0FBQSxBQUVBLE9BQUEsNEJBQUEsQ0FBQSxBQUNDLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixNQUFBLENBQUEsT0FBZSxDQUNmLEdBQUEsQ0FBQSxDQUFNLENBQ04sSUFBQSxDQUFBLENBQU8sQ0FDUCxLQUFBLENBQUEsQ0FBUSxDQUNSLE1BQUEsQ0FBQSxDQUFTLENBQ1QsZ0JBQUEsQ0FBQSxJQUFzQixDQUN0QixVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsYUFBQSxDQUFBLElBQW1CLEFBQ3BCLENBQUEsQUFFQSxtQ0FBQSxPQUFBLEFBQUEsQ0FBQSxBQUNDLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixPQUFBLENBQUEsRUFBVyxDQUNYLE1BQUEsQ0FBQSxPQUFlLENBQ2YsS0FBQSxDQUFBLE9BQWMsQ0FDZCxJQUFBLENBQUEsR0FBUyxDQUNULE1BQUEsQ0FBQSxHQUFXLENBQ1gsZ0JBQUEsQ0FBQSxLQUF1QixDQUN2QixVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLFVBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBdUMsQUFDeEMsQ0FBQSxBQUVBLG1CQUFBLFFBQUEsQ0FBQSxPQUFBLGNBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxXQUFBLENBQWtDLEFBQ25DLENBQUEsQUFFQSxtQkFBQSxRQUFBLENBQUEscUJBQUEsT0FBQSxBQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsV0FBQSxNQUFBLENBQTZCLEFBQzlCLENBQUEsQUFFQSxHQUFBLFdBQUEsNEJBQUEsQ0FBQSxBQUNDLFdBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQWtDLENBQ2xDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsU0FBQSxDQUFBLElBQWUsQ0FDZixVQUFBLENBQUEsS0FBaUIsQ0FDakIsT0FBQSxDQUFBLElBQWEsQ0FDYixjQUFBLENBQUEsR0FBbUIsQ0FDbkIsU0FBQSxDQUFBLElBQWUsQ0FDZixXQUFBLENBQUEsTUFBbUIsQUFDcEIsQ0FBQSxBQUVBLEtBQUEsNEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixhQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBOEIsQ0FDOUIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxNQUFBLENBQUEsTUFBQSxDQUFBLE1BQUEsQ0FBQSxNQUFvQyxDQUNwQyxXQUFBLENBQUEsSUFBaUIsQ0FDakIsS0FBQSxDQUFBLEdBQVUsQ0FDVixPQUFBLENBQUEsTUFBZSxDQUNmLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsa0JBQUEsQ0FBQSxJQUF3QixDQUN4QixlQUFBLENBQUEsSUFBcUIsQ0FDckIsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLEFBQ2hCLENBQUEsQUFDQSxpQ0FBQSxTQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBQ0EsaUNBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFFQSxLQUFBLDRCQUFBLENBQUEsQUFDQyxjQUFBLENBQUEsU0FBeUIsQ0FDekIsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFNBQUEsQ0FBQSxJQUFlLENBQ2YsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBLEFBRUEsVUFBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQ0FDYixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsVUFBQSxDQUFBLE1BQWtCLENBQ2xCLHFCQUFBLENBQUEsS0FBNEIsQ0FDcEIsa0JBQUEsQ0FBQSxLQUF5QixDQUNqQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFdBQUEsQ0FBQSxJQUFpQixBQUNsQixDQUFBLEFBRUEsc0NBQUEsT0FBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsRUFBVyxDQUNYLElBQUEsQ0FBQSxDQUFPLENBQ1AsYUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXdDLEFBQ3pDLENBQUEsQUFFQSxzQ0FBQSxLQUFBLE1BQUEsQ0FBQSxPQUFBLEFBQUEsQ0FBQSxBQUNDLFdBQUEsQ0FBQSxLQUFrQixDQUNsQixVQUFBLENBQUEsS0FBaUIsQUFDbEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJHZW5lcmljRm9ybS5zdmVsdGUiXX0= */");
}
function get_each_context12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  child_ctx[14] = list;
  child_ctx[15] = i;
  return child_ctx;
}
function get_each_context_14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  child_ctx[16] = list;
  child_ctx[17] = i;
  return child_ctx;
}
function create_if_block_8(ctx) {
  let infoicon;
  let current;
  infoicon = new InfoIcon_default({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(infoicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(infoicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(infoicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const infoicon_changes = {};
      if (dirty & /*$$scope, requiredOpts*/
      262146) {
        infoicon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      infoicon.$set(infoicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(infoicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(infoicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(infoicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(48:3) {#if opt.additionalInstructions}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let t_value = (
    /*opt*/
    ctx[13].additionalInstructions + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*requiredOpts*/
      2 && t_value !== (t_value = /*opt*/
      ctx2[13].additionalInstructions + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(49:4) <InfoIcon>",
    ctx
  });
  return block;
}
function create_if_block_72(ctx) {
  let label;
  let input;
  let t;
  let span;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[8].call(
      input,
      /*opt*/
      ctx[13]
    );
  }
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t = space();
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      input = claim_element(label_nodes, "INPUT", { type: true, class: true });
      t = claim_space(label_nodes);
      span = claim_element(label_nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "class", "svelte-us36jn");
      add_location(input, file41, 74, 4, 1907);
      attr_dev(span, "class", "slider svelte-us36jn");
      add_location(span, file41, 75, 4, 1997);
      attr_dev(label, "class", "switch svelte-us36jn");
      add_location(label, file41, 73, 3, 1880);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, input);
      input.checked = /*credentials*/
      ctx[0][
        /*opt*/
        ctx[13].id
      ];
      append_hydration_dev(label, t);
      append_hydration_dev(label, span);
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", input_change_handler),
          listen_dev(
            input,
            "change",
            /*handleChange*/
            ctx[3],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*credentials, requiredOpts*/
      3) {
        input.checked = /*credentials*/
        ctx[0][
          /*opt*/
          ctx[13].id
        ];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_72.name,
    type: "if",
    source: "(73:34) ",
    ctx
  });
  return block;
}
function create_if_block_64(ctx) {
  let input;
  let input_id_value;
  let input_name_value;
  let input_data_test_id_value;
  let mounted;
  let dispose;
  function input_input_handler_1() {
    ctx[7].call(
      input,
      /*opt*/
      ctx[13]
    );
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        "data-test-id": true,
        placeholder: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "password");
      attr_dev(input, "id", input_id_value = /*opt*/
      ctx[13].id);
      attr_dev(input, "name", input_name_value = /*opt*/
      ctx[13].id);
      attr_dev(input, "data-test-id", input_data_test_id_value = /*opt*/
      ctx[13].dataTestId ?? /*opt*/
      ctx[13].id);
      attr_dev(input, "placeholder", "password");
      attr_dev(input, "class", "svelte-us36jn");
      add_location(input, file41, 63, 3, 1639);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*credentials*/
        ctx[0][
          /*opt*/
          ctx[13].id
        ]
      );
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", input_input_handler_1),
          listen_dev(
            input,
            "keyup",
            /*handleChange*/
            ctx[3],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*requiredOpts*/
      2 && input_id_value !== (input_id_value = /*opt*/
      ctx[13].id)) {
        attr_dev(input, "id", input_id_value);
      }
      if (dirty & /*requiredOpts*/
      2 && input_name_value !== (input_name_value = /*opt*/
      ctx[13].id)) {
        attr_dev(input, "name", input_name_value);
      }
      if (dirty & /*requiredOpts*/
      2 && input_data_test_id_value !== (input_data_test_id_value = /*opt*/
      ctx[13].dataTestId ?? /*opt*/
      ctx[13].id)) {
        attr_dev(input, "data-test-id", input_data_test_id_value);
      }
      if (dirty & /*credentials, requiredOpts*/
      3 && input.value !== /*credentials*/
      ctx[0][
        /*opt*/
        ctx[13].id
      ]) {
        set_input_value(
          input,
          /*credentials*/
          ctx[0][
            /*opt*/
            ctx[13].id
          ]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_64.name,
    type: "if",
    source: "(63:36) ",
    ctx
  });
  return block;
}
function create_if_block_54(ctx) {
  let input;
  let input_id_value;
  let input_name_value;
  let input_data_test_id_value;
  let input_placeholder_value;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[6].call(
      input,
      /*opt*/
      ctx[13]
    );
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        "data-test-id": true,
        placeholder: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "text");
      attr_dev(input, "id", input_id_value = /*opt*/
      ctx[13].id);
      attr_dev(input, "name", input_name_value = /*opt*/
      ctx[13].id);
      attr_dev(input, "data-test-id", input_data_test_id_value = /*opt*/
      ctx[13].dataTestId ?? /*opt*/
      ctx[13].id);
      attr_dev(input, "placeholder", input_placeholder_value = /*opt*/
      ctx[13].placeholder);
      attr_dev(input, "class", "svelte-us36jn");
      add_location(input, file41, 53, 3, 1393);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*credentials*/
        ctx[0][
          /*opt*/
          ctx[13].id
        ]
      );
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", input_input_handler),
          listen_dev(
            input,
            "keyup",
            /*handleChange*/
            ctx[3],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*requiredOpts*/
      2 && input_id_value !== (input_id_value = /*opt*/
      ctx[13].id)) {
        attr_dev(input, "id", input_id_value);
      }
      if (dirty & /*requiredOpts*/
      2 && input_name_value !== (input_name_value = /*opt*/
      ctx[13].id)) {
        attr_dev(input, "name", input_name_value);
      }
      if (dirty & /*requiredOpts*/
      2 && input_data_test_id_value !== (input_data_test_id_value = /*opt*/
      ctx[13].dataTestId ?? /*opt*/
      ctx[13].id)) {
        attr_dev(input, "data-test-id", input_data_test_id_value);
      }
      if (dirty & /*requiredOpts*/
      2 && input_placeholder_value !== (input_placeholder_value = /*opt*/
      ctx[13].placeholder)) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*credentials, requiredOpts*/
      3 && input.value !== /*credentials*/
      ctx[0][
        /*opt*/
        ctx[13].id
      ]) {
        set_input_value(
          input,
          /*credentials*/
          ctx[0][
            /*opt*/
            ctx[13].id
          ]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_54.name,
    type: "if",
    source: "(53:2) {#if opt.type === 'text'}",
    ctx
  });
  return block;
}
function create_each_block_14(ctx) {
  let div;
  let label;
  let t0_value = (
    /*opt*/
    ctx[13].label + ""
  );
  let t0;
  let t1;
  let label_for_value;
  let t2;
  let current;
  let if_block0 = (
    /*opt*/
    ctx[13].additionalInstructions && create_if_block_8(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*opt*/
      ctx2[13].type === "text"
    )
      return create_if_block_54;
    if (
      /*opt*/
      ctx2[13].type === "password"
    )
      return create_if_block_64;
    if (
      /*opt*/
      ctx2[13].type === "toggle"
    )
      return create_if_block_72;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      label = claim_element(div_nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      t0 = claim_text(label_nodes, t0_value);
      t1 = claim_space(label_nodes);
      if (if_block0)
        if_block0.l(label_nodes);
      label_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label, "for", label_for_value = /*opt*/
      ctx[13].id);
      attr_dev(label, "class", "flex items-center gap-1 svelte-us36jn");
      add_location(label, file41, 44, 2, 1182);
      attr_dev(div, "class", "input-item svelte-us36jn");
      add_location(div, file41, 43, 1, 1155);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, label);
      append_hydration_dev(label, t0);
      append_hydration_dev(label, t1);
      if (if_block0)
        if_block0.m(label, null);
      append_hydration_dev(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*requiredOpts*/
      2) && t0_value !== (t0_value = /*opt*/
      ctx2[13].label + ""))
        set_data_dev(t0, t0_value);
      if (
        /*opt*/
        ctx2[13].additionalInstructions
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*requiredOpts*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(label, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*requiredOpts*/
      2 && label_for_value !== (label_for_value = /*opt*/
      ctx2[13].id)) {
        attr_dev(label, "for", label_for_value);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div, null);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_14.name,
    type: "each",
    source: "(43:0) {#each requiredOpts as opt}",
    ctx
  });
  return block;
}
function create_if_block_44(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text("Optional");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, "Optional");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "separator svelte-us36jn");
      add_location(div, file41, 82, 1, 2089);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(82:0) {#if optionalOpts.length > 0}",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let infoicon;
  let current;
  infoicon = new InfoIcon_default({
    props: {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(infoicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(infoicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(infoicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const infoicon_changes = {};
      if (dirty & /*$$scope, optionalOpts*/
      262148) {
        infoicon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      infoicon.$set(infoicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(infoicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(infoicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(infoicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(91:3) {#if opt.additionalInstructions}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let t_value = (
    /*opt*/
    ctx[13].additionalInstructions + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*optionalOpts*/
      4 && t_value !== (t_value = /*opt*/
      ctx2[13].additionalInstructions + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(92:4) <InfoIcon>",
    ctx
  });
  return block;
}
function create_if_block_211(ctx) {
  let label;
  let input;
  let t;
  let span;
  let mounted;
  let dispose;
  function input_change_handler_1() {
    ctx[11].call(
      input,
      /*opt*/
      ctx[13]
    );
  }
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t = space();
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      input = claim_element(label_nodes, "INPUT", { type: true, class: true });
      t = claim_space(label_nodes);
      span = claim_element(label_nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "class", "svelte-us36jn");
      add_location(input, file41, 115, 4, 2827);
      attr_dev(span, "class", "slider svelte-us36jn");
      add_location(span, file41, 116, 4, 2917);
      attr_dev(label, "class", "switch svelte-us36jn");
      add_location(label, file41, 114, 3, 2800);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, input);
      input.checked = /*credentials*/
      ctx[0][
        /*opt*/
        ctx[13].id
      ];
      append_hydration_dev(label, t);
      append_hydration_dev(label, span);
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", input_change_handler_1),
          listen_dev(
            input,
            "change",
            /*handleChange*/
            ctx[3],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*credentials, optionalOpts*/
      5) {
        input.checked = /*credentials*/
        ctx[0][
          /*opt*/
          ctx[13].id
        ];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_211.name,
    type: "if",
    source: "(114:34) ",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let input;
  let input_id_value;
  let input_name_value;
  let mounted;
  let dispose;
  function input_input_handler_3() {
    ctx[10].call(
      input,
      /*opt*/
      ctx[13]
    );
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        placeholder: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "password");
      attr_dev(input, "id", input_id_value = /*opt*/
      ctx[13].id);
      attr_dev(input, "name", input_name_value = /*opt*/
      ctx[13].id);
      attr_dev(input, "placeholder", "password");
      attr_dev(input, "class", "svelte-us36jn");
      add_location(input, file41, 105, 3, 2603);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*credentials*/
        ctx[0][
          /*opt*/
          ctx[13].id
        ]
      );
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", input_input_handler_3),
          listen_dev(
            input,
            "keyup",
            /*handleChange*/
            ctx[3],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*optionalOpts*/
      4 && input_id_value !== (input_id_value = /*opt*/
      ctx[13].id)) {
        attr_dev(input, "id", input_id_value);
      }
      if (dirty & /*optionalOpts*/
      4 && input_name_value !== (input_name_value = /*opt*/
      ctx[13].id)) {
        attr_dev(input, "name", input_name_value);
      }
      if (dirty & /*credentials, optionalOpts*/
      5 && input.value !== /*credentials*/
      ctx[0][
        /*opt*/
        ctx[13].id
      ]) {
        set_input_value(
          input,
          /*credentials*/
          ctx[0][
            /*opt*/
            ctx[13].id
          ]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(105:36) ",
    ctx
  });
  return block;
}
function create_if_block28(ctx) {
  let input;
  let input_id_value;
  let input_name_value;
  let input_placeholder_value;
  let mounted;
  let dispose;
  function input_input_handler_2() {
    ctx[9].call(
      input,
      /*opt*/
      ctx[13]
    );
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        placeholder: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "text");
      attr_dev(input, "id", input_id_value = /*opt*/
      ctx[13].id);
      attr_dev(input, "name", input_name_value = /*opt*/
      ctx[13].id);
      attr_dev(input, "placeholder", input_placeholder_value = /*opt*/
      ctx[13].placeholder);
      attr_dev(input, "class", "svelte-us36jn");
      add_location(input, file41, 96, 3, 2401);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*credentials*/
        ctx[0][
          /*opt*/
          ctx[13].id
        ]
      );
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", input_input_handler_2),
          listen_dev(
            input,
            "keyup",
            /*handleChange*/
            ctx[3],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*optionalOpts*/
      4 && input_id_value !== (input_id_value = /*opt*/
      ctx[13].id)) {
        attr_dev(input, "id", input_id_value);
      }
      if (dirty & /*optionalOpts*/
      4 && input_name_value !== (input_name_value = /*opt*/
      ctx[13].id)) {
        attr_dev(input, "name", input_name_value);
      }
      if (dirty & /*optionalOpts*/
      4 && input_placeholder_value !== (input_placeholder_value = /*opt*/
      ctx[13].placeholder)) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*credentials, optionalOpts*/
      5 && input.value !== /*credentials*/
      ctx[0][
        /*opt*/
        ctx[13].id
      ]) {
        set_input_value(
          input,
          /*credentials*/
          ctx[0][
            /*opt*/
            ctx[13].id
          ]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(96:2) {#if opt.type === 'text'}",
    ctx
  });
  return block;
}
function create_each_block12(ctx) {
  let div;
  let label;
  let t0_value = (
    /*opt*/
    ctx[13].label + ""
  );
  let t0;
  let t1;
  let label_for_value;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*opt*/
    ctx[13].additionalInstructions && create_if_block_34(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*opt*/
      ctx2[13].type === "text"
    )
      return create_if_block28;
    if (
      /*opt*/
      ctx2[13].type === "password"
    )
      return create_if_block_112;
    if (
      /*opt*/
      ctx2[13].type === "toggle"
    )
      return create_if_block_211;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block1 = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      label = claim_element(div_nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      t0 = claim_text(label_nodes, t0_value);
      t1 = claim_space(label_nodes);
      if (if_block0)
        if_block0.l(label_nodes);
      label_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t3 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label, "for", label_for_value = /*opt*/
      ctx[13].id);
      attr_dev(label, "class", "flex items-center gap-1 svelte-us36jn");
      add_location(label, file41, 87, 2, 2190);
      attr_dev(div, "class", "input-item svelte-us36jn");
      add_location(div, file41, 86, 1, 2163);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, label);
      append_hydration_dev(label, t0);
      append_hydration_dev(label, t1);
      if (if_block0)
        if_block0.m(label, null);
      append_hydration_dev(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t3);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*optionalOpts*/
      4) && t0_value !== (t0_value = /*opt*/
      ctx2[13].label + ""))
        set_data_dev(t0, t0_value);
      if (
        /*opt*/
        ctx2[13].additionalInstructions
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*optionalOpts*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_34(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(label, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*optionalOpts*/
      4 && label_for_value !== (label_for_value = /*opt*/
      ctx2[13].id)) {
        attr_dev(label, "for", label_for_value);
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div, t3);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block12.name,
    type: "each",
    source: "(86:0) {#each optionalOpts as opt}",
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let t0;
  let t1;
  let each1_anchor;
  let current;
  let each_value_1 = (
    /*requiredOpts*/
    ctx[1]
  );
  validate_each_argument(each_value_1);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_14(get_each_context_14(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let if_block = (
    /*optionalOpts*/
    ctx[2].length > 0 && create_if_block_44(ctx)
  );
  let each_value = (
    /*optionalOpts*/
    ctx[2]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block12(get_each_context12(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(nodes);
      }
      t0 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      t1 = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(target, anchor);
      }
      insert_hydration_dev(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*requiredOpts, credentials, handleChange*/
      11) {
        each_value_1 = /*requiredOpts*/
        ctx2[1];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_14(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_14(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (
        /*optionalOpts*/
        ctx2[2].length > 0
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_44(ctx2);
          if_block.c();
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*optionalOpts, credentials, handleChange*/
      13) {
        each_value = /*optionalOpts*/
        ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context12(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each1_anchor.parentNode, each1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks_1, detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t1);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude40 = true;
function instance43($$self, $$props, $$invalidate) {
  let requiredOpts;
  let optionalOpts;
  let overrideOpts;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GenericForm", slots, []);
  let { opts } = $$props;
  let { credentials } = $$props;
  let { disableSave } = $$props;
  function handleChange() {
    let filledFields = 0;
    let fieldStatus = false;
    let overrideFields = 0;
    let overrideFieldStatus = false;
    for (let i = 0; i < requiredOpts.length; i++) {
      fieldStatus = credentials[requiredOpts[i].id] != void 0 && credentials[requiredOpts[i].id] !== "";
      filledFields = filledFields + fieldStatus;
    }
    for (let j = 0; j < overrideOpts.length; j++) {
      overrideFieldStatus = credentials[overrideOpts[j].id] != void 0 && credentials[overrideOpts[j].id] !== "";
      overrideFields = overrideFields + overrideFieldStatus;
    }
    if (filledFields === requiredOpts.length || overrideFields > 0) {
      $$invalidate(4, disableSave = false);
    } else {
      $$invalidate(4, disableSave = true);
    }
  }
  $$self.$$.on_mount.push(function() {
    if (opts === void 0 && !("opts" in $$props || $$self.$$.bound[$$self.$$.props["opts"]])) {
      console.warn("<GenericForm> was created without expected prop 'opts'");
    }
    if (credentials === void 0 && !("credentials" in $$props || $$self.$$.bound[$$self.$$.props["credentials"]])) {
      console.warn("<GenericForm> was created without expected prop 'credentials'");
    }
    if (disableSave === void 0 && !("disableSave" in $$props || $$self.$$.bound[$$self.$$.props["disableSave"]])) {
      console.warn("<GenericForm> was created without expected prop 'disableSave'");
    }
  });
  const writable_props = ["opts", "credentials", "disableSave"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GenericForm> was created with unknown prop '${key}'`);
  });
  function input_input_handler(opt) {
    credentials[opt.id] = this.value;
    $$invalidate(0, credentials);
  }
  function input_input_handler_1(opt) {
    credentials[opt.id] = this.value;
    $$invalidate(0, credentials);
  }
  function input_change_handler(opt) {
    credentials[opt.id] = this.checked;
    $$invalidate(0, credentials);
  }
  function input_input_handler_2(opt) {
    credentials[opt.id] = this.value;
    $$invalidate(0, credentials);
  }
  function input_input_handler_3(opt) {
    credentials[opt.id] = this.value;
    $$invalidate(0, credentials);
  }
  function input_change_handler_1(opt) {
    credentials[opt.id] = this.checked;
    $$invalidate(0, credentials);
  }
  $$self.$$set = ($$props2) => {
    if ("opts" in $$props2)
      $$invalidate(5, opts = $$props2.opts);
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("disableSave" in $$props2)
      $$invalidate(4, disableSave = $$props2.disableSave);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude40,
    InfoIcon: InfoIcon_default,
    opts,
    credentials,
    disableSave,
    handleChange,
    requiredOpts,
    overrideOpts,
    optionalOpts
  });
  $$self.$inject_state = ($$props2) => {
    if ("opts" in $$props2)
      $$invalidate(5, opts = $$props2.opts);
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("disableSave" in $$props2)
      $$invalidate(4, disableSave = $$props2.disableSave);
    if ("requiredOpts" in $$props2)
      $$invalidate(1, requiredOpts = $$props2.requiredOpts);
    if ("overrideOpts" in $$props2)
      overrideOpts = $$props2.overrideOpts;
    if ("optionalOpts" in $$props2)
      $$invalidate(2, optionalOpts = $$props2.optionalOpts);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*opts*/
    32) {
      $:
        $$invalidate(1, requiredOpts = opts.filter((d) => d.optional !== true));
    }
    if ($$self.$$.dirty & /*opts*/
    32) {
      $:
        $$invalidate(2, optionalOpts = opts.filter((d) => d.optional === true));
    }
    if ($$self.$$.dirty & /*opts*/
    32) {
      $:
        overrideOpts = opts.filter((d) => d.optional === true && d.override === true);
    }
  };
  return [
    credentials,
    requiredOpts,
    optionalOpts,
    handleChange,
    disableSave,
    opts,
    input_input_handler,
    input_input_handler_1,
    input_change_handler,
    input_input_handler_2,
    input_input_handler_3,
    input_change_handler_1
  ];
}
var GenericForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, { opts: 5, credentials: 0, disableSave: 4 }, add_css31);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GenericForm",
      options,
      id: create_fragment43.name
    });
  }
  get opts() {
    throw new Error("<GenericForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opts(value) {
    throw new Error("<GenericForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get credentials() {
    throw new Error("<GenericForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set credentials(value) {
    throw new Error("<GenericForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableSave() {
    throw new Error("<GenericForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableSave(value) {
    throw new Error("<GenericForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GenericForm_default = GenericForm;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/PostgresForm.svelte
function create_fragment44(ctx) {
  let genericform;
  let updating_credentials;
  let updating_disableSave;
  let current;
  function genericform_credentials_binding(value) {
    ctx[4](value);
  }
  function genericform_disableSave_binding(value) {
    ctx[5](value);
  }
  let genericform_props = { opts: (
    /*opts*/
    ctx[2]
  ) };
  if (
    /*credentials*/
    ctx[0] !== void 0
  ) {
    genericform_props.credentials = /*credentials*/
    ctx[0];
  }
  if (
    /*disableSave*/
    ctx[1] !== void 0
  ) {
    genericform_props.disableSave = /*disableSave*/
    ctx[1];
  }
  genericform = new GenericForm_default({ props: genericform_props, $$inline: true });
  binding_callbacks.push(() => bind(
    genericform,
    "credentials",
    genericform_credentials_binding,
    /*credentials*/
    ctx[0]
  ));
  binding_callbacks.push(() => bind(
    genericform,
    "disableSave",
    genericform_disableSave_binding,
    /*disableSave*/
    ctx[1]
  ));
  const block = {
    c: function create() {
      create_component(genericform.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(genericform.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(genericform, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const genericform_changes = {};
      if (!updating_credentials && dirty & /*credentials*/
      1) {
        updating_credentials = true;
        genericform_changes.credentials = /*credentials*/
        ctx2[0];
        add_flush_callback(() => updating_credentials = false);
      }
      if (!updating_disableSave && dirty & /*disableSave*/
      2) {
        updating_disableSave = true;
        genericform_changes.disableSave = /*disableSave*/
        ctx2[1];
        add_flush_callback(() => updating_disableSave = false);
      }
      genericform.$set(genericform_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(genericform.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(genericform.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(genericform, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude41 = true;
function instance44($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PostgresForm", slots, []);
  let { credentials } = $$props;
  let { existingCredentials } = $$props;
  let { disableSave } = $$props;
  credentials = { ...existingCredentials };
  let opts = [
    {
      id: "host",
      label: "Host",
      type: "text",
      optional: false,
      override: false,
      placeholder: "database.server.com",
      value: credentials.host ?? ""
    },
    {
      id: "database",
      label: "Database",
      type: "text",
      optional: false,
      override: false,
      placeholder: "my-database-name",
      value: credentials.database ?? ""
    },
    {
      id: "user",
      label: "User",
      type: "text",
      optional: false,
      override: false,
      placeholder: "postgres",
      value: credentials.user ?? ""
    },
    {
      id: "password",
      label: "Password",
      type: "password",
      optional: false,
      override: false,
      placeholder: "password",
      value: credentials.password ?? ""
    },
    {
      id: "port",
      label: "Port",
      type: "text",
      optional: false,
      override: false,
      placeholder: "5432",
      value: credentials.port ?? ""
    },
    {
      id: "schema",
      label: "Schema",
      type: "text",
      optional: true,
      override: false,
      placeholder: "public",
      value: credentials.schema ?? "",
      additionalInstructions: "The default schema to run queries against."
    },
    {
      id: "ssl",
      label: "SSL",
      type: "text",
      optional: true,
      override: false,
      placeholder: "no-verify",
      value: credentials.ssl ?? "",
      additionalInstructions: "Options are true, false, no-verify. When using Heroku this is commonly required."
    },
    {
      id: "connectionString",
      label: "Connection String",
      type: "text",
      optional: true,
      override: true,
      placeholder: "postgres://ewfeijgrftj:[password]@ec2-57-211-78-100.compute-1.amazonaws.com:5432/kencd6d32m0s51",
      additionalInstructions: "If your database host provides a connection string, you can use that here in place of the user/password fields above.",
      value: credentials.connectionString ?? ""
    }
  ];
  $$self.$$.on_mount.push(function() {
    if (credentials === void 0 && !("credentials" in $$props || $$self.$$.bound[$$self.$$.props["credentials"]])) {
      console.warn("<PostgresForm> was created without expected prop 'credentials'");
    }
    if (existingCredentials === void 0 && !("existingCredentials" in $$props || $$self.$$.bound[$$self.$$.props["existingCredentials"]])) {
      console.warn("<PostgresForm> was created without expected prop 'existingCredentials'");
    }
    if (disableSave === void 0 && !("disableSave" in $$props || $$self.$$.bound[$$self.$$.props["disableSave"]])) {
      console.warn("<PostgresForm> was created without expected prop 'disableSave'");
    }
  });
  const writable_props = ["credentials", "existingCredentials", "disableSave"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PostgresForm> was created with unknown prop '${key}'`);
  });
  function genericform_credentials_binding(value) {
    credentials = value;
    $$invalidate(0, credentials);
  }
  function genericform_disableSave_binding(value) {
    disableSave = value;
    $$invalidate(1, disableSave);
  }
  $$self.$$set = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(3, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(1, disableSave = $$props2.disableSave);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude41,
    credentials,
    existingCredentials,
    disableSave,
    opts,
    GenericForm: GenericForm_default
  });
  $$self.$inject_state = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(3, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(1, disableSave = $$props2.disableSave);
    if ("opts" in $$props2)
      $$invalidate(2, opts = $$props2.opts);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    credentials,
    disableSave,
    opts,
    existingCredentials,
    genericform_credentials_binding,
    genericform_disableSave_binding
  ];
}
var PostgresForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, {
      credentials: 0,
      existingCredentials: 3,
      disableSave: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PostgresForm",
      options,
      id: create_fragment44.name
    });
  }
  get credentials() {
    throw new Error("<PostgresForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set credentials(value) {
    throw new Error("<PostgresForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get existingCredentials() {
    throw new Error("<PostgresForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set existingCredentials(value) {
    throw new Error("<PostgresForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableSave() {
    throw new Error("<PostgresForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableSave(value) {
    throw new Error("<PostgresForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PostgresForm_default = PostgresForm;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/SnowflakeForm.svelte
var file42 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/SnowflakeForm.svelte";
function add_css32(target) {
  append_styles(target, "svelte-7s8s5b", "div.input-item.svelte-7s8s5b{font-family:var(--ui-font-family);color:var(--grey-999);font-size:16px;margin-top:1.1em;display:flex;flex-direction:row;flex-wrap:wrap;align-items:center}input.svelte-7s8s5b{box-sizing:border-box;border-radius:4px 4px 4px 4px;border:1px solid var(--grey-300);padding:0.25em 0.25em 0.25em 0.25em;margin-left:auto;width:62%;padding:0.35em;color:var(--grey-999);-webkit-appearance:none;-moz-appearance:none;vertical-align:middle;font-size:14px}input.svelte-7s8s5b:required{box-shadow:none}input.svelte-7s8s5b:focus{outline:none}input.svelte-7s8s5b:disabled{background-color:var(--grey-100);cursor:not-allowed}label.svelte-7s8s5b{width:35%;text-transform:uppercase;font-weight:normal;font-size:14px;color:var(--grey-800)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU25vd2ZsYWtlRm9ybS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBeVhDLEdBQUEsV0FBQSxjQUFBLENBQUEsQUFDQyxXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxDQUNsQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLENBQ2YsVUFBQSxDQUFBLEtBQWlCLENBQ2pCLE9BQUEsQ0FBQSxJQUFhLENBQ2IsY0FBQSxDQUFBLEdBQW1CLENBQ25CLFNBQUEsQ0FBQSxJQUFlLENBQ2YsV0FBQSxDQUFBLE1BQW1CLEFBQ3BCLENBQUEsQUFFQSxLQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixhQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBOEIsQ0FDOUIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxNQUFBLENBQUEsTUFBQSxDQUFBLE1BQUEsQ0FBQSxNQUFvQyxDQUNwQyxXQUFBLENBQUEsSUFBaUIsQ0FDakIsS0FBQSxDQUFBLEdBQVUsQ0FDVixPQUFBLENBQUEsTUFBZSxDQUNmLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsa0JBQUEsQ0FBQSxJQUF3QixDQUN4QixlQUFBLENBQUEsSUFBcUIsQ0FDckIsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLEFBQ2hCLENBQUEsQUFDQSxtQkFBQSxTQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBQ0EsbUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFDQSxtQkFBQSxTQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE1BQUEsQ0FBQSxXQUFtQixBQUNwQixDQUFBLEFBRUEsS0FBQSxjQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsR0FBVSxDQUNWLGNBQUEsQ0FBQSxTQUF5QixDQUN6QixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsU0FBQSxDQUFBLElBQWUsQ0FDZixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU25vd2ZsYWtlRm9ybS5zdmVsdGUiXX0= */");
}
function create_if_block29(ctx) {
  let div0;
  let label0;
  let t0;
  let t1;
  let t2;
  let div1;
  let label1;
  let t3;
  let t4;
  let input;
  let input_value_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*credentials*/
      ctx2[0].private_key
    )
      return create_if_block_113;
    return create_else_block12;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div0 = element("div");
      label0 = element("label");
      t0 = text("Private Key File");
      t1 = space();
      if_block.c();
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      t3 = text("Private Key");
      t4 = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      label0 = claim_element(div0_nodes, "LABEL", { for: true, class: true });
      var label0_nodes = children(label0);
      t0 = claim_text(label0_nodes, "Private Key File");
      label0_nodes.forEach(detach_dev);
      t1 = claim_space(div0_nodes);
      if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      label1 = claim_element(div1_nodes, "LABEL", { for: true, class: true });
      var label1_nodes = children(label1);
      t3 = claim_text(label1_nodes, "Private Key");
      label1_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      input = claim_element(div1_nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        class: true
      });
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(label0, "for", "private-key");
      attr_dev(label0, "class", "svelte-7s8s5b");
      add_location(label0, file42, 343, 2, 7966);
      attr_dev(div0, "class", "input-item svelte-7s8s5b");
      add_location(div0, file42, 342, 1, 7939);
      attr_dev(label1, "for", "private-key");
      attr_dev(label1, "class", "svelte-7s8s5b");
      add_location(label1, file42, 364, 2, 8383);
      attr_dev(input, "type", "password");
      attr_dev(input, "id", "private-key");
      attr_dev(input, "name", "private-key");
      input.value = input_value_value = /*credentials*/
      ((_a = ctx[0]) == null ? void 0 : _a.private_key) ?? "";
      input.disabled = true;
      attr_dev(input, "class", "svelte-7s8s5b");
      add_location(input, file42, 365, 2, 8432);
      attr_dev(div1, "class", "input-item svelte-7s8s5b");
      add_location(div1, file42, 363, 1, 8356);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      append_hydration_dev(div0, label0);
      append_hydration_dev(label0, t0);
      append_hydration_dev(div0, t1);
      if_block.m(div0, null);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, label1);
      append_hydration_dev(label1, t3);
      append_hydration_dev(div1, t4);
      append_hydration_dev(div1, input);
    },
    p: function update(ctx2, dirty) {
      var _a;
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
      if (dirty & /*credentials*/
      1 && input_value_value !== (input_value_value = /*credentials*/
      ((_a = ctx2[0]) == null ? void 0 : _a.private_key) ?? "") && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div0);
      if_block.d();
      if (detaching)
        detach_dev(t2);
      if (detaching)
        detach_dev(div1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(342:0) {#if credentials.authenticator === 'snowflake_jwt'}",
    ctx
  });
  return block;
}
function create_else_block12(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        id: true,
        type: true,
        accept: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "id", "private-key");
      attr_dev(input, "type", "file");
      attr_dev(input, "accept", "application/x-pem-file");
      input.required = true;
      attr_dev(input, "class", "svelte-7s8s5b");
      add_location(input, file42, 353, 3, 8196);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[9]
          ),
          listen_dev(
            input,
            "change",
            /*handleUpload*/
            ctx[5],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block12.name,
    type: "else",
    source: "(353:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_113(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        id: true,
        type: true,
        accept: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "id", "private-key");
      attr_dev(input, "type", "file");
      attr_dev(input, "accept", "application/x-pem-file");
      attr_dev(input, "class", "svelte-7s8s5b");
      add_location(input, file42, 345, 3, 8053);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[8]
          ),
          listen_dev(
            input,
            "change",
            /*handleUpload*/
            ctx[5],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(345:2) {#if credentials.private_key}",
    ctx
  });
  return block;
}
function create_fragment45(ctx) {
  let authselect;
  let updating_selected;
  let t0;
  let t1;
  let genericform;
  let updating_credentials;
  let updating_disableSave;
  let current;
  function authselect_selected_binding(value) {
    ctx[7](value);
  }
  let authselect_props = { options: (
    /*options*/
    ctx[4]
  ) };
  if (
    /*credentials*/
    ctx[0].authenticator !== void 0
  ) {
    authselect_props.selected = /*credentials*/
    ctx[0].authenticator;
  }
  authselect = new AuthSelect_default({ props: authselect_props, $$inline: true });
  binding_callbacks.push(() => bind(
    authselect,
    "selected",
    authselect_selected_binding,
    /*credentials*/
    ctx[0].authenticator
  ));
  let if_block = (
    /*credentials*/
    ctx[0].authenticator === "snowflake_jwt" && create_if_block29(ctx)
  );
  function genericform_credentials_binding(value) {
    ctx[10](value);
  }
  function genericform_disableSave_binding(value) {
    ctx[11](value);
  }
  let genericform_props = {
    opts: (
      /*opts*/
      ctx[3][
        /*credentials*/
        ctx[0].authenticator
      ]
    )
  };
  if (
    /*credentials*/
    ctx[0] !== void 0
  ) {
    genericform_props.credentials = /*credentials*/
    ctx[0];
  }
  if (
    /*disableSave*/
    ctx[1] !== void 0
  ) {
    genericform_props.disableSave = /*disableSave*/
    ctx[1];
  }
  genericform = new GenericForm_default({ props: genericform_props, $$inline: true });
  binding_callbacks.push(() => bind(
    genericform,
    "credentials",
    genericform_credentials_binding,
    /*credentials*/
    ctx[0]
  ));
  binding_callbacks.push(() => bind(
    genericform,
    "disableSave",
    genericform_disableSave_binding,
    /*disableSave*/
    ctx[1]
  ));
  const block = {
    c: function create() {
      create_component(authselect.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      create_component(genericform.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(authselect.$$.fragment, nodes);
      t0 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      t1 = claim_space(nodes);
      claim_component(genericform.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(authselect, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(genericform, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const authselect_changes = {};
      if (!updating_selected && dirty & /*credentials*/
      1) {
        updating_selected = true;
        authselect_changes.selected = /*credentials*/
        ctx2[0].authenticator;
        add_flush_callback(() => updating_selected = false);
      }
      authselect.$set(authselect_changes);
      if (
        /*credentials*/
        ctx2[0].authenticator === "snowflake_jwt"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block29(ctx2);
          if_block.c();
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const genericform_changes = {};
      if (dirty & /*credentials*/
      1)
        genericform_changes.opts = /*opts*/
        ctx2[3][
          /*credentials*/
          ctx2[0].authenticator
        ];
      if (!updating_credentials && dirty & /*credentials*/
      1) {
        updating_credentials = true;
        genericform_changes.credentials = /*credentials*/
        ctx2[0];
        add_flush_callback(() => updating_credentials = false);
      }
      if (!updating_disableSave && dirty & /*disableSave*/
      2) {
        updating_disableSave = true;
        genericform_changes.disableSave = /*disableSave*/
        ctx2[1];
        add_flush_callback(() => updating_disableSave = false);
      }
      genericform.$set(genericform_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(authselect.$$.fragment, local);
      transition_in(genericform.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(authselect.$$.fragment, local);
      transition_out(genericform.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(authselect, detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(genericform, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude42 = true;
function instance45($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SnowflakeForm", slots, []);
  let { credentials } = $$props;
  let { existingCredentials } = $$props;
  let { disableSave } = $$props;
  credentials = { ...existingCredentials };
  credentials.authenticator = "snowflake";
  const opts = {
    snowflake: [
      {
        id: "account",
        label: "Account",
        type: "text",
        optional: false,
        override: false,
        placeholder: "xy12345.us-east4.gcp | xy12345.eu-west-1 | xy12345",
        value: credentials.account,
        dataTestId: "snowflakeAccount",
        additionalInstructions: "The account number typically uses one of these formats: xy12345.us-east4.gcp, xy12345.eu-west-1 or xy12345. For more info see https://docs.snowflake.com/en/user-guide/admin-account-identifier"
      },
      {
        id: "username",
        label: "Username",
        type: "text",
        optional: false,
        override: false,
        placeholder: "weyland-yutani",
        value: credentials.username,
        dataTestId: "snowflakeUsername"
      },
      {
        id: "password",
        label: "Password",
        type: "password",
        optional: false,
        override: false,
        value: credentials.password,
        dataTestId: "snowflakePassword"
      },
      {
        id: "database",
        label: "Database",
        type: "text",
        optional: false,
        override: false,
        placeholder: "my-database",
        value: credentials.database,
        dataTestId: "snowflakeDatabase"
      },
      {
        id: "warehouse",
        label: "Warehouse",
        type: "text",
        optional: false,
        override: false,
        placeholder: "my_wh",
        value: credentials.warehouse,
        dataTestId: "snowflakeWarehouse"
      },
      {
        id: "role",
        label: "Role",
        type: "text",
        optional: true,
        override: false,
        placeholder: "public",
        value: credentials.role,
        dataTestId: "snowflakeRole"
      },
      {
        id: "schema",
        label: "Schema",
        type: "text",
        optional: true,
        override: false,
        placeholder: "public",
        value: credentials.schema,
        dataTestId: "snowflakeSchema"
      }
    ],
    okta: [
      {
        id: "okta_url",
        label: "Okta URL",
        type: "text",
        optional: false,
        override: false,
        placeholder: "https://your-organization.okta.com",
        value: credentials.okta_url,
        dataTestId: "oktaUrl"
      },
      {
        id: "account",
        label: "Account",
        type: "text",
        optional: false,
        override: false,
        placeholder: "xy12345.us-east4.gcp | xy12345.eu-west-1 | xy12345",
        value: credentials.account,
        dataTestId: "snowflakeAccount",
        additionalInstructions: "The account number typically uses one of these formats: xy12345.us-east4.gcp, xy12345.eu-west-1 or xy12345. For more info see https://docs.snowflake.com/en/user-guide/admin-account-identifier"
      },
      {
        id: "username",
        label: "Okta Username",
        type: "text",
        optional: false,
        override: false,
        placeholder: "weyland-yutani",
        value: credentials.username,
        dataTestId: "snowflakeUsername"
      },
      {
        id: "password",
        label: "Okta Password",
        type: "password",
        optional: false,
        override: false,
        value: credentials.password,
        dataTestId: "snowflakePassword"
      },
      {
        id: "database",
        label: "Database",
        type: "text",
        optional: false,
        override: false,
        placeholder: "my-database",
        value: credentials.database,
        dataTestId: "snowflakeDatabase"
      },
      {
        id: "warehouse",
        label: "Warehouse",
        type: "text",
        optional: false,
        override: false,
        placeholder: "my_wh",
        value: credentials.warehouse,
        dataTestId: "snowflakeWarehouse"
      },
      {
        id: "role",
        label: "Role",
        type: "text",
        optional: true,
        override: false,
        placeholder: "public",
        value: credentials.role,
        dataTestId: "snowflakeRole"
      },
      {
        id: "schema",
        label: "Schema",
        type: "text",
        optional: true,
        override: false,
        placeholder: "public",
        value: credentials.schema,
        dataTestId: "snowflakeSchema"
      }
    ],
    externalbrowser: [
      {
        id: "account",
        label: "Account",
        type: "text",
        optional: false,
        override: false,
        placeholder: "xy12345.us-east4.gcp | xy12345.eu-west-1 | xy12345",
        value: credentials.account,
        dataTestId: "snowflakeAccount",
        additionalInstructions: "The account number typically uses one of these formats: xy12345.us-east4.gcp, xy12345.eu-west-1 or xy12345. For more info see https://docs.snowflake.com/en/user-guide/admin-account-identifier"
      },
      {
        id: "username",
        label: "Username",
        type: "text",
        optional: false,
        override: false,
        placeholder: "weyland-yutani",
        value: credentials.username,
        dataTestId: "snowflakeUsername"
      },
      {
        id: "database",
        label: "Database",
        type: "text",
        optional: false,
        override: false,
        placeholder: "my-database",
        value: credentials.database,
        dataTestId: "snowflakeDatabase"
      },
      {
        id: "warehouse",
        label: "Warehouse",
        type: "text",
        optional: false,
        override: false,
        placeholder: "my_wh",
        value: credentials.warehouse,
        dataTestId: "snowflakeWarehouse"
      },
      {
        id: "role",
        label: "Role",
        type: "text",
        optional: true,
        override: false,
        placeholder: "public",
        value: credentials.role,
        dataTestId: "snowflakeRole"
      },
      {
        id: "schema",
        label: "Schema",
        type: "text",
        optional: true,
        override: false,
        placeholder: "public",
        value: credentials.schema,
        dataTestId: "snowflakeSchema"
      }
    ],
    snowflake_jwt: [
      {
        id: "account",
        label: "Account",
        type: "text",
        optional: false,
        override: false,
        placeholder: "xy12345.us-east4.gcp | xy12345.eu-west-1 | xy12345",
        value: credentials.account,
        dataTestId: "snowflakeAccount",
        additionalInstructions: "The account number typically uses one of these formats: xy12345.us-east4.gcp, xy12345.eu-west-1 or xy12345. For more info see https://docs.snowflake.com/en/user-guide/admin-account-identifier"
      },
      {
        id: "username",
        label: "Username",
        type: "text",
        optional: false,
        override: false,
        placeholder: "username",
        value: credentials.username,
        dataTestId: "snowflakeUsername"
      },
      {
        id: "database",
        label: "Database",
        type: "text",
        optional: false,
        override: false,
        placeholder: "my-database",
        value: credentials.database,
        dataTestId: "snowflakeDatabase"
      },
      {
        id: "warehouse",
        label: "Warehouse",
        type: "text",
        optional: false,
        override: false,
        placeholder: "my_wh",
        value: credentials.warehouse,
        dataTestId: "snowflakeWarehouse"
      },
      {
        id: "role",
        label: "Role",
        type: "text",
        optional: true,
        override: false,
        placeholder: "public",
        value: credentials.role,
        dataTestId: "snowflakeRole"
      },
      {
        id: "schema",
        label: "Schema",
        type: "text",
        optional: true,
        override: false,
        placeholder: "public",
        value: credentials.schema,
        dataTestId: "snowflakeSchema"
      },
      {
        id: "passphrase",
        label: "Private Key Passphrase",
        type: "password",
        optional: true,
        override: false,
        value: credentials.passphrase,
        dataTestId: "passphrase"
      }
    ]
  };
  const options = [
    {
      value: "snowflake",
      description: "Snowflake Account (default)"
    },
    {
      value: "externalbrowser",
      description: "SSO Browser Authentication"
    },
    {
      value: "okta",
      description: "Okta Authentication"
    },
    {
      value: "snowflake_jwt",
      description: "Key Pair Authentication"
    }
  ];
  let files;
  async function handleUpload() {
    for (const file68 of files) {
      $$invalidate(0, credentials.private_key = await file68.text(), credentials);
    }
    $$invalidate(1, disableSave = false);
  }
  $$self.$$.on_mount.push(function() {
    if (credentials === void 0 && !("credentials" in $$props || $$self.$$.bound[$$self.$$.props["credentials"]])) {
      console.warn("<SnowflakeForm> was created without expected prop 'credentials'");
    }
    if (existingCredentials === void 0 && !("existingCredentials" in $$props || $$self.$$.bound[$$self.$$.props["existingCredentials"]])) {
      console.warn("<SnowflakeForm> was created without expected prop 'existingCredentials'");
    }
    if (disableSave === void 0 && !("disableSave" in $$props || $$self.$$.bound[$$self.$$.props["disableSave"]])) {
      console.warn("<SnowflakeForm> was created without expected prop 'disableSave'");
    }
  });
  const writable_props = ["credentials", "existingCredentials", "disableSave"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SnowflakeForm> was created with unknown prop '${key}'`);
  });
  function authselect_selected_binding(value) {
    if ($$self.$$.not_equal(credentials.authenticator, value)) {
      credentials.authenticator = value;
      $$invalidate(0, credentials);
    }
  }
  function input_change_handler() {
    files = this.files;
    $$invalidate(2, files);
  }
  function input_change_handler_1() {
    files = this.files;
    $$invalidate(2, files);
  }
  function genericform_credentials_binding(value) {
    credentials = value;
    $$invalidate(0, credentials);
  }
  function genericform_disableSave_binding(value) {
    disableSave = value;
    $$invalidate(1, disableSave);
  }
  $$self.$$set = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(6, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(1, disableSave = $$props2.disableSave);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude42,
    GenericForm: GenericForm_default,
    AuthSelect: AuthSelect_default,
    credentials,
    existingCredentials,
    disableSave,
    opts,
    options,
    files,
    handleUpload
  });
  $$self.$inject_state = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(6, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(1, disableSave = $$props2.disableSave);
    if ("files" in $$props2)
      $$invalidate(2, files = $$props2.files);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    credentials,
    disableSave,
    files,
    opts,
    options,
    handleUpload,
    existingCredentials,
    authselect_selected_binding,
    input_change_handler,
    input_change_handler_1,
    genericform_credentials_binding,
    genericform_disableSave_binding
  ];
}
var SnowflakeForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance45,
      create_fragment45,
      safe_not_equal,
      {
        credentials: 0,
        existingCredentials: 6,
        disableSave: 1
      },
      add_css32
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SnowflakeForm",
      options,
      id: create_fragment45.name
    });
  }
  get credentials() {
    throw new Error("<SnowflakeForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set credentials(value) {
    throw new Error("<SnowflakeForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get existingCredentials() {
    throw new Error("<SnowflakeForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set existingCredentials(value) {
    throw new Error("<SnowflakeForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableSave() {
    throw new Error("<SnowflakeForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableSave(value) {
    throw new Error("<SnowflakeForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SnowflakeForm_default = SnowflakeForm;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/RedshiftForm.svelte
function create_fragment46(ctx) {
  let genericform;
  let updating_credentials;
  let updating_disableSave;
  let current;
  function genericform_credentials_binding(value) {
    ctx[4](value);
  }
  function genericform_disableSave_binding(value) {
    ctx[5](value);
  }
  let genericform_props = { opts: (
    /*opts*/
    ctx[2]
  ) };
  if (
    /*credentials*/
    ctx[0] !== void 0
  ) {
    genericform_props.credentials = /*credentials*/
    ctx[0];
  }
  if (
    /*disableSave*/
    ctx[1] !== void 0
  ) {
    genericform_props.disableSave = /*disableSave*/
    ctx[1];
  }
  genericform = new GenericForm_default({ props: genericform_props, $$inline: true });
  binding_callbacks.push(() => bind(
    genericform,
    "credentials",
    genericform_credentials_binding,
    /*credentials*/
    ctx[0]
  ));
  binding_callbacks.push(() => bind(
    genericform,
    "disableSave",
    genericform_disableSave_binding,
    /*disableSave*/
    ctx[1]
  ));
  const block = {
    c: function create() {
      create_component(genericform.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(genericform.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(genericform, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const genericform_changes = {};
      if (!updating_credentials && dirty & /*credentials*/
      1) {
        updating_credentials = true;
        genericform_changes.credentials = /*credentials*/
        ctx2[0];
        add_flush_callback(() => updating_credentials = false);
      }
      if (!updating_disableSave && dirty & /*disableSave*/
      2) {
        updating_disableSave = true;
        genericform_changes.disableSave = /*disableSave*/
        ctx2[1];
        add_flush_callback(() => updating_disableSave = false);
      }
      genericform.$set(genericform_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(genericform.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(genericform.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(genericform, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude43 = true;
function instance46($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RedshiftForm", slots, []);
  let { credentials } = $$props;
  let { existingCredentials } = $$props;
  let { disableSave } = $$props;
  credentials = { ...existingCredentials };
  let opts = [
    {
      id: "host",
      label: "Host",
      type: "text",
      optional: false,
      override: false,
      placeholder: "redshift-cluster-1.abcd12de3fgh.us-east-1.redshift.amazonaws.com",
      value: credentials.host ?? ""
    },
    {
      id: "database",
      label: "Database",
      type: "text",
      optional: false,
      override: false,
      placeholder: "dev",
      value: credentials.database ?? ""
    },
    {
      id: "user",
      label: "User",
      type: "text",
      optional: false,
      override: false,
      placeholder: "awsuser",
      value: credentials.user ?? ""
    },
    {
      id: "password",
      label: "Password",
      type: "password",
      optional: false,
      override: false,
      placeholder: "password",
      value: credentials.password ?? ""
    },
    {
      id: "port",
      label: "Port",
      type: "text",
      optional: false,
      override: false,
      placeholder: "5439",
      value: credentials.port ?? ""
    },
    {
      id: "ssl",
      label: "SSL",
      type: "text",
      optional: true,
      override: false,
      placeholder: "no-verify",
      value: credentials.ssl ?? "",
      additionalInstructions: "Options are true, false, no-verify."
    },
    {
      id: "connectionString",
      label: "Connection String",
      type: "text",
      optional: true,
      override: true,
      placeholder: "postgres://[username]:[password]@[host]:[port]/[database]",
      additionalInstructions: "If your database host provides a connection string, you can use that here in place of the user/password fields above.",
      value: credentials.connectionString ?? ""
    }
  ];
  $$self.$$.on_mount.push(function() {
    if (credentials === void 0 && !("credentials" in $$props || $$self.$$.bound[$$self.$$.props["credentials"]])) {
      console.warn("<RedshiftForm> was created without expected prop 'credentials'");
    }
    if (existingCredentials === void 0 && !("existingCredentials" in $$props || $$self.$$.bound[$$self.$$.props["existingCredentials"]])) {
      console.warn("<RedshiftForm> was created without expected prop 'existingCredentials'");
    }
    if (disableSave === void 0 && !("disableSave" in $$props || $$self.$$.bound[$$self.$$.props["disableSave"]])) {
      console.warn("<RedshiftForm> was created without expected prop 'disableSave'");
    }
  });
  const writable_props = ["credentials", "existingCredentials", "disableSave"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RedshiftForm> was created with unknown prop '${key}'`);
  });
  function genericform_credentials_binding(value) {
    credentials = value;
    $$invalidate(0, credentials);
  }
  function genericform_disableSave_binding(value) {
    disableSave = value;
    $$invalidate(1, disableSave);
  }
  $$self.$$set = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(3, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(1, disableSave = $$props2.disableSave);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude43,
    credentials,
    existingCredentials,
    disableSave,
    opts,
    GenericForm: GenericForm_default
  });
  $$self.$inject_state = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(3, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(1, disableSave = $$props2.disableSave);
    if ("opts" in $$props2)
      $$invalidate(2, opts = $$props2.opts);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    credentials,
    disableSave,
    opts,
    existingCredentials,
    genericform_credentials_binding,
    genericform_disableSave_binding
  ];
}
var RedshiftForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      credentials: 0,
      existingCredentials: 3,
      disableSave: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RedshiftForm",
      options,
      id: create_fragment46.name
    });
  }
  get credentials() {
    throw new Error("<RedshiftForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set credentials(value) {
    throw new Error("<RedshiftForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get existingCredentials() {
    throw new Error("<RedshiftForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set existingCredentials(value) {
    throw new Error("<RedshiftForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableSave() {
    throw new Error("<RedshiftForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableSave(value) {
    throw new Error("<RedshiftForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RedshiftForm_default = RedshiftForm;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/MysqlForm.svelte
function create_fragment47(ctx) {
  let genericform;
  let updating_credentials;
  let updating_disableSave;
  let current;
  function genericform_credentials_binding(value) {
    ctx[4](value);
  }
  function genericform_disableSave_binding(value) {
    ctx[5](value);
  }
  let genericform_props = { opts: (
    /*opts*/
    ctx[2]
  ) };
  if (
    /*credentials*/
    ctx[0] !== void 0
  ) {
    genericform_props.credentials = /*credentials*/
    ctx[0];
  }
  if (
    /*disableSave*/
    ctx[1] !== void 0
  ) {
    genericform_props.disableSave = /*disableSave*/
    ctx[1];
  }
  genericform = new GenericForm_default({ props: genericform_props, $$inline: true });
  binding_callbacks.push(() => bind(
    genericform,
    "credentials",
    genericform_credentials_binding,
    /*credentials*/
    ctx[0]
  ));
  binding_callbacks.push(() => bind(
    genericform,
    "disableSave",
    genericform_disableSave_binding,
    /*disableSave*/
    ctx[1]
  ));
  const block = {
    c: function create() {
      create_component(genericform.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(genericform.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(genericform, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const genericform_changes = {};
      if (!updating_credentials && dirty & /*credentials*/
      1) {
        updating_credentials = true;
        genericform_changes.credentials = /*credentials*/
        ctx2[0];
        add_flush_callback(() => updating_credentials = false);
      }
      if (!updating_disableSave && dirty & /*disableSave*/
      2) {
        updating_disableSave = true;
        genericform_changes.disableSave = /*disableSave*/
        ctx2[1];
        add_flush_callback(() => updating_disableSave = false);
      }
      genericform.$set(genericform_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(genericform.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(genericform.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(genericform, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude44 = true;
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MysqlForm", slots, []);
  let { credentials } = $$props;
  let { existingCredentials } = $$props;
  let { disableSave } = $$props;
  credentials = { ...existingCredentials };
  credentials = {
    host: credentials.host,
    database: credentials.database,
    user: credentials.user,
    password: credentials.password,
    port: credentials.port,
    ssl: credentials.ssl,
    socketPath: credentials.socketPath
  };
  let opts = [
    {
      id: "host",
      label: "Host",
      type: "text",
      optional: true,
      override: false,
      placeholder: "database.server.com",
      value: credentials.host ?? ""
    },
    {
      id: "database",
      label: "Database",
      optional: false,
      override: false,
      placeholder: "my-database-name",
      type: "text",
      value: credentials.database ?? ""
    },
    {
      id: "user",
      label: "User",
      type: "text",
      optional: false,
      override: false,
      placeholder: "username",
      value: credentials.user ?? ""
    },
    {
      id: "password",
      label: "Password",
      type: "password",
      optional: false,
      override: false,
      placeholder: "password",
      value: credentials.password ?? ""
    },
    {
      id: "port",
      label: "Port",
      type: "text",
      optional: true,
      override: false,
      placeholder: "3306",
      value: credentials.port ?? ""
    },
    {
      id: "ssl",
      label: "SSL",
      type: "text",
      optional: true,
      override: false,
      placeholder: "true",
      value: credentials.ssl ?? ""
    },
    {
      id: "socketPath",
      label: "Socket Path",
      type: "text",
      additionalInstructions: "This is an optional field. When using Google Cloud MySQL this is commonly required.",
      optional: true,
      override: false,
      placeholder: "/cloudsql/my-project-123:us-northeast2:my-instance",
      value: credentials.socketPath ?? ""
    }
  ];
  $$self.$$.on_mount.push(function() {
    if (credentials === void 0 && !("credentials" in $$props || $$self.$$.bound[$$self.$$.props["credentials"]])) {
      console.warn("<MysqlForm> was created without expected prop 'credentials'");
    }
    if (existingCredentials === void 0 && !("existingCredentials" in $$props || $$self.$$.bound[$$self.$$.props["existingCredentials"]])) {
      console.warn("<MysqlForm> was created without expected prop 'existingCredentials'");
    }
    if (disableSave === void 0 && !("disableSave" in $$props || $$self.$$.bound[$$self.$$.props["disableSave"]])) {
      console.warn("<MysqlForm> was created without expected prop 'disableSave'");
    }
  });
  const writable_props = ["credentials", "existingCredentials", "disableSave"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MysqlForm> was created with unknown prop '${key}'`);
  });
  function genericform_credentials_binding(value) {
    credentials = value;
    $$invalidate(0, credentials);
  }
  function genericform_disableSave_binding(value) {
    disableSave = value;
    $$invalidate(1, disableSave);
  }
  $$self.$$set = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(3, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(1, disableSave = $$props2.disableSave);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude44,
    credentials,
    existingCredentials,
    disableSave,
    opts,
    GenericForm: GenericForm_default
  });
  $$self.$inject_state = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(3, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(1, disableSave = $$props2.disableSave);
    if ("opts" in $$props2)
      $$invalidate(2, opts = $$props2.opts);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    credentials,
    disableSave,
    opts,
    existingCredentials,
    genericform_credentials_binding,
    genericform_disableSave_binding
  ];
}
var MysqlForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      credentials: 0,
      existingCredentials: 3,
      disableSave: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MysqlForm",
      options,
      id: create_fragment47.name
    });
  }
  get credentials() {
    throw new Error("<MysqlForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set credentials(value) {
    throw new Error("<MysqlForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get existingCredentials() {
    throw new Error("<MysqlForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set existingCredentials(value) {
    throw new Error("<MysqlForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableSave() {
    throw new Error("<MysqlForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableSave(value) {
    throw new Error("<MysqlForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MysqlForm_default = MysqlForm;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/SqliteForm.svelte
var file_1 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/SqliteForm.svelte";
function add_css33(target) {
  append_styles(target, "svelte-9kz6so", "span.additional-info-icon.svelte-9kz6so.svelte-9kz6so{width:18px;color:var(--grey-600);display:inline-block;vertical-align:middle;line-height:1em;cursor:help;position:relative;text-transform:none}div.input-item.svelte-9kz6so.svelte-9kz6so{font-family:var(--ui-font-family);color:var(--grey-999);font-size:16px;margin-top:1.25em;display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;justify-content:space-between}.basic.svelte-9kz6so.svelte-9kz6so{box-sizing:border-box;border-radius:4px 4px 4px 4px;border:1px solid var(--grey-300);padding:0.25em 0.25em 0.25em 0.25em;margin-left:5%;width:50%;padding:0.35em;color:var(--grey-999);-webkit-appearance:none;-moz-appearance:none;vertical-align:middle;font-size:16px;height:1.95rem}.basic.svelte-9kz6so.svelte-9kz6so:required{box-shadow:none}.basic.svelte-9kz6so.svelte-9kz6so:focus{outline:none}label.svelte-9kz6so.svelte-9kz6so{text-transform:uppercase;font-weight:normal;font-size:14px;color:var(--grey-800);white-space:nowrap}.additional-info-icon.svelte-9kz6so .info-msg.svelte-9kz6so{visibility:hidden;position:absolute;top:-5px;left:105%;white-space:nowrap;padding-left:5px;padding-right:5px;padding-top:2px;padding-bottom:1px;color:white;font-family:sans-serif;font-size:0.8em;background-color:var(--grey-900);opacity:0.85;border-radius:6px;z-index:1}.additional-info-icon.svelte-9kz6so:hover .info-msg.svelte-9kz6so{visibility:visible}.ext.svelte-9kz6so.svelte-9kz6so{-moz-appearance:none;appearance:none;-webkit-appearance:none;outline:none;margin-left:-10%;box-sizing:border-box;background-color:var(--grey-100);background-image:url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%237d8285%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');background-repeat:no-repeat, repeat;background-position:right 0.7em top 50%, 0 0;background-size:0.65em auto, 100%;border:1px solid var(--grey-300);color:var(--grey-700);border-radius:0px 4px 4px 0px;padding:0.15em 0.35em;font-size:16px;vertical-align:middle;height:1.95rem;width:25%;position:relative}.filenameError.svelte-9kz6so.svelte-9kz6so{border-color:var(--red-600);display:block}.error-msg.svelte-9kz6so.svelte-9kz6so{color:var(--red-600);font-size:8pt;text-align:right;margin-left:35%;padding-top:0.5em;display:none}.error-msg.filenameError.svelte-9kz6so.svelte-9kz6so{display:block}.hidden.svelte-9kz6so.svelte-9kz6so{display:none}.switch.svelte-9kz6so.svelte-9kz6so{position:relative;display:inline-block;width:2.8rem;height:1.75rem;margin-left:auto;margin-right:2px}.switch.svelte-9kz6so input.svelte-9kz6so{opacity:0;width:0;height:0}.slider.svelte-9kz6so.svelte-9kz6so{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;transition:0.4s;border-radius:25px}.slider.svelte-9kz6so.svelte-9kz6so:before{position:absolute;content:'';height:1.25rem;width:1.25rem;left:4px;bottom:4px;background-color:white;transition:0.4s;border-radius:50%;box-shadow:0px 1px 2px var(--grey-500)}input.svelte-9kz6so:checked+.slider.svelte-9kz6so{background-color:var(--green-500)}input.svelte-9kz6so:checked+.slider.svelte-9kz6so:before{transform:translateX(1.1rem)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3FsaXRlRm9ybS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBOElDLElBQUEscUJBQUEsNEJBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFXLENBQ1gsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixPQUFBLENBQUEsWUFBcUIsQ0FDckIsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLFdBQUEsQ0FBQSxHQUFnQixDQUNoQixNQUFBLENBQUEsSUFBWSxDQUNaLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixjQUFBLENBQUEsSUFBb0IsQUFDckIsQ0FBQSxBQUVBLEdBQUEsV0FBQSw0QkFBQSxDQUFBLEFBQ0MsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixTQUFBLENBQUEsSUFBZSxDQUNmLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixPQUFBLENBQUEsSUFBYSxDQUNiLGNBQUEsQ0FBQSxHQUFtQixDQUNuQixTQUFBLENBQUEsSUFBZSxDQUNmLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixlQUFBLENBQUEsYUFBOEIsQUFDL0IsQ0FBQSxBQUVBLE1BQUEsNEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixhQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBOEIsQ0FDOUIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxNQUFBLENBQUEsTUFBQSxDQUFBLE1BQUEsQ0FBQSxNQUFvQyxDQUNwQyxXQUFBLENBQUEsRUFBZSxDQUNmLEtBQUEsQ0FBQSxHQUFVLENBQ1YsT0FBQSxDQUFBLE1BQWUsQ0FDZixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGtCQUFBLENBQUEsSUFBd0IsQ0FDeEIsZUFBQSxDQUFBLElBQXFCLENBQ3JCLGNBQUEsQ0FBQSxNQUFzQixDQUN0QixTQUFBLENBQUEsSUFBZSxDQUNmLE1BQUEsQ0FBQSxPQUFlLEFBQ2hCLENBQUEsQUFDQSxrQ0FBQSxTQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBQ0Esa0NBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFFQSxLQUFBLDRCQUFBLENBQUEsQUFDQyxjQUFBLENBQUEsU0FBeUIsQ0FDekIsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFNBQUEsQ0FBQSxJQUFlLENBQ2YsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixXQUFBLENBQUEsTUFBbUIsQUFDcEIsQ0FBQSxBQUVBLG1DQUFBLENBQUEsU0FBQSxjQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsTUFBa0IsQ0FDbEIsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLEdBQUEsQ0FBQSxJQUFTLENBQ1QsSUFBQSxDQUFBLElBQVUsQ0FDVixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsWUFBQSxDQUFBLEdBQWlCLENBQ2pCLGFBQUEsQ0FBQSxHQUFrQixDQUNsQixXQUFBLENBQUEsR0FBZ0IsQ0FDaEIsY0FBQSxDQUFBLEdBQW1CLENBQ25CLEtBQUEsQ0FBQSxLQUFZLENBQ1osV0FBQSxDQUFBLFVBQXVCLENBQ3ZCLFNBQUEsQ0FBQSxLQUFnQixDQUNoQixnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxPQUFBLENBQUEsSUFBYSxDQUNiLGFBQUEsQ0FBQSxHQUFrQixDQUNsQixPQUFBLENBQUEsQ0FBVSxBQUNYLENBQUEsQUFFQSxtQ0FBQSxNQUFBLENBQUEsU0FBQSxjQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsT0FBbUIsQUFDcEIsQ0FBQSxBQUVBLElBQUEsNEJBQUEsQ0FBQSxBQUNDLGVBQUEsQ0FBQSxJQUFxQixDQUNoQixVQUFBLENBQUEsSUFBZ0IsQ0FDckIsa0JBQUEsQ0FBQSxJQUF3QixDQUN4QixPQUFBLENBQUEsSUFBYSxDQUNiLFdBQUEsQ0FBQSxJQUFpQixDQUNqQixVQUFBLENBQUEsVUFBc0IsQ0FDdEIsZ0JBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsZ0JBQUEsQ0FBQSxrZUFBb2YsQ0FDcGYsaUJBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBQSxNQUFvQyxDQUNwQyxtQkFBQSxDQUFBLEtBQUEsQ0FBQSxLQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUE2QyxDQUM3QyxlQUFBLENBQUEsTUFBQSxDQUFBLElBQUEsQ0FBQSxDQUFBLElBQWtDLENBQ2xDLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGFBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUE4QixDQUM5QixPQUFBLENBQUEsTUFBQSxDQUFBLE1BQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLENBQ2YsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLE1BQUEsQ0FBQSxPQUFlLENBQ2YsS0FBQSxDQUFBLEdBQVUsQ0FDVixRQUFBLENBQUEsUUFBa0IsQUFDbkIsQ0FBQSxBQUVBLGNBQUEsNEJBQUEsQ0FBQSxBQUNDLFlBQUEsQ0FBQSxJQUFBLFNBQUEsQ0FBNEIsQ0FDNUIsT0FBQSxDQUFBLEtBQWMsQUFDZixDQUFBLEFBRUEsVUFBQSw0QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsU0FBQSxDQUFxQixDQUNyQixTQUFBLENBQUEsR0FBYyxDQUNkLFVBQUEsQ0FBQSxLQUFpQixDQUNqQixXQUFBLENBQUEsR0FBZ0IsQ0FDaEIsV0FBQSxDQUFBLEtBQWtCLENBQ2xCLE9BQUEsQ0FBQSxJQUFhLEFBQ2QsQ0FBQSxBQUVBLFVBQUEsY0FBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLEtBQWMsQUFDZixDQUFBLEFBRUEsT0FBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQUFDZCxDQUFBLEFBRUEsT0FBQSw0QkFBQSxDQUFBLEFBQ0MsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLE9BQUEsQ0FBQSxZQUFxQixDQUNyQixLQUFBLENBQUEsTUFBYSxDQUNiLE1BQUEsQ0FBQSxPQUFlLENBQ2YsV0FBQSxDQUFBLElBQWlCLENBQ2pCLFlBQUEsQ0FBQSxHQUFpQixBQUNsQixDQUFBLEFBRUEscUJBQUEsQ0FBQSxLQUFBLGNBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxDQUFVLENBQ1YsS0FBQSxDQUFBLENBQVEsQ0FDUixNQUFBLENBQUEsQ0FBUyxBQUNWLENBQUEsQUFFQSxPQUFBLDRCQUFBLENBQUEsQUFDQyxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsTUFBQSxDQUFBLE9BQWUsQ0FDZixHQUFBLENBQUEsQ0FBTSxDQUNOLElBQUEsQ0FBQSxDQUFPLENBQ1AsS0FBQSxDQUFBLENBQVEsQ0FDUixNQUFBLENBQUEsQ0FBUyxDQUNULGdCQUFBLENBQUEsSUFBc0IsQ0FDdEIsVUFBQSxDQUFBLElBQWdCLENBQ2hCLGFBQUEsQ0FBQSxJQUFtQixBQUNwQixDQUFBLEFBRUEsbUNBQUEsT0FBQSxBQUFBLENBQUEsQUFDQyxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsT0FBQSxDQUFBLEVBQVcsQ0FDWCxNQUFBLENBQUEsT0FBZSxDQUNmLEtBQUEsQ0FBQSxPQUFjLENBQ2QsSUFBQSxDQUFBLEdBQVMsQ0FDVCxNQUFBLENBQUEsR0FBVyxDQUNYLGdCQUFBLENBQUEsS0FBdUIsQ0FDdkIsVUFBQSxDQUFBLElBQWdCLENBQ2hCLGFBQUEsQ0FBQSxHQUFrQixDQUNsQixVQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsSUFBQSxVQUFBLENBQXVDLEFBQ3hDLENBQUEsQUFFQSxtQkFBQSxRQUFBLENBQUEsT0FBQSxjQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsV0FBQSxDQUFrQyxBQUNuQyxDQUFBLEFBRUEsbUJBQUEsUUFBQSxDQUFBLHFCQUFBLE9BQUEsQUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLFdBQUEsTUFBQSxDQUE2QixBQUM5QixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlNxbGl0ZUZvcm0uc3ZlbHRlIl19 */");
}
function get_each_context13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[17] = list;
  child_ctx[18] = i;
  return child_ctx;
}
function create_if_block_212(ctx) {
  let span1;
  let icon;
  let t0;
  let span0;
  let t1_value = (
    /*opt*/
    ctx[16].additionalInstructions + ""
  );
  let t1;
  let current;
  icon = new Icon_default({
    props: {
      src: InfoCircle,
      class: "h-5 text-gray-600 pb-0.5"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span1 = element("span");
      create_component(icon.$$.fragment);
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      claim_component(icon.$$.fragment, span1_nodes);
      t0 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t1 = claim_text(span0_nodes, t1_value);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "info-msg svelte-9kz6so");
      add_location(span0, file_1, 91, 5, 2219);
      attr_dev(span1, "class", "additional-info-icon svelte-9kz6so");
      add_location(span1, file_1, 89, 4, 2114);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      mount_component(icon, span1, null);
      append_hydration_dev(span1, t0);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t1);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_212.name,
    type: "if",
    source: "(89:3) {#if opt.additionalInstructions}",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  let label;
  let input;
  let t;
  let span;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[15].call(
      input,
      /*opt*/
      ctx[16]
    );
  }
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t = space();
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      input = claim_element(label_nodes, "INPUT", { type: true, class: true });
      t = claim_space(label_nodes);
      span = claim_element(label_nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "class", "svelte-9kz6so");
      add_location(input, file_1, 134, 4, 3145);
      attr_dev(span, "class", "slider svelte-9kz6so");
      add_location(span, file_1, 135, 4, 3234);
      attr_dev(label, "class", "switch svelte-9kz6so");
      add_location(label, file_1, 133, 3, 3118);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, input);
      input.checked = /*credentials*/
      ctx[0][
        /*opt*/
        ctx[16].id
      ];
      append_hydration_dev(label, t);
      append_hydration_dev(label, span);
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", input_change_handler),
          listen_dev(
            input,
            "change",
            /*handleCheck*/
            ctx[7],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*credentials, opts*/
      33) {
        input.checked = /*credentials*/
        ctx[0][
          /*opt*/
          ctx[16].id
        ];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(133:34) ",
    ctx
  });
  return block;
}
function create_if_block30(ctx) {
  let input0;
  let input0_placeholder_value;
  let t0;
  let select;
  let option0;
  let t1;
  let option1;
  let t2;
  let option2;
  let t3;
  let t4;
  let input1;
  let input1_id_value;
  let input1_name_value;
  let t5;
  let p;
  let t6;
  let mounted;
  let dispose;
  function input1_input_handler() {
    ctx[14].call(
      input1,
      /*opt*/
      ctx[16]
    );
  }
  const block = {
    c: function create() {
      input0 = element("input");
      t0 = space();
      select = element("select");
      option0 = element("option");
      t1 = text(".db");
      option1 = element("option");
      t2 = text(".sqlite");
      option2 = element("option");
      t3 = text(".sqlite3");
      t4 = space();
      input1 = element("input");
      t5 = space();
      p = element("p");
      t6 = text("Filename cannot include folders");
      this.h();
    },
    l: function claim(nodes) {
      input0 = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        id: true,
        "data-test-id": true,
        name: true,
        placeholder: true
      });
      t0 = claim_space(nodes);
      select = claim_element(nodes, "SELECT", { class: true, name: true, id: true });
      var select_nodes = children(select);
      option0 = claim_element(select_nodes, "OPTION", {});
      var option0_nodes = children(option0);
      t1 = claim_text(option0_nodes, ".db");
      option0_nodes.forEach(detach_dev);
      option1 = claim_element(select_nodes, "OPTION", {});
      var option1_nodes = children(option1);
      t2 = claim_text(option1_nodes, ".sqlite");
      option1_nodes.forEach(detach_dev);
      option2 = claim_element(select_nodes, "OPTION", {});
      var option2_nodes = children(option2);
      t3 = claim_text(option2_nodes, ".sqlite3");
      option2_nodes.forEach(detach_dev);
      select_nodes.forEach(detach_dev);
      t4 = claim_space(nodes);
      input1 = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        id: true,
        name: true
      });
      t5 = claim_space(nodes);
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      t6 = claim_text(p_nodes, "Filename cannot include folders");
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input0, "class", "basic svelte-9kz6so");
      attr_dev(input0, "type", "text");
      attr_dev(input0, "id", "file");
      attr_dev(input0, "data-test-id", "sqlite3FilePrefix");
      attr_dev(input0, "name", "file");
      attr_dev(input0, "placeholder", input0_placeholder_value = /*opt*/
      ctx[16].placeholder);
      input0.required = true;
      toggle_class(
        input0,
        "filenameError",
        /*filenameError*/
        ctx[4]
      );
      add_location(input0, file_1, 97, 3, 2346);
      option0.__value = ".db";
      option0.value = option0.__value;
      add_location(option0, file_1, 118, 4, 2714);
      option1.__value = ".sqlite";
      option1.value = option1.__value;
      add_location(option1, file_1, 119, 4, 2751);
      option2.__value = ".sqlite3";
      option2.value = option2.__value;
      add_location(option2, file_1, 120, 4, 2796);
      attr_dev(select, "class", "ext svelte-9kz6so");
      attr_dev(select, "name", "ext");
      attr_dev(select, "id", "ext");
      if (
        /*ext*/
        ctx[3] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[12].call(select)
        ));
      toggle_class(
        select,
        "filenameError",
        /*filenameError*/
        ctx[4]
      );
      add_location(select, file_1, 110, 3, 2582);
      attr_dev(input1, "class", "hidden svelte-9kz6so");
      attr_dev(input1, "type", "text");
      attr_dev(input1, "id", input1_id_value = /*opt*/
      ctx[16].id);
      attr_dev(input1, "name", input1_name_value = /*opt*/
      ctx[16].id);
      add_location(input1, file_1, 123, 3, 2856);
      attr_dev(p, "class", "error-msg svelte-9kz6so");
      toggle_class(
        p,
        "filenameError",
        /*filenameError*/
        ctx[4]
      );
      add_location(p, file_1, 131, 3, 3003);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input0, anchor);
      set_input_value(
        input0,
        /*file*/
        ctx[2]
      );
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, select, anchor);
      append_hydration_dev(select, option0);
      append_hydration_dev(option0, t1);
      append_hydration_dev(select, option1);
      append_hydration_dev(option1, t2);
      append_hydration_dev(select, option2);
      append_hydration_dev(option2, t3);
      select_option(
        select,
        /*ext*/
        ctx[3]
      );
      insert_hydration_dev(target, t4, anchor);
      insert_hydration_dev(target, input1, anchor);
      ctx[13](input1);
      set_input_value(
        input1,
        /*credentials*/
        ctx[0][
          /*opt*/
          ctx[16].id
        ]
      );
      insert_hydration_dev(target, t5, anchor);
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t6);
      if (!mounted) {
        dispose = [
          listen_dev(
            input0,
            "keyup",
            /*handleKey*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[11]
          ),
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[12]
          ),
          listen_dev(
            select,
            "change",
            /*handleKey*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(input1, "input", input1_input_handler)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*file*/
      4 && input0.value !== /*file*/
      ctx[2]) {
        set_input_value(
          input0,
          /*file*/
          ctx[2]
        );
      }
      if (dirty & /*filenameError*/
      16) {
        toggle_class(
          input0,
          "filenameError",
          /*filenameError*/
          ctx[4]
        );
      }
      if (dirty & /*ext*/
      8) {
        select_option(
          select,
          /*ext*/
          ctx[3]
        );
      }
      if (dirty & /*filenameError*/
      16) {
        toggle_class(
          select,
          "filenameError",
          /*filenameError*/
          ctx[4]
        );
      }
      if (dirty & /*credentials, opts*/
      33 && input1.value !== /*credentials*/
      ctx[0][
        /*opt*/
        ctx[16].id
      ]) {
        set_input_value(
          input1,
          /*credentials*/
          ctx[0][
            /*opt*/
            ctx[16].id
          ]
        );
      }
      if (dirty & /*filenameError*/
      16) {
        toggle_class(
          p,
          "filenameError",
          /*filenameError*/
          ctx[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input0);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(select);
      if (detaching)
        detach_dev(t4);
      if (detaching)
        detach_dev(input1);
      ctx[13](null);
      if (detaching)
        detach_dev(t5);
      if (detaching)
        detach_dev(p);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(97:2) {#if opt.type === 'filename'}",
    ctx
  });
  return block;
}
function create_each_block13(ctx) {
  let div;
  let label;
  let t0_value = (
    /*opt*/
    ctx[16].label + ""
  );
  let t0;
  let t1;
  let label_for_value;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*opt*/
    ctx[16].additionalInstructions && create_if_block_212(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*opt*/
      ctx2[16].type === "filename"
    )
      return create_if_block30;
    if (
      /*opt*/
      ctx2[16].type === "toggle"
    )
      return create_if_block_114;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      label = claim_element(div_nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      t0 = claim_text(label_nodes, t0_value);
      t1 = claim_space(label_nodes);
      if (if_block0)
        if_block0.l(label_nodes);
      label_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t3 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label, "for", label_for_value = /*opt*/
      ctx[16].id);
      attr_dev(label, "class", "flex items-center gap-1 svelte-9kz6so");
      add_location(label, file_1, 85, 2, 2005);
      attr_dev(div, "class", "input-item svelte-9kz6so");
      add_location(div, file_1, 84, 1, 1978);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, label);
      append_hydration_dev(label, t0);
      append_hydration_dev(label, t1);
      if (if_block0)
        if_block0.m(label, null);
      append_hydration_dev(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t3);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*opt*/
        ctx2[16].additionalInstructions
      )
        if_block0.p(ctx2, dirty);
      if (if_block1)
        if_block1.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block13.name,
    type: "each",
    source: "(84:0) {#each opts as opt}",
    ctx
  });
  return block;
}
function create_fragment48(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*opts*/
    ctx[5]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block13(get_each_context13(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*filenameError, opts, filename, credentials, ext, handleKey, file, handleCheck, InfoCircle*/
      255) {
        each_value = /*opts*/
        ctx2[5];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context13(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block13(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude45 = true;
function instance48($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SqliteForm", slots, []);
  let { credentials } = $$props;
  let { existingCredentials } = $$props;
  let { gitIgnore } = $$props;
  existingCredentials.gitignoreSqlite = gitIgnore ? gitIgnore.match(/.db(?=|$)/) && gitIgnore.match(/.sqlite3(?=|$)/) && gitIgnore.match(/.sqlite(?=|$)/) : false;
  let { disableSave } = $$props;
  credentials = { ...existingCredentials };
  credentials = {
    filename: credentials.filename,
    gitignoreSqlite: credentials.gitignoreSqlite
  };
  let opts = [
    {
      id: "filename",
      label: "Filename",
      type: "filename",
      additionalInstructions: "Name of file stored in the same directory as your Evidence project",
      optional: false,
      override: false,
      placeholder: "mydatabase",
      value: credentials.filename ?? ""
    },
    {
      id: "gitignoreSqlite",
      label: "Gitignore all SQLite files",
      type: "toggle",
      additionalInstructions: "If enabled, Evidence will gitignore .db, .sqlite, and .sqlite3 files",
      optional: false,
      override: false,
      value: credentials.gitignoreSqlite ?? true
    }
  ];
  let filename = opts.filter((d) => d.id === "filename")[0].value;
  let file68;
  let ext;
  if (filename != void 0 && filename !== "") {
    file68 = filename.split(".")[0];
    ext = "." + filename.split(".")[1];
  }
  let filenameError = false;
  function handleKey() {
    if (file68 !== "" && file68 != void 0) {
      $$invalidate(1, filename.value = file68 + ext, filename);
    }
    $$invalidate(0, credentials.filename = filename.value, credentials);
    if (file68 == null ? void 0 : file68.includes("/")) {
      $$invalidate(4, filenameError = true);
      $$invalidate(9, disableSave = true);
    } else if (file68 === "" || file68 == void 0) {
      $$invalidate(4, filenameError = false);
      $$invalidate(9, disableSave = true);
    } else {
      $$invalidate(4, filenameError = false);
      $$invalidate(9, disableSave = false);
    }
  }
  function handleCheck() {
    if (file68 != void 0 && file68 !== "" && filenameError === false) {
      $$invalidate(9, disableSave = false);
    }
  }
  $$self.$$.on_mount.push(function() {
    if (credentials === void 0 && !("credentials" in $$props || $$self.$$.bound[$$self.$$.props["credentials"]])) {
      console.warn("<SqliteForm> was created without expected prop 'credentials'");
    }
    if (existingCredentials === void 0 && !("existingCredentials" in $$props || $$self.$$.bound[$$self.$$.props["existingCredentials"]])) {
      console.warn("<SqliteForm> was created without expected prop 'existingCredentials'");
    }
    if (gitIgnore === void 0 && !("gitIgnore" in $$props || $$self.$$.bound[$$self.$$.props["gitIgnore"]])) {
      console.warn("<SqliteForm> was created without expected prop 'gitIgnore'");
    }
    if (disableSave === void 0 && !("disableSave" in $$props || $$self.$$.bound[$$self.$$.props["disableSave"]])) {
      console.warn("<SqliteForm> was created without expected prop 'disableSave'");
    }
  });
  const writable_props = ["credentials", "existingCredentials", "gitIgnore", "disableSave"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SqliteForm> was created with unknown prop '${key}'`);
  });
  function input0_input_handler() {
    file68 = this.value;
    $$invalidate(2, file68);
  }
  function select_change_handler() {
    ext = select_value(this);
    $$invalidate(3, ext);
  }
  function input1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      filename = $$value;
      $$invalidate(1, filename);
    });
  }
  function input1_input_handler(opt) {
    credentials[opt.id] = this.value;
    $$invalidate(0, credentials);
  }
  function input_change_handler(opt) {
    credentials[opt.id] = this.checked;
    $$invalidate(0, credentials);
  }
  $$self.$$set = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(8, existingCredentials = $$props2.existingCredentials);
    if ("gitIgnore" in $$props2)
      $$invalidate(10, gitIgnore = $$props2.gitIgnore);
    if ("disableSave" in $$props2)
      $$invalidate(9, disableSave = $$props2.disableSave);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude45,
    Icon: Icon_default,
    InfoCircle,
    credentials,
    existingCredentials,
    gitIgnore,
    disableSave,
    opts,
    filename,
    file: file68,
    ext,
    filenameError,
    handleKey,
    handleCheck
  });
  $$self.$inject_state = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(8, existingCredentials = $$props2.existingCredentials);
    if ("gitIgnore" in $$props2)
      $$invalidate(10, gitIgnore = $$props2.gitIgnore);
    if ("disableSave" in $$props2)
      $$invalidate(9, disableSave = $$props2.disableSave);
    if ("opts" in $$props2)
      $$invalidate(5, opts = $$props2.opts);
    if ("filename" in $$props2)
      $$invalidate(1, filename = $$props2.filename);
    if ("file" in $$props2)
      $$invalidate(2, file68 = $$props2.file);
    if ("ext" in $$props2)
      $$invalidate(3, ext = $$props2.ext);
    if ("filenameError" in $$props2)
      $$invalidate(4, filenameError = $$props2.filenameError);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    credentials,
    filename,
    file68,
    ext,
    filenameError,
    opts,
    handleKey,
    handleCheck,
    existingCredentials,
    disableSave,
    gitIgnore,
    input0_input_handler,
    select_change_handler,
    input1_binding,
    input1_input_handler,
    input_change_handler
  ];
}
var SqliteForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance48,
      create_fragment48,
      safe_not_equal,
      {
        credentials: 0,
        existingCredentials: 8,
        gitIgnore: 10,
        disableSave: 9
      },
      add_css33
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SqliteForm",
      options,
      id: create_fragment48.name
    });
  }
  get credentials() {
    throw new Error("<SqliteForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set credentials(value) {
    throw new Error("<SqliteForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get existingCredentials() {
    throw new Error("<SqliteForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set existingCredentials(value) {
    throw new Error("<SqliteForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gitIgnore() {
    throw new Error("<SqliteForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gitIgnore(value) {
    throw new Error("<SqliteForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableSave() {
    throw new Error("<SqliteForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableSave(value) {
    throw new Error("<SqliteForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SqliteForm_default = SqliteForm;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/DuckdbForm.svelte
var file_12 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/DuckdbForm.svelte";
function add_css34(target) {
  append_styles(target, "svelte-9kz6so", "span.additional-info-icon.svelte-9kz6so.svelte-9kz6so{width:18px;color:var(--grey-600);display:inline-block;vertical-align:middle;line-height:1em;cursor:help;position:relative;text-transform:none}div.input-item.svelte-9kz6so.svelte-9kz6so{font-family:var(--ui-font-family);color:var(--grey-999);font-size:16px;margin-top:1.25em;display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;justify-content:space-between}.basic.svelte-9kz6so.svelte-9kz6so{box-sizing:border-box;border-radius:4px 4px 4px 4px;border:1px solid var(--grey-300);padding:0.25em 0.25em 0.25em 0.25em;margin-left:5%;width:50%;padding:0.35em;color:var(--grey-999);-webkit-appearance:none;-moz-appearance:none;vertical-align:middle;font-size:16px;height:1.95rem}.basic.svelte-9kz6so.svelte-9kz6so:required{box-shadow:none}.basic.svelte-9kz6so.svelte-9kz6so:focus{outline:none}label.svelte-9kz6so.svelte-9kz6so{text-transform:uppercase;font-weight:normal;font-size:14px;color:var(--grey-800);white-space:nowrap}.additional-info-icon.svelte-9kz6so .info-msg.svelte-9kz6so{visibility:hidden;position:absolute;top:-5px;left:105%;white-space:nowrap;padding-left:5px;padding-right:5px;padding-top:2px;padding-bottom:1px;color:white;font-family:sans-serif;font-size:0.8em;background-color:var(--grey-900);opacity:0.85;border-radius:6px;z-index:1}.additional-info-icon.svelte-9kz6so:hover .info-msg.svelte-9kz6so{visibility:visible}.ext.svelte-9kz6so.svelte-9kz6so{-moz-appearance:none;appearance:none;-webkit-appearance:none;outline:none;margin-left:-10%;box-sizing:border-box;background-color:var(--grey-100);background-image:url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%237d8285%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');background-repeat:no-repeat, repeat;background-position:right 0.7em top 50%, 0 0;background-size:0.65em auto, 100%;border:1px solid var(--grey-300);color:var(--grey-700);border-radius:0px 4px 4px 0px;padding:0.15em 0.35em;font-size:16px;vertical-align:middle;height:1.95rem;width:25%;position:relative}.filenameError.svelte-9kz6so.svelte-9kz6so{border-color:var(--red-600);display:block}.error-msg.svelte-9kz6so.svelte-9kz6so{color:var(--red-600);font-size:8pt;text-align:right;margin-left:35%;padding-top:0.5em;display:none}.error-msg.filenameError.svelte-9kz6so.svelte-9kz6so{display:block}.hidden.svelte-9kz6so.svelte-9kz6so{display:none}.switch.svelte-9kz6so.svelte-9kz6so{position:relative;display:inline-block;width:2.8rem;height:1.75rem;margin-left:auto;margin-right:2px}.switch.svelte-9kz6so input.svelte-9kz6so{opacity:0;width:0;height:0}.slider.svelte-9kz6so.svelte-9kz6so{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;transition:0.4s;border-radius:25px}.slider.svelte-9kz6so.svelte-9kz6so:before{position:absolute;content:'';height:1.25rem;width:1.25rem;left:4px;bottom:4px;background-color:white;transition:0.4s;border-radius:50%;box-shadow:0px 1px 2px var(--grey-500)}input.svelte-9kz6so:checked+.slider.svelte-9kz6so{background-color:var(--green-500)}input.svelte-9kz6so:checked+.slider.svelte-9kz6so:before{transform:translateX(1.1rem)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRHVja2RiRm9ybS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNElDLElBQUEscUJBQUEsNEJBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFXLENBQ1gsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixPQUFBLENBQUEsWUFBcUIsQ0FDckIsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLFdBQUEsQ0FBQSxHQUFnQixDQUNoQixNQUFBLENBQUEsSUFBWSxDQUNaLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixjQUFBLENBQUEsSUFBb0IsQUFDckIsQ0FBQSxBQUVBLEdBQUEsV0FBQSw0QkFBQSxDQUFBLEFBQ0MsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixTQUFBLENBQUEsSUFBZSxDQUNmLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixPQUFBLENBQUEsSUFBYSxDQUNiLGNBQUEsQ0FBQSxHQUFtQixDQUNuQixTQUFBLENBQUEsSUFBZSxDQUNmLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixlQUFBLENBQUEsYUFBOEIsQUFDL0IsQ0FBQSxBQUVBLE1BQUEsNEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixhQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBOEIsQ0FDOUIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxNQUFBLENBQUEsTUFBQSxDQUFBLE1BQUEsQ0FBQSxNQUFvQyxDQUNwQyxXQUFBLENBQUEsRUFBZSxDQUNmLEtBQUEsQ0FBQSxHQUFVLENBQ1YsT0FBQSxDQUFBLE1BQWUsQ0FDZixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGtCQUFBLENBQUEsSUFBd0IsQ0FDeEIsZUFBQSxDQUFBLElBQXFCLENBQ3JCLGNBQUEsQ0FBQSxNQUFzQixDQUN0QixTQUFBLENBQUEsSUFBZSxDQUNmLE1BQUEsQ0FBQSxPQUFlLEFBQ2hCLENBQUEsQUFDQSxrQ0FBQSxTQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBQ0Esa0NBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFFQSxLQUFBLDRCQUFBLENBQUEsQUFDQyxjQUFBLENBQUEsU0FBeUIsQ0FDekIsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFNBQUEsQ0FBQSxJQUFlLENBQ2YsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixXQUFBLENBQUEsTUFBbUIsQUFDcEIsQ0FBQSxBQUVBLG1DQUFBLENBQUEsU0FBQSxjQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsTUFBa0IsQ0FDbEIsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLEdBQUEsQ0FBQSxJQUFTLENBQ1QsSUFBQSxDQUFBLElBQVUsQ0FDVixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsWUFBQSxDQUFBLEdBQWlCLENBQ2pCLGFBQUEsQ0FBQSxHQUFrQixDQUNsQixXQUFBLENBQUEsR0FBZ0IsQ0FDaEIsY0FBQSxDQUFBLEdBQW1CLENBQ25CLEtBQUEsQ0FBQSxLQUFZLENBQ1osV0FBQSxDQUFBLFVBQXVCLENBQ3ZCLFNBQUEsQ0FBQSxLQUFnQixDQUNoQixnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxPQUFBLENBQUEsSUFBYSxDQUNiLGFBQUEsQ0FBQSxHQUFrQixDQUNsQixPQUFBLENBQUEsQ0FBVSxBQUNYLENBQUEsQUFFQSxtQ0FBQSxNQUFBLENBQUEsU0FBQSxjQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsT0FBbUIsQUFDcEIsQ0FBQSxBQUVBLElBQUEsNEJBQUEsQ0FBQSxBQUNDLGVBQUEsQ0FBQSxJQUFxQixDQUNoQixVQUFBLENBQUEsSUFBZ0IsQ0FDckIsa0JBQUEsQ0FBQSxJQUF3QixDQUN4QixPQUFBLENBQUEsSUFBYSxDQUNiLFdBQUEsQ0FBQSxJQUFpQixDQUNqQixVQUFBLENBQUEsVUFBc0IsQ0FDdEIsZ0JBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsZ0JBQUEsQ0FBQSxrZUFBb2YsQ0FDcGYsaUJBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBQSxNQUFvQyxDQUNwQyxtQkFBQSxDQUFBLEtBQUEsQ0FBQSxLQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUE2QyxDQUM3QyxlQUFBLENBQUEsTUFBQSxDQUFBLElBQUEsQ0FBQSxDQUFBLElBQWtDLENBQ2xDLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGFBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUE4QixDQUM5QixPQUFBLENBQUEsTUFBQSxDQUFBLE1BQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLENBQ2YsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLE1BQUEsQ0FBQSxPQUFlLENBQ2YsS0FBQSxDQUFBLEdBQVUsQ0FDVixRQUFBLENBQUEsUUFBa0IsQUFDbkIsQ0FBQSxBQUVBLGNBQUEsNEJBQUEsQ0FBQSxBQUNDLFlBQUEsQ0FBQSxJQUFBLFNBQUEsQ0FBNEIsQ0FDNUIsT0FBQSxDQUFBLEtBQWMsQUFDZixDQUFBLEFBRUEsVUFBQSw0QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsU0FBQSxDQUFxQixDQUNyQixTQUFBLENBQUEsR0FBYyxDQUNkLFVBQUEsQ0FBQSxLQUFpQixDQUNqQixXQUFBLENBQUEsR0FBZ0IsQ0FDaEIsV0FBQSxDQUFBLEtBQWtCLENBQ2xCLE9BQUEsQ0FBQSxJQUFhLEFBQ2QsQ0FBQSxBQUVBLFVBQUEsY0FBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLEtBQWMsQUFDZixDQUFBLEFBRUEsT0FBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQUFDZCxDQUFBLEFBRUEsT0FBQSw0QkFBQSxDQUFBLEFBQ0MsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLE9BQUEsQ0FBQSxZQUFxQixDQUNyQixLQUFBLENBQUEsTUFBYSxDQUNiLE1BQUEsQ0FBQSxPQUFlLENBQ2YsV0FBQSxDQUFBLElBQWlCLENBQ2pCLFlBQUEsQ0FBQSxHQUFpQixBQUNsQixDQUFBLEFBRUEscUJBQUEsQ0FBQSxLQUFBLGNBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxDQUFVLENBQ1YsS0FBQSxDQUFBLENBQVEsQ0FDUixNQUFBLENBQUEsQ0FBUyxBQUNWLENBQUEsQUFFQSxPQUFBLDRCQUFBLENBQUEsQUFDQyxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsTUFBQSxDQUFBLE9BQWUsQ0FDZixHQUFBLENBQUEsQ0FBTSxDQUNOLElBQUEsQ0FBQSxDQUFPLENBQ1AsS0FBQSxDQUFBLENBQVEsQ0FDUixNQUFBLENBQUEsQ0FBUyxDQUNULGdCQUFBLENBQUEsSUFBc0IsQ0FDdEIsVUFBQSxDQUFBLElBQWdCLENBQ2hCLGFBQUEsQ0FBQSxJQUFtQixBQUNwQixDQUFBLEFBRUEsbUNBQUEsT0FBQSxBQUFBLENBQUEsQUFDQyxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsT0FBQSxDQUFBLEVBQVcsQ0FDWCxNQUFBLENBQUEsT0FBZSxDQUNmLEtBQUEsQ0FBQSxPQUFjLENBQ2QsSUFBQSxDQUFBLEdBQVMsQ0FDVCxNQUFBLENBQUEsR0FBVyxDQUNYLGdCQUFBLENBQUEsS0FBdUIsQ0FDdkIsVUFBQSxDQUFBLElBQWdCLENBQ2hCLGFBQUEsQ0FBQSxHQUFrQixDQUNsQixVQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsSUFBQSxVQUFBLENBQXVDLEFBQ3hDLENBQUEsQUFFQSxtQkFBQSxRQUFBLENBQUEsT0FBQSxjQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsV0FBQSxDQUFrQyxBQUNuQyxDQUFBLEFBRUEsbUJBQUEsUUFBQSxDQUFBLHFCQUFBLE9BQUEsQUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLFdBQUEsTUFBQSxDQUE2QixBQUM5QixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkR1Y2tkYkZvcm0uc3ZlbHRlIl19 */");
}
function get_each_context14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[17] = list;
  child_ctx[18] = i;
  return child_ctx;
}
function create_if_block_213(ctx) {
  let span1;
  let icon;
  let t0;
  let span0;
  let t1_value = (
    /*opt*/
    ctx[16].additionalInstructions + ""
  );
  let t1;
  let current;
  icon = new Icon_default({
    props: {
      src: InfoCircle,
      class: "h-5 text-gray-600 pb-0.5"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span1 = element("span");
      create_component(icon.$$.fragment);
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      claim_component(icon.$$.fragment, span1_nodes);
      t0 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t1 = claim_text(span0_nodes, t1_value);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "info-msg svelte-9kz6so");
      add_location(span0, file_12, 89, 5, 2248);
      attr_dev(span1, "class", "additional-info-icon svelte-9kz6so");
      add_location(span1, file_12, 87, 4, 2143);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      mount_component(icon, span1, null);
      append_hydration_dev(span1, t0);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t1);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_213.name,
    type: "if",
    source: "(87:3) {#if opt.additionalInstructions}",
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let label;
  let input;
  let t;
  let span;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[15].call(
      input,
      /*opt*/
      ctx[16]
    );
  }
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t = space();
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      input = claim_element(label_nodes, "INPUT", { type: true, class: true });
      t = claim_space(label_nodes);
      span = claim_element(label_nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "class", "svelte-9kz6so");
      add_location(input, file_12, 132, 4, 3169);
      attr_dev(span, "class", "slider svelte-9kz6so");
      add_location(span, file_12, 133, 4, 3258);
      attr_dev(label, "class", "switch svelte-9kz6so");
      add_location(label, file_12, 131, 3, 3142);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, input);
      input.checked = /*credentials*/
      ctx[0][
        /*opt*/
        ctx[16].id
      ];
      append_hydration_dev(label, t);
      append_hydration_dev(label, span);
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", input_change_handler),
          listen_dev(
            input,
            "change",
            /*handleCheck*/
            ctx[7],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*credentials, opts*/
      33) {
        input.checked = /*credentials*/
        ctx[0][
          /*opt*/
          ctx[16].id
        ];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(131:34) ",
    ctx
  });
  return block;
}
function create_if_block31(ctx) {
  let input0;
  let input0_placeholder_value;
  let t0;
  let select;
  let option0;
  let t1;
  let option1;
  let t2;
  let option2;
  let t3;
  let t4;
  let input1;
  let input1_id_value;
  let input1_name_value;
  let t5;
  let p;
  let t6;
  let mounted;
  let dispose;
  function input1_input_handler() {
    ctx[14].call(
      input1,
      /*opt*/
      ctx[16]
    );
  }
  const block = {
    c: function create() {
      input0 = element("input");
      t0 = space();
      select = element("select");
      option0 = element("option");
      t1 = text(".duckdb");
      option1 = element("option");
      t2 = text(".db");
      option2 = element("option");
      t3 = text("No extension");
      t4 = space();
      input1 = element("input");
      t5 = space();
      p = element("p");
      t6 = text("Filename cannot include folders");
      this.h();
    },
    l: function claim(nodes) {
      input0 = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        id: true,
        "data-test-id": true,
        name: true,
        placeholder: true
      });
      t0 = claim_space(nodes);
      select = claim_element(nodes, "SELECT", { class: true, name: true, id: true });
      var select_nodes = children(select);
      option0 = claim_element(select_nodes, "OPTION", {});
      var option0_nodes = children(option0);
      t1 = claim_text(option0_nodes, ".duckdb");
      option0_nodes.forEach(detach_dev);
      option1 = claim_element(select_nodes, "OPTION", {});
      var option1_nodes = children(option1);
      t2 = claim_text(option1_nodes, ".db");
      option1_nodes.forEach(detach_dev);
      option2 = claim_element(select_nodes, "OPTION", {});
      var option2_nodes = children(option2);
      t3 = claim_text(option2_nodes, "No extension");
      option2_nodes.forEach(detach_dev);
      select_nodes.forEach(detach_dev);
      t4 = claim_space(nodes);
      input1 = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        id: true,
        name: true
      });
      t5 = claim_space(nodes);
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      t6 = claim_text(p_nodes, "Filename cannot include folders");
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input0, "class", "basic svelte-9kz6so");
      attr_dev(input0, "type", "text");
      attr_dev(input0, "id", "file");
      attr_dev(input0, "data-test-id", "duckdbFilePrefix");
      attr_dev(input0, "name", "file");
      attr_dev(input0, "placeholder", input0_placeholder_value = /*opt*/
      ctx[16].placeholder);
      input0.required = true;
      toggle_class(
        input0,
        "filenameError",
        /*filenameError*/
        ctx[4]
      );
      add_location(input0, file_12, 95, 3, 2375);
      option0.__value = ".duckdb";
      option0.value = option0.__value;
      add_location(option0, file_12, 116, 4, 2742);
      option1.__value = ".db";
      option1.value = option1.__value;
      add_location(option1, file_12, 117, 4, 2787);
      option2.__value = "";
      option2.value = option2.__value;
      add_location(option2, file_12, 118, 4, 2824);
      attr_dev(select, "class", "ext svelte-9kz6so");
      attr_dev(select, "name", "ext");
      attr_dev(select, "id", "ext");
      if (
        /*ext*/
        ctx[3] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[12].call(select)
        ));
      toggle_class(
        select,
        "filenameError",
        /*filenameError*/
        ctx[4]
      );
      add_location(select, file_12, 108, 3, 2610);
      attr_dev(input1, "class", "hidden svelte-9kz6so");
      attr_dev(input1, "type", "text");
      attr_dev(input1, "id", input1_id_value = /*opt*/
      ctx[16].id);
      attr_dev(input1, "name", input1_name_value = /*opt*/
      ctx[16].id);
      add_location(input1, file_12, 121, 3, 2880);
      attr_dev(p, "class", "error-msg svelte-9kz6so");
      toggle_class(
        p,
        "filenameError",
        /*filenameError*/
        ctx[4]
      );
      add_location(p, file_12, 129, 3, 3027);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input0, anchor);
      set_input_value(
        input0,
        /*file*/
        ctx[2]
      );
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, select, anchor);
      append_hydration_dev(select, option0);
      append_hydration_dev(option0, t1);
      append_hydration_dev(select, option1);
      append_hydration_dev(option1, t2);
      append_hydration_dev(select, option2);
      append_hydration_dev(option2, t3);
      select_option(
        select,
        /*ext*/
        ctx[3]
      );
      insert_hydration_dev(target, t4, anchor);
      insert_hydration_dev(target, input1, anchor);
      ctx[13](input1);
      set_input_value(
        input1,
        /*credentials*/
        ctx[0][
          /*opt*/
          ctx[16].id
        ]
      );
      insert_hydration_dev(target, t5, anchor);
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t6);
      if (!mounted) {
        dispose = [
          listen_dev(
            input0,
            "keyup",
            /*handleKey*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[11]
          ),
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[12]
          ),
          listen_dev(
            select,
            "change",
            /*handleKey*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(input1, "input", input1_input_handler)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*file*/
      4 && input0.value !== /*file*/
      ctx[2]) {
        set_input_value(
          input0,
          /*file*/
          ctx[2]
        );
      }
      if (dirty & /*filenameError*/
      16) {
        toggle_class(
          input0,
          "filenameError",
          /*filenameError*/
          ctx[4]
        );
      }
      if (dirty & /*ext*/
      8) {
        select_option(
          select,
          /*ext*/
          ctx[3]
        );
      }
      if (dirty & /*filenameError*/
      16) {
        toggle_class(
          select,
          "filenameError",
          /*filenameError*/
          ctx[4]
        );
      }
      if (dirty & /*credentials, opts*/
      33 && input1.value !== /*credentials*/
      ctx[0][
        /*opt*/
        ctx[16].id
      ]) {
        set_input_value(
          input1,
          /*credentials*/
          ctx[0][
            /*opt*/
            ctx[16].id
          ]
        );
      }
      if (dirty & /*filenameError*/
      16) {
        toggle_class(
          p,
          "filenameError",
          /*filenameError*/
          ctx[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input0);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(select);
      if (detaching)
        detach_dev(t4);
      if (detaching)
        detach_dev(input1);
      ctx[13](null);
      if (detaching)
        detach_dev(t5);
      if (detaching)
        detach_dev(p);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block31.name,
    type: "if",
    source: "(95:2) {#if opt.type === 'filename'}",
    ctx
  });
  return block;
}
function create_each_block14(ctx) {
  let div;
  let label;
  let t0_value = (
    /*opt*/
    ctx[16].label + ""
  );
  let t0;
  let t1;
  let label_for_value;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*opt*/
    ctx[16].additionalInstructions && create_if_block_213(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*opt*/
      ctx2[16].type === "filename"
    )
      return create_if_block31;
    if (
      /*opt*/
      ctx2[16].type === "toggle"
    )
      return create_if_block_115;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      label = claim_element(div_nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      t0 = claim_text(label_nodes, t0_value);
      t1 = claim_space(label_nodes);
      if (if_block0)
        if_block0.l(label_nodes);
      label_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t3 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label, "for", label_for_value = /*opt*/
      ctx[16].id);
      attr_dev(label, "class", "flex items-center gap-1 svelte-9kz6so");
      add_location(label, file_12, 83, 2, 2034);
      attr_dev(div, "class", "input-item svelte-9kz6so");
      add_location(div, file_12, 82, 1, 2007);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, label);
      append_hydration_dev(label, t0);
      append_hydration_dev(label, t1);
      if (if_block0)
        if_block0.m(label, null);
      append_hydration_dev(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t3);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*opt*/
        ctx2[16].additionalInstructions
      )
        if_block0.p(ctx2, dirty);
      if (if_block1)
        if_block1.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block14.name,
    type: "each",
    source: "(82:0) {#each opts as opt}",
    ctx
  });
  return block;
}
function create_fragment49(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*opts*/
    ctx[5]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block14(get_each_context14(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*filenameError, opts, filename, credentials, ext, handleKey, file, handleCheck, InfoCircle*/
      255) {
        each_value = /*opts*/
        ctx2[5];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context14(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block14(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude46 = true;
function instance49($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DuckdbForm", slots, []);
  let { credentials } = $$props;
  let { existingCredentials } = $$props;
  let { gitIgnore } = $$props;
  existingCredentials.gitignoreDuckdb = gitIgnore ? gitIgnore.match(/\n.db(?=\n|$)/) && gitIgnore.match(/\n.duckdb(?=\n|$)/) : false;
  let { disableSave } = $$props;
  credentials = { ...existingCredentials };
  credentials = {
    filename: credentials.filename,
    gitignoreDuckdb: credentials.gitignoreDuckdb
  };
  let opts = [
    {
      id: "filename",
      label: "Filename",
      type: "filename",
      additionalInstructions: 'Name of file stored in the same directory as your Evidence project. For MotherDuck, use "md:?motherduck_token=[TOKEN], and select No extension.',
      optional: false,
      override: false,
      placeholder: "mydatabase",
      value: credentials.filename ?? ""
    },
    {
      id: "gitignoreDuckdb",
      label: "Gitignore all DuckDB files",
      type: "toggle",
      additionalInstructions: "If enabled, Evidence will gitignore .db and .duckdb files",
      optional: false,
      override: false,
      value: credentials.gitignoreDuckdb ?? true
    }
  ];
  let filename = opts.filter((d) => d.id === "filename")[0].value;
  let file68;
  let ext;
  if (filename != void 0 && filename !== "") {
    file68 = filename.split(".")[0];
    ext = "." + filename.split(".")[1];
  }
  let filenameError = false;
  function handleKey() {
    if (file68 !== "" && file68 != void 0) {
      $$invalidate(1, filename.value = file68 + ext, filename);
    }
    $$invalidate(0, credentials.filename = filename.value, credentials);
    if (file68 == null ? void 0 : file68.includes("/")) {
      $$invalidate(4, filenameError = true);
      $$invalidate(9, disableSave = true);
    } else if (file68 === "" || file68 == void 0) {
      $$invalidate(4, filenameError = false);
      $$invalidate(9, disableSave = true);
    } else {
      $$invalidate(4, filenameError = false);
      $$invalidate(9, disableSave = false);
    }
  }
  function handleCheck() {
    if (file68 != void 0 && file68 !== "" && filenameError === false) {
      $$invalidate(9, disableSave = false);
    }
  }
  $$self.$$.on_mount.push(function() {
    if (credentials === void 0 && !("credentials" in $$props || $$self.$$.bound[$$self.$$.props["credentials"]])) {
      console.warn("<DuckdbForm> was created without expected prop 'credentials'");
    }
    if (existingCredentials === void 0 && !("existingCredentials" in $$props || $$self.$$.bound[$$self.$$.props["existingCredentials"]])) {
      console.warn("<DuckdbForm> was created without expected prop 'existingCredentials'");
    }
    if (gitIgnore === void 0 && !("gitIgnore" in $$props || $$self.$$.bound[$$self.$$.props["gitIgnore"]])) {
      console.warn("<DuckdbForm> was created without expected prop 'gitIgnore'");
    }
    if (disableSave === void 0 && !("disableSave" in $$props || $$self.$$.bound[$$self.$$.props["disableSave"]])) {
      console.warn("<DuckdbForm> was created without expected prop 'disableSave'");
    }
  });
  const writable_props = ["credentials", "existingCredentials", "gitIgnore", "disableSave"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DuckdbForm> was created with unknown prop '${key}'`);
  });
  function input0_input_handler() {
    file68 = this.value;
    $$invalidate(2, file68);
  }
  function select_change_handler() {
    ext = select_value(this);
    $$invalidate(3, ext);
  }
  function input1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      filename = $$value;
      $$invalidate(1, filename);
    });
  }
  function input1_input_handler(opt) {
    credentials[opt.id] = this.value;
    $$invalidate(0, credentials);
  }
  function input_change_handler(opt) {
    credentials[opt.id] = this.checked;
    $$invalidate(0, credentials);
  }
  $$self.$$set = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(8, existingCredentials = $$props2.existingCredentials);
    if ("gitIgnore" in $$props2)
      $$invalidate(10, gitIgnore = $$props2.gitIgnore);
    if ("disableSave" in $$props2)
      $$invalidate(9, disableSave = $$props2.disableSave);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude46,
    Icon: Icon_default,
    InfoCircle,
    credentials,
    existingCredentials,
    gitIgnore,
    disableSave,
    opts,
    filename,
    file: file68,
    ext,
    filenameError,
    handleKey,
    handleCheck
  });
  $$self.$inject_state = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(8, existingCredentials = $$props2.existingCredentials);
    if ("gitIgnore" in $$props2)
      $$invalidate(10, gitIgnore = $$props2.gitIgnore);
    if ("disableSave" in $$props2)
      $$invalidate(9, disableSave = $$props2.disableSave);
    if ("opts" in $$props2)
      $$invalidate(5, opts = $$props2.opts);
    if ("filename" in $$props2)
      $$invalidate(1, filename = $$props2.filename);
    if ("file" in $$props2)
      $$invalidate(2, file68 = $$props2.file);
    if ("ext" in $$props2)
      $$invalidate(3, ext = $$props2.ext);
    if ("filenameError" in $$props2)
      $$invalidate(4, filenameError = $$props2.filenameError);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    credentials,
    filename,
    file68,
    ext,
    filenameError,
    opts,
    handleKey,
    handleCheck,
    existingCredentials,
    disableSave,
    gitIgnore,
    input0_input_handler,
    select_change_handler,
    input1_binding,
    input1_input_handler,
    input_change_handler
  ];
}
var DuckdbForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance49,
      create_fragment49,
      safe_not_equal,
      {
        credentials: 0,
        existingCredentials: 8,
        gitIgnore: 10,
        disableSave: 9
      },
      add_css34
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DuckdbForm",
      options,
      id: create_fragment49.name
    });
  }
  get credentials() {
    throw new Error("<DuckdbForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set credentials(value) {
    throw new Error("<DuckdbForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get existingCredentials() {
    throw new Error("<DuckdbForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set existingCredentials(value) {
    throw new Error("<DuckdbForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gitIgnore() {
    throw new Error("<DuckdbForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gitIgnore(value) {
    throw new Error("<DuckdbForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableSave() {
    throw new Error("<DuckdbForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableSave(value) {
    throw new Error("<DuckdbForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DuckdbForm_default = DuckdbForm;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/MSSQLForm.svelte
function create_fragment50(ctx) {
  let genericform;
  let updating_credentials;
  let updating_disableSave;
  let current;
  function genericform_credentials_binding(value) {
    ctx[4](value);
  }
  function genericform_disableSave_binding(value) {
    ctx[5](value);
  }
  let genericform_props = { opts: (
    /*opts*/
    ctx[2]
  ) };
  if (
    /*credentials*/
    ctx[0] !== void 0
  ) {
    genericform_props.credentials = /*credentials*/
    ctx[0];
  }
  if (
    /*disableSave*/
    ctx[1] !== void 0
  ) {
    genericform_props.disableSave = /*disableSave*/
    ctx[1];
  }
  genericform = new GenericForm_default({ props: genericform_props, $$inline: true });
  binding_callbacks.push(() => bind(
    genericform,
    "credentials",
    genericform_credentials_binding,
    /*credentials*/
    ctx[0]
  ));
  binding_callbacks.push(() => bind(
    genericform,
    "disableSave",
    genericform_disableSave_binding,
    /*disableSave*/
    ctx[1]
  ));
  const block = {
    c: function create() {
      create_component(genericform.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(genericform.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(genericform, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const genericform_changes = {};
      if (!updating_credentials && dirty & /*credentials*/
      1) {
        updating_credentials = true;
        genericform_changes.credentials = /*credentials*/
        ctx2[0];
        add_flush_callback(() => updating_credentials = false);
      }
      if (!updating_disableSave && dirty & /*disableSave*/
      2) {
        updating_disableSave = true;
        genericform_changes.disableSave = /*disableSave*/
        ctx2[1];
        add_flush_callback(() => updating_disableSave = false);
      }
      genericform.$set(genericform_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(genericform.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(genericform.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(genericform, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude47 = true;
function instance50($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MSSQLForm", slots, []);
  let { credentials } = $$props;
  let { existingCredentials } = $$props;
  let { disableSave } = $$props;
  credentials = { ...existingCredentials };
  let opts = [
    {
      id: "host",
      label: "Host",
      type: "text",
      optional: false,
      override: false,
      placeholder: "database.server.com",
      value: credentials.host ?? ""
    },
    {
      id: "database",
      label: "Database",
      optional: false,
      override: false,
      placeholder: "my-database-name",
      type: "text",
      value: credentials.database ?? ""
    },
    {
      id: "user",
      label: "User",
      type: "text",
      optional: false,
      override: false,
      placeholder: "username",
      value: credentials.user ?? ""
    },
    {
      id: "password",
      label: "Password",
      type: "password",
      optional: false,
      override: false,
      placeholder: "password",
      value: credentials.password ?? ""
    },
    {
      id: "port",
      label: "Port",
      type: "text",
      optional: true,
      override: false,
      placeholder: "1433",
      value: credentials.port ?? ""
    },
    {
      id: "trust_server_certificate",
      label: "Trust Server Certificate",
      type: "text",
      additionalInstructions: "Should be true for local dev / self-signed certificates",
      optional: true,
      override: false,
      placeholder: "false",
      value: credentials.trustServerCertificate ?? ""
    },
    {
      id: "encrypt",
      label: "Encrypt",
      type: "text",
      additionalInstructions: "Should be true when using Azure",
      optional: true,
      override: false,
      placeholder: "true",
      value: credentials.encrypt ?? ""
    }
  ];
  $$self.$$.on_mount.push(function() {
    if (credentials === void 0 && !("credentials" in $$props || $$self.$$.bound[$$self.$$.props["credentials"]])) {
      console.warn("<MSSQLForm> was created without expected prop 'credentials'");
    }
    if (existingCredentials === void 0 && !("existingCredentials" in $$props || $$self.$$.bound[$$self.$$.props["existingCredentials"]])) {
      console.warn("<MSSQLForm> was created without expected prop 'existingCredentials'");
    }
    if (disableSave === void 0 && !("disableSave" in $$props || $$self.$$.bound[$$self.$$.props["disableSave"]])) {
      console.warn("<MSSQLForm> was created without expected prop 'disableSave'");
    }
  });
  const writable_props = ["credentials", "existingCredentials", "disableSave"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MSSQLForm> was created with unknown prop '${key}'`);
  });
  function genericform_credentials_binding(value) {
    credentials = value;
    $$invalidate(0, credentials);
  }
  function genericform_disableSave_binding(value) {
    disableSave = value;
    $$invalidate(1, disableSave);
  }
  $$self.$$set = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(3, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(1, disableSave = $$props2.disableSave);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude47,
    credentials,
    existingCredentials,
    disableSave,
    opts,
    GenericForm: GenericForm_default
  });
  $$self.$inject_state = ($$props2) => {
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(3, existingCredentials = $$props2.existingCredentials);
    if ("disableSave" in $$props2)
      $$invalidate(1, disableSave = $$props2.disableSave);
    if ("opts" in $$props2)
      $$invalidate(2, opts = $$props2.opts);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    credentials,
    disableSave,
    opts,
    existingCredentials,
    genericform_credentials_binding,
    genericform_disableSave_binding
  ];
}
var MSSQLForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, {
      credentials: 0,
      existingCredentials: 3,
      disableSave: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MSSQLForm",
      options,
      id: create_fragment50.name
    });
  }
  get credentials() {
    throw new Error("<MSSQLForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set credentials(value) {
    throw new Error("<MSSQLForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get existingCredentials() {
    throw new Error("<MSSQLForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set existingCredentials(value) {
    throw new Error("<MSSQLForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableSave() {
    throw new Error("<MSSQLForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableSave(value) {
    throw new Error("<MSSQLForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MSSQLForm_default = MSSQLForm;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/DatabaseSettingsPanel.svelte
var { Error: Error_13 } = globals;
var file43 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Databases/DatabaseSettingsPanel.svelte";
function add_css35(target) {
  append_styles(target, "svelte-b48xai", "@keyframes svelte-b48xai-pulse-blue{0%{transform:scale(0.95);box-shadow:0 0 0 0 var(--blue-200)}70%{transform:scale(1);box-shadow:0 0 0 6px rgba(255, 82, 82, 0)}100%{transform:scale(0.95);box-shadow:0 0 0 0 rgba(255, 82, 82, 0)}}@keyframes svelte-b48xai-pulse-green{0%{transform:scale(0.95);box-shadow:0 0 0 0 var(--green-200)}70%{transform:scale(1);box-shadow:0 0 0 6px rgba(255, 82, 82, 0)}100%{transform:scale(0.95);box-shadow:0 0 0 0 rgba(255, 82, 82, 0)}}span.indicator.svelte-b48xai{border-radius:100%;height:10px;width:10px;margin-right:8px;display:inline-block;box-sizing:border-box}span.indicator.running.svelte-b48xai{background-color:var(--blue-500);transform:scale(1);animation:svelte-b48xai-pulse-blue 2s infinite}span.indicator.success.svelte-b48xai{background-color:var(--green-600);transform:scale(1);animation:svelte-b48xai-pulse-green 2s infinite}span.indicator.fail.svelte-b48xai{background-color:var(--red-600)}p.error.svelte-b48xai{font-family:'monoco', Roboto Mono, monospace;padding-top:1em;word-break:break-all}h3.svelte-b48xai{text-transform:uppercase;font-weight:normal;font-style:normal;font-size:14px}.docs-link.svelte-b48xai{color:var(--blue-600);text-decoration:none}.docs-link.svelte-b48xai:hover{color:var(--blue-800)}.container.svelte-b48xai{border-top:1px solid var(--grey-200);border-left:1px solid var(--grey-200);border-right:1px solid var(--grey-200);border-radius:5px 5px 0 0;font-size:14px;font-family:var(--ui-font-family);min-width:100%}form.svelte-b48xai{scroll-margin-top:3.5rem}.panel.svelte-b48xai{border-top:1px solid var(--grey-200);padding:0em 1em 1em 1em}.panel.svelte-b48xai:first-of-type{border-top:none}.panel.test-result.svelte-b48xai{padding-top:1em}select.svelte-b48xai{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0.3rem 0.6rem;width:100%;border:1px solid var(--grey-200);font-family:var(--ui-font-family);color:var(--grey-800);margin:0.5em 0 0 0;transition:all 400ms;cursor:pointer}select.svelte-b48xai:hover{border:1px solid var(--grey-300);transition:all 400ms;box-shadow:0 5px 5px 2px hsl(0deg 0% 97%)}select.svelte-b48xai:focus{outline:none}footer.svelte-b48xai{border:1px solid var(--grey-200);border-radius:0 0 5px 5px;background-color:var(--grey-100);padding:1em;display:flex;font-size:14px;align-items:center;font-family:var(--ui-font-family)}button.svelte-b48xai{padding:0.4em 0.5em;margin-right:0.25em;margin-left:auto;font-style:normal;text-decoration:none;font-size:14px;cursor:pointer}#save.svelte-b48xai{background-color:var(--blue-600);color:white;font-weight:bold;border-radius:4px;border:1px solid var(--blue-700);padding:0.4em 1.1em;transition-property:background, color;transition-duration:350ms}#save.svelte-b48xai:active{background-color:var(--blue-800);color:white;font-weight:bold;border-radius:4px;border:1px solid var(--blue-900);padding:0.4em 1.1em;transition-property:background, color;transition-duration:350ms}#save.svelte-b48xai:disabled,button[disabled].svelte-b48xai{border:1px solid var(--grey-400);background-color:var(--grey-100);color:var(--grey-600);cursor:not-allowed;transition-property:background, color;transition-duration:350ms}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0YWJhc2VTZXR0aW5nc1BhbmVsLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE2S0MsV0FBQSx3QkFBQSxDQUFBLEFBQ0MsRUFBQSxBQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsTUFBQSxJQUFBLENBQXNCLENBQ3RCLFVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxVQUFBLENBQW1DLEFBQ3BDLENBQUEsQUFFQSxHQUFBLEFBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxNQUFBLENBQUEsQ0FBbUIsQ0FDbkIsVUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLEdBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBMEMsQUFDM0MsQ0FBQSxBQUVBLElBQUEsQUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLE1BQUEsSUFBQSxDQUFzQixDQUN0QixVQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEtBQUEsR0FBQSxDQUFBLENBQUEsRUFBQSxDQUFBLENBQUEsRUFBQSxDQUFBLENBQUEsQ0FBQSxDQUF3QyxBQUN6QyxDQUFBLEFBQ0QsQ0FBQSxBQUVBLFdBQUEseUJBQUEsQ0FBQSxBQUNDLEVBQUEsQUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLE1BQUEsSUFBQSxDQUFzQixDQUN0QixVQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsV0FBQSxDQUFvQyxBQUNyQyxDQUFBLEFBRUEsR0FBQSxBQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsTUFBQSxDQUFBLENBQW1CLENBQ25CLFVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxHQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsQ0FBQSxDQUFBLENBQTBDLEFBQzNDLENBQUEsQUFFQSxJQUFBLEFBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxNQUFBLElBQUEsQ0FBc0IsQ0FDdEIsVUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxLQUFBLEdBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBd0MsQUFDekMsQ0FBQSxBQUNELENBQUEsQUFFQSxJQUFBLFVBQUEsY0FBQSxDQUFBLEFBQ0MsYUFBQSxDQUFBLElBQW1CLENBQ25CLE1BQUEsQ0FBQSxJQUFZLENBQ1osS0FBQSxDQUFBLElBQVcsQ0FDWCxZQUFBLENBQUEsR0FBaUIsQ0FDakIsT0FBQSxDQUFBLFlBQXFCLENBQ3JCLFVBQUEsQ0FBQSxVQUFzQixBQUN2QixDQUFBLEFBRUEsSUFBQSxVQUFBLFFBQUEsY0FBQSxDQUFBLEFBQ0MsZ0JBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsU0FBQSxDQUFBLE1BQUEsQ0FBQSxDQUFtQixDQUNuQixTQUFBLENBQUEsd0JBQUEsQ0FBQSxFQUFBLENBQUEsUUFBaUMsQUFDbEMsQ0FBQSxBQUVBLElBQUEsVUFBQSxRQUFBLGNBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxXQUFBLENBQWtDLENBQ2xDLFNBQUEsQ0FBQSxNQUFBLENBQUEsQ0FBbUIsQ0FDbkIsU0FBQSxDQUFBLHlCQUFBLENBQUEsRUFBQSxDQUFBLFFBQWtDLEFBQ25DLENBQUEsQUFFQSxJQUFBLFVBQUEsS0FBQSxjQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsU0FBQSxDQUFnQyxBQUNqQyxDQUFBLEFBRUEsQ0FBQSxNQUFBLGNBQUEsQ0FBQSxBQUNDLFdBQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQSxNQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsU0FBNkMsQ0FDN0MsV0FBQSxDQUFBLEdBQWdCLENBQ2hCLFVBQUEsQ0FBQSxTQUFxQixBQUN0QixDQUFBLEFBRUEsRUFBQSxjQUFBLENBQUEsQUFDQyxjQUFBLENBQUEsU0FBeUIsQ0FDekIsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixTQUFBLENBQUEsSUFBZSxBQUNoQixDQUFBLEFBRUEsVUFBQSxjQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGVBQUEsQ0FBQSxJQUFxQixBQUN0QixDQUFBLEFBRUEsd0JBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEsQUFFQSxVQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFxQyxDQUNyQyxXQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0MsQ0FDdEMsWUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXVDLENBQ3ZDLGFBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUEwQixDQUMxQixTQUFBLENBQUEsSUFBZSxDQUNmLFdBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQWtDLENBQ2xDLFNBQUEsQ0FBQSxJQUFlLEFBQ2hCLENBQUEsQUFFQSxJQUFBLGNBQUEsQ0FBQSxBQUNDLGlCQUFBLENBQUEsTUFBeUIsQUFDMUIsQ0FBQSxBQUVBLE1BQUEsY0FBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXFDLENBQ3JDLE9BQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUF3QixBQUN6QixDQUFBLEFBRUEsb0JBQUEsY0FBQSxBQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBZ0IsQUFDakIsQ0FBQSxBQUVBLE1BQUEsWUFBQSxjQUFBLENBQUEsQUFDQyxXQUFBLENBQUEsR0FBZ0IsQUFDakIsQ0FBQSxBQUVBLE1BQUEsY0FBQSxDQUFBLEFBQ0Msa0JBQUEsQ0FBQSxJQUF3QixDQUN4QixlQUFBLENBQUEsSUFBcUIsQ0FDckIsVUFBQSxDQUFBLElBQWdCLENBQ2hCLE9BQUEsQ0FBQSxNQUFBLENBQUEsTUFBc0IsQ0FDdEIsS0FBQSxDQUFBLElBQVcsQ0FDWCxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixNQUFBLENBQUEsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBbUIsQ0FDbkIsVUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFxQixDQUNyQixNQUFBLENBQUEsT0FBZSxBQUNoQixDQUFBLEFBRUEsb0JBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsVUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFxQixDQUNyQixVQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLElBQUEsSUFBQSxDQUFBLEVBQUEsQ0FBQSxHQUFBLENBQTBDLEFBQzNDLENBQUEsQUFFQSxvQkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxJQUFhLEFBQ2QsQ0FBQSxBQUVBLE1BQUEsY0FBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLGFBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUEwQixDQUMxQixnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxPQUFBLENBQUEsR0FBWSxDQUNaLE9BQUEsQ0FBQSxJQUFhLENBQ2IsU0FBQSxDQUFBLElBQWUsQ0FDZixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQUFDbkMsQ0FBQSxBQUVBLE1BQUEsY0FBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFvQixDQUNwQixZQUFBLENBQUEsTUFBb0IsQ0FDcEIsV0FBQSxDQUFBLElBQWlCLENBQ2pCLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixlQUFBLENBQUEsSUFBcUIsQ0FDckIsU0FBQSxDQUFBLElBQWUsQ0FDZixNQUFBLENBQUEsT0FBZSxBQUNoQixDQUFBLEFBRUEsS0FBQSxjQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxLQUFBLENBQUEsS0FBWSxDQUNaLFdBQUEsQ0FBQSxJQUFpQixDQUNqQixhQUFBLENBQUEsR0FBa0IsQ0FDbEIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxLQUFBLENBQUEsS0FBb0IsQ0FDcEIsbUJBQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxLQUFzQyxDQUN0QyxtQkFBQSxDQUFBLEtBQTBCLEFBQzNCLENBQUEsQUFFQSxtQkFBQSxPQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLEtBQUEsQ0FBQSxLQUFZLENBQ1osV0FBQSxDQUFBLElBQWlCLENBQ2pCLGFBQUEsQ0FBQSxHQUFrQixDQUNsQixNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsT0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFvQixDQUNwQixtQkFBQSxDQUFBLFVBQUEsQ0FBQSxDQUFBLEtBQXNDLENBQ3RDLG1CQUFBLENBQUEsS0FBMEIsQUFDM0IsQ0FBQSxBQUVBLG1CQUFBLFNBQUEsZ0NBRUMsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsTUFBQSxDQUFBLFdBQW1CLENBQ25CLG1CQUFBLENBQUEsVUFBQSxDQUFBLENBQUEsS0FBc0MsQ0FDdEMsbUJBQUEsQ0FBQSxLQUEwQixBQUMzQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkRhdGFiYXNlU2V0dGluZ3NQYW5lbC5zdmVsdGUiXX0= */");
}
function get_each_context15(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function create_each_block15(ctx) {
  let option;
  let t0_value = (
    /*option*/
    ctx[17].name + ""
  );
  let t0;
  let t1;
  let option_data_test_id_value;
  let option_id_value;
  let option_value_value;
  let option_label_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {
        "data-test-id": true,
        id: true,
        label: true,
        class: true
      });
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, t0_value);
      t1 = claim_space(option_nodes);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(option, "data-test-id", option_data_test_id_value = /*option*/
      ctx[17].id);
      attr_dev(option, "id", option_id_value = /*option*/
      ctx[17].id);
      option.__value = option_value_value = /*option*/
      ctx[17];
      option.value = option.__value;
      attr_dev(option, "label", option_label_value = /*option*/
      ctx[17].name);
      attr_dev(option, "class", "svelte-b48xai");
      add_location(option, file43, 115, 5, 3626);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t0);
      append_hydration_dev(option, t1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block15.name,
    type: "each",
    source: "(115:4) {#each databaseOptions as option}",
    ctx
  });
  return block;
}
function create_if_block_45(ctx) {
  let div;
  let switch_instance;
  let updating_disableSave;
  let updating_credentials;
  let div_transition;
  let current;
  function switch_instance_disableSave_binding(value) {
    ctx[12](value);
  }
  function switch_instance_credentials_binding(value) {
    ctx[13](value);
  }
  var switch_value = (
    /*selectedDatabase*/
    ctx[5].formComponent
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      gitIgnore: (
        /*gitIgnore*/
        ctx2[1]
      ),
      existingCredentials: (
        /*selectedDatabase*/
        ctx2[5].id === /*settings*/
        ctx2[0].database ? (
          /*existingCredentials*/
          ctx2[3]
        ) : {}
      )
    };
    if (
      /*disableSave*/
      ctx2[6] !== void 0
    ) {
      switch_instance_props.disableSave = /*disableSave*/
      ctx2[6];
    }
    if (
      /*credentials*/
      ctx2[2] !== void 0
    ) {
      switch_instance_props.credentials = /*credentials*/
      ctx2[2];
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(
      switch_instance,
      "disableSave",
      switch_instance_disableSave_binding,
      /*disableSave*/
      ctx[6]
    ));
    binding_callbacks.push(() => bind(
      switch_instance,
      "credentials",
      switch_instance_credentials_binding,
      /*credentials*/
      ctx[2]
    ));
  }
  const block = {
    c: function create() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel svelte-b48xai");
      add_location(div, file43, 122, 3, 3821);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*gitIgnore*/
      2)
        switch_instance_changes.gitIgnore = /*gitIgnore*/
        ctx2[1];
      if (dirty & /*selectedDatabase, settings, existingCredentials*/
      41)
        switch_instance_changes.existingCredentials = /*selectedDatabase*/
        ctx2[5].id === /*settings*/
        ctx2[0].database ? (
          /*existingCredentials*/
          ctx2[3]
        ) : {};
      if (!updating_disableSave && dirty & /*disableSave*/
      64) {
        updating_disableSave = true;
        switch_instance_changes.disableSave = /*disableSave*/
        ctx2[6];
        add_flush_callback(() => updating_disableSave = false);
      }
      if (!updating_credentials && dirty & /*credentials*/
      4) {
        updating_credentials = true;
        switch_instance_changes.credentials = /*credentials*/
        ctx2[2];
        add_flush_callback(() => updating_credentials = false);
      }
      if (switch_value !== (switch_value = /*selectedDatabase*/
      ctx2[5].formComponent)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          binding_callbacks.push(() => bind(
            switch_instance,
            "disableSave",
            switch_instance_disableSave_binding,
            /*disableSave*/
            ctx2[6]
          ));
          binding_callbacks.push(() => bind(
            switch_instance,
            "credentials",
            switch_instance_credentials_binding,
            /*credentials*/
            ctx2[2]
          ));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (switch_instance)
        destroy_component(switch_instance);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_45.name,
    type: "if",
    source: "(122:2) {#if selectedDatabase.formComponent}",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let div;
  let promise;
  let div_transition;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 15,
    error: 16
  };
  handle_promise(promise = /*testResult*/
  ctx[4], info);
  const block = {
    c: function create() {
      div = element("div");
      info.block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      info.block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel test-result svelte-b48xai");
      add_location(div, file43, 133, 3, 4133);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & /*testResult*/
      16 && promise !== (promise = /*testResult*/
      ctx[4]) && handle_promise(promise, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(info.block);
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      info.block.d();
      info.token = null;
      info = null;
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(133:2) {#if testResult}",
    ctx
  });
  return block;
}
function create_catch_block(ctx) {
  let span0;
  let t0;
  let span1;
  let t1;
  let t2;
  let p;
  let t3_value = (
    /*error*/
    ctx[16].message + ""
  );
  let t3;
  let p_intro;
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text("Unable to connect");
      t2 = space();
      p = element("p");
      t3 = text(t3_value);
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      t0 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", { style: true });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, "Unable to connect");
      span1_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      t3 = claim_text(p_nodes, t3_value);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "indicator fail svelte-b48xai");
      add_location(span0, file43, 139, 5, 4387);
      set_style(span1, "color", "var(--red-600)");
      add_location(span1, file43, 140, 5, 4424);
      attr_dev(p, "class", "error svelte-b48xai");
      add_location(p, file43, 141, 5, 4489);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t1);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t3);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*testResult*/
      16 && t3_value !== (t3_value = /*error*/
      ctx2[16].message + ""))
        set_data_dev(t3, t3_value);
    },
    i: function intro(local) {
      if (local) {
        if (!p_intro) {
          add_render_callback(() => {
            p_intro = create_in_transition(p, slide, {});
            p_intro.start();
          });
        }
      }
    },
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span0);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(span1);
      if (detaching)
        detach_dev(t2);
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_catch_block.name,
    type: "catch",
    source: "(139:4) {:catch error}",
    ctx
  });
  return block;
}
function create_then_block(ctx) {
  let span0;
  let span1;
  let t_value = (
    /*result*/
    ctx[15] + ""
  );
  let t;
  const block = {
    c: function create() {
      span0 = element("span");
      span1 = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      span1 = claim_element(nodes, "SPAN", {});
      var span1_nodes = children(span1);
      t = claim_text(span1_nodes, t_value);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "indicator success svelte-b48xai");
      add_location(span0, file43, 137, 5, 4307);
      add_location(span1, file43, 137, 39, 4341);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*testResult*/
      16 && t_value !== (t_value = /*result*/
      ctx2[15] + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span0);
      if (detaching)
        detach_dev(span1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_then_block.name,
    type: "then",
    source: "(137:4) {:then result}",
    ctx
  });
  return block;
}
function create_pending_block(ctx) {
  let span0;
  let span1;
  let t;
  const block = {
    c: function create() {
      span0 = element("span");
      span1 = element("span");
      t = text("Testing connection");
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      span1 = claim_element(nodes, "SPAN", {});
      var span1_nodes = children(span1);
      t = claim_text(span1_nodes, "Testing connection");
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "indicator running svelte-b48xai");
      add_location(span0, file43, 135, 5, 4217);
      add_location(span1, file43, 135, 39, 4251);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span0);
      if (detaching)
        detach_dev(span1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_pending_block.name,
    type: "pending",
    source: '(135:23)       <span class=\\"indicator running\\" /><span>Testing connection</span>     {:then result}',
    ctx
  });
  return block;
}
function create_else_block_23(ctx) {
  let span;
  let t0;
  let a;
  let t1;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text("Need help with this step? ");
      a = element("a");
      t1 = text("Get in touch ");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "Need help with this step? ");
      a = claim_element(span_nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      t1 = claim_text(a_nodes, "Get in touch ");
      a_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "class", "docs-link svelte-b48xai");
      attr_dev(a, "href", "https://docs.evidence.dev/community");
      add_location(a, file43, 155, 31, 4836);
      add_location(span, file43, 154, 3, 4799);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, a);
      append_hydration_dev(a, t1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_23.name,
    type: "else",
    source: "(154:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_214(ctx) {
  let span;
  let t0;
  let a;
  let t1_value = (
    /*selectedDatabase*/
    ctx[5].name + ""
  );
  let t1;
  let t2;
  let a_href_value;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text("Learn more about ");
      a = element("a");
      t1 = text(t1_value);
      t2 = text(" Connection Settings ");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "Learn more about ");
      a = claim_element(span_nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      t1 = claim_text(a_nodes, t1_value);
      t2 = claim_text(a_nodes, " Connection Settings ");
      a_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "class", "docs-link svelte-b48xai");
      attr_dev(a, "href", a_href_value = /*selectedDatabase*/
      ctx[5].docsHref);
      add_location(a, file43, 149, 22, 4655);
      add_location(span, file43, 148, 3, 4627);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, a);
      append_hydration_dev(a, t1);
      append_hydration_dev(a, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*selectedDatabase*/
      32 && t1_value !== (t1_value = /*selectedDatabase*/
      ctx2[5].name + ""))
        set_data_dev(t1, t1_value);
      if (dirty & /*selectedDatabase, databaseOptions*/
      288 && a_href_value !== (a_href_value = /*selectedDatabase*/
      ctx2[5].docsHref)) {
        attr_dev(a, "href", a_href_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_214.name,
    type: "if",
    source: "(148:2) {#if selectedDatabase.docsHref}",
    ctx
  });
  return block;
}
function create_else_block_17(ctx) {
  let button;
  let t;
  const block = {
    c: function create() {
      button = element("button");
      t = text("Save");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, id: true, class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, "Save");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "submit");
      attr_dev(button, "id", "save");
      button.disabled = true;
      attr_dev(button, "class", "svelte-b48xai");
      add_location(button, file43, 167, 3, 5165);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_17.name,
    type: "else",
    source: "(167:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block32(ctx) {
  let if_block_anchor;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*credentialsEdited*/
      ctx2[7]
    )
      return create_if_block_116;
    return create_else_block13;
  }
  let current_block_type = select_block_type_2(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block32.name,
    type: "if",
    source: "(161:2) {#if selectedDatabase.id}",
    ctx
  });
  return block;
}
function create_else_block13(ctx) {
  let button;
  let t;
  const block = {
    c: function create() {
      button = element("button");
      t = text("Test");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, id: true, class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, "Test");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "submit");
      attr_dev(button, "id", "save");
      attr_dev(button, "class", "svelte-b48xai");
      add_location(button, file43, 164, 4, 5097);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block13.name,
    type: "else",
    source: "(164:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_116(ctx) {
  let button;
  let t;
  const block = {
    c: function create() {
      button = element("button");
      t = text("Save");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, id: true, class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, "Save");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "submit");
      attr_dev(button, "id", "save");
      button.disabled = /*disableSave*/
      ctx[6];
      attr_dev(button, "class", "svelte-b48xai");
      add_location(button, file43, 162, 4, 5013);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*disableSave*/
      64) {
        prop_dev(
          button,
          "disabled",
          /*disableSave*/
          ctx2[6]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: "(162:3) {#if credentialsEdited}",
    ctx
  });
  return block;
}
function create_fragment51(ctx) {
  let form;
  let div1;
  let div0;
  let h2;
  let t0;
  let t1;
  let p0;
  let t2;
  let t3;
  let p1;
  let t4;
  let t5;
  let p2;
  let t6;
  let code0;
  let t7;
  let t8;
  let code1;
  let t9;
  let t10;
  let h3;
  let t11;
  let t12;
  let select;
  let t13;
  let t14;
  let t15;
  let footer;
  let t16;
  let form_intro;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*databaseOptions*/
    ctx[8]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block15(get_each_context15(ctx, each_value, i));
  }
  let if_block0 = (
    /*selectedDatabase*/
    ctx[5].formComponent && create_if_block_45(ctx)
  );
  let if_block1 = (
    /*testResult*/
    ctx[4] && create_if_block_35(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*selectedDatabase*/
      ctx2[5].docsHref
    )
      return create_if_block_214;
    return create_else_block_23;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block2 = current_block_type(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (
      /*selectedDatabase*/
      ctx2[5].id
    )
      return create_if_block32;
    return create_else_block_17;
  }
  let current_block_type_1 = select_block_type_1(ctx, -1);
  let if_block3 = current_block_type_1(ctx);
  const block = {
    c: function create() {
      form = element("form");
      div1 = element("div");
      div0 = element("div");
      h2 = element("h2");
      t0 = text("Data Source Connection");
      t1 = space();
      p0 = element("p");
      t2 = text("Evidence supports one data source per project.");
      t3 = space();
      p1 = element("p");
      t4 = text("These credentials will be used when running locally. For your production environment, see\n				the deployment panel.");
      t5 = space();
      p2 = element("p");
      t6 = text("To use the demo database included with the starter template, choose ");
      code0 = element("code");
      t7 = text("DuckDB");
      t8 = text(" and\n				");
      code1 = element("code");
      t9 = text("needful_things.duckdb");
      t10 = space();
      h3 = element("h3");
      t11 = text("Connection Type");
      t12 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t13 = space();
      if (if_block0)
        if_block0.c();
      t14 = space();
      if (if_block1)
        if_block1.c();
      t15 = space();
      footer = element("footer");
      if_block2.c();
      t16 = space();
      if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", {
        autocomplete: true,
        id: true,
        class: true
      });
      var form_nodes = children(form);
      div1 = claim_element(form_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      h2 = claim_element(div0_nodes, "H2", {});
      var h2_nodes = children(h2);
      t0 = claim_text(h2_nodes, "Data Source Connection");
      h2_nodes.forEach(detach_dev);
      t1 = claim_space(div0_nodes);
      p0 = claim_element(div0_nodes, "P", {});
      var p0_nodes = children(p0);
      t2 = claim_text(p0_nodes, "Evidence supports one data source per project.");
      p0_nodes.forEach(detach_dev);
      t3 = claim_space(div0_nodes);
      p1 = claim_element(div0_nodes, "P", {});
      var p1_nodes = children(p1);
      t4 = claim_text(p1_nodes, "These credentials will be used when running locally. For your production environment, see\n				the deployment panel.");
      p1_nodes.forEach(detach_dev);
      t5 = claim_space(div0_nodes);
      p2 = claim_element(div0_nodes, "P", {});
      var p2_nodes = children(p2);
      t6 = claim_text(p2_nodes, "To use the demo database included with the starter template, choose ");
      code0 = claim_element(p2_nodes, "CODE", {});
      var code0_nodes = children(code0);
      t7 = claim_text(code0_nodes, "DuckDB");
      code0_nodes.forEach(detach_dev);
      t8 = claim_text(p2_nodes, " and\n				");
      code1 = claim_element(p2_nodes, "CODE", {});
      var code1_nodes = children(code1);
      t9 = claim_text(code1_nodes, "needful_things.duckdb");
      code1_nodes.forEach(detach_dev);
      p2_nodes.forEach(detach_dev);
      t10 = claim_space(div0_nodes);
      h3 = claim_element(div0_nodes, "H3", { class: true });
      var h3_nodes = children(h3);
      t11 = claim_text(h3_nodes, "Connection Type");
      h3_nodes.forEach(detach_dev);
      t12 = claim_space(div0_nodes);
      select = claim_element(div0_nodes, "SELECT", { "data-test-id": true, class: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t13 = claim_space(div1_nodes);
      if (if_block0)
        if_block0.l(div1_nodes);
      t14 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t15 = claim_space(form_nodes);
      footer = claim_element(form_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      if_block2.l(footer_nodes);
      t16 = claim_space(footer_nodes);
      if_block3.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h2, file43, 98, 3, 3064);
      add_location(p0, file43, 99, 3, 3099);
      add_location(p1, file43, 100, 3, 3156);
      add_location(code0, file43, 105, 72, 3367);
      add_location(code1, file43, 106, 4, 3395);
      add_location(p2, file43, 104, 3, 3291);
      attr_dev(h3, "class", "svelte-b48xai");
      add_location(h3, file43, 108, 3, 3441);
      attr_dev(select, "data-test-id", "dbConnectionType");
      attr_dev(select, "class", "svelte-b48xai");
      if (
        /*selectedDatabase*/
        ctx[5] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[11].call(select)
        ));
      add_location(select, file43, 109, 3, 3469);
      attr_dev(div0, "class", "panel svelte-b48xai");
      add_location(div0, file43, 97, 2, 3041);
      attr_dev(div1, "class", "container svelte-b48xai");
      add_location(div1, file43, 96, 1, 3015);
      attr_dev(footer, "class", "svelte-b48xai");
      add_location(footer, file43, 146, 1, 4581);
      attr_dev(form, "autocomplete", "off");
      attr_dev(form, "id", "connect-database");
      attr_dev(form, "class", "svelte-b48xai");
      add_location(form, file43, 95, 0, 2914);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      append_hydration_dev(form, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, h2);
      append_hydration_dev(h2, t0);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div0, p0);
      append_hydration_dev(p0, t2);
      append_hydration_dev(div0, t3);
      append_hydration_dev(div0, p1);
      append_hydration_dev(p1, t4);
      append_hydration_dev(div0, t5);
      append_hydration_dev(div0, p2);
      append_hydration_dev(p2, t6);
      append_hydration_dev(p2, code0);
      append_hydration_dev(code0, t7);
      append_hydration_dev(p2, t8);
      append_hydration_dev(p2, code1);
      append_hydration_dev(code1, t9);
      append_hydration_dev(div0, t10);
      append_hydration_dev(div0, h3);
      append_hydration_dev(h3, t11);
      append_hydration_dev(div0, t12);
      append_hydration_dev(div0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(
        select,
        /*selectedDatabase*/
        ctx[5]
      );
      append_hydration_dev(div1, t13);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t14);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(form, t15);
      append_hydration_dev(form, footer);
      if_block2.m(footer, null);
      append_hydration_dev(footer, t16);
      if_block3.m(footer, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[11]
          ),
          listen_dev(
            select,
            "change",
            /*databaseChange*/
            ctx[10],
            false,
            false,
            false
          ),
          listen_dev(form, "submit", prevent_default(
            /*submitForm*/
            ctx[9]
          ), false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*databaseOptions*/
      256) {
        each_value = /*databaseOptions*/
        ctx2[8];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context15(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block15(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selectedDatabase, databaseOptions*/
      288) {
        select_option(
          select,
          /*selectedDatabase*/
          ctx2[5]
        );
      }
      if (
        /*selectedDatabase*/
        ctx2[5].formComponent
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*selectedDatabase*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_45(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t14);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*testResult*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*testResult*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_35(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(footer, t16);
        }
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2, dirty)) && if_block3) {
        if_block3.p(ctx2, dirty);
      } else {
        if_block3.d(1);
        if_block3 = current_block_type_1(ctx2);
        if (if_block3) {
          if_block3.c();
          if_block3.m(footer, null);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      if (local) {
        if (!form_intro) {
          add_render_callback(() => {
            form_intro = create_in_transition(form, blur, {});
            form_intro.start();
          });
        }
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      destroy_each(each_blocks, detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_block2.d();
      if_block3.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude48 = true;
async function runTest() {
  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
  await sleep(1e3);
  const res = await fetch("/api/testConnection.json", { method: "POST" });
  let result = await res.json();
  if (res.ok) {
    return result;
  } else {
    throw new Error(result);
  }
}
function instance51($$self, $$props, $$invalidate) {
  let credentialsEdited;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DatabaseSettingsPanel", slots, []);
  let { settings } = $$props;
  let { gitIgnore } = $$props;
  let credentials = {};
  let existingCredentials = settings.credentials;
  let testResult = null;
  const databaseOptions = [
    { name: "Choose a data source" },
    {
      id: "bigquery",
      name: "BigQuery",
      formComponent: BigqueryForm_default,
      docsHref: "https://docs.evidence.dev/core-concepts/data-sources/#bigquery"
    },
    {
      id: "postgres",
      name: "PostgreSQL",
      formComponent: PostgresForm_default
    },
    {
      id: "mysql",
      name: "MySQL",
      formComponent: MysqlForm_default
    },
    {
      id: "redshift",
      name: "Redshift",
      formComponent: RedshiftForm_default
    },
    {
      id: "snowflake",
      // Redshift uses the postgres connector under the hood
      name: "Snowflake",
      formComponent: SnowflakeForm_default
    },
    {
      id: "sqlite",
      name: "SQLite",
      formComponent: SqliteForm_default
    },
    {
      id: "duckdb",
      name: "DuckDB",
      formComponent: DuckdbForm_default
    },
    {
      id: "csv",
      name: "CSV",
      formComponent: CSVForm_default
    },
    {
      id: "mssql",
      name: "SQL Server",
      formComponent: MSSQLForm_default
    }
  ];
  let selectedDatabase = databaseOptions.filter((d) => d.id === settings.database)[0] ?? databaseOptions[0];
  let disableSave = false;
  async function save() {
    $$invalidate(0, settings.database = selectedDatabase.id, settings);
    $$invalidate(0, settings.credentials = credentials, settings);
    const submitted = await fetch("/api/settings.json", {
      method: "POST",
      body: JSON.stringify({ settings })
    });
    $$invalidate(0, settings = await submitted.json());
    $$invalidate(3, existingCredentials = settings.credentials);
  }
  async function submitForm() {
    if (credentialsEdited || selectedDatabase.id === "csv") {
      await save();
      $$invalidate(4, testResult = runTest());
    } else {
      $$invalidate(4, testResult = runTest());
    }
  }
  function databaseChange() {
    $$invalidate(4, testResult = null);
    if (selectedDatabase.id === "csv") {
      $$invalidate(6, disableSave = false);
    } else {
      $$invalidate(6, disableSave = true);
    }
  }
  $$self.$$.on_mount.push(function() {
    if (settings === void 0 && !("settings" in $$props || $$self.$$.bound[$$self.$$.props["settings"]])) {
      console.warn("<DatabaseSettingsPanel> was created without expected prop 'settings'");
    }
    if (gitIgnore === void 0 && !("gitIgnore" in $$props || $$self.$$.bound[$$self.$$.props["gitIgnore"]])) {
      console.warn("<DatabaseSettingsPanel> was created without expected prop 'gitIgnore'");
    }
  });
  const writable_props = ["settings", "gitIgnore"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DatabaseSettingsPanel> was created with unknown prop '${key}'`);
  });
  function select_change_handler() {
    selectedDatabase = select_value(this);
    $$invalidate(5, selectedDatabase);
    $$invalidate(8, databaseOptions);
  }
  function switch_instance_disableSave_binding(value) {
    disableSave = value;
    $$invalidate(6, disableSave);
  }
  function switch_instance_credentials_binding(value) {
    credentials = value;
    $$invalidate(2, credentials);
  }
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
    if ("gitIgnore" in $$props2)
      $$invalidate(1, gitIgnore = $$props2.gitIgnore);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude48,
    BigqueryForm: BigqueryForm_default,
    PostgresForm: PostgresForm_default,
    SnowflakeForm: SnowflakeForm_default,
    RedshiftForm: RedshiftForm_default,
    MysqlForm: MysqlForm_default,
    SqliteForm: SqliteForm_default,
    DuckdbForm: DuckdbForm_default,
    CSVForm: CSVForm_default,
    MSSQLForm: MSSQLForm_default,
    slide,
    blur,
    settings,
    gitIgnore,
    credentials,
    existingCredentials,
    testResult,
    databaseOptions,
    selectedDatabase,
    disableSave,
    runTest,
    save,
    submitForm,
    databaseChange,
    credentialsEdited
  });
  $$self.$inject_state = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
    if ("gitIgnore" in $$props2)
      $$invalidate(1, gitIgnore = $$props2.gitIgnore);
    if ("credentials" in $$props2)
      $$invalidate(2, credentials = $$props2.credentials);
    if ("existingCredentials" in $$props2)
      $$invalidate(3, existingCredentials = $$props2.existingCredentials);
    if ("testResult" in $$props2)
      $$invalidate(4, testResult = $$props2.testResult);
    if ("selectedDatabase" in $$props2)
      $$invalidate(5, selectedDatabase = $$props2.selectedDatabase);
    if ("disableSave" in $$props2)
      $$invalidate(6, disableSave = $$props2.disableSave);
    if ("credentialsEdited" in $$props2)
      $$invalidate(7, credentialsEdited = $$props2.credentialsEdited);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*credentials, existingCredentials*/
    12) {
      $:
        $$invalidate(7, credentialsEdited = JSON.stringify(credentials) != JSON.stringify(existingCredentials));
    }
  };
  return [
    settings,
    gitIgnore,
    credentials,
    existingCredentials,
    testResult,
    selectedDatabase,
    disableSave,
    credentialsEdited,
    databaseOptions,
    submitForm,
    databaseChange,
    select_change_handler,
    switch_instance_disableSave_binding,
    switch_instance_credentials_binding
  ];
}
var DatabaseSettingsPanel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, { settings: 0, gitIgnore: 1 }, add_css35);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DatabaseSettingsPanel",
      options,
      id: create_fragment51.name
    });
  }
  get settings() {
    throw new Error_13("<DatabaseSettingsPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error_13("<DatabaseSettingsPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gitIgnore() {
    throw new Error_13("<DatabaseSettingsPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gitIgnore(value) {
    throw new Error_13("<DatabaseSettingsPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DatabaseSettingsPanel_default = DatabaseSettingsPanel;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/EvidenceDeploy.svelte
var file44 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/EvidenceDeploy.svelte";
function add_css36(target) {
  append_styles(target, "svelte-15grw16", "button.svelte-15grw16.svelte-15grw16{margin-right:0.25em;margin-left:0.25em;font-style:normal;text-decoration:none;font-size:14px;cursor:pointer;background-color:var(--blue-600);color:white;font-weight:bold;border-radius:4px;border:1px solid var(--blue-700);padding:0.4em 1.1em;transition-property:background, color;transition-duration:350ms}div.new-format-buttons.svelte-15grw16.svelte-15grw16{display:flex;justify-content:flex-start;padding-top:0.5em}ul.svelte-15grw16.svelte-15grw16{list-style:none;-webkit-padding-start:0px;padding-inline-start:0px}ul.svelte-15grw16 li.svelte-15grw16::before{content:'\\2022';color:var(--grey-800);font-weight:bold;display:inline-block;width:0.9em;margin-left:1.5em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXZpZGVuY2VEZXBsb3kuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXdCQyxNQUFBLDhCQUFBLENBQUEsQUFDQyxZQUFBLENBQUEsTUFBb0IsQ0FDcEIsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixlQUFBLENBQUEsSUFBcUIsQ0FDckIsU0FBQSxDQUFBLElBQWUsQ0FDZixNQUFBLENBQUEsT0FBZSxDQUNmLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLEtBQUEsQ0FBQSxLQUFZLENBQ1osV0FBQSxDQUFBLElBQWlCLENBQ2pCLGFBQUEsQ0FBQSxHQUFrQixDQUNsQixNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsT0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFvQixDQUNwQixtQkFBQSxDQUFBLFVBQUEsQ0FBQSxDQUFBLEtBQXNDLENBQ3RDLG1CQUFBLENBQUEsS0FBMEIsQUFDM0IsQ0FBQSxBQUVBLEdBQUEsbUJBQUEsOEJBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxJQUFhLENBQ2IsZUFBQSxDQUFBLFVBQTJCLENBQzNCLFdBQUEsQ0FBQSxLQUFrQixBQUNuQixDQUFBLEFBRUEsRUFBQSw4QkFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQWdCLENBQ2hCLHFCQUFBLENBQUEsR0FBMEIsQ0FDbEIsb0JBQUEsQ0FBQSxHQUF5QixBQUNsQyxDQUFBLEFBRUEsaUJBQUEsQ0FBQSxpQkFBQSxRQUFBLEFBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxPQUFnQixDQUNoQixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFdBQUEsQ0FBQSxJQUFpQixDQUNqQixPQUFBLENBQUEsWUFBcUIsQ0FDckIsS0FBQSxDQUFBLEtBQVksQ0FDWixXQUFBLENBQUEsS0FBa0IsQUFDbkIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJFdmlkZW5jZURlcGxveS5zdmVsdGUiXX0= */");
}
function create_fragment52(ctx) {
  let h2;
  let t0;
  let t1;
  let p0;
  let t2;
  let t3;
  let ul;
  let li0;
  let t4;
  let code;
  let t5_value = "<";
  let t5;
  let t6;
  let t7_value = ">";
  let t7;
  let t8;
  let t9;
  let li1;
  let t10;
  let t11;
  let li2;
  let t12;
  let t13;
  let li3;
  let t14;
  let t15;
  let p1;
  let t16;
  let t17;
  let div;
  let button;
  let t18;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      h2 = element("h2");
      t0 = text("Deploying to Evidence Cloud");
      t1 = space();
      p0 = element("p");
      t2 = text("Evidence's Cloud hosting service allows you to:");
      t3 = space();
      ul = element("ul");
      li0 = element("li");
      t4 = text("Host your project at ");
      code = element("code");
      t5 = text(t5_value);
      t6 = text("organisation");
      t7 = text(t7_value);
      t8 = text(".evidence.app");
      t9 = space();
      li1 = element("li");
      t10 = text("Authenticate users");
      t11 = space();
      li2 = element("li");
      t12 = text("Schedule updates to your data");
      t13 = space();
      li3 = element("li");
      t14 = text("Re-build when you push changes to your project");
      t15 = space();
      p1 = element("p");
      t16 = text("Evidence Cloud is in private beta. Request early access below.");
      t17 = space();
      div = element("div");
      button = element("button");
      t18 = text("Request Early Access");
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", {});
      var h2_nodes = children(h2);
      t0 = claim_text(h2_nodes, "Deploying to Evidence Cloud");
      h2_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      p0 = claim_element(nodes, "P", {});
      var p0_nodes = children(p0);
      t2 = claim_text(p0_nodes, "Evidence's Cloud hosting service allows you to:");
      p0_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      li0 = claim_element(ul_nodes, "LI", { class: true });
      var li0_nodes = children(li0);
      t4 = claim_text(li0_nodes, "Host your project at ");
      code = claim_element(li0_nodes, "CODE", {});
      var code_nodes = children(code);
      t5 = claim_text(code_nodes, t5_value);
      t6 = claim_text(code_nodes, "organisation");
      t7 = claim_text(code_nodes, t7_value);
      t8 = claim_text(code_nodes, ".evidence.app");
      code_nodes.forEach(detach_dev);
      li0_nodes.forEach(detach_dev);
      t9 = claim_space(ul_nodes);
      li1 = claim_element(ul_nodes, "LI", { class: true });
      var li1_nodes = children(li1);
      t10 = claim_text(li1_nodes, "Authenticate users");
      li1_nodes.forEach(detach_dev);
      t11 = claim_space(ul_nodes);
      li2 = claim_element(ul_nodes, "LI", { class: true });
      var li2_nodes = children(li2);
      t12 = claim_text(li2_nodes, "Schedule updates to your data");
      li2_nodes.forEach(detach_dev);
      t13 = claim_space(ul_nodes);
      li3 = claim_element(ul_nodes, "LI", { class: true });
      var li3_nodes = children(li3);
      t14 = claim_text(li3_nodes, "Re-build when you push changes to your project");
      li3_nodes.forEach(detach_dev);
      ul_nodes.forEach(detach_dev);
      t15 = claim_space(nodes);
      p1 = claim_element(nodes, "P", {});
      var p1_nodes = children(p1);
      t16 = claim_text(p1_nodes, "Evidence Cloud is in private beta. Request early access below.");
      p1_nodes.forEach(detach_dev);
      t17 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t18 = claim_text(button_nodes, "Request Early Access");
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h2, file44, 4, 0, 75);
      add_location(p0, file44, 5, 0, 112);
      add_location(code, file44, 7, 26, 198);
      attr_dev(li0, "class", "svelte-15grw16");
      add_location(li0, file44, 7, 1, 173);
      attr_dev(li1, "class", "svelte-15grw16");
      add_location(li1, file44, 8, 1, 253);
      attr_dev(li2, "class", "svelte-15grw16");
      add_location(li2, file44, 9, 1, 282);
      attr_dev(li3, "class", "svelte-15grw16");
      add_location(li3, file44, 10, 1, 322);
      attr_dev(ul, "class", "svelte-15grw16");
      add_location(ul, file44, 6, 0, 167);
      add_location(p1, file44, 12, 0, 384);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "svelte-15grw16");
      add_location(button, file44, 14, 1, 488);
      attr_dev(div, "class", "new-format-buttons svelte-15grw16");
      add_location(div, file44, 13, 0, 454);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      append_hydration_dev(h2, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, p0, anchor);
      append_hydration_dev(p0, t2);
      insert_hydration_dev(target, t3, anchor);
      insert_hydration_dev(target, ul, anchor);
      append_hydration_dev(ul, li0);
      append_hydration_dev(li0, t4);
      append_hydration_dev(li0, code);
      append_hydration_dev(code, t5);
      append_hydration_dev(code, t6);
      append_hydration_dev(code, t7);
      append_hydration_dev(code, t8);
      append_hydration_dev(ul, t9);
      append_hydration_dev(ul, li1);
      append_hydration_dev(li1, t10);
      append_hydration_dev(ul, t11);
      append_hydration_dev(ul, li2);
      append_hydration_dev(li2, t12);
      append_hydration_dev(ul, t13);
      append_hydration_dev(ul, li3);
      append_hydration_dev(li3, t14);
      insert_hydration_dev(target, t15, anchor);
      insert_hydration_dev(target, p1, anchor);
      append_hydration_dev(p1, t16);
      insert_hydration_dev(target, t17, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      append_hydration_dev(button, t18);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[0],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h2);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(p0);
      if (detaching)
        detach_dev(t3);
      if (detaching)
        detach_dev(ul);
      if (detaching)
        detach_dev(t15);
      if (detaching)
        detach_dev(p1);
      if (detaching)
        detach_dev(t17);
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude49 = true;
function instance52($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EvidenceDeploy", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EvidenceDeploy> was created with unknown prop '${key}'`);
  });
  const click_handler = () => window.open("https://du3tapwtcbi.typeform.com/to/kwp7ZD3q?utm_source=product&utm_campaign=deploy_panel");
  $$self.$capture_state = () => ({ evidenceInclude: evidenceInclude49 });
  return [click_handler];
}
var EvidenceDeploy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, {}, add_css36);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EvidenceDeploy",
      options,
      id: create_fragment52.name
    });
  }
};
var EvidenceDeploy_default = EvidenceDeploy;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/VariableCopy.svelte
var file45 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/VariableCopy.svelte";
function add_css37(target) {
  append_styles(target, "svelte-augadu", "button.container.svelte-augadu{box-sizing:border-box;background-color:var(--grey-100);border-radius:4px 4px 4px 4px;border:1px solid var(--grey-200);padding:0.9em 0.35em;color:var(--grey-800);size:0.75em;cursor:pointer;user-select:none;-webkit-user-select:none;-moz-user-select:none;display:flex;flex-direction:row;justify-content:space-between;align-items:center;transition:all 400ms;width:100%;font-family:var(--monospace-font-family);line-height:1.6;font-size:inherit}button.container.svelte-augadu:hover{border-color:var(--blue-500);background-color:var(--blue-100);color:var(--blue-800);transition:all 400ms}button.container.svelte-augadu:active{border-color:var(--green-500);background-color:var(--green-100);color:var(--green-800)}button.container.copied.svelte-augadu{border-color:var(--green-500);background-color:var(--green-100);color:var(--green-900)}span.var-value.svelte-augadu{width:85%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:left}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmFyaWFibGVDb3B5LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEyREMsTUFBQSxVQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxhQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBOEIsQ0FDOUIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxLQUFBLENBQUEsTUFBcUIsQ0FDckIsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixJQUFBLENBQUEsTUFBWSxDQUNaLE1BQUEsQ0FBQSxPQUFlLENBQ2YsV0FBQSxDQUFBLElBQWlCLENBQ2pCLG1CQUFBLENBQUEsSUFBeUIsQ0FDekIsZ0JBQUEsQ0FBQSxJQUFzQixDQUN0QixPQUFBLENBQUEsSUFBYSxDQUNiLGNBQUEsQ0FBQSxHQUFtQixDQUNuQixlQUFBLENBQUEsYUFBOEIsQ0FDOUIsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBcUIsQ0FDckIsS0FBQSxDQUFBLElBQVcsQ0FDWCxXQUFBLENBQUEsSUFBQSx1QkFBQSxDQUF5QyxDQUN6QyxXQUFBLENBQUEsR0FBZ0IsQ0FDaEIsU0FBQSxDQUFBLE9BQWtCLEFBQ25CLENBQUEsQUFFQSxNQUFBLHdCQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsWUFBQSxDQUFBLElBQUEsVUFBQSxDQUE2QixDQUM3QixnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBcUIsQUFDdEIsQ0FBQSxBQUVBLE1BQUEsd0JBQUEsT0FBQSxBQUFBLENBQUEsQUFDQyxZQUFBLENBQUEsSUFBQSxXQUFBLENBQThCLENBQzlCLGdCQUFBLENBQUEsSUFBQSxXQUFBLENBQWtDLENBQ2xDLEtBQUEsQ0FBQSxJQUFBLFdBQUEsQ0FBdUIsQUFDeEIsQ0FBQSxBQUVBLE1BQUEsVUFBQSxPQUFBLGNBQUEsQ0FBQSxBQUNDLFlBQUEsQ0FBQSxJQUFBLFdBQUEsQ0FBOEIsQ0FDOUIsZ0JBQUEsQ0FBQSxJQUFBLFdBQUEsQ0FBa0MsQ0FDbEMsS0FBQSxDQUFBLElBQUEsV0FBQSxDQUF1QixBQUN4QixDQUFBLEFBRUEsSUFBQSxVQUFBLGNBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxHQUFVLENBQ1YsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFFBQUEsQ0FBQSxNQUFnQixDQUNoQixhQUFBLENBQUEsUUFBdUIsQ0FDdkIsVUFBQSxDQUFBLElBQWdCLEFBQ2pCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVmFyaWFibGVDb3B5LnN2ZWx0ZSJdfQ== */");
}
function create_else_block_18(ctx) {
  let span;
  let raw_value = (
    /*hideText*/
    (ctx[1] ? "&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;" : (
      /*text*/
      ctx[0]
    )) + ""
  );
  let span_intro;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file45, 42, 3, 752);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      span.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*hideText, text*/
      3 && raw_value !== (raw_value = /*hideText*/
      (ctx2[1] ? "&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;" : (
        /*text*/
        ctx2[0]
      )) + ""))
        span.innerHTML = raw_value;
      ;
    },
    i: function intro(local) {
      if (!span_intro) {
        add_render_callback(() => {
          span_intro = create_in_transition(span, blur, {});
          span_intro.start();
        });
      }
    },
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_18.name,
    type: "else",
    source: "(42:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_117(ctx) {
  let span;
  let t;
  let span_intro;
  const block = {
    c: function create() {
      span = element("span");
      t = text("Copied");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, "Copied");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file45, 40, 3, 711);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: noop,
    i: function intro(local) {
      if (!span_intro) {
        add_render_callback(() => {
          span_intro = create_in_transition(span, blur, {});
          span_intro.start();
        });
      }
    },
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(40:2) {#if copied}",
    ctx
  });
  return block;
}
function create_else_block14(ctx) {
  let copy_1;
  let current;
  copy_1 = new CopyIcon_default({
    props: { class: "bx--snippet__icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(copy_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(copy_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(copy_1, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(copy_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(copy_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(copy_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block14.name,
    type: "else",
    source: "(53:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block33(ctx) {
  let copy_1;
  let current;
  copy_1 = new CopyIcon_default({
    props: {
      class: "bx--snippet__icon",
      color: "var(--green-900)"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(copy_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(copy_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(copy_1, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(copy_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(copy_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(copy_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block33.name,
    type: "if",
    source: "(51:2) {#if copied}",
    ctx
  });
  return block;
}
function create_fragment53(ctx) {
  let button;
  let span;
  let t;
  let div;
  let current_block_type_index;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*copied*/
      ctx2[3]
    )
      return create_if_block_117;
    return create_else_block_18;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  const if_block_creators = [create_if_block33, create_else_block14];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*copied*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      button = element("button");
      span = element("span");
      if_block0.c();
      t = space();
      div = element("div");
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if_block0.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t = claim_space(button_nodes);
      div = claim_element(button_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "var-value svelte-augadu");
      add_location(span, file45, 38, 1, 668);
      attr_dev(div, "class", "w-4 h-4");
      add_location(div, file45, 49, 1, 999);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "container h-6 w-6 svelte-augadu");
      toggle_class(
        button,
        "copied",
        /*copied*/
        ctx[3]
      );
      add_location(button, file45, 28, 0, 531);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, span);
      if_block0.m(span, null);
      append_hydration_dev(button, t);
      append_hydration_dev(button, div);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[4],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(span, null);
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
      if (!current || dirty & /*copied*/
      8) {
        toggle_class(
          button,
          "copied",
          /*copied*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if_block0.d();
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude50 = true;
function instance53($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VariableCopy", slots, []);
  let { text: text2 = void 0 } = $$props;
  let { hideText = false } = $$props;
  let copied = false;
  const toggleCopied = function() {
    $$invalidate(3, copied = false);
  };
  let { copy = async (text3) => {
    try {
      if (!copied) {
        await navigator.clipboard.writeText(text3);
        $$invalidate(3, copied = true);
        setTimeout(toggleCopied, 2e3);
      }
    } catch {
    }
  } } = $$props;
  const writable_props = ["text", "hideText", "copy"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VariableCopy> was created with unknown prop '${key}'`);
  });
  const click_handler = () => {
    if (text2 !== void 0) {
      copy(text2);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("hideText" in $$props2)
      $$invalidate(1, hideText = $$props2.hideText);
    if ("copy" in $$props2)
      $$invalidate(2, copy = $$props2.copy);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude50,
    blur,
    Copy: CopyIcon_default,
    text: text2,
    hideText,
    copied,
    toggleCopied,
    copy
  });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("hideText" in $$props2)
      $$invalidate(1, hideText = $$props2.hideText);
    if ("copied" in $$props2)
      $$invalidate(3, copied = $$props2.copied);
    if ("copy" in $$props2)
      $$invalidate(2, copy = $$props2.copy);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [text2, hideText, copy, copied, click_handler];
}
var VariableCopy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, { text: 0, hideText: 1, copy: 2 }, add_css37);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VariableCopy",
      options,
      id: create_fragment53.name
    });
  }
  get text() {
    throw new Error("<VariableCopy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<VariableCopy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideText() {
    throw new Error("<VariableCopy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideText(value) {
    throw new Error("<VariableCopy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copy() {
    throw new Error("<VariableCopy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copy(value) {
    throw new Error("<VariableCopy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VariableCopy_default = VariableCopy;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/EnvironmentVarListing.svelte
var file46 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/EnvironmentVarListing.svelte";
function add_css38(target) {
  append_styles(target, "svelte-1nevhrv", "div.environment-variable.svelte-1nevhrv{font-family:var(--ui-font-family);color:var(--grey-999);font-size:16px;margin-bottom:1.25em;display:flex;flex-direction:row;justify-content:space-between;align-items:center}div.titles.svelte-1nevhrv{font-family:var(--ui-font-family);color:var(--grey-999);font-size:16px;margin-bottom:0.25em;display:flex;flex-direction:row;justify-content:space-between;align-items:center}div.var-value.svelte-1nevhrv{margin-left:auto;width:45%}div.var-name.svelte-1nevhrv{width:45%}span.title.svelte-1nevhrv{width:45%;font-size:0.85em;color:var(--grey-800);text-transform:uppercase;letter-spacing:0.07em}.docs-link.svelte-1nevhrv{color:var(--blue-600);text-decoration:none}.docs-link.svelte-1nevhrv:hover{color:var(--blue-800)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRW52aXJvbm1lbnRWYXJMaXN0aW5nLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE2SEMsR0FBQSxxQkFBQSxlQUFBLENBQUEsQUFDQyxXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxDQUNsQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLENBQ2YsYUFBQSxDQUFBLE1BQXFCLENBQ3JCLE9BQUEsQ0FBQSxJQUFhLENBQ2IsY0FBQSxDQUFBLEdBQW1CLENBQ25CLGVBQUEsQ0FBQSxhQUE4QixDQUM5QixXQUFBLENBQUEsTUFBbUIsQUFDcEIsQ0FBQSxBQUVBLEdBQUEsT0FBQSxlQUFBLENBQUEsQUFDQyxXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxDQUNsQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLENBQ2YsYUFBQSxDQUFBLE1BQXFCLENBQ3JCLE9BQUEsQ0FBQSxJQUFhLENBQ2IsY0FBQSxDQUFBLEdBQW1CLENBQ25CLGVBQUEsQ0FBQSxhQUE4QixDQUM5QixXQUFBLENBQUEsTUFBbUIsQUFDcEIsQ0FBQSxBQUVBLEdBQUEsVUFBQSxlQUFBLENBQUEsQUFDQyxXQUFBLENBQUEsSUFBaUIsQ0FDakIsS0FBQSxDQUFBLEdBQVUsQUFDWCxDQUFBLEFBRUEsR0FBQSxTQUFBLGVBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxHQUFVLEFBQ1gsQ0FBQSxBQUVBLElBQUEsTUFBQSxlQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsR0FBVSxDQUNWLFNBQUEsQ0FBQSxNQUFpQixDQUNqQixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGNBQUEsQ0FBQSxTQUF5QixDQUN6QixjQUFBLENBQUEsTUFBc0IsQUFDdkIsQ0FBQSxBQUVBLFVBQUEsZUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixlQUFBLENBQUEsSUFBcUIsQUFDdEIsQ0FBQSxBQUVBLHlCQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkVudmlyb25tZW50VmFyTGlzdGluZy5zdmVsdGUiXX0= */");
}
function get_each_context16(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_else_block15(ctx) {
  let div;
  let span0;
  let t0;
  let span1;
  let t1;
  let t2;
  let each_1_anchor;
  let current;
  let each_value = (
    /*targetEnvVars*/
    ctx[1]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block16(get_each_context16(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      span0 = element("span");
      t0 = text("Key");
      span1 = element("span");
      t1 = text("Value");
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span0 = claim_element(div_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, "Key");
      span0_nodes.forEach(detach_dev);
      span1 = claim_element(div_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, "Value");
      span1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "title svelte-1nevhrv");
      add_location(span0, file46, 110, 2, 3203);
      attr_dev(span1, "class", "title svelte-1nevhrv");
      add_location(span1, file46, 110, 32, 3233);
      attr_dev(div, "class", "titles svelte-1nevhrv");
      add_location(div, file46, 109, 1, 3180);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(div, span1);
      append_hydration_dev(span1, t1);
      insert_hydration_dev(target, t2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*targetEnvVars*/
      2) {
        each_value = /*targetEnvVars*/
        ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context16(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block16(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (detaching)
        detach_dev(t2);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block15.name,
    type: "else",
    source: "(109:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_118(ctx) {
  let hr;
  let t0;
  let p;
  let t1;
  const block = {
    c: function create() {
      hr = element("hr");
      t0 = space();
      p = element("p");
      t1 = text("GCloud authentication isn't supported in cloud deployments, as it needs access to a browser. Set\n		up one of the other authentication options for a deployment.");
      this.h();
    },
    l: function claim(nodes) {
      hr = claim_element(nodes, "HR", {});
      t0 = claim_space(nodes);
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t1 = claim_text(p_nodes, "GCloud authentication isn't supported in cloud deployments, as it needs access to a browser. Set\n		up one of the other authentication options for a deployment.");
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(hr, file46, 103, 1, 2991);
      add_location(p, file46, 104, 1, 2999);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, hr, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(hr);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_118.name,
    type: "if",
    source: "(103:53) ",
    ctx
  });
  return block;
}
function create_if_block34(ctx) {
  let hr;
  let t0;
  let p;
  let t1;
  const block = {
    c: function create() {
      hr = element("hr");
      t0 = space();
      p = element("p");
      t1 = text("External browser authentication isn't supported in cloud deployments, as it needs access to a\n		browser. Set up one of the other authentication options for a deployment.");
      this.h();
    },
    l: function claim(nodes) {
      hr = claim_element(nodes, "HR", {});
      t0 = claim_space(nodes);
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t1 = claim_text(p_nodes, "External browser authentication isn't supported in cloud deployments, as it needs access to a\n		browser. Set up one of the other authentication options for a deployment.");
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(hr, file46, 97, 1, 2746);
      add_location(p, file46, 98, 1, 2754);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, hr, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(hr);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block34.name,
    type: "if",
    source: "(97:0) {#if credentials.authenticator === 'externalbrowser'}",
    ctx
  });
  return block;
}
function create_each_block16(ctx) {
  let div2;
  let div0;
  let variablecopy0;
  let t0;
  let div1;
  let variablecopy1;
  let t1;
  let current;
  variablecopy0 = new VariableCopy_default({
    props: { text: (
      /*envVar*/
      ctx[3].name
    ) },
    $$inline: true
  });
  variablecopy1 = new VariableCopy_default({
    props: {
      text: (
        /*envVar*/
        ctx[3].value
      ),
      hideText: true
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      create_component(variablecopy0.$$.fragment);
      t0 = space();
      div1 = element("div");
      create_component(variablecopy1.$$.fragment);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(variablecopy0.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(variablecopy1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "var-name svelte-1nevhrv");
      add_location(div0, file46, 114, 3, 3347);
      attr_dev(div1, "class", "var-value svelte-1nevhrv");
      add_location(div1, file46, 117, 3, 3423);
      attr_dev(div2, "class", "environment-variable svelte-1nevhrv");
      add_location(div2, file46, 113, 2, 3309);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      mount_component(variablecopy0, div0, null);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      mount_component(variablecopy1, div1, null);
      append_hydration_dev(div2, t1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const variablecopy0_changes = {};
      if (dirty & /*targetEnvVars*/
      2)
        variablecopy0_changes.text = /*envVar*/
        ctx2[3].name;
      variablecopy0.$set(variablecopy0_changes);
      const variablecopy1_changes = {};
      if (dirty & /*targetEnvVars*/
      2)
        variablecopy1_changes.text = /*envVar*/
        ctx2[3].value;
      variablecopy1.$set(variablecopy1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(variablecopy0.$$.fragment, local);
      transition_in(variablecopy1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(variablecopy0.$$.fragment, local);
      transition_out(variablecopy1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      destroy_component(variablecopy0);
      destroy_component(variablecopy1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block16.name,
    type: "each",
    source: "(113:1) {#each targetEnvVars as envVar}",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let p;
  let t0;
  let a;
  let t1;
  let t2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block34, create_if_block_118, create_else_block15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*credentials*/
      ctx2[0].authenticator === "externalbrowser"
    )
      return 0;
    if (
      /*credentials*/
      ctx2[0].authenticator === "gcloud-cli"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      p = element("p");
      t0 = text("To use different data environments in production vs development, ");
      a = element("a");
      t1 = text("use different environment variable values.");
      t2 = space();
      if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t0 = claim_text(p_nodes, "To use different data environments in production vs development, ");
      a = claim_element(p_nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      t1 = claim_text(a_nodes, "use different environment variable values.");
      a_nodes.forEach(detach_dev);
      p_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "class", "docs-link svelte-1nevhrv");
      attr_dev(a, "href", "https://docs.evidence.dev/deployment/environments");
      add_location(a, file46, 89, 66, 2551);
      add_location(p, file46, 88, 0, 2481);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t0);
      append_hydration_dev(p, a);
      append_hydration_dev(a, t1);
      insert_hydration_dev(target, t2, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (detaching)
        detach_dev(t2);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude51 = true;
function instance54($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EnvironmentVarListing", slots, []);
  let { settings } = $$props;
  let credentials = {};
  let targetEnvVars = [];
  if (settings.credentials) {
    targetEnvVars = [
      {
        name: "EVIDENCE_DATABASE",
        value: settings.database
      }
    ];
    credentials = settings.credentials;
    if (settings.database == "bigquery") {
      if (credentials.authenticator === "oauth") {
        credentials = {
          project_id: credentials.project_id,
          token: credentials.token
        };
      } else if (credentials.authenticator === "gcloud-cli") {
        credentials = { project_id: credentials.project_id };
      } else {
        credentials = {
          project_id: credentials.project_id,
          client_email: credentials.client_email,
          private_key: credentials.private_key
        };
      }
      if (settings.credentials.authenticator)
        credentials.authenticator = settings.credentials.authenticator;
    }
    if (settings.database == "snowflake") {
      if (credentials.authenticator === "externalbrowser") {
        credentials = {
          account: credentials.account,
          username: credentials.username,
          warehouse: credentials.warehouse,
          database: credentials.database
        };
      } else if (credentials.authenticator === "okta") {
        credentials = {
          okta_url: credentials.okta_url,
          account: credentials.account,
          username: credentials.username,
          password: credentials.password,
          warehouse: credentials.warehouse,
          database: credentials.database
        };
      } else if (credentials.authenticator === "snowflake_jwt") {
        credentials = {
          account: credentials.account,
          username: credentials.username,
          private_key: credentials.private_key,
          passphrase: credentials.passphrase,
          warehouse: credentials.warehouse,
          database: credentials.database
        };
      } else {
        credentials = {
          account: credentials.account,
          username: credentials.username,
          password: credentials.password,
          warehouse: credentials.warehouse,
          database: credentials.database
        };
      }
      if (settings.credentials.authenticator)
        credentials.authenticator = settings.credentials.authenticator;
    }
    for (const key in credentials) {
      if (!key.startsWith("gitignore")) {
        let envVar = {
          name: `EVIDENCE_${settings.database.toUpperCase()}_${key.toUpperCase()}`,
          value: settings.credentials[key]
        };
        targetEnvVars.push(envVar);
      }
    }
  }
  $$self.$$.on_mount.push(function() {
    if (settings === void 0 && !("settings" in $$props || $$self.$$.bound[$$self.$$.props["settings"]])) {
      console.warn("<EnvironmentVarListing> was created without expected prop 'settings'");
    }
  });
  const writable_props = ["settings"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EnvironmentVarListing> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(2, settings = $$props2.settings);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude51,
    VariableCopy: VariableCopy_default,
    settings,
    credentials,
    targetEnvVars
  });
  $$self.$inject_state = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(2, settings = $$props2.settings);
    if ("credentials" in $$props2)
      $$invalidate(0, credentials = $$props2.credentials);
    if ("targetEnvVars" in $$props2)
      $$invalidate(1, targetEnvVars = $$props2.targetEnvVars);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [credentials, targetEnvVars, settings];
}
var EnvironmentVarListing = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, { settings: 2 }, add_css38);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EnvironmentVarListing",
      options,
      id: create_fragment54.name
    });
  }
  get settings() {
    throw new Error("<EnvironmentVarListing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<EnvironmentVarListing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EnvironmentVarListing_default = EnvironmentVarListing;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/NetlifyDeploy.svelte
var file47 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/NetlifyDeploy.svelte";
function add_css39(target) {
  append_styles(target, "svelte-kqtdbw", "a.svelte-kqtdbw{color:var(--blue-600);text-decoration:none}a.svelte-kqtdbw:hover{color:var(--blue-800);text-decoration:none}span.setting.svelte-kqtdbw{font-size:0.85em;color:var(--grey-800);text-transform:uppercase;letter-spacing:0.05em}div.setting-row.svelte-kqtdbw{margin-top:1.25em}div.setting-row.svelte-kqtdbw:first-of-type{margin-top:0em}div.setting-value.svelte-kqtdbw{margin-top:0.25em;width:45%}.separator.svelte-kqtdbw{display:flex;align-items:center;text-align:center;-webkit-margin-before:2.5em;margin-block-start:2.5em;color:var(--grey-700);font-weight:bold}.separator.svelte-kqtdbw::after{content:'';flex:1;border-bottom:1px solid var(--grey-200)}.separator.svelte-kqtdbw:not(:empty)::after{margin-left:1.5em;margin-top:0.1em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmV0bGlmeURlcGxveS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBa0VDLENBQUEsY0FBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixlQUFBLENBQUEsSUFBcUIsQUFDdEIsQ0FBQSxBQUVBLGVBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGVBQUEsQ0FBQSxJQUFxQixBQUN0QixDQUFBLEFBRUEsSUFBQSxRQUFBLGNBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxNQUFpQixDQUNqQixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGNBQUEsQ0FBQSxTQUF5QixDQUN6QixjQUFBLENBQUEsTUFBc0IsQUFDdkIsQ0FBQSxBQUVBLEdBQUEsWUFBQSxjQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsTUFBa0IsQUFDbkIsQ0FBQSxBQUVBLEdBQUEsMEJBQUEsY0FBQSxBQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsR0FBZSxBQUNoQixDQUFBLEFBRUEsR0FBQSxjQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixLQUFBLENBQUEsR0FBVSxBQUNYLENBQUEsQUFFQSxVQUFBLGNBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxJQUFhLENBQ2IsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixxQkFBQSxDQUFBLEtBQTRCLENBQ3BCLGtCQUFBLENBQUEsS0FBeUIsQ0FDakMsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixXQUFBLENBQUEsSUFBaUIsQUFDbEIsQ0FBQSxBQUVBLHdCQUFBLE9BQUEsQUFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLEVBQVcsQ0FDWCxJQUFBLENBQUEsQ0FBTyxDQUNQLGFBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUF3QyxBQUN6QyxDQUFBLEFBRUEsd0JBQUEsS0FBQSxNQUFBLENBQUEsT0FBQSxBQUFBLENBQUEsQUFDQyxXQUFBLENBQUEsS0FBa0IsQ0FDbEIsVUFBQSxDQUFBLEtBQWlCLEFBQ2xCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTmV0bGlmeURlcGxveS5zdmVsdGUiXX0= */");
}
function create_else_block16(ctx) {
  let h20;
  let t0;
  let t1;
  let ol0;
  let li0;
  let a0;
  let t2;
  let t3;
  let li1;
  let t4;
  let t5;
  let li2;
  let t6;
  let code;
  let t7;
  let t8;
  let t9;
  let div0;
  let t10;
  let t11;
  let div2;
  let span0;
  let t12;
  let t13;
  let div1;
  let variablecopy0;
  let t14;
  let div4;
  let span1;
  let t15;
  let t16;
  let div3;
  let variablecopy1;
  let t17;
  let div5;
  let t18;
  let t19;
  let p;
  let t20;
  let a1;
  let t21;
  let t22;
  let environmentvarlisting;
  let t23;
  let h21;
  let t24;
  let t25;
  let ol1;
  let li3;
  let a2;
  let t26;
  let t27;
  let li4;
  let a3;
  let t28;
  let current;
  variablecopy0 = new VariableCopy_default({
    props: { text: "npm run build" },
    $$inline: true
  });
  variablecopy1 = new VariableCopy_default({
    props: { text: "build/" },
    $$inline: true
  });
  environmentvarlisting = new EnvironmentVarListing_default({
    props: { settings: (
      /*settings*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h20 = element("h2");
      t0 = text("Deploying to Netlify");
      t1 = space();
      ol0 = element("ol");
      li0 = element("li");
      a0 = element("a");
      t2 = text("Start a new netlify project ");
      t3 = space();
      li1 = element("li");
      t4 = text("Choose the repo containing this project");
      t5 = space();
      li2 = element("li");
      t6 = text("Update the ");
      code = element("code");
      t7 = text("site settings");
      t8 = text(" to match those below");
      t9 = space();
      div0 = element("div");
      t10 = text("Basic Build Settings");
      t11 = space();
      div2 = element("div");
      span0 = element("span");
      t12 = text("Build command");
      t13 = space();
      div1 = element("div");
      create_component(variablecopy0.$$.fragment);
      t14 = space();
      div4 = element("div");
      span1 = element("span");
      t15 = text("Publish directory");
      t16 = space();
      div3 = element("div");
      create_component(variablecopy1.$$.fragment);
      t17 = space();
      div5 = element("div");
      t18 = text("Advanced Build Settings");
      t19 = space();
      p = element("p");
      t20 = text("Click 'Show Advanced' and copy paste the following into ");
      a1 = element("a");
      t21 = text("environment variables.");
      t22 = space();
      create_component(environmentvarlisting.$$.fragment);
      t23 = space();
      h21 = element("h2");
      t24 = text("Optional");
      t25 = space();
      ol1 = element("ol");
      li3 = element("li");
      a2 = element("a");
      t26 = text("Password protect your site");
      t27 = space();
      li4 = element("li");
      a3 = element("a");
      t28 = text("Schedule your site to update periodically");
      this.h();
    },
    l: function claim(nodes) {
      h20 = claim_element(nodes, "H2", {});
      var h20_nodes = children(h20);
      t0 = claim_text(h20_nodes, "Deploying to Netlify");
      h20_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      ol0 = claim_element(nodes, "OL", {});
      var ol0_nodes = children(ol0);
      li0 = claim_element(ol0_nodes, "LI", {});
      var li0_nodes = children(li0);
      a0 = claim_element(li0_nodes, "A", {
        href: true,
        target: true,
        rel: true,
        class: true
      });
      var a0_nodes = children(a0);
      t2 = claim_text(a0_nodes, "Start a new netlify project ");
      a0_nodes.forEach(detach_dev);
      li0_nodes.forEach(detach_dev);
      t3 = claim_space(ol0_nodes);
      li1 = claim_element(ol0_nodes, "LI", {});
      var li1_nodes = children(li1);
      t4 = claim_text(li1_nodes, "Choose the repo containing this project");
      li1_nodes.forEach(detach_dev);
      t5 = claim_space(ol0_nodes);
      li2 = claim_element(ol0_nodes, "LI", {});
      var li2_nodes = children(li2);
      t6 = claim_text(li2_nodes, "Update the ");
      code = claim_element(li2_nodes, "CODE", {});
      var code_nodes = children(code);
      t7 = claim_text(code_nodes, "site settings");
      code_nodes.forEach(detach_dev);
      t8 = claim_text(li2_nodes, " to match those below");
      li2_nodes.forEach(detach_dev);
      ol0_nodes.forEach(detach_dev);
      t9 = claim_space(nodes);
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t10 = claim_text(div0_nodes, "Basic Build Settings");
      div0_nodes.forEach(detach_dev);
      t11 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      span0 = claim_element(div2_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t12 = claim_text(span0_nodes, "Build command");
      span0_nodes.forEach(detach_dev);
      t13 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(variablecopy0.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t14 = claim_space(nodes);
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      span1 = claim_element(div4_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t15 = claim_text(span1_nodes, "Publish directory");
      span1_nodes.forEach(detach_dev);
      t16 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      claim_component(variablecopy1.$$.fragment, div3_nodes);
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      t17 = claim_space(nodes);
      div5 = claim_element(nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      t18 = claim_text(div5_nodes, "Advanced Build Settings");
      div5_nodes.forEach(detach_dev);
      t19 = claim_space(nodes);
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t20 = claim_text(p_nodes, "Click 'Show Advanced' and copy paste the following into ");
      a1 = claim_element(p_nodes, "A", { href: true, class: true });
      var a1_nodes = children(a1);
      t21 = claim_text(a1_nodes, "environment variables.");
      a1_nodes.forEach(detach_dev);
      p_nodes.forEach(detach_dev);
      t22 = claim_space(nodes);
      claim_component(environmentvarlisting.$$.fragment, nodes);
      t23 = claim_space(nodes);
      h21 = claim_element(nodes, "H2", {});
      var h21_nodes = children(h21);
      t24 = claim_text(h21_nodes, "Optional");
      h21_nodes.forEach(detach_dev);
      t25 = claim_space(nodes);
      ol1 = claim_element(nodes, "OL", {});
      var ol1_nodes = children(ol1);
      li3 = claim_element(ol1_nodes, "LI", {});
      var li3_nodes = children(li3);
      a2 = claim_element(li3_nodes, "A", { href: true, class: true });
      var a2_nodes = children(a2);
      t26 = claim_text(a2_nodes, "Password protect your site");
      a2_nodes.forEach(detach_dev);
      li3_nodes.forEach(detach_dev);
      t27 = claim_space(ol1_nodes);
      li4 = claim_element(ol1_nodes, "LI", {});
      var li4_nodes = children(li4);
      a3 = claim_element(li4_nodes, "A", { href: true, class: true });
      var a3_nodes = children(a3);
      t28 = claim_text(a3_nodes, "Schedule your site to update periodically");
      a3_nodes.forEach(detach_dev);
      li4_nodes.forEach(detach_dev);
      ol1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h20, file47, 15, 1, 447);
      attr_dev(a0, "href", "https://app.netlify.com/start");
      attr_dev(a0, "target", "_blank");
      attr_dev(a0, "rel", "noreferrer");
      attr_dev(a0, "class", "svelte-kqtdbw");
      add_location(a0, file47, 19, 3, 494);
      add_location(li0, file47, 18, 2, 486);
      add_location(li1, file47, 23, 2, 625);
      add_location(code, file47, 24, 17, 691);
      add_location(li2, file47, 24, 2, 676);
      add_location(ol0, file47, 17, 1, 479);
      attr_dev(div0, "class", "separator svelte-kqtdbw");
      add_location(div0, file47, 27, 1, 753);
      attr_dev(span0, "class", "setting svelte-kqtdbw");
      add_location(span0, file47, 30, 2, 833);
      attr_dev(div1, "class", "setting-value svelte-kqtdbw");
      add_location(div1, file47, 31, 2, 878);
      attr_dev(div2, "class", "setting-row svelte-kqtdbw");
      add_location(div2, file47, 29, 1, 805);
      attr_dev(span1, "class", "setting svelte-kqtdbw");
      add_location(span1, file47, 35, 2, 989);
      attr_dev(div3, "class", "setting-value svelte-kqtdbw");
      add_location(div3, file47, 36, 2, 1038);
      attr_dev(div4, "class", "setting-row svelte-kqtdbw");
      add_location(div4, file47, 34, 1, 961);
      attr_dev(div5, "class", "separator svelte-kqtdbw");
      add_location(div5, file47, 39, 1, 1114);
      attr_dev(a1, "href", "https://docs.netlify.com/configure-builds/environment-variables/");
      attr_dev(a1, "class", "svelte-kqtdbw");
      add_location(a1, file47, 41, 58, 1230);
      add_location(p, file47, 40, 1, 1168);
      add_location(h21, file47, 49, 1, 1389);
      attr_dev(a2, "href", "https://docs.netlify.com/visitor-access/password-protection/");
      attr_dev(a2, "class", "svelte-kqtdbw");
      add_location(a2, file47, 52, 3, 1423);
      add_location(li3, file47, 51, 2, 1415);
      attr_dev(a3, "href", "https://docs.evidence.dev/deployment/netlify#optional-schedule-updates-using-build-hooks");
      attr_dev(a3, "class", "svelte-kqtdbw");
      add_location(a3, file47, 57, 3, 1552);
      add_location(li4, file47, 56, 2, 1544);
      add_location(ol1, file47, 50, 1, 1408);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h20, anchor);
      append_hydration_dev(h20, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, ol0, anchor);
      append_hydration_dev(ol0, li0);
      append_hydration_dev(li0, a0);
      append_hydration_dev(a0, t2);
      append_hydration_dev(ol0, t3);
      append_hydration_dev(ol0, li1);
      append_hydration_dev(li1, t4);
      append_hydration_dev(ol0, t5);
      append_hydration_dev(ol0, li2);
      append_hydration_dev(li2, t6);
      append_hydration_dev(li2, code);
      append_hydration_dev(code, t7);
      append_hydration_dev(li2, t8);
      insert_hydration_dev(target, t9, anchor);
      insert_hydration_dev(target, div0, anchor);
      append_hydration_dev(div0, t10);
      insert_hydration_dev(target, t11, anchor);
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, span0);
      append_hydration_dev(span0, t12);
      append_hydration_dev(div2, t13);
      append_hydration_dev(div2, div1);
      mount_component(variablecopy0, div1, null);
      insert_hydration_dev(target, t14, anchor);
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, span1);
      append_hydration_dev(span1, t15);
      append_hydration_dev(div4, t16);
      append_hydration_dev(div4, div3);
      mount_component(variablecopy1, div3, null);
      insert_hydration_dev(target, t17, anchor);
      insert_hydration_dev(target, div5, anchor);
      append_hydration_dev(div5, t18);
      insert_hydration_dev(target, t19, anchor);
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t20);
      append_hydration_dev(p, a1);
      append_hydration_dev(a1, t21);
      insert_hydration_dev(target, t22, anchor);
      mount_component(environmentvarlisting, target, anchor);
      insert_hydration_dev(target, t23, anchor);
      insert_hydration_dev(target, h21, anchor);
      append_hydration_dev(h21, t24);
      insert_hydration_dev(target, t25, anchor);
      insert_hydration_dev(target, ol1, anchor);
      append_hydration_dev(ol1, li3);
      append_hydration_dev(li3, a2);
      append_hydration_dev(a2, t26);
      append_hydration_dev(ol1, t27);
      append_hydration_dev(ol1, li4);
      append_hydration_dev(li4, a3);
      append_hydration_dev(a3, t28);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const environmentvarlisting_changes = {};
      if (dirty & /*settings*/
      1)
        environmentvarlisting_changes.settings = /*settings*/
        ctx2[0];
      environmentvarlisting.$set(environmentvarlisting_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(variablecopy0.$$.fragment, local);
      transition_in(variablecopy1.$$.fragment, local);
      transition_in(environmentvarlisting.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(variablecopy0.$$.fragment, local);
      transition_out(variablecopy1.$$.fragment, local);
      transition_out(environmentvarlisting.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h20);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(ol0);
      if (detaching)
        detach_dev(t9);
      if (detaching)
        detach_dev(div0);
      if (detaching)
        detach_dev(t11);
      if (detaching)
        detach_dev(div2);
      destroy_component(variablecopy0);
      if (detaching)
        detach_dev(t14);
      if (detaching)
        detach_dev(div4);
      destroy_component(variablecopy1);
      if (detaching)
        detach_dev(t17);
      if (detaching)
        detach_dev(div5);
      if (detaching)
        detach_dev(t19);
      if (detaching)
        detach_dev(p);
      if (detaching)
        detach_dev(t22);
      destroy_component(environmentvarlisting, detaching);
      if (detaching)
        detach_dev(t23);
      if (detaching)
        detach_dev(h21);
      if (detaching)
        detach_dev(t25);
      if (detaching)
        detach_dev(ol1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block16.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_119(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text("You'll need to set up a git repo before deploying to netlify.");
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(p_nodes, "You'll need to set up a git repo before deploying to netlify.");
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file47, 13, 1, 369);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_119.name,
    type: "if",
    source: "(13:28) ",
    ctx
  });
  return block;
}
function create_if_block35(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text("You'll need to connect to a database before deploying to netlify.");
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(p_nodes, "You'll need to connect to a database before deploying to netlify.");
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file47, 11, 1, 266);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block35.name,
    type: "if",
    source: "(11:0) {#if !settings.credentials}",
    ctx
  });
  return block;
}
function create_fragment55(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block35, create_if_block_119, create_else_block16];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*settings*/
    ctx2[0].credentials)
      return 0;
    if (!/*settings*/
    ctx2[0].gitRepo)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude52 = true;
function instance55($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NetlifyDeploy", slots, []);
  let { settings } = $$props;
  $$self.$$.on_mount.push(function() {
    if (settings === void 0 && !("settings" in $$props || $$self.$$.bound[$$self.$$.props["settings"]])) {
      console.warn("<NetlifyDeploy> was created without expected prop 'settings'");
    }
  });
  const writable_props = ["settings"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NetlifyDeploy> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude52,
    EnvironmentVarListing: EnvironmentVarListing_default,
    VariableCopy: VariableCopy_default,
    settings
  });
  $$self.$inject_state = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [settings];
}
var NetlifyDeploy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, { settings: 0 }, add_css39);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NetlifyDeploy",
      options,
      id: create_fragment55.name
    });
  }
  get settings() {
    throw new Error("<NetlifyDeploy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<NetlifyDeploy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NetlifyDeploy_default = NetlifyDeploy;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/VercelDeploy.svelte
var file48 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/VercelDeploy.svelte";
function add_css40(target) {
  append_styles(target, "svelte-kqtdbw", "a.svelte-kqtdbw{color:var(--blue-600);text-decoration:none}a.svelte-kqtdbw:hover{color:var(--blue-800);text-decoration:none}span.setting.svelte-kqtdbw{font-size:0.85em;color:var(--grey-800);text-transform:uppercase;letter-spacing:0.05em}div.setting-row.svelte-kqtdbw{margin-top:1.25em}div.setting-row.svelte-kqtdbw:first-of-type{margin-top:0em}div.setting-value.svelte-kqtdbw{margin-top:0.25em;width:45%}.separator.svelte-kqtdbw{display:flex;align-items:center;text-align:center;-webkit-margin-before:2.5em;margin-block-start:2.5em;color:var(--grey-700);font-weight:bold}.separator.svelte-kqtdbw::after{content:'';flex:1;border-bottom:1px solid var(--grey-200)}.separator.svelte-kqtdbw:not(:empty)::after{margin-left:1.5em;margin-top:0.1em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmVyY2VsRGVwbG95LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE4REMsQ0FBQSxjQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGVBQUEsQ0FBQSxJQUFxQixBQUN0QixDQUFBLEFBRUEsZUFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsZUFBQSxDQUFBLElBQXFCLEFBQ3RCLENBQUEsQUFFQSxJQUFBLFFBQUEsY0FBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLE1BQWlCLENBQ2pCLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsY0FBQSxDQUFBLFNBQXlCLENBQ3pCLGNBQUEsQ0FBQSxNQUFzQixBQUN2QixDQUFBLEFBRUEsR0FBQSxZQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxNQUFrQixBQUNuQixDQUFBLEFBRUEsR0FBQSwwQkFBQSxjQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxHQUFlLEFBQ2hCLENBQUEsQUFFQSxHQUFBLGNBQUEsY0FBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLE1BQWtCLENBQ2xCLEtBQUEsQ0FBQSxHQUFVLEFBQ1gsQ0FBQSxBQUVBLFVBQUEsY0FBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQ0FDYixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsVUFBQSxDQUFBLE1BQWtCLENBQ2xCLHFCQUFBLENBQUEsS0FBNEIsQ0FDcEIsa0JBQUEsQ0FBQSxLQUF5QixDQUNqQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFdBQUEsQ0FBQSxJQUFpQixBQUNsQixDQUFBLEFBRUEsd0JBQUEsT0FBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsRUFBVyxDQUNYLElBQUEsQ0FBQSxDQUFPLENBQ1AsYUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXdDLEFBQ3pDLENBQUEsQUFFQSx3QkFBQSxLQUFBLE1BQUEsQ0FBQSxPQUFBLEFBQUEsQ0FBQSxBQUNDLFdBQUEsQ0FBQSxLQUFrQixDQUNsQixVQUFBLENBQUEsS0FBaUIsQUFDbEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJWZXJjZWxEZXBsb3kuc3ZlbHRlIl19 */");
}
function create_else_block17(ctx) {
  let h20;
  let t0;
  let t1;
  let ol0;
  let li0;
  let a0;
  let t2;
  let t3;
  let li1;
  let t4;
  let t5;
  let li2;
  let t6;
  let t7;
  let div0;
  let t8;
  let t9;
  let div2;
  let span0;
  let t10;
  let t11;
  let div1;
  let variablecopy0;
  let t12;
  let div4;
  let span1;
  let t13;
  let t14;
  let div3;
  let variablecopy1;
  let t15;
  let div6;
  let span2;
  let t16;
  let t17;
  let div5;
  let variablecopy2;
  let t18;
  let div7;
  let t19;
  let t20;
  let p;
  let t21;
  let t22;
  let environmentvarlisting;
  let t23;
  let h21;
  let t24;
  let t25;
  let ol1;
  let li3;
  let a1;
  let t26;
  let t27;
  let li4;
  let a2;
  let t28;
  let current;
  variablecopy0 = new VariableCopy_default({
    props: { text: "npm run build" },
    $$inline: true
  });
  variablecopy1 = new VariableCopy_default({
    props: { text: "build/" },
    $$inline: true
  });
  variablecopy2 = new VariableCopy_default({
    props: { text: "npm install" },
    $$inline: true
  });
  environmentvarlisting = new EnvironmentVarListing_default({
    props: { settings: (
      /*settings*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      h20 = element("h2");
      t0 = text("Deploying to Vercel");
      t1 = space();
      ol0 = element("ol");
      li0 = element("li");
      a0 = element("a");
      t2 = text("Start a new Vercel project ");
      t3 = space();
      li1 = element("li");
      t4 = text("Choose the repo containing this project");
      t5 = space();
      li2 = element("li");
      t6 = text("Configure your project to match the settings below");
      t7 = space();
      div0 = element("div");
      t8 = text("Build and Output Settings");
      t9 = space();
      div2 = element("div");
      span0 = element("span");
      t10 = text("Build Command");
      t11 = space();
      div1 = element("div");
      create_component(variablecopy0.$$.fragment);
      t12 = space();
      div4 = element("div");
      span1 = element("span");
      t13 = text("Output Directory");
      t14 = space();
      div3 = element("div");
      create_component(variablecopy1.$$.fragment);
      t15 = space();
      div6 = element("div");
      span2 = element("span");
      t16 = text("Install Command");
      t17 = space();
      div5 = element("div");
      create_component(variablecopy2.$$.fragment);
      t18 = space();
      div7 = element("div");
      t19 = text("Environment Variables");
      t20 = space();
      p = element("p");
      t21 = text("Copy paste the following into environment variables");
      t22 = space();
      create_component(environmentvarlisting.$$.fragment);
      t23 = space();
      h21 = element("h2");
      t24 = text("Optional");
      t25 = space();
      ol1 = element("ol");
      li3 = element("li");
      a1 = element("a");
      t26 = text("Password protect your site");
      t27 = space();
      li4 = element("li");
      a2 = element("a");
      t28 = text("Schedule your site to update periodically");
      this.h();
    },
    l: function claim(nodes) {
      h20 = claim_element(nodes, "H2", {});
      var h20_nodes = children(h20);
      t0 = claim_text(h20_nodes, "Deploying to Vercel");
      h20_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      ol0 = claim_element(nodes, "OL", {});
      var ol0_nodes = children(ol0);
      li0 = claim_element(ol0_nodes, "LI", {});
      var li0_nodes = children(li0);
      a0 = claim_element(li0_nodes, "A", {
        href: true,
        target: true,
        rel: true,
        class: true
      });
      var a0_nodes = children(a0);
      t2 = claim_text(a0_nodes, "Start a new Vercel project ");
      a0_nodes.forEach(detach_dev);
      li0_nodes.forEach(detach_dev);
      t3 = claim_space(ol0_nodes);
      li1 = claim_element(ol0_nodes, "LI", {});
      var li1_nodes = children(li1);
      t4 = claim_text(li1_nodes, "Choose the repo containing this project");
      li1_nodes.forEach(detach_dev);
      t5 = claim_space(ol0_nodes);
      li2 = claim_element(ol0_nodes, "LI", {});
      var li2_nodes = children(li2);
      t6 = claim_text(li2_nodes, "Configure your project to match the settings below");
      li2_nodes.forEach(detach_dev);
      ol0_nodes.forEach(detach_dev);
      t7 = claim_space(nodes);
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t8 = claim_text(div0_nodes, "Build and Output Settings");
      div0_nodes.forEach(detach_dev);
      t9 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      span0 = claim_element(div2_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t10 = claim_text(span0_nodes, "Build Command");
      span0_nodes.forEach(detach_dev);
      t11 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(variablecopy0.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t12 = claim_space(nodes);
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      span1 = claim_element(div4_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t13 = claim_text(span1_nodes, "Output Directory");
      span1_nodes.forEach(detach_dev);
      t14 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      claim_component(variablecopy1.$$.fragment, div3_nodes);
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      t15 = claim_space(nodes);
      div6 = claim_element(nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      span2 = claim_element(div6_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      t16 = claim_text(span2_nodes, "Install Command");
      span2_nodes.forEach(detach_dev);
      t17 = claim_space(div6_nodes);
      div5 = claim_element(div6_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      claim_component(variablecopy2.$$.fragment, div5_nodes);
      div5_nodes.forEach(detach_dev);
      div6_nodes.forEach(detach_dev);
      t18 = claim_space(nodes);
      div7 = claim_element(nodes, "DIV", { class: true });
      var div7_nodes = children(div7);
      t19 = claim_text(div7_nodes, "Environment Variables");
      div7_nodes.forEach(detach_dev);
      t20 = claim_space(nodes);
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t21 = claim_text(p_nodes, "Copy paste the following into environment variables");
      p_nodes.forEach(detach_dev);
      t22 = claim_space(nodes);
      claim_component(environmentvarlisting.$$.fragment, nodes);
      t23 = claim_space(nodes);
      h21 = claim_element(nodes, "H2", {});
      var h21_nodes = children(h21);
      t24 = claim_text(h21_nodes, "Optional");
      h21_nodes.forEach(detach_dev);
      t25 = claim_space(nodes);
      ol1 = claim_element(nodes, "OL", {});
      var ol1_nodes = children(ol1);
      li3 = claim_element(ol1_nodes, "LI", {});
      var li3_nodes = children(li3);
      a1 = claim_element(li3_nodes, "A", { href: true, class: true });
      var a1_nodes = children(a1);
      t26 = claim_text(a1_nodes, "Password protect your site");
      a1_nodes.forEach(detach_dev);
      li3_nodes.forEach(detach_dev);
      t27 = claim_space(ol1_nodes);
      li4 = claim_element(ol1_nodes, "LI", {});
      var li4_nodes = children(li4);
      a2 = claim_element(li4_nodes, "A", { href: true, class: true });
      var a2_nodes = children(a2);
      t28 = claim_text(a2_nodes, "Schedule your site to update periodically");
      a2_nodes.forEach(detach_dev);
      li4_nodes.forEach(detach_dev);
      ol1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h20, file48, 15, 1, 445);
      attr_dev(a0, "href", "https://vercel.com/new");
      attr_dev(a0, "target", "_blank");
      attr_dev(a0, "rel", "noreferrer");
      attr_dev(a0, "class", "svelte-kqtdbw");
      add_location(a0, file48, 19, 3, 491);
      add_location(li0, file48, 18, 2, 483);
      add_location(li1, file48, 23, 2, 614);
      add_location(li2, file48, 24, 2, 665);
      add_location(ol0, file48, 17, 1, 476);
      attr_dev(div0, "class", "separator svelte-kqtdbw");
      add_location(div0, file48, 27, 1, 734);
      attr_dev(span0, "class", "setting svelte-kqtdbw");
      add_location(span0, file48, 30, 2, 819);
      attr_dev(div1, "class", "setting-value svelte-kqtdbw");
      add_location(div1, file48, 31, 2, 864);
      attr_dev(div2, "class", "setting-row svelte-kqtdbw");
      add_location(div2, file48, 29, 1, 791);
      attr_dev(span1, "class", "setting svelte-kqtdbw");
      add_location(span1, file48, 35, 2, 975);
      attr_dev(div3, "class", "setting-value svelte-kqtdbw");
      add_location(div3, file48, 36, 2, 1023);
      attr_dev(div4, "class", "setting-row svelte-kqtdbw");
      add_location(div4, file48, 34, 1, 947);
      attr_dev(span2, "class", "setting svelte-kqtdbw");
      add_location(span2, file48, 40, 2, 1127);
      attr_dev(div5, "class", "setting-value svelte-kqtdbw");
      add_location(div5, file48, 41, 2, 1174);
      attr_dev(div6, "class", "setting-row svelte-kqtdbw");
      add_location(div6, file48, 39, 1, 1099);
      attr_dev(div7, "class", "separator svelte-kqtdbw");
      add_location(div7, file48, 44, 1, 1255);
      add_location(p, file48, 45, 1, 1307);
      add_location(h21, file48, 49, 1, 1407);
      attr_dev(a1, "href", "https://vercel.com/blog/protecting-deployments");
      attr_dev(a1, "class", "svelte-kqtdbw");
      add_location(a1, file48, 51, 6, 1437);
      add_location(li3, file48, 51, 2, 1433);
      attr_dev(a2, "href", "https://docs.evidence.dev/deployment/vercel#optional-schedule-updates-using-deploy-hooks");
      attr_dev(a2, "class", "svelte-kqtdbw");
      add_location(a2, file48, 53, 3, 1540);
      add_location(li4, file48, 52, 2, 1532);
      add_location(ol1, file48, 50, 1, 1426);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h20, anchor);
      append_hydration_dev(h20, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, ol0, anchor);
      append_hydration_dev(ol0, li0);
      append_hydration_dev(li0, a0);
      append_hydration_dev(a0, t2);
      append_hydration_dev(ol0, t3);
      append_hydration_dev(ol0, li1);
      append_hydration_dev(li1, t4);
      append_hydration_dev(ol0, t5);
      append_hydration_dev(ol0, li2);
      append_hydration_dev(li2, t6);
      insert_hydration_dev(target, t7, anchor);
      insert_hydration_dev(target, div0, anchor);
      append_hydration_dev(div0, t8);
      insert_hydration_dev(target, t9, anchor);
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, span0);
      append_hydration_dev(span0, t10);
      append_hydration_dev(div2, t11);
      append_hydration_dev(div2, div1);
      mount_component(variablecopy0, div1, null);
      insert_hydration_dev(target, t12, anchor);
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, span1);
      append_hydration_dev(span1, t13);
      append_hydration_dev(div4, t14);
      append_hydration_dev(div4, div3);
      mount_component(variablecopy1, div3, null);
      insert_hydration_dev(target, t15, anchor);
      insert_hydration_dev(target, div6, anchor);
      append_hydration_dev(div6, span2);
      append_hydration_dev(span2, t16);
      append_hydration_dev(div6, t17);
      append_hydration_dev(div6, div5);
      mount_component(variablecopy2, div5, null);
      insert_hydration_dev(target, t18, anchor);
      insert_hydration_dev(target, div7, anchor);
      append_hydration_dev(div7, t19);
      insert_hydration_dev(target, t20, anchor);
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t21);
      insert_hydration_dev(target, t22, anchor);
      mount_component(environmentvarlisting, target, anchor);
      insert_hydration_dev(target, t23, anchor);
      insert_hydration_dev(target, h21, anchor);
      append_hydration_dev(h21, t24);
      insert_hydration_dev(target, t25, anchor);
      insert_hydration_dev(target, ol1, anchor);
      append_hydration_dev(ol1, li3);
      append_hydration_dev(li3, a1);
      append_hydration_dev(a1, t26);
      append_hydration_dev(ol1, t27);
      append_hydration_dev(ol1, li4);
      append_hydration_dev(li4, a2);
      append_hydration_dev(a2, t28);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const environmentvarlisting_changes = {};
      if (dirty & /*settings*/
      1)
        environmentvarlisting_changes.settings = /*settings*/
        ctx2[0];
      environmentvarlisting.$set(environmentvarlisting_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(variablecopy0.$$.fragment, local);
      transition_in(variablecopy1.$$.fragment, local);
      transition_in(variablecopy2.$$.fragment, local);
      transition_in(environmentvarlisting.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(variablecopy0.$$.fragment, local);
      transition_out(variablecopy1.$$.fragment, local);
      transition_out(variablecopy2.$$.fragment, local);
      transition_out(environmentvarlisting.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h20);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(ol0);
      if (detaching)
        detach_dev(t7);
      if (detaching)
        detach_dev(div0);
      if (detaching)
        detach_dev(t9);
      if (detaching)
        detach_dev(div2);
      destroy_component(variablecopy0);
      if (detaching)
        detach_dev(t12);
      if (detaching)
        detach_dev(div4);
      destroy_component(variablecopy1);
      if (detaching)
        detach_dev(t15);
      if (detaching)
        detach_dev(div6);
      destroy_component(variablecopy2);
      if (detaching)
        detach_dev(t18);
      if (detaching)
        detach_dev(div7);
      if (detaching)
        detach_dev(t20);
      if (detaching)
        detach_dev(p);
      if (detaching)
        detach_dev(t22);
      destroy_component(environmentvarlisting, detaching);
      if (detaching)
        detach_dev(t23);
      if (detaching)
        detach_dev(h21);
      if (detaching)
        detach_dev(t25);
      if (detaching)
        detach_dev(ol1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block17.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_120(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text("You'll need to set up a git repo before deploying to Vercel.");
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(p_nodes, "You'll need to set up a git repo before deploying to Vercel.");
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file48, 13, 1, 368);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_120.name,
    type: "if",
    source: "(13:28) ",
    ctx
  });
  return block;
}
function create_if_block36(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text("You'll need to connect to a database before deploying to Vercel.");
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(p_nodes, "You'll need to connect to a database before deploying to Vercel.");
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file48, 11, 1, 266);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block36.name,
    type: "if",
    source: "(11:0) {#if !settings.credentials}",
    ctx
  });
  return block;
}
function create_fragment56(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block36, create_if_block_120, create_else_block17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*settings*/
    ctx2[0].credentials)
      return 0;
    if (!/*settings*/
    ctx2[0].gitRepo)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude53 = true;
function instance56($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VercelDeploy", slots, []);
  let { settings } = $$props;
  $$self.$$.on_mount.push(function() {
    if (settings === void 0 && !("settings" in $$props || $$self.$$.bound[$$self.$$.props["settings"]])) {
      console.warn("<VercelDeploy> was created without expected prop 'settings'");
    }
  });
  const writable_props = ["settings"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VercelDeploy> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude53,
    EnvironmentVarListing: EnvironmentVarListing_default,
    VariableCopy: VariableCopy_default,
    settings
  });
  $$self.$inject_state = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [settings];
}
var VercelDeploy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, { settings: 0 }, add_css40);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VercelDeploy",
      options,
      id: create_fragment56.name
    });
  }
  get settings() {
    throw new Error("<VercelDeploy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<VercelDeploy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VercelDeploy_default = VercelDeploy;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/OtherDeploy.svelte
var file49 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/OtherDeploy.svelte";
function add_css41(target) {
  append_styles(target, "svelte-1gtzu9y", "span.setting.svelte-1gtzu9y{font-size:0.85em;color:var(--grey-800);text-transform:uppercase;letter-spacing:0.05em}div.setting-row.svelte-1gtzu9y{margin-top:1.25em}div.setting-row.svelte-1gtzu9y:first-of-type{margin-top:0em}div.setting-value.svelte-1gtzu9y{margin-top:0.25em;width:45%}.separator.svelte-1gtzu9y{display:flex;align-items:center;text-align:center;-webkit-margin-before:2.5em;margin-block-start:2.5em;color:var(--grey-700);font-weight:bold}.separator.svelte-1gtzu9y::after{content:'';flex:1;border-bottom:1px solid var(--grey-200)}.separator.svelte-1gtzu9y:not(:empty)::after{margin-left:1.5em;margin-top:0.1em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT3RoZXJEZXBsb3kuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWlEQyxJQUFBLFFBQUEsZUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLE1BQWlCLENBQ2pCLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsY0FBQSxDQUFBLFNBQXlCLENBQ3pCLGNBQUEsQ0FBQSxNQUFzQixBQUN2QixDQUFBLEFBRUEsR0FBQSxZQUFBLGVBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxNQUFrQixBQUNuQixDQUFBLEFBRUEsR0FBQSwyQkFBQSxjQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxHQUFlLEFBQ2hCLENBQUEsQUFFQSxHQUFBLGNBQUEsZUFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLE1BQWtCLENBQ2xCLEtBQUEsQ0FBQSxHQUFVLEFBQ1gsQ0FBQSxBQUVBLFVBQUEsZUFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQ0FDYixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsVUFBQSxDQUFBLE1BQWtCLENBQ2xCLHFCQUFBLENBQUEsS0FBNEIsQ0FDcEIsa0JBQUEsQ0FBQSxLQUF5QixDQUNqQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFdBQUEsQ0FBQSxJQUFpQixBQUNsQixDQUFBLEFBRUEseUJBQUEsT0FBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsRUFBVyxDQUNYLElBQUEsQ0FBQSxDQUFPLENBQ1AsYUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXdDLEFBQ3pDLENBQUEsQUFFQSx5QkFBQSxLQUFBLE1BQUEsQ0FBQSxPQUFBLEFBQUEsQ0FBQSxBQUNDLFdBQUEsQ0FBQSxLQUFrQixDQUNsQixVQUFBLENBQUEsS0FBaUIsQUFDbEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJPdGhlckRlcGxveS5zdmVsdGUiXX0= */");
}
function create_else_block18(ctx) {
  let environmentvarlisting;
  let current;
  environmentvarlisting = new EnvironmentVarListing_default({
    props: { settings: (
      /*settings*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(environmentvarlisting.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(environmentvarlisting.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(environmentvarlisting, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const environmentvarlisting_changes = {};
      if (dirty & /*settings*/
      1)
        environmentvarlisting_changes.settings = /*settings*/
        ctx2[0];
      environmentvarlisting.$set(environmentvarlisting_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(environmentvarlisting.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(environmentvarlisting.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(environmentvarlisting, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block18.name,
    type: "else",
    source: "(45:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block37(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text("Your project does not have a database connection.");
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(p_nodes, "Your project does not have a database connection.");
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file49, 43, 1, 1275);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block37.name,
    type: "if",
    source: "(43:0) {#if !settings.credentials}",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let h2;
  let t0;
  let t1;
  let p0;
  let t2;
  let t3;
  let ol;
  let li0;
  let t4;
  let code0;
  let t5;
  let t6;
  let code1;
  let t7;
  let t8;
  let t9;
  let li1;
  let t10;
  let t11;
  let div0;
  let t12;
  let t13;
  let div2;
  let span0;
  let t14;
  let t15;
  let div1;
  let variablecopy0;
  let t16;
  let div4;
  let span1;
  let t17;
  let t18;
  let div3;
  let variablecopy1;
  let t19;
  let div5;
  let t20;
  let t21;
  let p1;
  let t22;
  let t23;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  variablecopy0 = new VariableCopy_default({
    props: { text: "npm run build" },
    $$inline: true
  });
  variablecopy1 = new VariableCopy_default({
    props: { text: "build/" },
    $$inline: true
  });
  const if_block_creators = [create_if_block37, create_else_block18];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*settings*/
    ctx2[0].credentials)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      h2 = element("h2");
      t0 = text("Deploying your Project");
      t1 = space();
      p0 = element("p");
      t2 = text("In production, Evidence functions like a static site generator:");
      t3 = space();
      ol = element("ol");
      li0 = element("li");
      t4 = text("Running ");
      code0 = element("code");
      t5 = text("npm run build");
      t6 = text(" will build a static site in the ");
      code1 = element("code");
      t7 = text("/build");
      t8 = text(" directory\n		using the credentials in the database connections panel, which you can host in a variety of environments");
      t9 = space();
      li1 = element("li");
      t10 = text("You can share your database credentials with your production environment by setting the\n		environment variables listed below");
      t11 = space();
      div0 = element("div");
      t12 = text("Building Your Project");
      t13 = space();
      div2 = element("div");
      span0 = element("span");
      t14 = text("Build command");
      t15 = space();
      div1 = element("div");
      create_component(variablecopy0.$$.fragment);
      t16 = space();
      div4 = element("div");
      span1 = element("span");
      t17 = text("Publish directory");
      t18 = space();
      div3 = element("div");
      create_component(variablecopy1.$$.fragment);
      t19 = space();
      div5 = element("div");
      t20 = text("Environment Variables");
      t21 = space();
      p1 = element("p");
      t22 = text("The following environment variables must be present in your deployment environment to enable your\n	database connection");
      t23 = space();
      if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", {});
      var h2_nodes = children(h2);
      t0 = claim_text(h2_nodes, "Deploying your Project");
      h2_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      p0 = claim_element(nodes, "P", {});
      var p0_nodes = children(p0);
      t2 = claim_text(p0_nodes, "In production, Evidence functions like a static site generator:");
      p0_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      ol = claim_element(nodes, "OL", {});
      var ol_nodes = children(ol);
      li0 = claim_element(ol_nodes, "LI", {});
      var li0_nodes = children(li0);
      t4 = claim_text(li0_nodes, "Running ");
      code0 = claim_element(li0_nodes, "CODE", {});
      var code0_nodes = children(code0);
      t5 = claim_text(code0_nodes, "npm run build");
      code0_nodes.forEach(detach_dev);
      t6 = claim_text(li0_nodes, " will build a static site in the ");
      code1 = claim_element(li0_nodes, "CODE", {});
      var code1_nodes = children(code1);
      t7 = claim_text(code1_nodes, "/build");
      code1_nodes.forEach(detach_dev);
      t8 = claim_text(li0_nodes, " directory\n		using the credentials in the database connections panel, which you can host in a variety of environments");
      li0_nodes.forEach(detach_dev);
      t9 = claim_space(ol_nodes);
      li1 = claim_element(ol_nodes, "LI", {});
      var li1_nodes = children(li1);
      t10 = claim_text(li1_nodes, "You can share your database credentials with your production environment by setting the\n		environment variables listed below");
      li1_nodes.forEach(detach_dev);
      ol_nodes.forEach(detach_dev);
      t11 = claim_space(nodes);
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t12 = claim_text(div0_nodes, "Building Your Project");
      div0_nodes.forEach(detach_dev);
      t13 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      span0 = claim_element(div2_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t14 = claim_text(span0_nodes, "Build command");
      span0_nodes.forEach(detach_dev);
      t15 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(variablecopy0.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t16 = claim_space(nodes);
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      span1 = claim_element(div4_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t17 = claim_text(span1_nodes, "Publish directory");
      span1_nodes.forEach(detach_dev);
      t18 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      claim_component(variablecopy1.$$.fragment, div3_nodes);
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      t19 = claim_space(nodes);
      div5 = claim_element(nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      t20 = claim_text(div5_nodes, "Environment Variables");
      div5_nodes.forEach(detach_dev);
      t21 = claim_space(nodes);
      p1 = claim_element(nodes, "P", {});
      var p1_nodes = children(p1);
      t22 = claim_text(p1_nodes, "The following environment variables must be present in your deployment environment to enable your\n	database connection");
      p1_nodes.forEach(detach_dev);
      t23 = claim_space(nodes);
      if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      add_location(h2, file49, 10, 0, 237);
      add_location(p0, file49, 12, 0, 270);
      add_location(code0, file49, 15, 10, 362);
      add_location(code1, file49, 15, 69, 421);
      add_location(li0, file49, 14, 1, 347);
      add_location(li1, file49, 18, 1, 566);
      add_location(ol, file49, 13, 0, 341);
      attr_dev(div0, "class", "separator svelte-1gtzu9y");
      add_location(div0, file49, 24, 0, 712);
      attr_dev(span0, "class", "setting svelte-1gtzu9y");
      add_location(span0, file49, 27, 1, 791);
      attr_dev(div1, "class", "setting-value svelte-1gtzu9y");
      add_location(div1, file49, 28, 1, 835);
      attr_dev(div2, "class", "setting-row svelte-1gtzu9y");
      add_location(div2, file49, 26, 0, 764);
      attr_dev(span1, "class", "setting svelte-1gtzu9y");
      add_location(span1, file49, 32, 1, 943);
      attr_dev(div3, "class", "setting-value svelte-1gtzu9y");
      add_location(div3, file49, 33, 1, 991);
      attr_dev(div4, "class", "setting-row svelte-1gtzu9y");
      add_location(div4, file49, 31, 0, 916);
      attr_dev(div5, "class", "separator svelte-1gtzu9y");
      add_location(div5, file49, 36, 0, 1065);
      add_location(p1, file49, 37, 0, 1116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      append_hydration_dev(h2, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, p0, anchor);
      append_hydration_dev(p0, t2);
      insert_hydration_dev(target, t3, anchor);
      insert_hydration_dev(target, ol, anchor);
      append_hydration_dev(ol, li0);
      append_hydration_dev(li0, t4);
      append_hydration_dev(li0, code0);
      append_hydration_dev(code0, t5);
      append_hydration_dev(li0, t6);
      append_hydration_dev(li0, code1);
      append_hydration_dev(code1, t7);
      append_hydration_dev(li0, t8);
      append_hydration_dev(ol, t9);
      append_hydration_dev(ol, li1);
      append_hydration_dev(li1, t10);
      insert_hydration_dev(target, t11, anchor);
      insert_hydration_dev(target, div0, anchor);
      append_hydration_dev(div0, t12);
      insert_hydration_dev(target, t13, anchor);
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, span0);
      append_hydration_dev(span0, t14);
      append_hydration_dev(div2, t15);
      append_hydration_dev(div2, div1);
      mount_component(variablecopy0, div1, null);
      insert_hydration_dev(target, t16, anchor);
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, span1);
      append_hydration_dev(span1, t17);
      append_hydration_dev(div4, t18);
      append_hydration_dev(div4, div3);
      mount_component(variablecopy1, div3, null);
      insert_hydration_dev(target, t19, anchor);
      insert_hydration_dev(target, div5, anchor);
      append_hydration_dev(div5, t20);
      insert_hydration_dev(target, t21, anchor);
      insert_hydration_dev(target, p1, anchor);
      append_hydration_dev(p1, t22);
      insert_hydration_dev(target, t23, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(variablecopy0.$$.fragment, local);
      transition_in(variablecopy1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(variablecopy0.$$.fragment, local);
      transition_out(variablecopy1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h2);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(p0);
      if (detaching)
        detach_dev(t3);
      if (detaching)
        detach_dev(ol);
      if (detaching)
        detach_dev(t11);
      if (detaching)
        detach_dev(div0);
      if (detaching)
        detach_dev(t13);
      if (detaching)
        detach_dev(div2);
      destroy_component(variablecopy0);
      if (detaching)
        detach_dev(t16);
      if (detaching)
        detach_dev(div4);
      destroy_component(variablecopy1);
      if (detaching)
        detach_dev(t19);
      if (detaching)
        detach_dev(div5);
      if (detaching)
        detach_dev(t21);
      if (detaching)
        detach_dev(p1);
      if (detaching)
        detach_dev(t23);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude54 = true;
function instance57($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OtherDeploy", slots, []);
  let { settings } = $$props;
  $$self.$$.on_mount.push(function() {
    if (settings === void 0 && !("settings" in $$props || $$self.$$.bound[$$self.$$.props["settings"]])) {
      console.warn("<OtherDeploy> was created without expected prop 'settings'");
    }
  });
  const writable_props = ["settings"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<OtherDeploy> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude54,
    EnvironmentVarListing: EnvironmentVarListing_default,
    VariableCopy: VariableCopy_default,
    settings
  });
  $$self.$inject_state = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [settings];
}
var OtherDeploy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, { settings: 0 }, add_css41);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OtherDeploy",
      options,
      id: create_fragment57.name
    });
  }
  get settings() {
    throw new Error("<OtherDeploy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<OtherDeploy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OtherDeploy_default = OtherDeploy;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/DeploySettingsPanel.svelte
var file50 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Deployment/DeploySettingsPanel.svelte";
function add_css42(target) {
  append_styles(target, "svelte-rzxh1p", "h3.svelte-rzxh1p{text-transform:uppercase;font-weight:normal;font-size:14px;font-style:normal}select.svelte-rzxh1p{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0.35em;width:100%;border:1px solid var(--grey-200);font-family:var(--ui-font-family);color:var(--grey-800);margin:0.5em 0 0 0;transition:all 400ms;cursor:pointer}select.svelte-rzxh1p:hover{border:1px solid var(--grey-300);transition:all 400ms;box-shadow:0 5px 5px 2px hsl(0deg 0% 97%)}select.svelte-rzxh1p:focus{outline:none}form.svelte-rzxh1p{scroll-margin-top:3.5rem}.container.svelte-rzxh1p{margin-top:2em;border-top:1px solid var(--grey-200);border-left:1px solid var(--grey-200);border-right:1px solid var(--grey-200);border-radius:5px 5px 0 0;font-size:14px;font-family:var(--ui-font-family);min-width:100%}.panel.svelte-rzxh1p{border-top:1px solid var(--grey-200);padding:0em 1em 1em 1em}.panel.svelte-rzxh1p:first-of-type{border-top:none}footer.svelte-rzxh1p{border:1px solid var(--grey-200);border-radius:0 0 5px 5px;background-color:var(--grey-100);padding:1em;display:flex;font-size:14px;align-items:center;font-family:var(--ui-font-family)}.docs-link.svelte-rzxh1p{color:var(--blue-600);text-decoration:none}.docs-link.svelte-rzxh1p:hover{color:var(--blue-800)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGVwbG95U2V0dGluZ3NQYW5lbC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBdURDLEVBQUEsY0FBQSxDQUFBLEFBQ0MsY0FBQSxDQUFBLFNBQXlCLENBQ3pCLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixTQUFBLENBQUEsSUFBZSxDQUNmLFVBQUEsQ0FBQSxNQUFrQixBQUNuQixDQUFBLEFBQ0EsTUFBQSxjQUFBLENBQUEsQUFDQyxrQkFBQSxDQUFBLElBQXdCLENBQ3hCLGVBQUEsQ0FBQSxJQUFxQixDQUNyQixVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsT0FBQSxDQUFBLE1BQWUsQ0FDZixLQUFBLENBQUEsSUFBVyxDQUNYLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxDQUNsQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLE1BQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFtQixDQUNuQixVQUFBLENBQUEsR0FBQSxDQUFBLEtBQXFCLENBQ3JCLE1BQUEsQ0FBQSxPQUFlLEFBQ2hCLENBQUEsQUFFQSxvQkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxVQUFBLENBQUEsR0FBQSxDQUFBLEtBQXFCLENBQ3JCLFVBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsSUFBQSxJQUFBLENBQUEsRUFBQSxDQUFBLEdBQUEsQ0FBMEMsQUFDM0MsQ0FBQSxBQUVBLG9CQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQUFDZCxDQUFBLEFBRUEsSUFBQSxjQUFBLENBQUEsQUFDQyxpQkFBQSxDQUFBLE1BQXlCLEFBQzFCLENBQUEsQUFDQSxVQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxHQUFlLENBQ2YsVUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXFDLENBQ3JDLFdBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQyxDQUN0QyxZQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBdUMsQ0FDdkMsYUFBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBQTBCLENBQzFCLFNBQUEsQ0FBQSxJQUFlLENBQ2YsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsU0FBQSxDQUFBLElBQWUsQUFDaEIsQ0FBQSxBQUVBLE1BQUEsY0FBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXFDLENBQ3JDLE9BQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUF3QixBQUN6QixDQUFBLEFBRUEsb0JBQUEsY0FBQSxBQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBZ0IsQUFDakIsQ0FBQSxBQUVBLE1BQUEsY0FBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLGFBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUEwQixDQUMxQixnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxPQUFBLENBQUEsR0FBWSxDQUNaLE9BQUEsQ0FBQSxJQUFhLENBQ2IsU0FBQSxDQUFBLElBQWUsQ0FDZixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQUFDbkMsQ0FBQSxBQUVBLFVBQUEsY0FBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixlQUFBLENBQUEsSUFBcUIsQUFDdEIsQ0FBQSxBQUVBLHdCQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkRlcGxveVNldHRpbmdzUGFuZWwuc3ZlbHRlIl19 */");
}
function get_each_context17(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_each_block17(ctx) {
  let option;
  let t0_value = (
    /*option*/
    ctx[4].name + ""
  );
  let t0;
  let t1;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, t0_value);
      t1 = claim_space(option_nodes);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*option*/
      ctx[4];
      option.value = option.__value;
      add_location(option, file50, 33, 5, 1109);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t0);
      append_hydration_dev(option, t1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block17.name,
    type: "each",
    source: "(33:4) {#each deploymentOptions as option}",
    ctx
  });
  return block;
}
function create_if_block38(ctx) {
  let div;
  let switch_instance;
  let div_transition;
  let current;
  var switch_value = (
    /*selectedDeployment*/
    ctx[1].formComponent
  );
  function switch_props(ctx2) {
    return {
      props: { settings: (
        /*settings*/
        ctx2[0]
      ) },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel svelte-rzxh1p");
      add_location(div, file50, 40, 3, 1246);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*settings*/
      1)
        switch_instance_changes.settings = /*settings*/
        ctx2[0];
      if (switch_value !== (switch_value = /*selectedDeployment*/
      ctx2[1].formComponent)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (switch_instance)
        destroy_component(switch_instance);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block38.name,
    type: "if",
    source: "(40:2) {#if selectedDeployment.formComponent}",
    ctx
  });
  return block;
}
function create_fragment58(ctx) {
  let form;
  let div1;
  let div0;
  let h2;
  let t0;
  let t1;
  let p;
  let t2;
  let b;
  let t3;
  let t4;
  let t5;
  let h3;
  let t6;
  let t7;
  let select;
  let t8;
  let t9;
  let footer;
  let span;
  let t10;
  let a;
  let t11;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*deploymentOptions*/
    ctx[2]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block17(get_each_context17(ctx, each_value, i));
  }
  let if_block = (
    /*selectedDeployment*/
    ctx[1].formComponent && create_if_block38(ctx)
  );
  const block = {
    c: function create() {
      form = element("form");
      div1 = element("div");
      div0 = element("div");
      h2 = element("h2");
      t0 = text("Deployment");
      t1 = space();
      p = element("p");
      t2 = text("Evidence projects can be deployed to a variety of cloud environments. The easiest way to\n				deploy your project is with ");
      b = element("b");
      t3 = text("Evidence Cloud");
      t4 = text(".");
      t5 = space();
      h3 = element("h3");
      t6 = text("Deployment Environment");
      t7 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t8 = space();
      if (if_block)
        if_block.c();
      t9 = space();
      footer = element("footer");
      span = element("span");
      t10 = text("Learn more about ");
      a = element("a");
      t11 = text("Deploying your Project ");
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { id: true, class: true });
      var form_nodes = children(form);
      div1 = claim_element(form_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      h2 = claim_element(div0_nodes, "H2", {});
      var h2_nodes = children(h2);
      t0 = claim_text(h2_nodes, "Deployment");
      h2_nodes.forEach(detach_dev);
      t1 = claim_space(div0_nodes);
      p = claim_element(div0_nodes, "P", {});
      var p_nodes = children(p);
      t2 = claim_text(p_nodes, "Evidence projects can be deployed to a variety of cloud environments. The easiest way to\n				deploy your project is with ");
      b = claim_element(p_nodes, "B", {});
      var b_nodes = children(b);
      t3 = claim_text(b_nodes, "Evidence Cloud");
      b_nodes.forEach(detach_dev);
      t4 = claim_text(p_nodes, ".");
      p_nodes.forEach(detach_dev);
      t5 = claim_space(div0_nodes);
      h3 = claim_element(div0_nodes, "H3", { class: true });
      var h3_nodes = children(h3);
      t6 = claim_text(h3_nodes, "Deployment Environment");
      h3_nodes.forEach(detach_dev);
      t7 = claim_space(div0_nodes);
      select = claim_element(div0_nodes, "SELECT", { class: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t8 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t9 = claim_space(form_nodes);
      footer = claim_element(form_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      span = claim_element(footer_nodes, "SPAN", {});
      var span_nodes = children(span);
      t10 = claim_text(span_nodes, "Learn more about ");
      a = claim_element(span_nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      t11 = claim_text(a_nodes, "Deploying your Project ");
      a_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h2, file50, 25, 3, 802);
      add_location(b, file50, 28, 32, 954);
      add_location(p, file50, 26, 3, 825);
      attr_dev(h3, "class", "svelte-rzxh1p");
      add_location(h3, file50, 30, 3, 988);
      attr_dev(select, "class", "svelte-rzxh1p");
      if (
        /*selectedDeployment*/
        ctx[1] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[3].call(select)
        ));
      add_location(select, file50, 31, 3, 1023);
      attr_dev(div0, "class", "panel svelte-rzxh1p");
      add_location(div0, file50, 24, 2, 779);
      attr_dev(div1, "class", "container svelte-rzxh1p");
      add_location(div1, file50, 23, 1, 753);
      attr_dev(a, "class", "docs-link svelte-rzxh1p");
      attr_dev(a, "href", "https://docs.evidence.dev/deployment/overview");
      add_location(a, file50, 47, 21, 1430);
      add_location(span, file50, 46, 2, 1403);
      attr_dev(footer, "class", "svelte-rzxh1p");
      add_location(footer, file50, 45, 1, 1392);
      attr_dev(form, "id", "deploy");
      attr_dev(form, "class", "svelte-rzxh1p");
      add_location(form, file50, 22, 0, 733);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      append_hydration_dev(form, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, h2);
      append_hydration_dev(h2, t0);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div0, p);
      append_hydration_dev(p, t2);
      append_hydration_dev(p, b);
      append_hydration_dev(b, t3);
      append_hydration_dev(p, t4);
      append_hydration_dev(div0, t5);
      append_hydration_dev(div0, h3);
      append_hydration_dev(h3, t6);
      append_hydration_dev(div0, t7);
      append_hydration_dev(div0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(
        select,
        /*selectedDeployment*/
        ctx[1]
      );
      append_hydration_dev(div1, t8);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(form, t9);
      append_hydration_dev(form, footer);
      append_hydration_dev(footer, span);
      append_hydration_dev(span, t10);
      append_hydration_dev(span, a);
      append_hydration_dev(a, t11);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          select,
          "change",
          /*select_change_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*deploymentOptions*/
      4) {
        each_value = /*deploymentOptions*/
        ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context17(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block17(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selectedDeployment, deploymentOptions*/
      6) {
        select_option(
          select,
          /*selectedDeployment*/
          ctx2[1]
        );
      }
      if (
        /*selectedDeployment*/
        ctx2[1].formComponent
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*selectedDeployment*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block38(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude55 = true;
function instance58($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DeploySettingsPanel", slots, []);
  let { settings } = $$props;
  let deploymentOptions = [
    {
      id: "evidence",
      name: "Evidence Cloud",
      formComponent: EvidenceDeploy_default
    },
    {
      id: "netlify",
      name: "Netlify",
      formComponent: NetlifyDeploy_default
    },
    {
      id: "vercel",
      name: "Vercel",
      formComponent: VercelDeploy_default
    },
    {
      id: "other",
      name: "Self-host (other)",
      formComponent: OtherDeploy_default
    }
  ];
  let selectedDeployment = deploymentOptions[0];
  $$self.$$.on_mount.push(function() {
    if (settings === void 0 && !("settings" in $$props || $$self.$$.bound[$$self.$$.props["settings"]])) {
      console.warn("<DeploySettingsPanel> was created without expected prop 'settings'");
    }
  });
  const writable_props = ["settings"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DeploySettingsPanel> was created with unknown prop '${key}'`);
  });
  function select_change_handler() {
    selectedDeployment = select_value(this);
    $$invalidate(1, selectedDeployment);
    $$invalidate(2, deploymentOptions);
  }
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude55,
    settings,
    EvidenceDeploy: EvidenceDeploy_default,
    NetlifyDeploy: NetlifyDeploy_default,
    VercelDeploy: VercelDeploy_default,
    OtherDeploy: OtherDeploy_default,
    slide,
    deploymentOptions,
    selectedDeployment
  });
  $$self.$inject_state = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
    if ("deploymentOptions" in $$props2)
      $$invalidate(2, deploymentOptions = $$props2.deploymentOptions);
    if ("selectedDeployment" in $$props2)
      $$invalidate(1, selectedDeployment = $$props2.selectedDeployment);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [settings, selectedDeployment, deploymentOptions, select_change_handler];
}
var DeploySettingsPanel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, { settings: 0 }, add_css42);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DeploySettingsPanel",
      options,
      id: create_fragment58.name
    });
  }
  get settings() {
    throw new Error("<DeploySettingsPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<DeploySettingsPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DeploySettingsPanel_default = DeploySettingsPanel;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/BuiltInFormatGrid.svelte
var file51 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/BuiltInFormatGrid.svelte";
function add_css43(target) {
  append_styles(target, "svelte-a9l586", "table.svelte-a9l586{font-size:14px;border-collapse:collapse;font-family:sans-serif;margin-left:-8px;width:calc(100% + 16px)}th.svelte-a9l586{max-width:1px;font-weight:600;padding:0px 8px;text-overflow:ellipsis;overflow:hidden}td.svelte-a9l586{padding:4px 8px;overflow:hidden;text-overflow:ellipsis}.align_left.svelte-a9l586{text-align:left}.align_right.svelte-a9l586{text-align:right}.wide_column.svelte-a9l586{min-width:120px}.narrow_column.svelte-a9l586{max-width:60px}.input_box.svelte-a9l586{width:100%}input.svelte-a9l586{box-sizing:border-box;border-radius:4px 4px 4px 4px;border:1px solid var(--grey-300);padding:0.25em 0.25em 0.25em 0.25em;margin-left:auto;width:65%;padding:0.35em;color:var(--grey-999);-webkit-appearance:none;-moz-appearance:none;vertical-align:middle;font-size:12px}input.svelte-a9l586:required{box-shadow:none}input.svelte-a9l586:focus{outline:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnVpbHRJbkZvcm1hdEdyaWQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1DQyxLQUFBLGNBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxJQUFlLENBQ2YsZUFBQSxDQUFBLFFBQXlCLENBQ3pCLFdBQUEsQ0FBQSxVQUF1QixDQUV2QixXQUFBLENBQUEsSUFBaUIsQ0FDakIsS0FBQSxDQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQXdCLEFBQ3pCLENBQUEsQUFDQSxFQUFBLGNBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxHQUFjLENBQ2QsV0FBQSxDQUFBLEdBQWdCLENBQ2hCLE9BQUEsQ0FBQSxHQUFBLENBQUEsR0FBZ0IsQ0FDaEIsYUFBQSxDQUFBLFFBQXVCLENBQ3ZCLFFBQUEsQ0FBQSxNQUFnQixBQUNqQixDQUFBLEFBQ0EsRUFBQSxjQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsR0FBQSxDQUFBLEdBQWdCLENBQ2hCLFFBQUEsQ0FBQSxNQUFnQixDQUNoQixhQUFBLENBQUEsUUFBdUIsQUFDeEIsQ0FBQSxBQUlBLFdBQUEsY0FBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQWdCLEFBQ2pCLENBQUEsQUFDQSxZQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxLQUFpQixBQUNsQixDQUFBLEFBQ0EsWUFBQSxjQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsS0FBZ0IsQUFDakIsQ0FBQSxBQUNBLGNBQUEsY0FBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLElBQWUsQUFDaEIsQ0FBQSxBQUNBLFVBQUEsY0FBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQVcsQUFDWixDQUFBLEFBRUEsS0FBQSxjQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsVUFBc0IsQ0FDdEIsYUFBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQThCLENBQzlCLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxPQUFBLENBQUEsTUFBQSxDQUFBLE1BQUEsQ0FBQSxNQUFBLENBQUEsTUFBb0MsQ0FDcEMsV0FBQSxDQUFBLElBQWlCLENBQ2pCLEtBQUEsQ0FBQSxHQUFVLENBQ1YsT0FBQSxDQUFBLE1BQWUsQ0FDZixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGtCQUFBLENBQUEsSUFBd0IsQ0FDeEIsZUFBQSxDQUFBLElBQXFCLENBQ3JCLGNBQUEsQ0FBQSxNQUFzQixDQUN0QixTQUFBLENBQUEsSUFBZSxBQUNoQixDQUFBLEFBQ0EsbUJBQUEsU0FBQSxBQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBZ0IsQUFDakIsQ0FBQSxBQUNBLG1CQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQUFDZCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJ1aWx0SW5Gb3JtYXRHcmlkLnN2ZWx0ZSJdfQ== */");
}
function get_each_context18(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  child_ctx[3] = list;
  child_ctx[4] = i;
  return child_ctx;
}
function create_each_block18(ctx) {
  let tr;
  let td0;
  let t0_value = (
    /*format*/
    ctx[2].formatTag + ""
  );
  let t0;
  let t1;
  let td1;
  let t2_value = (
    /*format*/
    ctx[2].formatCode + ""
  );
  let t2;
  let t3;
  let td2;
  let input;
  let input_id_value;
  let input_placeholder_value;
  let t4;
  let td3;
  let t5_value = formatExample(
    /*format*/
    ctx[2]
  ) + "";
  let t5;
  let t6;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[1].call(
      input,
      /*each_value*/
      ctx[3],
      /*format_index*/
      ctx[4]
    );
  }
  const block = {
    c: function create() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      input = element("input");
      t4 = space();
      td3 = element("td");
      t5 = text(t5_value);
      t6 = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      td0 = claim_element(tr_nodes, "TD", { class: true });
      var td0_nodes = children(td0);
      t0 = claim_text(td0_nodes, t0_value);
      td0_nodes.forEach(detach_dev);
      t1 = claim_space(tr_nodes);
      td1 = claim_element(tr_nodes, "TD", { class: true });
      var td1_nodes = children(td1);
      t2 = claim_text(td1_nodes, t2_value);
      td1_nodes.forEach(detach_dev);
      t3 = claim_space(tr_nodes);
      td2 = claim_element(tr_nodes, "TD", { class: true });
      var td2_nodes = children(td2);
      input = claim_element(td2_nodes, "INPUT", { id: true, placeholder: true, class: true });
      td2_nodes.forEach(detach_dev);
      t4 = claim_space(tr_nodes);
      td3 = claim_element(tr_nodes, "TD", { class: true });
      var td3_nodes = children(td3);
      t5 = claim_text(td3_nodes, t5_value);
      td3_nodes.forEach(detach_dev);
      t6 = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td0, "class", "svelte-a9l586");
      add_location(td0, file51, 18, 3, 499);
      attr_dev(td1, "class", "svelte-a9l586");
      add_location(td1, file51, 19, 3, 531);
      attr_dev(input, "id", input_id_value = "id_format_row" + /*format*/
      ctx[2].formatTag);
      attr_dev(input, "placeholder", input_placeholder_value = /*format*/
      ctx[2].exampleInput || defaultExample(
        /*format*/
        ctx[2].valueType
      ));
      attr_dev(input, "class", "align_left input_box svelte-a9l586");
      add_location(input, file51, 21, 4, 573);
      attr_dev(td2, "class", "svelte-a9l586");
      add_location(td2, file51, 20, 3, 564);
      attr_dev(td3, "class", "align_right svelte-a9l586");
      add_location(td3, file51, 29, 3, 831);
      add_location(tr, file51, 17, 2, 491);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      append_hydration_dev(tr, td0);
      append_hydration_dev(td0, t0);
      append_hydration_dev(tr, t1);
      append_hydration_dev(tr, td1);
      append_hydration_dev(td1, t2);
      append_hydration_dev(tr, t3);
      append_hydration_dev(tr, td2);
      append_hydration_dev(td2, input);
      set_input_value(
        input,
        /*format*/
        ctx[2].userInput
      );
      append_hydration_dev(tr, t4);
      append_hydration_dev(tr, td3);
      append_hydration_dev(td3, t5);
      append_hydration_dev(tr, t6);
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", input_input_handler),
          listen_dev(
            input,
            "blur",
            function() {
              if (is_function(
                /*format*/
                ctx[2].userInput = void 0
              ))
                /*format*/
                (ctx[2].userInput = void 0).apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*formats*/
      1 && t0_value !== (t0_value = /*format*/
      ctx[2].formatTag + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*formats*/
      1 && t2_value !== (t2_value = /*format*/
      ctx[2].formatCode + ""))
        set_data_dev(t2, t2_value);
      if (dirty & /*formats*/
      1 && input_id_value !== (input_id_value = "id_format_row" + /*format*/
      ctx[2].formatTag)) {
        attr_dev(input, "id", input_id_value);
      }
      if (dirty & /*formats*/
      1 && input_placeholder_value !== (input_placeholder_value = /*format*/
      ctx[2].exampleInput || defaultExample(
        /*format*/
        ctx[2].valueType
      ))) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*formats*/
      1 && input.value !== /*format*/
      ctx[2].userInput) {
        set_input_value(
          input,
          /*format*/
          ctx[2].userInput
        );
      }
      if (dirty & /*formats*/
      1 && t5_value !== (t5_value = formatExample(
        /*format*/
        ctx[2]
      ) + ""))
        set_data_dev(t5, t5_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block18.name,
    type: "each",
    source: "(17:1) {#each formats as format}",
    ctx
  });
  return block;
}
function create_fragment59(ctx) {
  let table;
  let thead;
  let th0;
  let t0;
  let t1;
  let th1;
  let t2;
  let t3;
  let th2;
  let t4;
  let t5;
  let th3;
  let t6;
  let t7;
  let each_value = (
    /*formats*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block18(get_each_context18(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      table = element("table");
      thead = element("thead");
      th0 = element("th");
      t0 = text("Format Name");
      t1 = space();
      th1 = element("th");
      t2 = text("Format Code");
      t3 = space();
      th2 = element("th");
      t4 = text("Example Input");
      t5 = space();
      th3 = element("th");
      t6 = text("Example Output");
      t7 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", {});
      var thead_nodes = children(thead);
      th0 = claim_element(thead_nodes, "TH", { class: true });
      var th0_nodes = children(th0);
      t0 = claim_text(th0_nodes, "Format Name");
      th0_nodes.forEach(detach_dev);
      t1 = claim_space(thead_nodes);
      th1 = claim_element(thead_nodes, "TH", { class: true });
      var th1_nodes = children(th1);
      t2 = claim_text(th1_nodes, "Format Code");
      th1_nodes.forEach(detach_dev);
      t3 = claim_space(thead_nodes);
      th2 = claim_element(thead_nodes, "TH", { class: true });
      var th2_nodes = children(th2);
      t4 = claim_text(th2_nodes, "Example Input");
      th2_nodes.forEach(detach_dev);
      t5 = claim_space(thead_nodes);
      th3 = claim_element(thead_nodes, "TH", { class: true });
      var th3_nodes = children(th3);
      t6 = claim_text(th3_nodes, "Example Output");
      th3_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t7 = claim_space(table_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(table_nodes);
      }
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th0, "class", "align_left narrow_column svelte-a9l586");
      add_location(th0, file51, 11, 2, 230);
      attr_dev(th1, "class", "align_left wide_column svelte-a9l586");
      add_location(th1, file51, 12, 2, 286);
      attr_dev(th2, "class", "align_left wide_column svelte-a9l586");
      add_location(th2, file51, 13, 2, 340);
      attr_dev(th3, "class", "align_right wide_column svelte-a9l586");
      add_location(th3, file51, 14, 2, 396);
      add_location(thead, file51, 10, 1, 220);
      attr_dev(table, "class", "svelte-a9l586");
      add_location(table, file51, 9, 0, 211);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, th0);
      append_hydration_dev(th0, t0);
      append_hydration_dev(thead, t1);
      append_hydration_dev(thead, th1);
      append_hydration_dev(th1, t2);
      append_hydration_dev(thead, t3);
      append_hydration_dev(thead, th2);
      append_hydration_dev(th2, t4);
      append_hydration_dev(thead, t5);
      append_hydration_dev(thead, th3);
      append_hydration_dev(th3, t6);
      append_hydration_dev(table, t7);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(table, null);
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*formatExample, formats, defaultExample, undefined*/
      1) {
        each_value = /*formats*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context18(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block18(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(table, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(table);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude56 = true;
function instance59($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BuiltInFormatGrid", slots, []);
  let { formats } = $$props;
  $$self.$$.on_mount.push(function() {
    if (formats === void 0 && !("formats" in $$props || $$self.$$.bound[$$self.$$.props["formats"]])) {
      console.warn("<BuiltInFormatGrid> was created without expected prop 'formats'");
    }
  });
  const writable_props = ["formats"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BuiltInFormatGrid> was created with unknown prop '${key}'`);
  });
  function input_input_handler(each_value, format_index) {
    each_value[format_index].userInput = this.value;
    $$invalidate(0, formats);
  }
  $$self.$$set = ($$props2) => {
    if ("formats" in $$props2)
      $$invalidate(0, formats = $$props2.formats);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude56,
    defaultExample,
    formatExample,
    formats
  });
  $$self.$inject_state = ($$props2) => {
    if ("formats" in $$props2)
      $$invalidate(0, formats = $$props2.formats);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [formats, input_input_handler];
}
var BuiltInFormatGrid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance59, create_fragment59, safe_not_equal, { formats: 0 }, add_css43);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BuiltInFormatGrid",
      options,
      id: create_fragment59.name
    });
  }
  get formats() {
    throw new Error("<BuiltInFormatGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formats(value) {
    throw new Error("<BuiltInFormatGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BuiltInFormatGrid_default = BuiltInFormatGrid;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/CollapsibleTableSection.svelte
var file52 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/CollapsibleTableSection.svelte";
function add_css44(target) {
  append_styles(target, "svelte-tqxdxm", "collapsibleHeader.svelte-tqxdxm{margin:0;padding:0;vertical-align:middle}h3.svelte-tqxdxm{margin:0;font-style:normal}button.svelte-tqxdxm{font-size:14px;background-color:var(--grey-100);border-radius:4px;color:var(--gray-999);display:flex;justify-content:space-between;width:100%;border:none;margin:0;padding:0.5em 0.5em;cursor:pointer}.collapsibleContents.svelte-tqxdxm{padding:0.5em 0.5em 1.5em 0.5em}.collapsibleSection.svelte-tqxdxm{padding:0px;margin:0.5em 0 0 0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29sbGFwc2libGVUYWJsZVNlY3Rpb24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTZCQyxpQkFBQSxjQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsQ0FBUyxDQUNULE9BQUEsQ0FBQSxDQUFVLENBQ1YsY0FBQSxDQUFBLE1BQXNCLEFBQ3ZCLENBQUEsQUFFQSxFQUFBLGNBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxDQUFTLENBQ1QsVUFBQSxDQUFBLE1BQWtCLEFBQ25CLENBQUEsQUFFQSxNQUFBLGNBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxJQUFlLENBQ2YsZ0JBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsT0FBQSxDQUFBLElBQWEsQ0FDYixlQUFBLENBQUEsYUFBOEIsQ0FDOUIsS0FBQSxDQUFBLElBQVcsQ0FDWCxNQUFBLENBQUEsSUFBWSxDQUNaLE1BQUEsQ0FBQSxDQUFTLENBQ1QsT0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFvQixDQUNwQixNQUFBLENBQUEsT0FBZSxBQUVoQixDQUFBLEFBRUEsb0JBQUEsY0FBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFBLENBQUEsS0FBQSxDQUFBLEtBQWdDLEFBQ2pDLENBQUEsQUFDQSxtQkFBQSxjQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsR0FBWSxDQUNaLE1BQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFtQixBQUNwQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNvbGxhcHNpYmxlVGFibGVTZWN0aW9uLnN2ZWx0ZSJdfQ== */");
}
function create_if_block39(ctx) {
  let div;
  let div_hidden_value;
  let div_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "collapsibleContents svelte-tqxdxm");
      div.hidden = div_hidden_value = !/*expanded*/
      ctx[0];
      add_location(div, file52, 22, 2, 562);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*expanded*/
      1 && div_hidden_value !== (div_hidden_value = !/*expanded*/
      ctx2[0])) {
        prop_dev(div, "hidden", div_hidden_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block39.name,
    type: "if",
    source: "(22:1) {#if expanded}",
    ctx
  });
  return block;
}
function create_fragment60(ctx) {
  let div;
  let collapsibleHeader;
  let button;
  let h3;
  let t0;
  let t1;
  let chevrontoggle;
  let t2;
  let current;
  let mounted;
  let dispose;
  chevrontoggle = new ChevronToggle_default({
    props: { toggled: (
      /*expanded*/
      ctx[0]
    ), size: "16" },
    $$inline: true
  });
  let if_block = (
    /*expanded*/
    ctx[0] && create_if_block39(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      collapsibleHeader = element("collapsibleHeader");
      button = element("button");
      h3 = element("h3");
      t0 = text(
        /*headerText*/
        ctx[1]
      );
      t1 = space();
      create_component(chevrontoggle.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      collapsibleHeader = claim_element(div_nodes, "COLLAPSIBLEHEADER", { class: true });
      var collapsibleHeader_nodes = children(collapsibleHeader);
      button = claim_element(collapsibleHeader_nodes, "BUTTON", { "area-expanded": true, class: true });
      var button_nodes = children(button);
      h3 = claim_element(button_nodes, "H3", { class: true });
      var h3_nodes = children(h3);
      t0 = claim_text(
        h3_nodes,
        /*headerText*/
        ctx[1]
      );
      h3_nodes.forEach(detach_dev);
      t1 = claim_space(button_nodes);
      claim_component(chevrontoggle.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      collapsibleHeader_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h3, "class", "svelte-tqxdxm");
      add_location(h3, file52, 17, 3, 438);
      attr_dev(
        button,
        "area-expanded",
        /*expanded*/
        ctx[0]
      );
      attr_dev(button, "class", "svelte-tqxdxm");
      add_location(button, file52, 16, 2, 360);
      attr_dev(collapsibleHeader, "class", "svelte-tqxdxm");
      add_location(collapsibleHeader, file52, 15, 1, 338);
      attr_dev(div, "class", "collapsibleSection svelte-tqxdxm");
      add_location(div, file52, 14, 0, 304);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, collapsibleHeader);
      append_hydration_dev(collapsibleHeader, button);
      append_hydration_dev(button, h3);
      append_hydration_dev(h3, t0);
      append_hydration_dev(button, t1);
      mount_component(chevrontoggle, button, null);
      append_hydration_dev(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", prevent_default(
          /*toggleExpanded*/
          ctx[2]
        ), false, true, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*headerText*/
      2)
        set_data_dev(
          t0,
          /*headerText*/
          ctx2[1]
        );
      const chevrontoggle_changes = {};
      if (dirty & /*expanded*/
      1)
        chevrontoggle_changes.toggled = /*expanded*/
        ctx2[0];
      chevrontoggle.$set(chevrontoggle_changes);
      if (!current || dirty & /*expanded*/
      1) {
        attr_dev(
          button,
          "area-expanded",
          /*expanded*/
          ctx2[0]
        );
      }
      if (
        /*expanded*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*expanded*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block39(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevrontoggle.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevrontoggle.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(chevrontoggle);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude57 = true;
function instance60($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CollapsibleTableSection", slots, ["default"]);
  let { headerText } = $$props;
  let { expanded = true } = $$props;
  let toggleExpanded = () => {
    $$invalidate(0, expanded = !expanded);
  };
  $$self.$$.on_mount.push(function() {
    if (headerText === void 0 && !("headerText" in $$props || $$self.$$.bound[$$self.$$.props["headerText"]])) {
      console.warn("<CollapsibleTableSection> was created without expected prop 'headerText'");
    }
  });
  const writable_props = ["headerText", "expanded"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CollapsibleTableSection> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("headerText" in $$props2)
      $$invalidate(1, headerText = $$props2.headerText);
    if ("expanded" in $$props2)
      $$invalidate(0, expanded = $$props2.expanded);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude57,
    slide,
    ChevronToggle: ChevronToggle_default,
    headerText,
    expanded,
    toggleExpanded
  });
  $$self.$inject_state = ($$props2) => {
    if ("headerText" in $$props2)
      $$invalidate(1, headerText = $$props2.headerText);
    if ("expanded" in $$props2)
      $$invalidate(0, expanded = $$props2.expanded);
    if ("toggleExpanded" in $$props2)
      $$invalidate(2, toggleExpanded = $$props2.toggleExpanded);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [expanded, headerText, toggleExpanded, $$scope, slots];
}
var CollapsibleTableSection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, { headerText: 1, expanded: 0 }, add_css44);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CollapsibleTableSection",
      options,
      id: create_fragment60.name
    });
  }
  get headerText() {
    throw new Error("<CollapsibleTableSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerText(value) {
    throw new Error("<CollapsibleTableSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<CollapsibleTableSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<CollapsibleTableSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CollapsibleTableSection_default = CollapsibleTableSection;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/CurrencyFormatGrid.svelte
var file53 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/CurrencyFormatGrid.svelte";
function add_css45(target) {
  append_styles(target, "svelte-12no4z2", "select.svelte-12no4z2{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0.35em;width:calc(100% + 14px);border:1px solid var(--grey-200);font-family:var(--ui-font-family);color:var(--grey-800);margin:0.5em 0 1.5em -7px;transition:all 400ms;cursor:pointer;font-size:14px}select.svelte-12no4z2:hover{border:1px solid var(--grey-300);transition:all 400ms;box-shadow:0 5px 5px 2px hsl(0deg 0% 97%)}select.svelte-12no4z2:focus{outline:none}table.svelte-12no4z2{font-size:14px;border-collapse:collapse;font-family:sans-serif;margin-left:-8px;width:calc(100% + 16px)}th.svelte-12no4z2{max-width:1px;font-weight:600;padding:0px 8px;text-overflow:ellipsis;overflow:hidden}td.svelte-12no4z2{padding:4px 8px;overflow:hidden;text-overflow:ellipsis}.align_left.svelte-12no4z2{text-align:left}.align_right.svelte-12no4z2{text-align:right}.wide_column.svelte-12no4z2{min-width:120px}.narrow_column.svelte-12no4z2{max-width:60px}.input_box.svelte-12no4z2{width:100%}input.svelte-12no4z2{box-sizing:border-box;border-radius:4px 4px 4px 4px;border:1px solid var(--grey-300);padding:0.25em 0.25em 0.25em 0.25em;margin-left:auto;width:65%;padding:0.35em;color:var(--grey-999);-webkit-appearance:none;-moz-appearance:none;vertical-align:middle;font-size:12px}input.svelte-12no4z2:required{box-shadow:none}input.svelte-12no4z2:focus{outline:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3VycmVuY3lGb3JtYXRHcmlkLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFrREMsTUFBQSxlQUFBLENBQUEsQUFDQyxrQkFBQSxDQUFBLElBQXdCLENBQ3hCLGVBQUEsQ0FBQSxJQUFxQixDQUNyQixVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsT0FBQSxDQUFBLE1BQWUsQ0FDZixLQUFBLENBQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBd0IsQ0FDeEIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLFdBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQWtDLENBQ2xDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsTUFBQSxDQUFBLEtBQUEsQ0FBQSxDQUFBLENBQUEsS0FBQSxDQUFBLElBQTBCLENBQzFCLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBcUIsQ0FDckIsTUFBQSxDQUFBLE9BQWUsQ0FDZixTQUFBLENBQUEsSUFBZSxBQUNoQixDQUFBLEFBQ0EscUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsVUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFxQixDQUNyQixVQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLElBQUEsSUFBQSxDQUFBLEVBQUEsQ0FBQSxHQUFBLENBQTBDLEFBQzNDLENBQUEsQUFDQSxxQkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxJQUFhLEFBQ2QsQ0FBQSxBQUVBLEtBQUEsZUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLElBQWUsQ0FDZixlQUFBLENBQUEsUUFBeUIsQ0FDekIsV0FBQSxDQUFBLFVBQXVCLENBRXZCLFdBQUEsQ0FBQSxJQUFpQixDQUNqQixLQUFBLENBQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBd0IsQUFDekIsQ0FBQSxBQUNBLEVBQUEsZUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLEdBQWMsQ0FDZCxXQUFBLENBQUEsR0FBZ0IsQ0FDaEIsT0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFnQixDQUNoQixhQUFBLENBQUEsUUFBdUIsQ0FDdkIsUUFBQSxDQUFBLE1BQWdCLEFBQ2pCLENBQUEsQUFDQSxFQUFBLGVBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxHQUFBLENBQUEsR0FBZ0IsQ0FDaEIsUUFBQSxDQUFBLE1BQWdCLENBQ2hCLGFBQUEsQ0FBQSxRQUF1QixBQUN4QixDQUFBLEFBSUEsV0FBQSxlQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBZ0IsQUFDakIsQ0FBQSxBQUNBLFlBQUEsZUFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLEtBQWlCLEFBQ2xCLENBQUEsQUFDQSxZQUFBLGVBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxLQUFnQixBQUNqQixDQUFBLEFBQ0EsY0FBQSxlQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsSUFBZSxBQUNoQixDQUFBLEFBQ0EsVUFBQSxlQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBVyxBQUNaLENBQUEsQUFFQSxLQUFBLGVBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixhQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBOEIsQ0FDOUIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxNQUFBLENBQUEsTUFBQSxDQUFBLE1BQUEsQ0FBQSxNQUFvQyxDQUNwQyxXQUFBLENBQUEsSUFBaUIsQ0FDakIsS0FBQSxDQUFBLEdBQVUsQ0FDVixPQUFBLENBQUEsTUFBZSxDQUNmLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsa0JBQUEsQ0FBQSxJQUF3QixDQUN4QixlQUFBLENBQUEsSUFBcUIsQ0FDckIsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLEFBQ2hCLENBQUEsQUFDQSxvQkFBQSxTQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBQ0Esb0JBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ3VycmVuY3lGb3JtYXRHcmlkLnN2ZWx0ZSJdfQ== */");
}
function get_each_context19(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  child_ctx[6] = list;
  child_ctx[7] = i;
  return child_ctx;
}
function get_each_context_15(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_each_block_15(ctx) {
  let option;
  let t_value = (
    /*currency*/
    ctx[8].displayName + ""
  );
  let t;
  let option_name_value;
  let option_id_value;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", { name: true, id: true });
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(option, "name", option_name_value = /*currency*/
      ctx[8].primaryCode);
      attr_dev(option, "id", option_id_value = /*currency*/
      ctx[8].primaryCode);
      option.__value = option_value_value = /*currency*/
      ctx[8].primaryCode;
      option.value = option.__value;
      add_location(option, file53, 15, 2, 516);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_15.name,
    type: "each",
    source: "(15:2) {#each SUPPORTED_CURRENCIES as currency}",
    ctx
  });
  return block;
}
function create_if_block40(ctx) {
  let div;
  let table;
  let thead;
  let th0;
  let t0;
  let t1;
  let th1;
  let t2;
  let t3;
  let th2;
  let t4;
  let t5;
  let th3;
  let t6;
  let t7;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_transition;
  let current;
  let each_value = (
    /*formats*/
    ctx[0].filter(
      /*func*/
      ctx[3]
    )
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*format*/
    ctx2[5].formatTag
  );
  validate_each_keys(ctx, each_value, get_each_context19, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context19(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block19(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      table = element("table");
      thead = element("thead");
      th0 = element("th");
      t0 = text("Format Name");
      t1 = space();
      th1 = element("th");
      t2 = text("Format Code");
      t3 = space();
      th2 = element("th");
      t4 = text("Example Input");
      t5 = space();
      th3 = element("th");
      t6 = text("Example Output");
      t7 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      table = claim_element(div_nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", {});
      var thead_nodes = children(thead);
      th0 = claim_element(thead_nodes, "TH", { class: true });
      var th0_nodes = children(th0);
      t0 = claim_text(th0_nodes, "Format Name");
      th0_nodes.forEach(detach_dev);
      t1 = claim_space(thead_nodes);
      th1 = claim_element(thead_nodes, "TH", { class: true });
      var th1_nodes = children(th1);
      t2 = claim_text(th1_nodes, "Format Code");
      th1_nodes.forEach(detach_dev);
      t3 = claim_space(thead_nodes);
      th2 = claim_element(thead_nodes, "TH", { class: true });
      var th2_nodes = children(th2);
      t4 = claim_text(th2_nodes, "Example Input");
      th2_nodes.forEach(detach_dev);
      t5 = claim_space(thead_nodes);
      th3 = claim_element(thead_nodes, "TH", { class: true });
      var th3_nodes = children(th3);
      t6 = claim_text(th3_nodes, "Example Output");
      th3_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t7 = claim_space(table_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(table_nodes);
      }
      table_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th0, "class", "align_left narrow_column svelte-12no4z2");
      add_location(th0, file53, 24, 4, 760);
      attr_dev(th1, "class", "align_left wide_column svelte-12no4z2");
      add_location(th1, file53, 25, 4, 818);
      attr_dev(th2, "class", "align_left wide_column svelte-12no4z2");
      add_location(th2, file53, 26, 4, 874);
      attr_dev(th3, "class", "align_right wide_column svelte-12no4z2");
      add_location(th3, file53, 27, 4, 932);
      add_location(thead, file53, 23, 3, 748);
      attr_dev(table, "class", "svelte-12no4z2");
      add_location(table, file53, 22, 2, 737);
      add_location(div, file53, 21, 1, 712);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, table);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, th0);
      append_hydration_dev(th0, t0);
      append_hydration_dev(thead, t1);
      append_hydration_dev(thead, th1);
      append_hydration_dev(th1, t2);
      append_hydration_dev(thead, t3);
      append_hydration_dev(thead, th2);
      append_hydration_dev(th2, t4);
      append_hydration_dev(thead, t5);
      append_hydration_dev(thead, th3);
      append_hydration_dev(th3, t6);
      append_hydration_dev(table, t7);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(table, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*formatExample, formats, selectedCurrency, defaultExample, undefined*/
      3) {
        each_value = /*formats*/
        ctx2[0].filter(
          /*func*/
          ctx2[3]
        );
        validate_each_argument(each_value);
        validate_each_keys(ctx2, each_value, get_each_context19, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, table, destroy_block, create_each_block19, null, get_each_context19);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, true);
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, {}, false);
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block40.name,
    type: "if",
    source: "(21:0) {#if selectedCurrency != 'Choose a currency'}",
    ctx
  });
  return block;
}
function create_each_block19(key_1, ctx) {
  let tr;
  let td0;
  let t0_value = (
    /*format*/
    ctx[5].formatTag + ""
  );
  let t0;
  let td0_intro;
  let t1;
  let td1;
  let t2_value = (
    /*format*/
    ctx[5].formatCode + ""
  );
  let t2;
  let td1_intro;
  let t3;
  let td2;
  let input;
  let input_id_value;
  let input_placeholder_value;
  let t4;
  let td3;
  let t5_value = formatExample(
    /*format*/
    ctx[5]
  ) + "";
  let t5;
  let td3_intro;
  let t6;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[4].call(
      input,
      /*each_value*/
      ctx[6],
      /*format_index*/
      ctx[7]
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      input = element("input");
      t4 = space();
      td3 = element("td");
      t5 = text(t5_value);
      t6 = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      td0 = claim_element(tr_nodes, "TD", { class: true });
      var td0_nodes = children(td0);
      t0 = claim_text(td0_nodes, t0_value);
      td0_nodes.forEach(detach_dev);
      t1 = claim_space(tr_nodes);
      td1 = claim_element(tr_nodes, "TD", { class: true });
      var td1_nodes = children(td1);
      t2 = claim_text(td1_nodes, t2_value);
      td1_nodes.forEach(detach_dev);
      t3 = claim_space(tr_nodes);
      td2 = claim_element(tr_nodes, "TD", { class: true });
      var td2_nodes = children(td2);
      input = claim_element(td2_nodes, "INPUT", { id: true, placeholder: true, class: true });
      td2_nodes.forEach(detach_dev);
      t4 = claim_space(tr_nodes);
      td3 = claim_element(tr_nodes, "TD", { class: true });
      var td3_nodes = children(td3);
      t5 = claim_text(td3_nodes, t5_value);
      td3_nodes.forEach(detach_dev);
      t6 = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td0, "class", "svelte-12no4z2");
      add_location(td0, file53, 31, 5, 1113);
      attr_dev(td1, "class", "svelte-12no4z2");
      add_location(td1, file53, 32, 5, 1161);
      attr_dev(input, "id", input_id_value = "id_format_row" + /*format*/
      ctx[5].formatTag);
      attr_dev(input, "placeholder", input_placeholder_value = /*format*/
      ctx[5].exampleInput || defaultExample(
        /*format*/
        ctx[5].valueType
      ));
      attr_dev(input, "class", "align_left input_box svelte-12no4z2");
      add_location(input, file53, 34, 6, 1221);
      attr_dev(td2, "class", "svelte-12no4z2");
      add_location(td2, file53, 33, 5, 1210);
      attr_dev(td3, "class", "align_right svelte-12no4z2");
      add_location(td3, file53, 42, 5, 1495);
      add_location(tr, file53, 30, 4, 1103);
      this.first = tr;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      append_hydration_dev(tr, td0);
      append_hydration_dev(td0, t0);
      append_hydration_dev(tr, t1);
      append_hydration_dev(tr, td1);
      append_hydration_dev(td1, t2);
      append_hydration_dev(tr, t3);
      append_hydration_dev(tr, td2);
      append_hydration_dev(td2, input);
      set_input_value(
        input,
        /*format*/
        ctx[5].userInput
      );
      append_hydration_dev(tr, t4);
      append_hydration_dev(tr, td3);
      append_hydration_dev(td3, t5);
      append_hydration_dev(tr, t6);
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", input_input_handler),
          listen_dev(
            input,
            "blur",
            function() {
              if (is_function(
                /*format*/
                ctx[5].userInput = void 0
              ))
                /*format*/
                (ctx[5].userInput = void 0).apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*formats, selectedCurrency*/
      3 && t0_value !== (t0_value = /*format*/
      ctx[5].formatTag + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*formats, selectedCurrency*/
      3 && t2_value !== (t2_value = /*format*/
      ctx[5].formatCode + ""))
        set_data_dev(t2, t2_value);
      if (dirty & /*formats, selectedCurrency, SUPPORTED_CURRENCIES*/
      3 && input_id_value !== (input_id_value = "id_format_row" + /*format*/
      ctx[5].formatTag)) {
        attr_dev(input, "id", input_id_value);
      }
      if (dirty & /*formats, selectedCurrency, SUPPORTED_CURRENCIES*/
      3 && input_placeholder_value !== (input_placeholder_value = /*format*/
      ctx[5].exampleInput || defaultExample(
        /*format*/
        ctx[5].valueType
      ))) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*formats, selectedCurrency, SUPPORTED_CURRENCIES*/
      3 && input.value !== /*format*/
      ctx[5].userInput) {
        set_input_value(
          input,
          /*format*/
          ctx[5].userInput
        );
      }
      if (dirty & /*formats, selectedCurrency*/
      3 && t5_value !== (t5_value = formatExample(
        /*format*/
        ctx[5]
      ) + ""))
        set_data_dev(t5, t5_value);
    },
    i: function intro(local) {
      if (local) {
        if (!td0_intro) {
          add_render_callback(() => {
            td0_intro = create_in_transition(td0, blur, {});
            td0_intro.start();
          });
        }
      }
      if (local) {
        if (!td1_intro) {
          add_render_callback(() => {
            td1_intro = create_in_transition(td1, blur, {});
            td1_intro.start();
          });
        }
      }
      if (local) {
        if (!td3_intro) {
          add_render_callback(() => {
            td3_intro = create_in_transition(td3, blur, {});
            td3_intro.start();
          });
        }
      }
    },
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block19.name,
    type: "each",
    source: "(30:3) {#each formats.filter((d) => d.parentFormat === selectedCurrency) as format (format.formatTag)}",
    ctx
  });
  return block;
}
function create_fragment61(ctx) {
  let select;
  let option;
  let t0;
  let t1;
  let t2;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = SUPPORTED_CURRENCIES;
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_15(get_each_context_15(ctx, each_value_1, i));
  }
  let if_block = (
    /*selectedCurrency*/
    ctx[1] != "Choose a currency" && create_if_block40(ctx)
  );
  const block = {
    c: function create() {
      select = element("select");
      option = element("option");
      t0 = text("Choose a currency");
      t1 = text("\n	$");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      select = claim_element(nodes, "SELECT", { class: true });
      var select_nodes = children(select);
      option = claim_element(select_nodes, "OPTION", {});
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, "Choose a currency");
      option_nodes.forEach(detach_dev);
      t1 = claim_text(select_nodes, "\n	$");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      option.__value = "Choose a currency";
      option.value = option.__value;
      add_location(option, file53, 13, 1, 436);
      attr_dev(select, "class", "svelte-12no4z2");
      if (
        /*selectedCurrency*/
        ctx[1] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[2].call(select)
        ));
      add_location(select, file53, 12, 0, 396);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, select, anchor);
      append_hydration_dev(select, option);
      append_hydration_dev(option, t0);
      append_hydration_dev(select, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(
        select,
        /*selectedCurrency*/
        ctx[1]
      );
      insert_hydration_dev(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          select,
          "change",
          /*select_change_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*SUPPORTED_CURRENCIES*/
      0) {
        each_value_1 = SUPPORTED_CURRENCIES;
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_15(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_15(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*selectedCurrency, SUPPORTED_CURRENCIES*/
      2) {
        select_option(
          select,
          /*selectedCurrency*/
          ctx2[1]
        );
      }
      if (
        /*selectedCurrency*/
        ctx2[1] != "Choose a currency"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*selectedCurrency*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block40(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(select);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude58 = true;
function instance61($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CurrencyFormatGrid", slots, []);
  let { formats } = $$props;
  let selectedCurrency = "Choose a currency";
  $$self.$$.on_mount.push(function() {
    if (formats === void 0 && !("formats" in $$props || $$self.$$.bound[$$self.$$.props["formats"]])) {
      console.warn("<CurrencyFormatGrid> was created without expected prop 'formats'");
    }
  });
  const writable_props = ["formats"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CurrencyFormatGrid> was created with unknown prop '${key}'`);
  });
  function select_change_handler() {
    selectedCurrency = select_value(this);
    $$invalidate(1, selectedCurrency);
  }
  const func3 = (d) => d.parentFormat === selectedCurrency;
  function input_input_handler(each_value, format_index) {
    each_value[format_index].userInput = this.value;
    $$invalidate(0, formats);
    $$invalidate(1, selectedCurrency);
  }
  $$self.$$set = ($$props2) => {
    if ("formats" in $$props2)
      $$invalidate(0, formats = $$props2.formats);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude58,
    blur,
    slide,
    SUPPORTED_CURRENCIES,
    defaultExample,
    formatExample,
    formats,
    selectedCurrency
  });
  $$self.$inject_state = ($$props2) => {
    if ("formats" in $$props2)
      $$invalidate(0, formats = $$props2.formats);
    if ("selectedCurrency" in $$props2)
      $$invalidate(1, selectedCurrency = $$props2.selectedCurrency);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [formats, selectedCurrency, select_change_handler, func3, input_input_handler];
}
var CurrencyFormatGrid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, { formats: 0 }, add_css45);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CurrencyFormatGrid",
      options,
      id: create_fragment61.name
    });
  }
  get formats() {
    throw new Error("<CurrencyFormatGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formats(value) {
    throw new Error("<CurrencyFormatGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CurrencyFormatGrid_default = CurrencyFormatGrid;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/CustomFormatGrid.svelte
var file54 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/CustomFormatGrid.svelte";
function add_css46(target) {
  append_styles(target, "svelte-tx6uu3", ".deleteIcon.svelte-tx6uu3{color:var(--red-600);width:16px;cursor:pointer}button.svelte-tx6uu3{background:none;border:none;cursor:pointer;vertical-align:middle}.deleteIcon.svelte-tx6uu3:hover{color:var(--red-700)}table.svelte-tx6uu3{font-size:14px;border-collapse:collapse;font-family:sans-serif;margin-left:-8px;width:calc(100% + 16px)}th.svelte-tx6uu3{max-width:1px;font-weight:600;padding:0px 8px;text-overflow:ellipsis;overflow:hidden}td.svelte-tx6uu3{padding:4px 8px;overflow:hidden;text-overflow:ellipsis}.align_left.svelte-tx6uu3{text-align:left}.align_right.svelte-tx6uu3{text-align:right}.wide_column.svelte-tx6uu3{min-width:120px}.narrow_column.svelte-tx6uu3{max-width:60px}.input_box.svelte-tx6uu3{width:100%}input.svelte-tx6uu3{box-sizing:border-box;border-radius:4px 4px 4px 4px;border:1px solid var(--grey-300);padding:0.25em 0.25em 0.25em 0.25em;margin-left:auto;width:65%;padding:0.35em;color:var(--grey-999);-webkit-appearance:none;-moz-appearance:none;vertical-align:middle;font-size:12px}input.svelte-tx6uu3:required{box-shadow:none}input.svelte-tx6uu3:focus{outline:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3VzdG9tRm9ybWF0R3JpZC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBb0RDLFdBQUEsY0FBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsU0FBQSxDQUFxQixDQUNyQixLQUFBLENBQUEsSUFBVyxDQUNYLE1BQUEsQ0FBQSxPQUFlLEFBQ2hCLENBQUEsQUFFQSxNQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixDQUNoQixNQUFBLENBQUEsSUFBWSxDQUNaLE1BQUEsQ0FBQSxPQUFlLENBQ2YsY0FBQSxDQUFBLE1BQXNCLEFBQ3ZCLENBQUEsQUFFQSx5QkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFNBQUEsQ0FBcUIsQUFDdEIsQ0FBQSxBQUVBLEtBQUEsY0FBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLElBQWUsQ0FDZixlQUFBLENBQUEsUUFBeUIsQ0FDekIsV0FBQSxDQUFBLFVBQXVCLENBRXZCLFdBQUEsQ0FBQSxJQUFpQixDQUNqQixLQUFBLENBQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBd0IsQUFDekIsQ0FBQSxBQUNBLEVBQUEsY0FBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLEdBQWMsQ0FDZCxXQUFBLENBQUEsR0FBZ0IsQ0FDaEIsT0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFnQixDQUNoQixhQUFBLENBQUEsUUFBdUIsQ0FDdkIsUUFBQSxDQUFBLE1BQWdCLEFBQ2pCLENBQUEsQUFDQSxFQUFBLGNBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxHQUFBLENBQUEsR0FBZ0IsQ0FDaEIsUUFBQSxDQUFBLE1BQWdCLENBQ2hCLGFBQUEsQ0FBQSxRQUF1QixBQUN4QixDQUFBLEFBSUEsV0FBQSxjQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBZ0IsQUFDakIsQ0FBQSxBQUNBLFlBQUEsY0FBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLEtBQWlCLEFBQ2xCLENBQUEsQUFDQSxZQUFBLGNBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxLQUFnQixBQUNqQixDQUFBLEFBQ0EsY0FBQSxjQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsSUFBZSxBQUNoQixDQUFBLEFBQ0EsVUFBQSxjQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBVyxBQUNaLENBQUEsQUFFQSxLQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixhQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBOEIsQ0FDOUIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxNQUFBLENBQUEsTUFBQSxDQUFBLE1BQUEsQ0FBQSxNQUFvQyxDQUNwQyxXQUFBLENBQUEsSUFBaUIsQ0FDakIsS0FBQSxDQUFBLEdBQVUsQ0FDVixPQUFBLENBQUEsTUFBZSxDQUNmLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsa0JBQUEsQ0FBQSxJQUF3QixDQUN4QixlQUFBLENBQUEsSUFBcUIsQ0FDckIsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLEFBQ2hCLENBQUEsQUFDQSxtQkFBQSxTQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBQ0EsbUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ3VzdG9tRm9ybWF0R3JpZC5zdmVsdGUiXX0= */");
}
function get_each_context20(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  child_ctx[5] = list;
  child_ctx[6] = i;
  return child_ctx;
}
function create_each_block20(ctx) {
  let tr;
  let td0;
  let t0_value = (
    /*format*/
    ctx[4].formatTag + ""
  );
  let t0;
  let t1;
  let td1;
  let t2_value = (
    /*format*/
    ctx[4].formatCode + ""
  );
  let t2;
  let t3;
  let td2;
  let input;
  let input_id_value;
  let input_placeholder_value;
  let t4;
  let td3;
  let t5_value = formatExample(
    /*format*/
    ctx[4]
  ) + "";
  let t5;
  let t6;
  let td4;
  let button;
  let div;
  let icon;
  let t7;
  let current;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[2].call(
      input,
      /*each_value*/
      ctx[5],
      /*format_index*/
      ctx[6]
    );
  }
  icon = new Icon_default({ props: { src: CircleX }, $$inline: true });
  function click_handler() {
    return (
      /*click_handler*/
      ctx[3](
        /*format*/
        ctx[4]
      )
    );
  }
  const block = {
    c: function create() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      input = element("input");
      t4 = space();
      td3 = element("td");
      t5 = text(t5_value);
      t6 = space();
      td4 = element("td");
      button = element("button");
      div = element("div");
      create_component(icon.$$.fragment);
      t7 = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      td0 = claim_element(tr_nodes, "TD", { class: true });
      var td0_nodes = children(td0);
      t0 = claim_text(td0_nodes, t0_value);
      td0_nodes.forEach(detach_dev);
      t1 = claim_space(tr_nodes);
      td1 = claim_element(tr_nodes, "TD", { class: true });
      var td1_nodes = children(td1);
      t2 = claim_text(td1_nodes, t2_value);
      td1_nodes.forEach(detach_dev);
      t3 = claim_space(tr_nodes);
      td2 = claim_element(tr_nodes, "TD", { class: true });
      var td2_nodes = children(td2);
      input = claim_element(td2_nodes, "INPUT", { id: true, placeholder: true, class: true });
      td2_nodes.forEach(detach_dev);
      t4 = claim_space(tr_nodes);
      td3 = claim_element(tr_nodes, "TD", { class: true });
      var td3_nodes = children(td3);
      t5 = claim_text(td3_nodes, t5_value);
      td3_nodes.forEach(detach_dev);
      t6 = claim_space(tr_nodes);
      td4 = claim_element(tr_nodes, "TD", { class: true });
      var td4_nodes = children(td4);
      button = claim_element(td4_nodes, "BUTTON", { type: true, tooltip: true, class: true });
      var button_nodes = children(button);
      div = claim_element(button_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(icon.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      td4_nodes.forEach(detach_dev);
      t7 = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td0, "class", "svelte-tx6uu3");
      add_location(td0, file54, 23, 3, 654);
      attr_dev(td1, "class", "svelte-tx6uu3");
      add_location(td1, file54, 24, 3, 686);
      attr_dev(input, "id", input_id_value = "id_format_row" + /*format*/
      ctx[4].formatTag);
      attr_dev(input, "placeholder", input_placeholder_value = /*format*/
      ctx[4].exampleInput || defaultExample(
        /*format*/
        ctx[4].valueType
      ));
      attr_dev(input, "class", "align_left input_box svelte-tx6uu3");
      add_location(input, file54, 26, 4, 728);
      attr_dev(td2, "class", "svelte-tx6uu3");
      add_location(td2, file54, 25, 3, 719);
      attr_dev(td3, "class", "align_right svelte-tx6uu3");
      add_location(td3, file54, 34, 3, 986);
      attr_dev(div, "class", "deleteIcon svelte-tx6uu3");
      add_location(div, file54, 42, 5, 1175);
      attr_dev(button, "type", "button");
      attr_dev(button, "tooltip", "Remove");
      attr_dev(button, "class", "mb-0.5 svelte-tx6uu3");
      add_location(button, file54, 36, 4, 1051);
      attr_dev(td4, "class", "svelte-tx6uu3");
      add_location(td4, file54, 35, 3, 1042);
      add_location(tr, file54, 22, 2, 646);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      append_hydration_dev(tr, td0);
      append_hydration_dev(td0, t0);
      append_hydration_dev(tr, t1);
      append_hydration_dev(tr, td1);
      append_hydration_dev(td1, t2);
      append_hydration_dev(tr, t3);
      append_hydration_dev(tr, td2);
      append_hydration_dev(td2, input);
      set_input_value(
        input,
        /*format*/
        ctx[4].userInput
      );
      append_hydration_dev(tr, t4);
      append_hydration_dev(tr, td3);
      append_hydration_dev(td3, t5);
      append_hydration_dev(tr, t6);
      append_hydration_dev(tr, td4);
      append_hydration_dev(td4, button);
      append_hydration_dev(button, div);
      mount_component(icon, div, null);
      append_hydration_dev(tr, t7);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", input_input_handler),
          listen_dev(
            input,
            "blur",
            function() {
              if (is_function(
                /*format*/
                ctx[4].userInput = void 0
              ))
                /*format*/
                (ctx[4].userInput = void 0).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(button, "click", click_handler, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*formats*/
      1) && t0_value !== (t0_value = /*format*/
      ctx[4].formatTag + ""))
        set_data_dev(t0, t0_value);
      if ((!current || dirty & /*formats*/
      1) && t2_value !== (t2_value = /*format*/
      ctx[4].formatCode + ""))
        set_data_dev(t2, t2_value);
      if (!current || dirty & /*formats*/
      1 && input_id_value !== (input_id_value = "id_format_row" + /*format*/
      ctx[4].formatTag)) {
        attr_dev(input, "id", input_id_value);
      }
      if (!current || dirty & /*formats*/
      1 && input_placeholder_value !== (input_placeholder_value = /*format*/
      ctx[4].exampleInput || defaultExample(
        /*format*/
        ctx[4].valueType
      ))) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*formats*/
      1 && input.value !== /*format*/
      ctx[4].userInput) {
        set_input_value(
          input,
          /*format*/
          ctx[4].userInput
        );
      }
      if ((!current || dirty & /*formats*/
      1) && t5_value !== (t5_value = formatExample(
        /*format*/
        ctx[4]
      ) + ""))
        set_data_dev(t5, t5_value);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      destroy_component(icon);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block20.name,
    type: "each",
    source: "(22:1) {#each formats as format}",
    ctx
  });
  return block;
}
function create_fragment62(ctx) {
  let table;
  let thead;
  let th0;
  let t0;
  let t1;
  let th1;
  let t2;
  let t3;
  let th2;
  let t4;
  let t5;
  let th3;
  let t6;
  let t7;
  let th4;
  let t8;
  let current;
  let each_value = (
    /*formats*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block20(get_each_context20(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      table = element("table");
      thead = element("thead");
      th0 = element("th");
      t0 = text("Format Name");
      t1 = space();
      th1 = element("th");
      t2 = text("Format Code");
      t3 = space();
      th2 = element("th");
      t4 = text("Example Input");
      t5 = space();
      th3 = element("th");
      t6 = text("Example Output");
      t7 = space();
      th4 = element("th");
      t8 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", {});
      var thead_nodes = children(thead);
      th0 = claim_element(thead_nodes, "TH", { class: true });
      var th0_nodes = children(th0);
      t0 = claim_text(th0_nodes, "Format Name");
      th0_nodes.forEach(detach_dev);
      t1 = claim_space(thead_nodes);
      th1 = claim_element(thead_nodes, "TH", { class: true });
      var th1_nodes = children(th1);
      t2 = claim_text(th1_nodes, "Format Code");
      th1_nodes.forEach(detach_dev);
      t3 = claim_space(thead_nodes);
      th2 = claim_element(thead_nodes, "TH", { class: true });
      var th2_nodes = children(th2);
      t4 = claim_text(th2_nodes, "Example Input");
      th2_nodes.forEach(detach_dev);
      t5 = claim_space(thead_nodes);
      th3 = claim_element(thead_nodes, "TH", { class: true });
      var th3_nodes = children(th3);
      t6 = claim_text(th3_nodes, "Example Output");
      th3_nodes.forEach(detach_dev);
      t7 = claim_space(thead_nodes);
      th4 = claim_element(thead_nodes, "TH", { class: true });
      var th4_nodes = children(th4);
      th4_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t8 = claim_space(table_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(table_nodes);
      }
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th0, "class", "align_left narrow_column svelte-tx6uu3");
      add_location(th0, file54, 15, 2, 358);
      attr_dev(th1, "class", "align_left wide_column svelte-tx6uu3");
      add_location(th1, file54, 16, 2, 414);
      attr_dev(th2, "class", "align_left wide_column svelte-tx6uu3");
      add_location(th2, file54, 17, 2, 468);
      attr_dev(th3, "class", "align_right wide_column svelte-tx6uu3");
      add_location(th3, file54, 18, 2, 524);
      attr_dev(th4, "class", "svelte-tx6uu3");
      add_location(th4, file54, 19, 2, 582);
      add_location(thead, file54, 14, 1, 348);
      attr_dev(table, "class", "svelte-tx6uu3");
      add_location(table, file54, 13, 0, 339);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, th0);
      append_hydration_dev(th0, t0);
      append_hydration_dev(thead, t1);
      append_hydration_dev(thead, th1);
      append_hydration_dev(th1, t2);
      append_hydration_dev(thead, t3);
      append_hydration_dev(thead, th2);
      append_hydration_dev(th2, t4);
      append_hydration_dev(thead, t5);
      append_hydration_dev(thead, th3);
      append_hydration_dev(th3, t6);
      append_hydration_dev(thead, t7);
      append_hydration_dev(thead, th4);
      append_hydration_dev(table, t8);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(table, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*deleteHandler, formats, CircleX, formatExample, defaultExample, undefined*/
      3) {
        each_value = /*formats*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context20(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block20(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(table, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(table);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude59 = true;
function instance62($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CustomFormatGrid", slots, []);
  let { formats } = $$props;
  let { deleteHandler } = $$props;
  $$self.$$.on_mount.push(function() {
    if (formats === void 0 && !("formats" in $$props || $$self.$$.bound[$$self.$$.props["formats"]])) {
      console.warn("<CustomFormatGrid> was created without expected prop 'formats'");
    }
    if (deleteHandler === void 0 && !("deleteHandler" in $$props || $$self.$$.bound[$$self.$$.props["deleteHandler"]])) {
      console.warn("<CustomFormatGrid> was created without expected prop 'deleteHandler'");
    }
  });
  const writable_props = ["formats", "deleteHandler"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CustomFormatGrid> was created with unknown prop '${key}'`);
  });
  function input_input_handler(each_value, format_index) {
    each_value[format_index].userInput = this.value;
    $$invalidate(0, formats);
  }
  const click_handler = (format) => deleteHandler(format);
  $$self.$$set = ($$props2) => {
    if ("formats" in $$props2)
      $$invalidate(0, formats = $$props2.formats);
    if ("deleteHandler" in $$props2)
      $$invalidate(1, deleteHandler = $$props2.deleteHandler);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude59,
    Icon: Icon_default,
    CircleX,
    defaultExample,
    formatExample,
    formats,
    deleteHandler
  });
  $$self.$inject_state = ($$props2) => {
    if ("formats" in $$props2)
      $$invalidate(0, formats = $$props2.formats);
    if ("deleteHandler" in $$props2)
      $$invalidate(1, deleteHandler = $$props2.deleteHandler);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [formats, deleteHandler, input_input_handler, click_handler];
}
var CustomFormatGrid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment62, safe_not_equal, { formats: 0, deleteHandler: 1 }, add_css46);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CustomFormatGrid",
      options,
      id: create_fragment62.name
    });
  }
  get formats() {
    throw new Error("<CustomFormatGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formats(value) {
    throw new Error("<CustomFormatGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteHandler() {
    throw new Error("<CustomFormatGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteHandler(value) {
    throw new Error("<CustomFormatGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CustomFormatGrid_default = CustomFormatGrid;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/CustomFormatsSection.svelte
var import_ssf = __toESM(require_ssf());
var file55 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/CustomFormatsSection.svelte";
function add_css47(target) {
  append_styles(target, "svelte-5fwe7l", "input.svelte-5fwe7l{box-sizing:border-box;border-radius:4px 4px 4px 4px;border:1px solid var(--grey-300);padding:0.25em 0.25em 0.25em 0.25em;margin-left:auto;width:62%;padding:0.35em;color:var(--grey-999);-webkit-appearance:none;-moz-appearance:none;vertical-align:middle;font-size:14px}input.svelte-5fwe7l:required{box-shadow:none}input.svelte-5fwe7l:focus{outline:none}label.svelte-5fwe7l{width:35%;text-transform:uppercase;font-weight:normal;font-size:14px;color:var(--grey-800)}button.svelte-5fwe7l{padding:0.4em 0.5em;margin-right:0.25em;margin-left:0.25em;font-style:normal;text-decoration:none;font-size:14px;cursor:pointer}select.svelte-5fwe7l{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:1px solid var(--grey-200);border-radius:4px 4px 4px 4px;font-family:var(--ui-font-family);color:var(--grey-800);transition:all 400ms;cursor:pointer;vertical-align:middle;box-sizing:border-box;padding:0.35em;margin-left:auto;width:62%;font-size:14px}select.svelte-5fwe7l:hover{border:1px solid var(--grey-300);transition:all 400ms;box-shadow:0 5px 5px 2px hsl(0deg 0% 97%)}select.svelte-5fwe7l:focus{outline:none}div.input-item.svelte-5fwe7l{font-family:var(--ui-font-family);color:var(--grey-999);font-size:16px;margin-top:1.1em;display:flex;flex-direction:row;flex-wrap:wrap;align-items:center}div.new-format-buttons.svelte-5fwe7l{display:flex;justify-content:flex-end;padding-top:0.5em}.error.svelte-5fwe7l{color:var(--red-600)}#submitCustomFormatButton.svelte-5fwe7l{background-color:var(--blue-600);color:white;font-weight:bold;border-radius:4px;border:1px solid var(--blue-700);padding:0.4em 1.1em;transition-property:background, color;transition-duration:350ms}#submitCustomFormatButton.svelte-5fwe7l:active{background-color:var(--blue-800);color:white;font-weight:bold;border-radius:4px;border:1px solid var(--blue-900);padding:0.4em 1.1em;transition-property:background, color;transition-duration:350ms}#submitCustomFormatButton.svelte-5fwe7l:disabled,button[disabled].svelte-5fwe7l{border:1px solid var(--grey-400);background-color:var(--grey-100);color:var(--grey-600);cursor:not-allowed;transition-property:background, color;transition-duration:350ms}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3VzdG9tRm9ybWF0c1NlY3Rpb24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXVJQyxLQUFBLGNBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixhQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBOEIsQ0FDOUIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxNQUFBLENBQUEsTUFBQSxDQUFBLE1BQUEsQ0FBQSxNQUFvQyxDQUNwQyxXQUFBLENBQUEsSUFBaUIsQ0FDakIsS0FBQSxDQUFBLEdBQVUsQ0FDVixPQUFBLENBQUEsTUFBZSxDQUNmLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsa0JBQUEsQ0FBQSxJQUF3QixDQUN4QixlQUFBLENBQUEsSUFBcUIsQ0FDckIsY0FBQSxDQUFBLE1BQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLEFBQ2hCLENBQUEsQUFDQSxtQkFBQSxTQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBQ0EsbUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFDQSxLQUFBLGNBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxHQUFVLENBQ1YsY0FBQSxDQUFBLFNBQXlCLENBQ3pCLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixTQUFBLENBQUEsSUFBZSxDQUNmLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUNBLE1BQUEsY0FBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFvQixDQUNwQixZQUFBLENBQUEsTUFBb0IsQ0FDcEIsV0FBQSxDQUFBLE1BQW1CLENBQ25CLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixlQUFBLENBQUEsSUFBcUIsQ0FDckIsU0FBQSxDQUFBLElBQWUsQ0FDZixNQUFBLENBQUEsT0FBZSxBQUNoQixDQUFBLEFBQ0EsTUFBQSxjQUFBLENBQUEsQUFDQyxrQkFBQSxDQUFBLElBQXdCLENBQ3hCLGVBQUEsQ0FBQSxJQUFxQixDQUNyQixVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLGFBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUE4QixDQUM5QixXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxDQUNsQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBcUIsQ0FDckIsTUFBQSxDQUFBLE9BQWUsQ0FFZixjQUFBLENBQUEsTUFBc0IsQ0FDdEIsVUFBQSxDQUFBLFVBQXNCLENBQ3RCLE9BQUEsQ0FBQSxNQUFlLENBQ2YsV0FBQSxDQUFBLElBQWlCLENBQ2pCLEtBQUEsQ0FBQSxHQUFVLENBQ1YsU0FBQSxDQUFBLElBQWUsQUFDaEIsQ0FBQSxBQUNBLG9CQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBcUIsQ0FDckIsVUFBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxJQUFBLElBQUEsQ0FBQSxFQUFBLENBQUEsR0FBQSxDQUEwQyxBQUMzQyxDQUFBLEFBQ0Esb0JBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFFQSxHQUFBLFdBQUEsY0FBQSxDQUFBLEFBQ0MsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixTQUFBLENBQUEsSUFBZSxDQUNmLFVBQUEsQ0FBQSxLQUFpQixDQUNqQixPQUFBLENBQUEsSUFBYSxDQUNiLGNBQUEsQ0FBQSxHQUFtQixDQUNuQixTQUFBLENBQUEsSUFBZSxDQUNmLFdBQUEsQ0FBQSxNQUFtQixBQUNwQixDQUFBLEFBQ0EsR0FBQSxtQkFBQSxjQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxDQUNiLGVBQUEsQ0FBQSxRQUF5QixDQUN6QixXQUFBLENBQUEsS0FBa0IsQUFDbkIsQ0FBQSxBQUNBLE1BQUEsY0FBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsU0FBQSxDQUFxQixBQUN0QixDQUFBLEFBRUEseUJBQUEsY0FBQSxDQUFBLEFBQ0MsZ0JBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsS0FBQSxDQUFBLEtBQVksQ0FDWixXQUFBLENBQUEsSUFBaUIsQ0FDakIsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxPQUFBLENBQUEsS0FBQSxDQUFBLEtBQW9CLENBQ3BCLG1CQUFBLENBQUEsVUFBQSxDQUFBLENBQUEsS0FBc0MsQ0FDdEMsbUJBQUEsQ0FBQSxLQUEwQixBQUMzQixDQUFBLEFBRUEsdUNBQUEsT0FBQSxBQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxLQUFBLENBQUEsS0FBWSxDQUNaLFdBQUEsQ0FBQSxJQUFpQixDQUNqQixhQUFBLENBQUEsR0FBa0IsQ0FDbEIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxLQUFBLENBQUEsS0FBb0IsQ0FDcEIsbUJBQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxLQUFzQyxDQUN0QyxtQkFBQSxDQUFBLEtBQTBCLEFBQzNCLENBQUEsQUFFQSx1Q0FBQSxTQUFBLGdDQUVDLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxnQkFBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLE1BQUEsQ0FBQSxXQUFtQixDQUNuQixtQkFBQSxDQUFBLFVBQUEsQ0FBQSxDQUFBLEtBQXNDLENBQ3RDLG1CQUFBLENBQUEsS0FBMEIsQUFDM0IsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDdXN0b21Gb3JtYXRzU2VjdGlvbi5zdmVsdGUiXX0= */");
}
function get_each_context21(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function create_if_block41(ctx) {
  let collapsibletablesection;
  let current;
  collapsibletablesection = new CollapsibleTableSection_default({
    props: {
      headerText: "Saved Custom Formats",
      expanded: false,
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(collapsibletablesection.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(collapsibletablesection.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(collapsibletablesection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const collapsibletablesection_changes = {};
      if (dirty & /*$$scope, customFormattingSettings*/
      131073) {
        collapsibletablesection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapsibletablesection.$set(collapsibletablesection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(collapsibletablesection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(collapsibletablesection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(collapsibletablesection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block41.name,
    type: "if",
    source: "(94:0) {#if customFormattingSettings.customFormats && customFormattingSettings.customFormats.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let customformatgrid;
  let current;
  customformatgrid = new CustomFormatGrid_default({
    props: {
      formats: (
        /*customFormattingSettings*/
        ctx[0].customFormats
      ),
      deleteHandler: (
        /*deleteCustomFormat*/
        ctx[6]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(customformatgrid.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(customformatgrid.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(customformatgrid, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const customformatgrid_changes = {};
      if (dirty & /*customFormattingSettings*/
      1)
        customformatgrid_changes.formats = /*customFormattingSettings*/
        ctx2[0].customFormats;
      customformatgrid.$set(customformatgrid_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(customformatgrid.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(customformatgrid.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(customformatgrid, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(95:1) <CollapsibleTableSection headerText={'Saved Custom Formats'} expanded={false}>",
    ctx
  });
  return block;
}
function create_each_block21(ctx) {
  let option;
  let t0_value = (
    /*option*/
    ctx[14] + ""
  );
  let t0;
  let t1;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, t0_value);
      t1 = claim_space(option_nodes);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*option*/
      ctx[14];
      option.value = option.__value;
      add_location(option, file55, 107, 4, 3083);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t0);
      append_hydration_dev(option, t1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block21.name,
    type: "each",
    source: "(107:3) {#each valueTypeOptions as option}",
    ctx
  });
  return block;
}
function create_fragment63(ctx) {
  let t0;
  let form;
  let div0;
  let label0;
  let t1;
  let t2;
  let select;
  let t3;
  let div1;
  let label1;
  let t4;
  let t5;
  let input0;
  let t6;
  let div2;
  let label2;
  let t7;
  let t8;
  let input1;
  let input1_placeholder_value;
  let t9;
  let div3;
  let button;
  let t10;
  let button_disabled_value;
  let t11;
  let div4;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*customFormattingSettings*/
    ctx[0].customFormats && /*customFormattingSettings*/
    ctx[0].customFormats.length > 0 && create_if_block41(ctx)
  );
  let each_value = (
    /*valueTypeOptions*/
    ctx[5]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block21(get_each_context21(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t0 = space();
      form = element("form");
      div0 = element("div");
      label0 = element("label");
      t1 = text("Value Type");
      t2 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      div1 = element("div");
      label1 = element("label");
      t4 = text("Format Name");
      t5 = space();
      input0 = element("input");
      t6 = space();
      div2 = element("div");
      label2 = element("label");
      t7 = text("Format Code");
      t8 = space();
      input1 = element("input");
      t9 = space();
      div3 = element("div");
      button = element("button");
      t10 = text("Add Custom Format");
      t11 = space();
      div4 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t0 = claim_space(nodes);
      form = claim_element(nodes, "FORM", { autocomplete: true, class: true });
      var form_nodes = children(form);
      div0 = claim_element(form_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      label0 = claim_element(div0_nodes, "LABEL", { for: true, class: true });
      var label0_nodes = children(label0);
      t1 = claim_text(label0_nodes, "Value Type");
      label0_nodes.forEach(detach_dev);
      t2 = claim_space(div0_nodes);
      select = claim_element(div0_nodes, "SELECT", { id: true, class: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t3 = claim_space(form_nodes);
      div1 = claim_element(form_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      label1 = claim_element(div1_nodes, "LABEL", { for: true, class: true });
      var label1_nodes = children(label1);
      t4 = claim_text(label1_nodes, "Format Name");
      label1_nodes.forEach(detach_dev);
      t5 = claim_space(div1_nodes);
      input0 = claim_element(div1_nodes, "INPUT", {
        id: true,
        type: true,
        placeholder: true,
        class: true
      });
      div1_nodes.forEach(detach_dev);
      t6 = claim_space(form_nodes);
      div2 = claim_element(form_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      label2 = claim_element(div2_nodes, "LABEL", { for: true, class: true });
      var label2_nodes = children(label2);
      t7 = claim_text(label2_nodes, "Format Code");
      label2_nodes.forEach(detach_dev);
      t8 = claim_space(div2_nodes);
      input1 = claim_element(div2_nodes, "INPUT", {
        id: true,
        type: true,
        placeholder: true,
        class: true
      });
      div2_nodes.forEach(detach_dev);
      t9 = claim_space(form_nodes);
      div3 = claim_element(form_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      button = claim_element(div3_nodes, "BUTTON", { id: true, type: true, class: true });
      var button_nodes = children(button);
      t10 = claim_text(button_nodes, "Add Custom Format");
      button_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      t11 = claim_space(form_nodes);
      div4 = claim_element(form_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div4_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label0, "for", "valueType");
      attr_dev(label0, "class", "svelte-5fwe7l");
      add_location(label0, file55, 104, 2, 2950);
      attr_dev(select, "id", "valueType");
      attr_dev(select, "class", "svelte-5fwe7l");
      if (
        /*valueType*/
        ctx[3] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[9].call(select)
        ));
      add_location(select, file55, 105, 2, 2994);
      attr_dev(div0, "class", "input-item svelte-5fwe7l");
      add_location(div0, file55, 103, 1, 2923);
      attr_dev(label1, "for", "formatTag");
      attr_dev(label1, "class", "svelte-5fwe7l");
      add_location(label1, file55, 114, 2, 3194);
      attr_dev(input0, "id", "formatTag");
      attr_dev(input0, "type", "text");
      attr_dev(input0, "placeholder", "myformat");
      attr_dev(input0, "class", "svelte-5fwe7l");
      add_location(input0, file55, 115, 2, 3239);
      attr_dev(div1, "class", "input-item svelte-5fwe7l");
      add_location(div1, file55, 113, 1, 3167);
      attr_dev(label2, "for", "formatCode");
      attr_dev(label2, "class", "svelte-5fwe7l");
      add_location(label2, file55, 118, 2, 3358);
      attr_dev(input1, "id", "formatCode");
      attr_dev(input1, "type", "text");
      attr_dev(input1, "placeholder", input1_placeholder_value = /*valueType*/
      ctx[3] === "date" ? "mm/dd/yyyy" : "$#,##0.0");
      attr_dev(input1, "class", "svelte-5fwe7l");
      add_location(input1, file55, 119, 2, 3404);
      attr_dev(div2, "class", "input-item svelte-5fwe7l");
      add_location(div2, file55, 117, 1, 3331);
      attr_dev(button, "id", "submitCustomFormatButton");
      attr_dev(button, "type", "submit");
      button.disabled = button_disabled_value = !/*formatTag*/
      (ctx[1] && /*formatCode*/
      ctx[2]);
      attr_dev(button, "class", "svelte-5fwe7l");
      add_location(button, file55, 127, 2, 3587);
      attr_dev(div3, "class", "new-format-buttons svelte-5fwe7l");
      add_location(div3, file55, 126, 1, 3552);
      attr_dev(div4, "class", "error svelte-5fwe7l");
      add_location(div4, file55, 131, 1, 3720);
      attr_dev(form, "autocomplete", "off");
      attr_dev(form, "class", "addFormatForm");
      add_location(form, file55, 102, 0, 2825);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, form, anchor);
      append_hydration_dev(form, div0);
      append_hydration_dev(div0, label0);
      append_hydration_dev(label0, t1);
      append_hydration_dev(div0, t2);
      append_hydration_dev(div0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(
        select,
        /*valueType*/
        ctx[3]
      );
      append_hydration_dev(form, t3);
      append_hydration_dev(form, div1);
      append_hydration_dev(div1, label1);
      append_hydration_dev(label1, t4);
      append_hydration_dev(div1, t5);
      append_hydration_dev(div1, input0);
      set_input_value(
        input0,
        /*formatTag*/
        ctx[1]
      );
      append_hydration_dev(form, t6);
      append_hydration_dev(form, div2);
      append_hydration_dev(div2, label2);
      append_hydration_dev(label2, t7);
      append_hydration_dev(div2, t8);
      append_hydration_dev(div2, input1);
      set_input_value(
        input1,
        /*formatCode*/
        ctx[2]
      );
      append_hydration_dev(form, t9);
      append_hydration_dev(form, div3);
      append_hydration_dev(div3, button);
      append_hydration_dev(button, t10);
      append_hydration_dev(form, t11);
      append_hydration_dev(form, div4);
      div4.innerHTML = /*newFormatValidationErrors*/
      ctx[4];
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[9]
          ),
          listen_dev(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[10]
          ),
          listen_dev(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[11]
          ),
          listen_dev(form, "submit", prevent_default(
            /*submitNewCustomFormat*/
            ctx[7]
          ), false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*customFormattingSettings*/
        ctx2[0].customFormats && /*customFormattingSettings*/
        ctx2[0].customFormats.length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*customFormattingSettings*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block41(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*valueTypeOptions*/
      32) {
        each_value = /*valueTypeOptions*/
        ctx2[5];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context21(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block21(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*valueType, valueTypeOptions*/
      40) {
        select_option(
          select,
          /*valueType*/
          ctx2[3]
        );
      }
      if (dirty & /*formatTag*/
      2 && input0.value !== /*formatTag*/
      ctx2[1]) {
        set_input_value(
          input0,
          /*formatTag*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*valueType, valueTypeOptions*/
      40 && input1_placeholder_value !== (input1_placeholder_value = /*valueType*/
      ctx2[3] === "date" ? "mm/dd/yyyy" : "$#,##0.0")) {
        attr_dev(input1, "placeholder", input1_placeholder_value);
      }
      if (dirty & /*formatCode*/
      4 && input1.value !== /*formatCode*/
      ctx2[2]) {
        set_input_value(
          input1,
          /*formatCode*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*formatTag, formatCode*/
      6 && button_disabled_value !== (button_disabled_value = !/*formatTag*/
      (ctx2[1] && /*formatCode*/
      ctx2[2]))) {
        prop_dev(button, "disabled", button_disabled_value);
      }
      if (!current || dirty & /*newFormatValidationErrors*/
      16)
        div4.innerHTML = /*newFormatValidationErrors*/
        ctx2[4];
      ;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(form);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude60 = true;
function instance63($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CustomFormatsSection", slots, []);
  let { builtInFormats = {} } = $$props;
  let { customFormattingSettings = {} } = $$props;
  const valueTypeOptions = ["number", "date"];
  let formatTag;
  let formatCode;
  let valueType;
  let newFormatValidationErrors = "";
  async function deleteCustomFormat(format) {
    const submitted = await fetch("/api/customFormattingSettings.json", {
      method: "DELETE",
      body: JSON.stringify({ formatTag: format.formatTag })
    });
    let result = await submitted.json();
    if (result) {
      $$invalidate(0, customFormattingSettings = result);
    }
  }
  async function submitNewCustomFormat() {
    let validationErrors = getValidationErrors();
    if (validationErrors && validationErrors.length > 0) {
      $$invalidate(4, newFormatValidationErrors = validationErrors.join("<br/>"));
    } else {
      const submitted = await fetch("/api/customFormattingSettings.json", {
        method: "POST",
        body: JSON.stringify({
          newCustomFormat: { formatTag, formatCode, valueType }
        })
      });
      let result = await submitted.json();
      if (result) {
        $$invalidate(0, customFormattingSettings = result);
        resetNewCustomFormat();
      } else {
        $$invalidate(4, newFormatValidationErrors = `Unable to create new custom format ${formatTag}`);
      }
    }
  }
  function resetNewCustomFormat() {
    $$invalidate(1, formatTag = void 0);
    $$invalidate(2, formatCode = void 0);
    $$invalidate(3, valueType = "number");
    $$invalidate(4, newFormatValidationErrors = "");
  }
  function getValidationErrors() {
    var _a;
    let errors = [];
    if (!/^[a-zA-Z][a-zA-Z0-9]*$/.test(formatTag)) {
      errors.push(`"${formatTag}" is not a valid format name. The format name should always start with a letter and only contain letters and numbers.`);
    }
    let testValue = 10;
    let testResult;
    let ssfError;
    if (valueType === "date") {
      testValue = /* @__PURE__ */ new Date();
    }
    try {
      testResult = import_ssf.default.format(formatCode, testValue);
    } catch (error) {
      ssfError = error;
    }
    if (!testResult) {
      errors.push(`Format "${formatCode}" is invalid for type "${valueType}".`);
    }
    if (ssfError) {
      errors.push(ssfError);
    }
    if (builtInFormats.find((format) => format.formatTag === formatTag) || ((_a = customFormattingSettings.customFormats) == null ? void 0 : _a.find((format) => format.formatTag === formatTag))) {
      errors.push(`The format name "${formatTag}"" is already assigned to an existing format.`);
    }
    return errors;
  }
  const writable_props = ["builtInFormats", "customFormattingSettings"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CustomFormatsSection> was created with unknown prop '${key}'`);
  });
  function select_change_handler() {
    valueType = select_value(this);
    $$invalidate(3, valueType);
    $$invalidate(5, valueTypeOptions);
  }
  function input0_input_handler() {
    formatTag = this.value;
    $$invalidate(1, formatTag);
  }
  function input1_input_handler() {
    formatCode = this.value;
    $$invalidate(2, formatCode);
  }
  $$self.$$set = ($$props2) => {
    if ("builtInFormats" in $$props2)
      $$invalidate(8, builtInFormats = $$props2.builtInFormats);
    if ("customFormattingSettings" in $$props2)
      $$invalidate(0, customFormattingSettings = $$props2.customFormattingSettings);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude60,
    CustomFormatGrid: CustomFormatGrid_default,
    CollapsibleTableSection: CollapsibleTableSection_default,
    ssf: import_ssf.default,
    builtInFormats,
    customFormattingSettings,
    valueTypeOptions,
    formatTag,
    formatCode,
    valueType,
    newFormatValidationErrors,
    deleteCustomFormat,
    submitNewCustomFormat,
    resetNewCustomFormat,
    getValidationErrors
  });
  $$self.$inject_state = ($$props2) => {
    if ("builtInFormats" in $$props2)
      $$invalidate(8, builtInFormats = $$props2.builtInFormats);
    if ("customFormattingSettings" in $$props2)
      $$invalidate(0, customFormattingSettings = $$props2.customFormattingSettings);
    if ("formatTag" in $$props2)
      $$invalidate(1, formatTag = $$props2.formatTag);
    if ("formatCode" in $$props2)
      $$invalidate(2, formatCode = $$props2.formatCode);
    if ("valueType" in $$props2)
      $$invalidate(3, valueType = $$props2.valueType);
    if ("newFormatValidationErrors" in $$props2)
      $$invalidate(4, newFormatValidationErrors = $$props2.newFormatValidationErrors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    customFormattingSettings,
    formatTag,
    formatCode,
    valueType,
    newFormatValidationErrors,
    valueTypeOptions,
    deleteCustomFormat,
    submitNewCustomFormat,
    builtInFormats,
    select_change_handler,
    input0_input_handler,
    input1_input_handler
  ];
}
var CustomFormatsSection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance63,
      create_fragment63,
      safe_not_equal,
      {
        builtInFormats: 8,
        customFormattingSettings: 0
      },
      add_css47
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CustomFormatsSection",
      options,
      id: create_fragment63.name
    });
  }
  get builtInFormats() {
    throw new Error("<CustomFormatsSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set builtInFormats(value) {
    throw new Error("<CustomFormatsSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get customFormattingSettings() {
    throw new Error("<CustomFormatsSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set customFormattingSettings(value) {
    throw new Error("<CustomFormatsSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CustomFormatsSection_default = CustomFormatsSection;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/FormattingSettingsPanel.svelte
var file56 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Formatting/FormattingSettingsPanel.svelte";
function add_css48(target) {
  append_styles(target, "svelte-1caq7yn", "form.svelte-1caq7yn{scroll-margin-top:3.5rem}.container.svelte-1caq7yn{margin-top:2em;border-top:1px solid var(--grey-200);border-left:1px solid var(--grey-200);border-right:1px solid var(--grey-200);border-radius:5px 5px 0 0;font-size:14px;font-family:var(--ui-font-family);min-width:100%}.panel.svelte-1caq7yn{border-top:1px solid var(--grey-200);padding:0em 1em 1em 1em}.panel.svelte-1caq7yn:first-of-type{border-top:none}div.code-container.svelte-1caq7yn{background-color:var(--grey-100);border:1px solid var(--grey-200);overflow:auto;border-radius:4px}footer.svelte-1caq7yn{border:1px solid var(--grey-200);border-radius:0 0 5px 5px;background-color:var(--grey-100);padding:1em;display:flex;font-size:14px;align-items:center;font-family:var(--ui-font-family)}.docs-link.svelte-1caq7yn{color:var(--blue-600);text-decoration:none}.docs-link.svelte-1caq7yn:hover{color:var(--blue-800)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9ybWF0dGluZ1NldHRpbmdzUGFuZWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXlHQyxJQUFBLGVBQUEsQ0FBQSxBQUNDLGlCQUFBLENBQUEsTUFBeUIsQUFDMUIsQ0FBQSxBQUVBLFVBQUEsZUFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLEdBQWUsQ0FDZixVQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBcUMsQ0FDckMsV0FBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNDLENBQ3RDLFlBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUF1QyxDQUN2QyxhQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBMEIsQ0FDMUIsU0FBQSxDQUFBLElBQWUsQ0FDZixXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxDQUNsQyxTQUFBLENBQUEsSUFBZSxBQUNoQixDQUFBLEFBQ0EsTUFBQSxlQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBcUMsQ0FDckMsT0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQXdCLEFBQ3pCLENBQUEsQUFFQSxxQkFBQSxjQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBRUEsR0FBQSxlQUFBLGVBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE1BQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFpQyxDQUNqQyxRQUFBLENBQUEsSUFBYyxDQUNkLGFBQUEsQ0FBQSxHQUFrQixBQUNuQixDQUFBLEFBUUEsTUFBQSxlQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsYUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLEdBQTBCLENBQzFCLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxHQUFZLENBQ1osT0FBQSxDQUFBLElBQWEsQ0FDYixTQUFBLENBQUEsSUFBZSxDQUNmLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxBQUNuQyxDQUFBLEFBRUEsVUFBQSxlQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLGVBQUEsQ0FBQSxJQUFxQixBQUN0QixDQUFBLEFBRUEseUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRm9ybWF0dGluZ1NldHRpbmdzUGFuZWwuc3ZlbHRlIl19 */");
}
function create_default_slot_3(ctx) {
  let builtinformatgrid;
  let current;
  builtinformatgrid = new BuiltInFormatGrid_default({
    props: { formats: BUILT_IN_FORMATS.filter(func) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(builtinformatgrid.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(builtinformatgrid.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(builtinformatgrid, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(builtinformatgrid.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(builtinformatgrid.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(builtinformatgrid, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(60:3) <CollapsibleTableSection headerText={'Dates'} expanded={false}>",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let currencyformatgrid;
  let current;
  currencyformatgrid = new CurrencyFormatGrid_default({
    props: { formats: BUILT_IN_FORMATS.filter(func_1) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(currencyformatgrid.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(currencyformatgrid.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(currencyformatgrid, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(currencyformatgrid.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(currencyformatgrid.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(currencyformatgrid, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(63:3) <CollapsibleTableSection headerText={'Currencies'} expanded={false}>",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let builtinformatgrid;
  let current;
  builtinformatgrid = new BuiltInFormatGrid_default({
    props: { formats: BUILT_IN_FORMATS.filter(func_2) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(builtinformatgrid.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(builtinformatgrid.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(builtinformatgrid, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(builtinformatgrid.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(builtinformatgrid.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(builtinformatgrid, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(68:3) <CollapsibleTableSection headerText={'Numbers'} expanded={false}>",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let builtinformatgrid;
  let current;
  builtinformatgrid = new BuiltInFormatGrid_default({
    props: { formats: BUILT_IN_FORMATS.filter(func_3) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(builtinformatgrid.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(builtinformatgrid.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(builtinformatgrid, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(builtinformatgrid.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(builtinformatgrid.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(builtinformatgrid, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(73:3) <CollapsibleTableSection headerText={'Percentages'} expanded={false}>",
    ctx
  });
  return block;
}
function create_fragment64(ctx) {
  let form;
  let div6;
  let div3;
  let h20;
  let t0;
  let t1;
  let p0;
  let t2;
  let code0;
  let t3;
  let t4;
  let code1;
  let t5;
  let t6;
  let code2;
  let t7;
  let t8;
  let t9;
  let p1;
  let t10;
  let code3;
  let t11;
  let t12;
  let t13;
  let div0;
  let prism0;
  let t14;
  let br0;
  let t15;
  let p2;
  let t16;
  let code4;
  let t17;
  let t18;
  let code5;
  let t19;
  let t20;
  let t21;
  let div1;
  let prism1;
  let t22;
  let br1;
  let t23;
  let p3;
  let t24;
  let t25;
  let div2;
  let prism2;
  let t26;
  let p4;
  let t27;
  let div4;
  let h21;
  let t28;
  let t29;
  let p5;
  let t30;
  let t31;
  let collapsibletablesection0;
  let t32;
  let collapsibletablesection1;
  let t33;
  let collapsibletablesection2;
  let t34;
  let collapsibletablesection3;
  let t35;
  let div5;
  let h22;
  let t36;
  let t37;
  let p6;
  let t38;
  let a0;
  let t39;
  let t40;
  let customformatssection;
  let t41;
  let footer;
  let span;
  let t42;
  let a1;
  let t43;
  let current;
  prism0 = new Prismjs_default({
    props: {
      language: "html",
      code: (
        /*valueExample*/
        ctx[3]
      )
    },
    $$inline: true
  });
  prism1 = new Prismjs_default({
    props: {
      language: "jsx",
      code: (
        /*componentExample*/
        ctx[2]
      )
    },
    $$inline: true
  });
  prism2 = new Prismjs_default({
    props: {
      language: "sql",
      code: (
        /*exampleQuery*/
        ctx[1]
      )
    },
    $$inline: true
  });
  collapsibletablesection0 = new CollapsibleTableSection_default({
    props: {
      headerText: "Dates",
      expanded: false,
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  collapsibletablesection1 = new CollapsibleTableSection_default({
    props: {
      headerText: "Currencies",
      expanded: false,
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  collapsibletablesection2 = new CollapsibleTableSection_default({
    props: {
      headerText: "Numbers",
      expanded: false,
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  collapsibletablesection3 = new CollapsibleTableSection_default({
    props: {
      headerText: "Percentages",
      expanded: false,
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  customformatssection = new CustomFormatsSection_default({
    props: {
      builtInFormats: BUILT_IN_FORMATS,
      customFormattingSettings: (
        /*customFormattingSettings*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      form = element("form");
      div6 = element("div");
      div3 = element("div");
      h20 = element("h2");
      t0 = text("Value Formatting");
      t1 = space();
      p0 = element("p");
      t2 = text("Evidence supports built-in formats (like ");
      code0 = element("code");
      t3 = text("usd");
      t4 = text(" and ");
      code1 = element("code");
      t5 = text("pct");
      t6 = text(") and\n				Excel-style formats (like ");
      code2 = element("code");
      t7 = text("$#,##0.0");
      t8 = text("). The easiest way to apply these formats is\n				using component props. For example:");
      t9 = space();
      p1 = element("p");
      t10 = text("In the Value component, you can use the ");
      code3 = element("code");
      t11 = text("fmt");
      t12 = text(" prop");
      t13 = space();
      div0 = element("div");
      create_component(prism0.$$.fragment);
      t14 = space();
      br0 = element("br");
      t15 = space();
      p2 = element("p");
      t16 = text("In charts, you can use the ");
      code4 = element("code");
      t17 = text("xFmt");
      t18 = text(" and ");
      code5 = element("code");
      t19 = text("yFmt");
      t20 = text(" props");
      t21 = space();
      div1 = element("div");
      create_component(prism1.$$.fragment);
      t22 = space();
      br1 = element("br");
      t23 = space();
      p3 = element("p");
      t24 = text("You can also set formats within your SQL queries using SQL format tags. Use these by\n				aliasing your column names and appending a format. For example:");
      t25 = space();
      div2 = element("div");
      create_component(prism2.$$.fragment);
      t26 = space();
      p4 = element("p");
      t27 = space();
      div4 = element("div");
      h21 = element("h2");
      t28 = text("Built-in Formats");
      t29 = space();
      p5 = element("p");
      t30 = text("All built-in formats are listed below for reference.");
      t31 = space();
      create_component(collapsibletablesection0.$$.fragment);
      t32 = space();
      create_component(collapsibletablesection1.$$.fragment);
      t33 = space();
      create_component(collapsibletablesection2.$$.fragment);
      t34 = space();
      create_component(collapsibletablesection3.$$.fragment);
      t35 = space();
      div5 = element("div");
      h22 = element("h2");
      t36 = text("Custom Formats");
      t37 = space();
      p6 = element("p");
      t38 = text("Add new formats to your project. Custom formats use ");
      a0 = element("a");
      t39 = text("excel-style format codes.");
      t40 = space();
      create_component(customformatssection.$$.fragment);
      t41 = space();
      footer = element("footer");
      span = element("span");
      t42 = text("Learn more about ");
      a1 = element("a");
      t43 = text("formatting in Evidence ");
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { id: true, class: true });
      var form_nodes = children(form);
      div6 = claim_element(form_nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      div3 = claim_element(div6_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      h20 = claim_element(div3_nodes, "H2", {});
      var h20_nodes = children(h20);
      t0 = claim_text(h20_nodes, "Value Formatting");
      h20_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      p0 = claim_element(div3_nodes, "P", {});
      var p0_nodes = children(p0);
      t2 = claim_text(p0_nodes, "Evidence supports built-in formats (like ");
      code0 = claim_element(p0_nodes, "CODE", {});
      var code0_nodes = children(code0);
      t3 = claim_text(code0_nodes, "usd");
      code0_nodes.forEach(detach_dev);
      t4 = claim_text(p0_nodes, " and ");
      code1 = claim_element(p0_nodes, "CODE", {});
      var code1_nodes = children(code1);
      t5 = claim_text(code1_nodes, "pct");
      code1_nodes.forEach(detach_dev);
      t6 = claim_text(p0_nodes, ") and\n				Excel-style formats (like ");
      code2 = claim_element(p0_nodes, "CODE", {});
      var code2_nodes = children(code2);
      t7 = claim_text(code2_nodes, "$#,##0.0");
      code2_nodes.forEach(detach_dev);
      t8 = claim_text(p0_nodes, "). The easiest way to apply these formats is\n				using component props. For example:");
      p0_nodes.forEach(detach_dev);
      t9 = claim_space(div3_nodes);
      p1 = claim_element(div3_nodes, "P", {});
      var p1_nodes = children(p1);
      t10 = claim_text(p1_nodes, "In the Value component, you can use the ");
      code3 = claim_element(p1_nodes, "CODE", {});
      var code3_nodes = children(code3);
      t11 = claim_text(code3_nodes, "fmt");
      code3_nodes.forEach(detach_dev);
      t12 = claim_text(p1_nodes, " prop");
      p1_nodes.forEach(detach_dev);
      t13 = claim_space(div3_nodes);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(prism0.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t14 = claim_space(div3_nodes);
      br0 = claim_element(div3_nodes, "BR", {});
      t15 = claim_space(div3_nodes);
      p2 = claim_element(div3_nodes, "P", {});
      var p2_nodes = children(p2);
      t16 = claim_text(p2_nodes, "In charts, you can use the ");
      code4 = claim_element(p2_nodes, "CODE", {});
      var code4_nodes = children(code4);
      t17 = claim_text(code4_nodes, "xFmt");
      code4_nodes.forEach(detach_dev);
      t18 = claim_text(p2_nodes, " and ");
      code5 = claim_element(p2_nodes, "CODE", {});
      var code5_nodes = children(code5);
      t19 = claim_text(code5_nodes, "yFmt");
      code5_nodes.forEach(detach_dev);
      t20 = claim_text(p2_nodes, " props");
      p2_nodes.forEach(detach_dev);
      t21 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(prism1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      t22 = claim_space(div3_nodes);
      br1 = claim_element(div3_nodes, "BR", {});
      t23 = claim_space(div3_nodes);
      p3 = claim_element(div3_nodes, "P", {});
      var p3_nodes = children(p3);
      t24 = claim_text(p3_nodes, "You can also set formats within your SQL queries using SQL format tags. Use these by\n				aliasing your column names and appending a format. For example:");
      p3_nodes.forEach(detach_dev);
      t25 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      claim_component(prism2.$$.fragment, div2_nodes);
      div2_nodes.forEach(detach_dev);
      t26 = claim_space(div3_nodes);
      p4 = claim_element(div3_nodes, "P", {});
      children(p4).forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      t27 = claim_space(div6_nodes);
      div4 = claim_element(div6_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      h21 = claim_element(div4_nodes, "H2", {});
      var h21_nodes = children(h21);
      t28 = claim_text(h21_nodes, "Built-in Formats");
      h21_nodes.forEach(detach_dev);
      t29 = claim_space(div4_nodes);
      p5 = claim_element(div4_nodes, "P", {});
      var p5_nodes = children(p5);
      t30 = claim_text(p5_nodes, "All built-in formats are listed below for reference.");
      p5_nodes.forEach(detach_dev);
      t31 = claim_space(div4_nodes);
      claim_component(collapsibletablesection0.$$.fragment, div4_nodes);
      t32 = claim_space(div4_nodes);
      claim_component(collapsibletablesection1.$$.fragment, div4_nodes);
      t33 = claim_space(div4_nodes);
      claim_component(collapsibletablesection2.$$.fragment, div4_nodes);
      t34 = claim_space(div4_nodes);
      claim_component(collapsibletablesection3.$$.fragment, div4_nodes);
      div4_nodes.forEach(detach_dev);
      t35 = claim_space(div6_nodes);
      div5 = claim_element(div6_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      h22 = claim_element(div5_nodes, "H2", {});
      var h22_nodes = children(h22);
      t36 = claim_text(h22_nodes, "Custom Formats");
      h22_nodes.forEach(detach_dev);
      t37 = claim_space(div5_nodes);
      p6 = claim_element(div5_nodes, "P", {});
      var p6_nodes = children(p6);
      t38 = claim_text(p6_nodes, "Add new formats to your project. Custom formats use ");
      a0 = claim_element(p6_nodes, "A", { class: true, target: true, href: true });
      var a0_nodes = children(a0);
      t39 = claim_text(a0_nodes, "excel-style format codes.");
      a0_nodes.forEach(detach_dev);
      p6_nodes.forEach(detach_dev);
      t40 = claim_space(div5_nodes);
      claim_component(customformatssection.$$.fragment, div5_nodes);
      div5_nodes.forEach(detach_dev);
      div6_nodes.forEach(detach_dev);
      t41 = claim_space(form_nodes);
      footer = claim_element(form_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      span = claim_element(footer_nodes, "SPAN", {});
      var span_nodes = children(span);
      t42 = claim_text(span_nodes, "Learn more about ");
      a1 = claim_element(span_nodes, "A", { class: true, target: true, href: true });
      var a1_nodes = children(a1);
      t43 = claim_text(a1_nodes, "formatting in Evidence ");
      a1_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h20, file56, 31, 3, 929);
      add_location(code0, file56, 33, 45, 1007);
      add_location(code1, file56, 33, 66, 1028);
      add_location(code2, file56, 34, 30, 1080);
      add_location(p0, file56, 32, 3, 958);
      add_location(code3, file56, 37, 46, 1240);
      add_location(p1, file56, 37, 3, 1197);
      attr_dev(div0, "class", "code-container p-2 svelte-1caq7yn");
      add_location(div0, file56, 38, 3, 1269);
      add_location(br0, file56, 41, 3, 1365);
      add_location(code4, file56, 42, 33, 1405);
      add_location(code5, file56, 42, 55, 1427);
      add_location(p2, file56, 42, 3, 1375);
      attr_dev(div1, "class", "code-container p-2 svelte-1caq7yn");
      add_location(div1, file56, 43, 3, 1458);
      add_location(br1, file56, 46, 3, 1557);
      add_location(p3, file56, 47, 3, 1567);
      attr_dev(div2, "class", "code-container p-2 svelte-1caq7yn");
      add_location(div2, file56, 51, 3, 1739);
      add_location(p4, file56, 54, 3, 1834);
      attr_dev(div3, "class", "panel svelte-1caq7yn");
      add_location(div3, file56, 30, 2, 906);
      add_location(h21, file56, 57, 3, 1874);
      add_location(p5, file56, 58, 3, 1903);
      attr_dev(div4, "class", "panel svelte-1caq7yn");
      add_location(div4, file56, 56, 2, 1851);
      add_location(h22, file56, 79, 3, 2819);
      attr_dev(a0, "class", "docs-link svelte-1caq7yn");
      attr_dev(a0, "target", "none");
      attr_dev(a0, "href", "https://support.microsoft.com/en-us/office/number-format-codes-5026bbd6-04bc-48cd-bf33-80f18b4eae68");
      add_location(a0, file56, 81, 56, 2906);
      add_location(p6, file56, 80, 3, 2846);
      attr_dev(div5, "class", "panel svelte-1caq7yn");
      add_location(div5, file56, 78, 2, 2796);
      attr_dev(div6, "class", "container svelte-1caq7yn");
      add_location(div6, file56, 29, 1, 880);
      attr_dev(a1, "class", "docs-link svelte-1caq7yn");
      attr_dev(a1, "target", "none");
      attr_dev(a1, "href", "https://docs.evidence.dev/core-concepts/formatting/");
      add_location(a1, file56, 93, 21, 3257);
      add_location(span, file56, 92, 2, 3230);
      attr_dev(footer, "class", "svelte-1caq7yn");
      add_location(footer, file56, 91, 1, 3219);
      attr_dev(form, "id", "formatting");
      attr_dev(form, "class", "svelte-1caq7yn");
      add_location(form, file56, 28, 0, 856);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      append_hydration_dev(form, div6);
      append_hydration_dev(div6, div3);
      append_hydration_dev(div3, h20);
      append_hydration_dev(h20, t0);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, p0);
      append_hydration_dev(p0, t2);
      append_hydration_dev(p0, code0);
      append_hydration_dev(code0, t3);
      append_hydration_dev(p0, t4);
      append_hydration_dev(p0, code1);
      append_hydration_dev(code1, t5);
      append_hydration_dev(p0, t6);
      append_hydration_dev(p0, code2);
      append_hydration_dev(code2, t7);
      append_hydration_dev(p0, t8);
      append_hydration_dev(div3, t9);
      append_hydration_dev(div3, p1);
      append_hydration_dev(p1, t10);
      append_hydration_dev(p1, code3);
      append_hydration_dev(code3, t11);
      append_hydration_dev(p1, t12);
      append_hydration_dev(div3, t13);
      append_hydration_dev(div3, div0);
      mount_component(prism0, div0, null);
      append_hydration_dev(div3, t14);
      append_hydration_dev(div3, br0);
      append_hydration_dev(div3, t15);
      append_hydration_dev(div3, p2);
      append_hydration_dev(p2, t16);
      append_hydration_dev(p2, code4);
      append_hydration_dev(code4, t17);
      append_hydration_dev(p2, t18);
      append_hydration_dev(p2, code5);
      append_hydration_dev(code5, t19);
      append_hydration_dev(p2, t20);
      append_hydration_dev(div3, t21);
      append_hydration_dev(div3, div1);
      mount_component(prism1, div1, null);
      append_hydration_dev(div3, t22);
      append_hydration_dev(div3, br1);
      append_hydration_dev(div3, t23);
      append_hydration_dev(div3, p3);
      append_hydration_dev(p3, t24);
      append_hydration_dev(div3, t25);
      append_hydration_dev(div3, div2);
      mount_component(prism2, div2, null);
      append_hydration_dev(div3, t26);
      append_hydration_dev(div3, p4);
      append_hydration_dev(div6, t27);
      append_hydration_dev(div6, div4);
      append_hydration_dev(div4, h21);
      append_hydration_dev(h21, t28);
      append_hydration_dev(div4, t29);
      append_hydration_dev(div4, p5);
      append_hydration_dev(p5, t30);
      append_hydration_dev(div4, t31);
      mount_component(collapsibletablesection0, div4, null);
      append_hydration_dev(div4, t32);
      mount_component(collapsibletablesection1, div4, null);
      append_hydration_dev(div4, t33);
      mount_component(collapsibletablesection2, div4, null);
      append_hydration_dev(div4, t34);
      mount_component(collapsibletablesection3, div4, null);
      append_hydration_dev(div6, t35);
      append_hydration_dev(div6, div5);
      append_hydration_dev(div5, h22);
      append_hydration_dev(h22, t36);
      append_hydration_dev(div5, t37);
      append_hydration_dev(div5, p6);
      append_hydration_dev(p6, t38);
      append_hydration_dev(p6, a0);
      append_hydration_dev(a0, t39);
      append_hydration_dev(div5, t40);
      mount_component(customformatssection, div5, null);
      append_hydration_dev(form, t41);
      append_hydration_dev(form, footer);
      append_hydration_dev(footer, span);
      append_hydration_dev(span, t42);
      append_hydration_dev(span, a1);
      append_hydration_dev(a1, t43);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const collapsibletablesection0_changes = {};
      if (dirty & /*$$scope*/
      16) {
        collapsibletablesection0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapsibletablesection0.$set(collapsibletablesection0_changes);
      const collapsibletablesection1_changes = {};
      if (dirty & /*$$scope*/
      16) {
        collapsibletablesection1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapsibletablesection1.$set(collapsibletablesection1_changes);
      const collapsibletablesection2_changes = {};
      if (dirty & /*$$scope*/
      16) {
        collapsibletablesection2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapsibletablesection2.$set(collapsibletablesection2_changes);
      const collapsibletablesection3_changes = {};
      if (dirty & /*$$scope*/
      16) {
        collapsibletablesection3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapsibletablesection3.$set(collapsibletablesection3_changes);
      const customformatssection_changes = {};
      if (dirty & /*customFormattingSettings*/
      1)
        customformatssection_changes.customFormattingSettings = /*customFormattingSettings*/
        ctx2[0];
      customformatssection.$set(customformatssection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prism0.$$.fragment, local);
      transition_in(prism1.$$.fragment, local);
      transition_in(prism2.$$.fragment, local);
      transition_in(collapsibletablesection0.$$.fragment, local);
      transition_in(collapsibletablesection1.$$.fragment, local);
      transition_in(collapsibletablesection2.$$.fragment, local);
      transition_in(collapsibletablesection3.$$.fragment, local);
      transition_in(customformatssection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prism0.$$.fragment, local);
      transition_out(prism1.$$.fragment, local);
      transition_out(prism2.$$.fragment, local);
      transition_out(collapsibletablesection0.$$.fragment, local);
      transition_out(collapsibletablesection1.$$.fragment, local);
      transition_out(collapsibletablesection2.$$.fragment, local);
      transition_out(collapsibletablesection3.$$.fragment, local);
      transition_out(customformatssection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      destroy_component(prism0);
      destroy_component(prism1);
      destroy_component(prism2);
      destroy_component(collapsibletablesection0);
      destroy_component(collapsibletablesection1);
      destroy_component(collapsibletablesection2);
      destroy_component(collapsibletablesection3);
      destroy_component(customformatssection);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude61 = true;
var func = (d) => d.formatCategory === "date";
var func_1 = (d) => d.formatCategory === "currency";
var func_2 = (d) => d.formatCategory === "number";
var func_3 = (d) => d.formatCategory === "percent";
function instance64($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormattingSettingsPanel", slots, []);
  let { customFormattingSettings } = $$props;
  let exampleQuery = `select 
  growth as growth_pct, -- formatted as a percentage
  sales as sales_usd    -- formatted as US dollars
from table`;
  let componentExample = `<LineChart
	data={sales_data}
	x=date
	y=sales
	yFmt=euro
/>`;
  let valueExample = `<Value data={sales_data} column=sales fmt='$#,##0' />`;
  $$self.$$.on_mount.push(function() {
    if (customFormattingSettings === void 0 && !("customFormattingSettings" in $$props || $$self.$$.bound[$$self.$$.props["customFormattingSettings"]])) {
      console.warn("<FormattingSettingsPanel> was created without expected prop 'customFormattingSettings'");
    }
  });
  const writable_props = ["customFormattingSettings"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FormattingSettingsPanel> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("customFormattingSettings" in $$props2)
      $$invalidate(0, customFormattingSettings = $$props2.customFormattingSettings);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude61,
    customFormattingSettings,
    BUILT_IN_FORMATS,
    BuiltInFormatGrid: BuiltInFormatGrid_default,
    CustomFormatsSection: CustomFormatsSection_default,
    CollapsibleTableSection: CollapsibleTableSection_default,
    CurrencyFormatGrid: CurrencyFormatGrid_default,
    Prism: Prismjs_default,
    exampleQuery,
    componentExample,
    valueExample
  });
  $$self.$inject_state = ($$props2) => {
    if ("customFormattingSettings" in $$props2)
      $$invalidate(0, customFormattingSettings = $$props2.customFormattingSettings);
    if ("exampleQuery" in $$props2)
      $$invalidate(1, exampleQuery = $$props2.exampleQuery);
    if ("componentExample" in $$props2)
      $$invalidate(2, componentExample = $$props2.componentExample);
    if ("valueExample" in $$props2)
      $$invalidate(3, valueExample = $$props2.valueExample);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [customFormattingSettings, exampleQuery, componentExample, valueExample];
}
var FormattingSettingsPanel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, { customFormattingSettings: 0 }, add_css48);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormattingSettingsPanel",
      options,
      id: create_fragment64.name
    });
  }
  get customFormattingSettings() {
    throw new Error("<FormattingSettingsPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set customFormattingSettings(value) {
    throw new Error("<FormattingSettingsPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormattingSettingsPanel_default = FormattingSettingsPanel;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Tabs/Tabs.svelte
var file57 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/Tabs/Tabs.svelte";
function get_each_context22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_each_block22(ctx) {
  let button;
  let t0_value = (
    /*tab*/
    ctx[10].label + ""
  );
  let t0;
  let t1;
  let button_class_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[9](
        /*tab*/
        ctx[10]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, t0_value);
      t1 = claim_space(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "mt-2 p-2 rounded-t flex-1 text-sm font-sans whitespace-nowrap transition duration-200 ease-in active:bg-gray-100 " + /*$tabItems*/
      (ctx[0].active === /*tab*/
      ctx[10].id ? (
        /*classes*/
        ctx[1].active
      ) : (
        /*classes*/
        ctx[1].notActive
      )));
      set_style(
        button,
        "--bgColor",
        /*bgColor*/
        ctx[2]
      );
      set_style(
        button,
        "--borderColor",
        /*borderColor*/
        ctx[3]
      );
      add_location(button, file57, 86, 3, 2465);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$tabItems*/
      1 && t0_value !== (t0_value = /*tab*/
      ctx[10].label + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*$tabItems*/
      1 && button_class_value !== (button_class_value = "mt-2 p-2 rounded-t flex-1 text-sm font-sans whitespace-nowrap transition duration-200 ease-in active:bg-gray-100 " + /*$tabItems*/
      (ctx[0].active === /*tab*/
      ctx[10].id ? (
        /*classes*/
        ctx[1].active
      ) : (
        /*classes*/
        ctx[1].notActive
      )))) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block22.name,
    type: "each",
    source: "(86:2) {#each $tabItems.tabs as tab}",
    ctx
  });
  return block;
}
function create_fragment65(ctx) {
  let section;
  let nav;
  let t;
  let div;
  let current;
  let each_value = (
    /*$tabItems*/
    ctx[0].tabs
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block22(get_each_context22(ctx, each_value, i));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      section = element("section");
      nav = element("nav");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", {});
      var section_nodes = children(section);
      nav = claim_element(section_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nav_nodes);
      }
      nav_nodes.forEach(detach_dev);
      t = claim_space(section_nodes);
      div = claim_element(section_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(nav, "class", "my-6 flex flex-wrap gap-x-4 gap-y-1");
      add_location(nav, file57, 84, 1, 2380);
      attr_dev(div, "class", "text-base");
      add_location(div, file57, 99, 1, 2850);
      add_location(section, file57, 83, 0, 2369);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      append_hydration_dev(section, nav);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(nav, null);
      }
      append_hydration_dev(section, t);
      append_hydration_dev(section, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$tabItems, classes, bgColor, borderColor*/
      15) {
        each_value = /*$tabItems*/
        ctx2[0].tabs;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context22(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block22(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(nav, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(section);
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude62 = true;
function isHex(inputColor) {
  const hexRegex = /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/i;
  return hexRegex.test(inputColor);
}
function isRGB(inputColor) {
  const rgbRegex = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i;
  return rgbRegex.test(inputColor);
}
function isHSL(inputColor) {
  const hslRegex = /^hsl\(\s*(\d{1,3})\s*,\s*(\d{1,3}%)\s*,\s*(\d{1,3}%)\s*\)$/i;
  return hslRegex.test(inputColor);
}
function isValidColorString(inputColor) {
  return isHex(inputColor) || isRGB(inputColor) || isHSL(inputColor);
}
function addOpacityToColor(colorString) {
  if (isHex(colorString)) {
    return colorString + "1a";
  } else if (isRGB(colorString) || isHSL(colorString)) {
    return colorString.replace(/(\)|\s|$)/, ", 0.1$1");
  }
}
function instance65($$self, $$props, $$invalidate) {
  let $tabItems;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tabs", slots, ["default"]);
  const classes = {
    notActive: "text-gray-600 hover:text-gray-800 hover:bg-gray-200",
    active: "text-black border-b-2 border-[--borderColor] bg-[--bgColor]"
  };
  let { id } = $$props;
  let { color = "hsla(207, 65%, 39%, 1)" } = $$props;
  color = color.replace(/\s+/g, "");
  const bgColor = isValidColorString(color) ? addOpacityToColor(color) : "hsla(207, 65%, 39%, 0.1)";
  const borderColor = isValidColorString(color) ? color : "hsla(207, 65%, 39%, 1)";
  const tabItems = writable({ tabs: [], active: null });
  validate_store(tabItems, "tabItems");
  component_subscribe($$self, tabItems, (value) => $$invalidate(0, $tabItems = value));
  onMount(() => {
    const url = new URL(window.location.href);
    const urlActive = url.searchParams.get(id);
    if (urlActive) {
      set_store_value(tabItems, $tabItems.active = urlActive, $tabItems);
    }
  });
  setContext("TAB_REGISTRATION", tabItems);
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Tabs> was created without expected prop 'id'");
    }
  });
  const writable_props = ["id", "color"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tabs> was created with unknown prop '${key}'`);
  });
  const click_handler = (tab) => set_store_value(tabItems, $tabItems.active = tab.id, $tabItems);
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(6, id = $$props2.id);
    if ("color" in $$props2)
      $$invalidate(5, color = $$props2.color);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude62,
    onMount,
    setContext,
    writable,
    classes,
    id,
    color,
    bgColor,
    borderColor,
    isHex,
    isRGB,
    isHSL,
    isValidColorString,
    addOpacityToColor,
    tabItems,
    $tabItems
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(6, id = $$props2.id);
    if ("color" in $$props2)
      $$invalidate(5, color = $$props2.color);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$tabItems*/
    1) {
      $:
        if (!$tabItems.active && $tabItems.tabs.length)
          set_store_value(tabItems, $tabItems.active = $tabItems.tabs[0].id, $tabItems);
    }
    if ($$self.$$.dirty & /*$tabItems, id*/
    65) {
      $:
        if ($tabItems.active && id) {
          const url = new URL(window.location.href);
          url.searchParams.set(id, $tabItems.active);
          history.replaceState({}, "", url);
        }
    }
  };
  return [
    $tabItems,
    classes,
    bgColor,
    borderColor,
    tabItems,
    color,
    id,
    $$scope,
    slots,
    click_handler
  ];
}
var Tabs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, { id: 6, color: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tabs",
      options,
      id: create_fragment65.name
    });
  }
  get id() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tabs_default = Tabs;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/Tabs/Tab.svelte
function create_if_block42(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block42.name,
    type: "if",
    source: "(48:0) {#if selected}",
    ctx
  });
  return block;
}
function create_fragment66(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*selected*/
    ctx[0] && create_if_block42(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*selected*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*selected*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block42(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude63 = true;
function instance66($$self, $$props, $$invalidate) {
  let $tabs;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["default"]);
  let { label } = $$props;
  let { id = label } = $$props;
  let { selected } = $$props;
  const tabs = getContext("TAB_REGISTRATION");
  validate_store(tabs, "tabs");
  component_subscribe($$self, tabs, (value) => $$invalidate(6, $tabs = value));
  onMount(() => {
    set_store_value(tabs, $tabs.tabs = [...$tabs.tabs, { label, id }], $tabs);
    if (selected)
      set_store_value(tabs, $tabs.active = id, $tabs);
    return tabs.subscribe(({ active }) => {
      $$invalidate(0, selected = active === id);
    });
  });
  onDestroy(() => {
    var _a;
    set_store_value(tabs, $tabs.tabs = $tabs.tabs.filter((t) => t.id !== id), $tabs);
    if ($tabs.active === id) {
      set_store_value(tabs, $tabs.active = (_a = $tabs.tabs[0]) == null ? void 0 : _a.id, $tabs);
    }
  });
  $$self.$$.on_mount.push(function() {
    if (label === void 0 && !("label" in $$props || $$self.$$.bound[$$self.$$.props["label"]])) {
      console.warn("<Tab> was created without expected prop 'label'");
    }
    if (selected === void 0 && !("selected" in $$props || $$self.$$.bound[$$self.$$.props["selected"]])) {
      console.warn("<Tab> was created without expected prop 'selected'");
    }
  });
  const writable_props = ["label", "id", "selected"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tab> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("id" in $$props2)
      $$invalidate(3, id = $$props2.id);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude63,
    getContext,
    onDestroy,
    onMount,
    label,
    id,
    selected,
    tabs,
    $tabs
  });
  $$self.$inject_state = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("id" in $$props2)
      $$invalidate(3, id = $$props2.id);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [selected, tabs, label, id, $$scope, slots];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, { label: 2, id: 3, selected: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment66.name
    });
  }
  get label() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tab_default = Tab;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/TelemetryOptOut/TelemetrySettingsPanel.svelte
var file58 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/TelemetryOptOut/TelemetrySettingsPanel.svelte";
function add_css49(target) {
  append_styles(target, "svelte-y9mxr5", "form.svelte-y9mxr5.svelte-y9mxr5{scroll-margin-top:3.5rem}.container.svelte-y9mxr5.svelte-y9mxr5{margin-top:2em;border-top:1px solid var(--grey-200);border-left:1px solid var(--grey-200);border-right:1px solid var(--grey-200);border-radius:5px 5px 0 0;font-size:14px;font-family:var(--ui-font-family);min-width:100%}.panel.svelte-y9mxr5.svelte-y9mxr5{border-top:1px solid var(--grey-200);padding:0em 1em 1em 1em}.panel.svelte-y9mxr5.svelte-y9mxr5:first-of-type{border-top:none}footer.svelte-y9mxr5.svelte-y9mxr5{border:1px solid var(--grey-200);border-radius:0 0 5px 5px;background-color:var(--grey-100);padding:1em;display:flex;font-size:14px;align-items:center;font-family:var(--ui-font-family)}.docs-link.svelte-y9mxr5.svelte-y9mxr5{color:var(--blue-600);text-decoration:none}.docs-link.svelte-y9mxr5.svelte-y9mxr5:hover{color:var(--blue-800)}.switch.svelte-y9mxr5.svelte-y9mxr5{position:relative;display:inline-block;width:2.8rem;height:1.75rem;margin-left:auto;margin-right:2px;-webkit-user-select:none;-moz-user-select:none;user-select:none}.switch.svelte-y9mxr5 input.svelte-y9mxr5{opacity:0;width:0;height:0}.slider.svelte-y9mxr5.svelte-y9mxr5{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;transition:0.4s;border-radius:25px}.slider.svelte-y9mxr5.svelte-y9mxr5:before{position:absolute;content:'';height:1.25rem;width:1.25rem;left:4px;bottom:4px;background-color:white;transition:0.4s;border-radius:50%;box-shadow:0px 1px 2px var(--grey-500)}input.svelte-y9mxr5:checked+.slider.svelte-y9mxr5{background-color:var(--green-500)}input.svelte-y9mxr5:checked+.slider.svelte-y9mxr5:before{transform:translateX(1.1rem)}label.svelte-y9mxr5.svelte-y9mxr5{width:30%;text-transform:uppercase;font-weight:normal;font-size:14px;color:var(--grey-800);white-space:nowrap}div.input-item.svelte-y9mxr5.svelte-y9mxr5{font-family:var(--ui-font-family);color:var(--grey-999);font-size:16px;margin-top:1.25em;display:flex;flex-direction:row;flex-wrap:wrap;align-items:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGVsZW1ldHJ5U2V0dGluZ3NQYW5lbC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBc0VDLElBQUEsNEJBQUEsQ0FBQSxBQUNDLGlCQUFBLENBQUEsTUFBeUIsQUFDMUIsQ0FBQSxBQUNBLFVBQUEsNEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxHQUFlLENBQ2YsVUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXFDLENBQ3JDLFdBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQyxDQUN0QyxZQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBdUMsQ0FDdkMsYUFBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBQTBCLENBQzFCLFNBQUEsQ0FBQSxJQUFlLENBQ2YsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsU0FBQSxDQUFBLElBQWUsQUFDaEIsQ0FBQSxBQUVBLE1BQUEsNEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFxQyxDQUNyQyxPQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBd0IsQUFDekIsQ0FBQSxBQUVBLGtDQUFBLGNBQUEsQUFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQWdCLEFBQ2pCLENBQUEsQUFFQSxNQUFBLDRCQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsYUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLEdBQTBCLENBQzFCLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxHQUFZLENBQ1osT0FBQSxDQUFBLElBQWEsQ0FDYixTQUFBLENBQUEsSUFBZSxDQUNmLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxBQUNuQyxDQUFBLEFBRUEsVUFBQSw0QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixlQUFBLENBQUEsSUFBcUIsQUFDdEIsQ0FBQSxBQUVBLHNDQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBLEFBRUEsT0FBQSw0QkFBQSxDQUFBLEFBQ0MsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLE9BQUEsQ0FBQSxZQUFxQixDQUNyQixLQUFBLENBQUEsTUFBYSxDQUNiLE1BQUEsQ0FBQSxPQUFlLENBQ2YsV0FBQSxDQUFBLElBQWlCLENBQ2pCLFlBQUEsQ0FBQSxHQUFpQixDQUNqQixtQkFBQSxDQUFBLElBQXlCLENBQ3RCLGdCQUFBLENBQUEsSUFBc0IsQ0FDakIsV0FBQSxDQUFBLElBQWlCLEFBQzFCLENBQUEsQUFFQSxxQkFBQSxDQUFBLEtBQUEsY0FBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLENBQVUsQ0FDVixLQUFBLENBQUEsQ0FBUSxDQUNSLE1BQUEsQ0FBQSxDQUFTLEFBQ1YsQ0FBQSxBQUVBLE9BQUEsNEJBQUEsQ0FBQSxBQUNDLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixNQUFBLENBQUEsT0FBZSxDQUNmLEdBQUEsQ0FBQSxDQUFNLENBQ04sSUFBQSxDQUFBLENBQU8sQ0FDUCxLQUFBLENBQUEsQ0FBUSxDQUNSLE1BQUEsQ0FBQSxDQUFTLENBQ1QsZ0JBQUEsQ0FBQSxJQUFzQixDQUN0QixVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsYUFBQSxDQUFBLElBQW1CLEFBQ3BCLENBQUEsQUFFQSxtQ0FBQSxPQUFBLEFBQUEsQ0FBQSxBQUNDLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixPQUFBLENBQUEsRUFBVyxDQUNYLE1BQUEsQ0FBQSxPQUFlLENBQ2YsS0FBQSxDQUFBLE9BQWMsQ0FDZCxJQUFBLENBQUEsR0FBUyxDQUNULE1BQUEsQ0FBQSxHQUFXLENBQ1gsZ0JBQUEsQ0FBQSxLQUF1QixDQUN2QixVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLFVBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBdUMsQUFDeEMsQ0FBQSxBQUVBLG1CQUFBLFFBQUEsQ0FBQSxPQUFBLGNBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxXQUFBLENBQWtDLEFBQ25DLENBQUEsQUFFQSxtQkFBQSxRQUFBLENBQUEscUJBQUEsT0FBQSxBQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsV0FBQSxNQUFBLENBQTZCLEFBQzlCLENBQUEsQUFFQSxLQUFBLDRCQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsR0FBVSxDQUNWLGNBQUEsQ0FBQSxTQUF5QixDQUN6QixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsU0FBQSxDQUFBLElBQWUsQ0FDZixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFdBQUEsQ0FBQSxNQUFtQixBQUNwQixDQUFBLEFBRUEsR0FBQSxXQUFBLDRCQUFBLENBQUEsQUFDQyxXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxDQUNsQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFNBQUEsQ0FBQSxJQUFlLENBQ2YsVUFBQSxDQUFBLE1BQWtCLENBQ2xCLE9BQUEsQ0FBQSxJQUFhLENBQ2IsY0FBQSxDQUFBLEdBQW1CLENBQ25CLFNBQUEsQ0FBQSxJQUFlLENBQ2YsV0FBQSxDQUFBLE1BQW1CLEFBQ3BCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVGVsZW1ldHJ5U2V0dGluZ3NQYW5lbC5zdmVsdGUiXX0= */");
}
function create_default_slot5(ctx) {
  let p0;
  let t0;
  let t1;
  let ol;
  let li0;
  let t2;
  let code;
  let t3;
  let t4;
  let li1;
  let t5;
  let t6;
  let li2;
  let t7;
  let t8;
  let li3;
  let t9;
  let t10;
  let li4;
  let t11;
  let t12;
  let li5;
  let t13;
  let t14;
  let p1;
  let t15;
  let t16;
  let div;
  let label0;
  let t17;
  let t18;
  let label1;
  let input;
  let t19;
  let span;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      p0 = element("p");
      t0 = text("Each time you run a query, we get the following pieces of information:");
      t1 = space();
      ol = element("ol");
      li0 = element("li");
      t2 = text("A random identifier that is stored in ");
      code = element("code");
      t3 = text(".evidence/template/.profile.json");
      t4 = space();
      li1 = element("li");
      t5 = text("An anonymized identifier based on the git repository you're using for the project");
      t6 = space();
      li2 = element("li");
      t7 = text("Whether your project is running in development or build mode");
      t8 = space();
      li3 = element("li");
      t9 = text("Whether your query returned from the cache, from your database, or returned an error");
      t10 = space();
      li4 = element("li");
      t11 = text("The type of Evidence database connector you are using (postgres, snowflake, etc.)");
      t12 = space();
      li5 = element("li");
      t13 = text("The operating system your project is running on (windows, mac, etc.)");
      t14 = space();
      p1 = element("p");
      t15 = text("Sharing anonymous usage data is one of the best ways you can support Evidence.");
      t16 = space();
      div = element("div");
      label0 = element("label");
      t17 = text("Share anonymous usage data");
      t18 = space();
      label1 = element("label");
      input = element("input");
      t19 = space();
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      p0 = claim_element(nodes, "P", {});
      var p0_nodes = children(p0);
      t0 = claim_text(p0_nodes, "Each time you run a query, we get the following pieces of information:");
      p0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      ol = claim_element(nodes, "OL", {});
      var ol_nodes = children(ol);
      li0 = claim_element(ol_nodes, "LI", {});
      var li0_nodes = children(li0);
      t2 = claim_text(li0_nodes, "A random identifier that is stored in ");
      code = claim_element(li0_nodes, "CODE", {});
      var code_nodes = children(code);
      t3 = claim_text(code_nodes, ".evidence/template/.profile.json");
      code_nodes.forEach(detach_dev);
      li0_nodes.forEach(detach_dev);
      t4 = claim_space(ol_nodes);
      li1 = claim_element(ol_nodes, "LI", {});
      var li1_nodes = children(li1);
      t5 = claim_text(li1_nodes, "An anonymized identifier based on the git repository you're using for the project");
      li1_nodes.forEach(detach_dev);
      t6 = claim_space(ol_nodes);
      li2 = claim_element(ol_nodes, "LI", {});
      var li2_nodes = children(li2);
      t7 = claim_text(li2_nodes, "Whether your project is running in development or build mode");
      li2_nodes.forEach(detach_dev);
      t8 = claim_space(ol_nodes);
      li3 = claim_element(ol_nodes, "LI", {});
      var li3_nodes = children(li3);
      t9 = claim_text(li3_nodes, "Whether your query returned from the cache, from your database, or returned an error");
      li3_nodes.forEach(detach_dev);
      t10 = claim_space(ol_nodes);
      li4 = claim_element(ol_nodes, "LI", {});
      var li4_nodes = children(li4);
      t11 = claim_text(li4_nodes, "The type of Evidence database connector you are using (postgres, snowflake, etc.)");
      li4_nodes.forEach(detach_dev);
      t12 = claim_space(ol_nodes);
      li5 = claim_element(ol_nodes, "LI", {});
      var li5_nodes = children(li5);
      t13 = claim_text(li5_nodes, "The operating system your project is running on (windows, mac, etc.)");
      li5_nodes.forEach(detach_dev);
      ol_nodes.forEach(detach_dev);
      t14 = claim_space(nodes);
      p1 = claim_element(nodes, "P", {});
      var p1_nodes = children(p1);
      t15 = claim_text(p1_nodes, "Sharing anonymous usage data is one of the best ways you can support Evidence.");
      p1_nodes.forEach(detach_dev);
      t16 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      label0 = claim_element(div_nodes, "LABEL", { for: true, class: true });
      var label0_nodes = children(label0);
      t17 = claim_text(label0_nodes, "Share anonymous usage data");
      label0_nodes.forEach(detach_dev);
      t18 = claim_space(div_nodes);
      label1 = claim_element(div_nodes, "LABEL", { class: true });
      var label1_nodes = children(label1);
      input = claim_element(label1_nodes, "INPUT", { type: true, id: true, class: true });
      t19 = claim_space(label1_nodes);
      span = claim_element(label1_nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      label1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p0, file58, 29, 4, 759);
      add_location(code, file58, 32, 44, 900);
      add_location(li0, file58, 31, 5, 851);
      add_location(li1, file58, 34, 5, 962);
      add_location(li2, file58, 35, 5, 1058);
      add_location(li3, file58, 36, 5, 1133);
      add_location(li4, file58, 39, 5, 1245);
      add_location(li5, file58, 40, 5, 1341);
      add_location(ol, file58, 30, 4, 841);
      add_location(p1, file58, 42, 4, 1433);
      attr_dev(label0, "for", "telemetry-toggle");
      attr_dev(label0, "class", "svelte-y9mxr5");
      add_location(label0, file58, 44, 5, 1553);
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "id", "telemetry-toggle");
      attr_dev(input, "class", "svelte-y9mxr5");
      add_location(input, file58, 46, 6, 1654);
      attr_dev(span, "class", "slider svelte-y9mxr5");
      add_location(span, file58, 52, 6, 1785);
      attr_dev(label1, "class", "switch svelte-y9mxr5");
      add_location(label1, file58, 45, 5, 1625);
      attr_dev(div, "class", "input-item svelte-y9mxr5");
      add_location(div, file58, 43, 4, 1523);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p0, anchor);
      append_hydration_dev(p0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, ol, anchor);
      append_hydration_dev(ol, li0);
      append_hydration_dev(li0, t2);
      append_hydration_dev(li0, code);
      append_hydration_dev(code, t3);
      append_hydration_dev(ol, t4);
      append_hydration_dev(ol, li1);
      append_hydration_dev(li1, t5);
      append_hydration_dev(ol, t6);
      append_hydration_dev(ol, li2);
      append_hydration_dev(li2, t7);
      append_hydration_dev(ol, t8);
      append_hydration_dev(ol, li3);
      append_hydration_dev(li3, t9);
      append_hydration_dev(ol, t10);
      append_hydration_dev(ol, li4);
      append_hydration_dev(li4, t11);
      append_hydration_dev(ol, t12);
      append_hydration_dev(ol, li5);
      append_hydration_dev(li5, t13);
      insert_hydration_dev(target, t14, anchor);
      insert_hydration_dev(target, p1, anchor);
      append_hydration_dev(p1, t15);
      insert_hydration_dev(target, t16, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, label0);
      append_hydration_dev(label0, t17);
      append_hydration_dev(div, t18);
      append_hydration_dev(div, label1);
      append_hydration_dev(label1, input);
      input.checked = /*usageStats*/
      ctx[0];
      append_hydration_dev(label1, t19);
      append_hydration_dev(label1, span);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[3]
          ),
          listen_dev(
            input,
            "change",
            /*save*/
            ctx[1],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*usageStats*/
      1) {
        input.checked = /*usageStats*/
        ctx2[0];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(ol);
      if (detaching)
        detach_dev(t14);
      if (detaching)
        detach_dev(p1);
      if (detaching)
        detach_dev(t16);
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: '(29:3) <CollapsibleTableSection headerText=\\"More\\" expanded={false}>',
    ctx
  });
  return block;
}
function create_fragment67(ctx) {
  let form;
  let div1;
  let div0;
  let h2;
  let t0;
  let t1;
  let p;
  let t2;
  let t3;
  let collapsibletablesection;
  let t4;
  let footer;
  let span;
  let t5;
  let a;
  let t6;
  let current;
  collapsibletablesection = new CollapsibleTableSection_default({
    props: {
      headerText: "More",
      expanded: false,
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      form = element("form");
      div1 = element("div");
      div0 = element("div");
      h2 = element("h2");
      t0 = text("Telemetry");
      t1 = space();
      p = element("p");
      t2 = text("Evidence collects anonymous usage data to help us understand how often the tool is being\n				used.");
      t3 = space();
      create_component(collapsibletablesection.$$.fragment);
      t4 = space();
      footer = element("footer");
      span = element("span");
      t5 = text("The source code for our telemetry can be ");
      a = element("a");
      t6 = text("found here ");
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { id: true, class: true });
      var form_nodes = children(form);
      div1 = claim_element(form_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      h2 = claim_element(div0_nodes, "H2", {});
      var h2_nodes = children(h2);
      t0 = claim_text(h2_nodes, "Telemetry");
      h2_nodes.forEach(detach_dev);
      t1 = claim_space(div0_nodes);
      p = claim_element(div0_nodes, "P", {});
      var p_nodes = children(p);
      t2 = claim_text(p_nodes, "Evidence collects anonymous usage data to help us understand how often the tool is being\n				used.");
      p_nodes.forEach(detach_dev);
      t3 = claim_space(div0_nodes);
      claim_component(collapsibletablesection.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t4 = claim_space(form_nodes);
      footer = claim_element(form_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      span = claim_element(footer_nodes, "SPAN", {});
      var span_nodes = children(span);
      t5 = claim_text(span_nodes, "The source code for our telemetry can be ");
      a = claim_element(span_nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      t6 = claim_text(a_nodes, "found here ");
      a_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h2, file58, 23, 3, 554);
      add_location(p, file58, 24, 3, 576);
      attr_dev(div0, "class", "panel svelte-y9mxr5");
      add_location(div0, file58, 22, 2, 531);
      attr_dev(div1, "class", "container svelte-y9mxr5");
      add_location(div1, file58, 21, 1, 505);
      attr_dev(a, "class", "docs-link svelte-y9mxr5");
      attr_dev(a, "href", "https://github.com/evidence-dev/evidence/blob/main/packages/telemetry/index.cjs");
      add_location(a, file58, 60, 45, 1944);
      add_location(span, file58, 59, 2, 1893);
      attr_dev(footer, "class", "svelte-y9mxr5");
      add_location(footer, file58, 58, 1, 1882);
      attr_dev(form, "id", "telemetry");
      attr_dev(form, "class", "svelte-y9mxr5");
      add_location(form, file58, 20, 0, 482);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      append_hydration_dev(form, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, h2);
      append_hydration_dev(h2, t0);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div0, p);
      append_hydration_dev(p, t2);
      append_hydration_dev(div0, t3);
      mount_component(collapsibletablesection, div0, null);
      append_hydration_dev(form, t4);
      append_hydration_dev(form, footer);
      append_hydration_dev(footer, span);
      append_hydration_dev(span, t5);
      append_hydration_dev(span, a);
      append_hydration_dev(a, t6);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const collapsibletablesection_changes = {};
      if (dirty & /*$$scope, usageStats*/
      17) {
        collapsibletablesection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapsibletablesection.$set(collapsibletablesection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(collapsibletablesection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(collapsibletablesection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      destroy_component(collapsibletablesection);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude64 = true;
function instance67($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TelemetrySettingsPanel", slots, []);
  let { settings } = $$props;
  let usageStats = (settings.send_anonymous_usage_stats ?? "yes") === "yes";
  async function save() {
    $$invalidate(2, settings.send_anonymous_usage_stats = usageStats ? "yes" : "no", settings);
    await fetch("/api/settings.json", {
      method: "POST",
      body: JSON.stringify({ settings })
    });
  }
  $$self.$$.on_mount.push(function() {
    if (settings === void 0 && !("settings" in $$props || $$self.$$.bound[$$self.$$.props["settings"]])) {
      console.warn("<TelemetrySettingsPanel> was created without expected prop 'settings'");
    }
  });
  const writable_props = ["settings"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TelemetrySettingsPanel> was created with unknown prop '${key}'`);
  });
  function input_change_handler() {
    usageStats = this.checked;
    $$invalidate(0, usageStats);
  }
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(2, settings = $$props2.settings);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude64,
    CollapsibleTableSection: CollapsibleTableSection_default,
    settings,
    usageStats,
    save
  });
  $$self.$inject_state = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(2, settings = $$props2.settings);
    if ("usageStats" in $$props2)
      $$invalidate(0, usageStats = $$props2.usageStats);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [usageStats, save, settings, input_change_handler];
}
var TelemetrySettingsPanel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, { settings: 2 }, add_css49);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TelemetrySettingsPanel",
      options,
      id: create_fragment67.name
    });
  }
  get settings() {
    throw new Error("<TelemetrySettingsPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<TelemetrySettingsPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TelemetrySettingsPanel_default = TelemetrySettingsPanel;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/ui/VersionControl/VersionControlPanel.svelte
var file59 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/ui/VersionControl/VersionControlPanel.svelte";
function add_css50(target) {
  append_styles(target, "svelte-121yqh3", "form.svelte-121yqh3.svelte-121yqh3{scroll-margin-top:3.5rem}.container.svelte-121yqh3.svelte-121yqh3{margin-top:2em;border-top:1px solid var(--grey-200);border-left:1px solid var(--grey-200);border-right:1px solid var(--grey-200);border-radius:5px 5px 0 0;font-size:14px;font-family:var(--ui-font-family);min-width:100%}.panel.svelte-121yqh3.svelte-121yqh3{border-top:1px solid var(--grey-200);padding:0em 1em 1em 1em}.panel.svelte-121yqh3.svelte-121yqh3:first-of-type{border-top:none}footer.svelte-121yqh3.svelte-121yqh3{border:1px solid var(--grey-200);border-radius:0 0 5px 5px;background-color:var(--grey-100);padding:1em;display:flex;font-size:14px;align-items:center;font-family:var(--ui-font-family)}.docs-link.svelte-121yqh3.svelte-121yqh3{color:var(--blue-600);text-decoration:none}.docs-link.svelte-121yqh3.svelte-121yqh3:hover{color:var(--blue-800)}.gitcheck-icon.svelte-121yqh3.svelte-121yqh3{color:var(--green-700);float:right;margin-right:5px}.gitx-icon.svelte-121yqh3.svelte-121yqh3{color:var(--red-700);float:right;margin-right:5px}.git-item.svelte-121yqh3.svelte-121yqh3{margin-top:18px;margin-bottom:10px}.result-msg.svelte-121yqh3.svelte-121yqh3{word-break:break-all;margin-top:3px}.repo-location.svelte-121yqh3.svelte-121yqh3{color:var(--grey-500);font-size:0.8rem;text-decoration:unset}.item-label.svelte-121yqh3.svelte-121yqh3{color:var(--grey-800);text-transform:uppercase}.help-icon.svelte-121yqh3.svelte-121yqh3{width:18px;color:var(--grey-600);display:inline-block;vertical-align:middle;line-height:1em;cursor:help;position:relative;text-transform:none}.help-icon.svelte-121yqh3 .info-msg.svelte-121yqh3{visibility:hidden;display:none;position:absolute;top:-5px;left:105%;padding-left:5px;padding-right:5px;padding-top:2px;padding-bottom:1px;color:white;font-family:sans-serif;font-size:0.8em;background-color:var(--grey-900);opacity:0.85;border-radius:6px;z-index:1;max-width:200px;min-width:100px}.help-icon.svelte-121yqh3:hover .info-msg.svelte-121yqh3{visibility:visible;display:inline}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmVyc2lvbkNvbnRyb2xQYW5lbC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBaUZDLElBQUEsOEJBQUEsQ0FBQSxBQUNDLGlCQUFBLENBQUEsTUFBeUIsQUFDMUIsQ0FBQSxBQUNBLFVBQUEsOEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxHQUFlLENBQ2YsVUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXFDLENBQ3JDLFdBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQyxDQUN0QyxZQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBdUMsQ0FDdkMsYUFBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBQTBCLENBQzFCLFNBQUEsQ0FBQSxJQUFlLENBQ2YsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsU0FBQSxDQUFBLElBQWUsQUFDaEIsQ0FBQSxBQUVBLE1BQUEsOEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFxQyxDQUNyQyxPQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsR0FBd0IsQUFDekIsQ0FBQSxBQUVBLG9DQUFBLGNBQUEsQUFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQWdCLEFBQ2pCLENBQUEsQUFFQSxNQUFBLDhCQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsYUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLEdBQTBCLENBQzFCLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxHQUFZLENBQ1osT0FBQSxDQUFBLElBQWEsQ0FDYixTQUFBLENBQUEsSUFBZSxDQUNmLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixXQUFBLENBQUEsSUFBQSxnQkFBQSxDQUFrQyxBQUNuQyxDQUFBLEFBRUEsVUFBQSw4QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixlQUFBLENBQUEsSUFBcUIsQUFDdEIsQ0FBQSxBQUVBLHdDQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBLEFBRUEsY0FBQSw4QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsV0FBQSxDQUF1QixDQUN2QixLQUFBLENBQUEsS0FBWSxDQUNaLFlBQUEsQ0FBQSxHQUFpQixBQUNsQixDQUFBLEFBRUEsVUFBQSw4QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsU0FBQSxDQUFxQixDQUNyQixLQUFBLENBQUEsS0FBWSxDQUNaLFlBQUEsQ0FBQSxHQUFpQixBQUNsQixDQUFBLEFBRUEsU0FBQSw4QkFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQWdCLENBQ2hCLGFBQUEsQ0FBQSxJQUFtQixBQUNwQixDQUFBLEFBRUEsV0FBQSw4QkFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLFNBQXFCLENBQ3JCLFVBQUEsQ0FBQSxHQUFlLEFBQ2hCLENBQUEsQUFFQSxjQUFBLDhCQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFNBQUEsQ0FBQSxNQUFpQixDQUNqQixlQUFBLENBQUEsS0FBc0IsQUFDdkIsQ0FBQSxBQUVBLFdBQUEsOEJBQUEsQ0FBQSxBQUVDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsY0FBQSxDQUFBLFNBQXlCLEFBQzFCLENBQUEsQUFFQSxVQUFBLDhCQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBVyxDQUNYLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsT0FBQSxDQUFBLFlBQXFCLENBQ3JCLGNBQUEsQ0FBQSxNQUFzQixDQUN0QixXQUFBLENBQUEsR0FBZ0IsQ0FDaEIsTUFBQSxDQUFBLElBQVksQ0FDWixRQUFBLENBQUEsUUFBa0IsQ0FDbEIsY0FBQSxDQUFBLElBQW9CLEFBQ3JCLENBQUEsQUFFQSx5QkFBQSxDQUFBLFNBQUEsZUFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLE1BQWtCLENBQ2xCLE9BQUEsQ0FBQSxJQUFhLENBQ2IsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLEdBQUEsQ0FBQSxJQUFTLENBQ1QsSUFBQSxDQUFBLElBQVUsQ0FDVixZQUFBLENBQUEsR0FBaUIsQ0FDakIsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLFdBQUEsQ0FBQSxHQUFnQixDQUNoQixjQUFBLENBQUEsR0FBbUIsQ0FDbkIsS0FBQSxDQUFBLEtBQVksQ0FDWixXQUFBLENBQUEsVUFBdUIsQ0FDdkIsU0FBQSxDQUFBLEtBQWdCLENBQ2hCLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxJQUFhLENBQ2IsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLE9BQUEsQ0FBQSxDQUFVLENBQ1YsU0FBQSxDQUFBLEtBQWdCLENBQ2hCLFNBQUEsQ0FBQSxLQUFnQixBQUNqQixDQUFBLEFBRUEseUJBQUEsTUFBQSxDQUFBLFNBQUEsZUFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLE9BQW1CLENBQ25CLE9BQUEsQ0FBQSxNQUFlLEFBQ2hCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVmVyc2lvbkNvbnRyb2xQYW5lbC5zdmVsdGUiXX0= */");
}
function create_else_block_3(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: CircleX,
      theme: "filled",
      class: "h-6 w-6  text-red-700"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "gitx-icon svelte-121yqh3");
      add_location(span, file59, 24, 5, 700);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_3.name,
    type: "else",
    source: "(24:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_36(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: CircleCheck,
      theme: "filled",
      class: "h-6 w-6  text-green-700"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "gitcheck-icon svelte-121yqh3");
      add_location(span, file59, 20, 5, 561);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(20:4) {#if settings.localGitRepo}",
    ctx
  });
  return block;
}
function create_else_block_24(ctx) {
  let span1;
  let icon;
  let t0;
  let span0;
  let t1;
  let current;
  icon = new Icon_default({
    props: { src: HelpCircle, class: "h-5 w-5 pb-0.5" },
    $$inline: true
  });
  const block = {
    c: function create() {
      span1 = element("span");
      create_component(icon.$$.fragment);
      t0 = space();
      span0 = element("span");
      t1 = text("Use your code editor to initialize a repo or run `git init` in a terminal");
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      claim_component(icon.$$.fragment, span1_nodes);
      t0 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t1 = claim_text(span0_nodes, "Use your code editor to initialize a repo or run `git init` in a terminal");
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "info-msg svelte-121yqh3");
      add_location(span0, file59, 36, 6, 1124);
      attr_dev(span1, "class", "help-icon svelte-121yqh3");
      add_location(span1, file59, 34, 5, 1038);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      mount_component(icon, span1, null);
      append_hydration_dev(span1, t0);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t1);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_24.name,
    type: "else",
    source: "(34:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_215(ctx) {
  let div;
  let span;
  let t0;
  let t1_value = (
    /*settings*/
    ctx[0].localGitRepo + ""
  );
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      t0 = text("Tracking ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "Tracking ");
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "repo-location svelte-121yqh3");
      add_location(span, file59, 31, 6, 941);
      attr_dev(div, "class", "result-msg svelte-121yqh3");
      add_location(div, file59, 30, 5, 910);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*settings*/
      1 && t1_value !== (t1_value = /*settings*/
      ctx2[0].localGitRepo + ""))
        set_data_dev(t1, t1_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_215.name,
    type: "if",
    source: "(30:4) {#if settings.localGitRepo}",
    ctx
  });
  return block;
}
function create_else_block_19(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: CircleX,
      theme: "filled",
      class: "h-6 w-6  text-red-700"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "gitx-icon svelte-121yqh3");
      add_location(span, file59, 49, 5, 1474);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_19.name,
    type: "else",
    source: "(49:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_121(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: CircleCheck,
      theme: "filled",
      class: "h-6 w-6  text-green-700"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "gitcheck-icon svelte-121yqh3");
      add_location(span, file59, 45, 5, 1335);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_121.name,
    type: "if",
    source: "(45:4) {#if settings.gitRepo}",
    ctx
  });
  return block;
}
function create_else_block19(ctx) {
  let span1;
  let icon;
  let t0;
  let span0;
  let t1;
  let current;
  icon = new Icon_default({
    props: { src: HelpCircle, class: "h-5 w-5 pb-0.5" },
    $$inline: true
  });
  const block = {
    c: function create() {
      span1 = element("span");
      create_component(icon.$$.fragment);
      t0 = space();
      span0 = element("span");
      t1 = text("Publish your git repo to a platform like GitHub or GitLab");
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      claim_component(icon.$$.fragment, span1_nodes);
      t0 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t1 = claim_text(span0_nodes, "Publish your git repo to a platform like GitHub or GitLab");
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "info-msg svelte-121yqh3");
      add_location(span0, file59, 63, 6, 2002);
      attr_dev(span1, "class", "help-icon svelte-121yqh3");
      add_location(span1, file59, 61, 5, 1916);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      mount_component(icon, span1, null);
      append_hydration_dev(span1, t0);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t1);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block19.name,
    type: "else",
    source: "(61:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block43(ctx) {
  let div;
  let a;
  let span;
  let t_value = (
    /*settings*/
    ctx[0].gitRepo.replace(".git", "") + ""
  );
  let t;
  let a_href_value;
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { href: true, target: true, rel: true });
      var a_nodes = children(a);
      span = claim_element(a_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "repo-location svelte-121yqh3");
      add_location(span, file59, 57, 8, 1802);
      attr_dev(a, "href", a_href_value = /*settings*/
      ctx[0].gitRepo.replace(".git", ""));
      attr_dev(a, "target", "_blank");
      attr_dev(a, "rel", "noreferrer");
      add_location(a, file59, 56, 6, 1714);
      attr_dev(div, "class", "result-msg svelte-121yqh3");
      add_location(div, file59, 55, 5, 1683);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a);
      append_hydration_dev(a, span);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*settings*/
      1 && t_value !== (t_value = /*settings*/
      ctx2[0].gitRepo.replace(".git", "") + ""))
        set_data_dev(t, t_value);
      if (dirty & /*settings*/
      1 && a_href_value !== (a_href_value = /*settings*/
      ctx2[0].gitRepo.replace(".git", ""))) {
        attr_dev(a, "href", a_href_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block43.name,
    type: "if",
    source: "(55:4) {#if settings.gitRepo}",
    ctx
  });
  return block;
}
function create_fragment68(ctx) {
  let form;
  let div3;
  let div2;
  let h2;
  let t0;
  let t1;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t2;
  let span0;
  let t3;
  let t4;
  let current_block_type_index_1;
  let if_block1;
  let t5;
  let div1;
  let current_block_type_index_2;
  let if_block2;
  let t6;
  let span1;
  let t7;
  let t8;
  let current_block_type_index_3;
  let if_block3;
  let t9;
  let footer;
  let span2;
  let t10;
  let a;
  let t11;
  let current;
  const if_block_creators = [create_if_block_36, create_else_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*settings*/
      ctx2[0].localGitRepo
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const if_block_creators_1 = [create_if_block_215, create_else_block_24];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*settings*/
      ctx2[0].localGitRepo
    )
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_1(ctx, -1);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  const if_block_creators_2 = [create_if_block_121, create_else_block_19];
  const if_blocks_2 = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*settings*/
      ctx2[0].gitRepo
    )
      return 0;
    return 1;
  }
  current_block_type_index_2 = select_block_type_2(ctx, -1);
  if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
  const if_block_creators_3 = [create_if_block43, create_else_block19];
  const if_blocks_3 = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*settings*/
      ctx2[0].gitRepo
    )
      return 0;
    return 1;
  }
  current_block_type_index_3 = select_block_type_3(ctx, -1);
  if_block3 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
  const block = {
    c: function create() {
      form = element("form");
      div3 = element("div");
      div2 = element("div");
      h2 = element("h2");
      t0 = text("Version Control");
      t1 = text("\n			Use version control to keep track of changes to your project. A published git repo is needed if\n			you want to deploy your Evidence project online.\n\n			");
      div0 = element("div");
      if_block0.c();
      t2 = space();
      span0 = element("span");
      t3 = text("Local Git Repo");
      t4 = space();
      if_block1.c();
      t5 = space();
      div1 = element("div");
      if_block2.c();
      t6 = space();
      span1 = element("span");
      t7 = text("Git Repo Published");
      t8 = space();
      if_block3.c();
      t9 = space();
      footer = element("footer");
      span2 = element("span");
      t10 = text("Learn more about ");
      a = element("a");
      t11 = text("Setting Up Version Control ");
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { id: true, class: true });
      var form_nodes = children(form);
      div3 = claim_element(form_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      h2 = claim_element(div2_nodes, "H2", {});
      var h2_nodes = children(h2);
      t0 = claim_text(h2_nodes, "Version Control");
      h2_nodes.forEach(detach_dev);
      t1 = claim_text(div2_nodes, "\n			Use version control to keep track of changes to your project. A published git repo is needed if\n			you want to deploy your Evidence project online.\n\n			");
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block0.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      span0 = claim_element(div0_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t3 = claim_text(span0_nodes, "Local Git Repo");
      span0_nodes.forEach(detach_dev);
      t4 = claim_space(div0_nodes);
      if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t5 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if_block2.l(div1_nodes);
      t6 = claim_space(div1_nodes);
      span1 = claim_element(div1_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t7 = claim_text(span1_nodes, "Git Repo Published");
      span1_nodes.forEach(detach_dev);
      t8 = claim_space(div1_nodes);
      if_block3.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      t9 = claim_space(form_nodes);
      footer = claim_element(form_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      span2 = claim_element(footer_nodes, "SPAN", {});
      var span2_nodes = children(span2);
      t10 = claim_text(span2_nodes, "Learn more about ");
      a = claim_element(span2_nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      t11 = claim_text(a_nodes, "Setting Up Version Control ");
      a_nodes.forEach(detach_dev);
      span2_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h2, file59, 14, 3, 321);
      attr_dev(span0, "class", "item-label svelte-121yqh3");
      add_location(span0, file59, 28, 4, 826);
      attr_dev(div0, "class", "git-item svelte-121yqh3");
      add_location(div0, file59, 18, 3, 501);
      attr_dev(span1, "class", "item-label svelte-121yqh3");
      add_location(span1, file59, 53, 4, 1600);
      attr_dev(div1, "class", "git-item svelte-121yqh3");
      add_location(div1, file59, 43, 3, 1280);
      attr_dev(div2, "class", "panel svelte-121yqh3");
      add_location(div2, file59, 13, 2, 298);
      attr_dev(div3, "class", "container svelte-121yqh3");
      add_location(div3, file59, 12, 1, 272);
      attr_dev(a, "class", "docs-link svelte-121yqh3");
      attr_dev(a, "href", "https://docs.github.com/en/get-started/using-git/about-git");
      add_location(a, file59, 71, 21, 2179);
      add_location(span2, file59, 70, 2, 2152);
      attr_dev(footer, "class", "svelte-121yqh3");
      add_location(footer, file59, 69, 1, 2141);
      attr_dev(form, "id", "version-control");
      attr_dev(form, "class", "svelte-121yqh3");
      add_location(form, file59, 11, 0, 243);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      append_hydration_dev(form, div3);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, h2);
      append_hydration_dev(h2, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append_hydration_dev(div0, t2);
      append_hydration_dev(div0, span0);
      append_hydration_dev(span0, t3);
      append_hydration_dev(div0, t4);
      if_blocks_1[current_block_type_index_1].m(div0, null);
      append_hydration_dev(div2, t5);
      append_hydration_dev(div2, div1);
      if_blocks_2[current_block_type_index_2].m(div1, null);
      append_hydration_dev(div1, t6);
      append_hydration_dev(div1, span1);
      append_hydration_dev(span1, t7);
      append_hydration_dev(div1, t8);
      if_blocks_3[current_block_type_index_3].m(div1, null);
      append_hydration_dev(form, t9);
      append_hydration_dev(form, footer);
      append_hydration_dev(footer, span2);
      append_hydration_dev(span2, t10);
      append_hydration_dev(span2, a);
      append_hydration_dev(a, t11);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, t2);
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2, dirty);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block1 = if_blocks_1[current_block_type_index_1];
        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div0, null);
      }
      let previous_block_index_2 = current_block_type_index_2;
      current_block_type_index_2 = select_block_type_2(ctx2, dirty);
      if (current_block_type_index_2 === previous_block_index_2) {
        if_blocks_2[current_block_type_index_2].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
          if_blocks_2[previous_block_index_2] = null;
        });
        check_outros();
        if_block2 = if_blocks_2[current_block_type_index_2];
        if (!if_block2) {
          if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div1, t6);
      }
      let previous_block_index_3 = current_block_type_index_3;
      current_block_type_index_3 = select_block_type_3(ctx2, dirty);
      if (current_block_type_index_3 === previous_block_index_3) {
        if_blocks_3[current_block_type_index_3].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
          if_blocks_3[previous_block_index_3] = null;
        });
        check_outros();
        if_block3 = if_blocks_3[current_block_type_index_3];
        if (!if_block3) {
          if_block3 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx2);
          if_block3.c();
        } else {
          if_block3.p(ctx2, dirty);
        }
        transition_in(if_block3, 1);
        if_block3.m(div1, null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      if_blocks[current_block_type_index].d();
      if_blocks_1[current_block_type_index_1].d();
      if_blocks_2[current_block_type_index_2].d();
      if_blocks_3[current_block_type_index_3].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude65 = true;
function instance68($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VersionControlPanel", slots, []);
  let { settings } = $$props;
  $$self.$$.on_mount.push(function() {
    if (settings === void 0 && !("settings" in $$props || $$self.$$.bound[$$self.$$.props["settings"]])) {
      console.warn("<VersionControlPanel> was created without expected prop 'settings'");
    }
  });
  const writable_props = ["settings"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VersionControlPanel> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude65,
    Icon: Icon_default,
    CircleX,
    CircleCheck,
    HelpCircle,
    settings
  });
  $$self.$inject_state = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [settings];
}
var VersionControlPanel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance68, create_fragment68, safe_not_equal, { settings: 0 }, add_css50);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VersionControlPanel",
      options,
      id: create_fragment68.name
    });
  }
  get settings() {
    throw new Error("<VersionControlPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<VersionControlPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VersionControlPanel_default = VersionControlPanel;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/context.js
var configKey = Symbol();
var propKey = Symbol();
var strictBuild = import.meta.env.VITE_BUILD_STRICT === "true";

// ../../node_modules/@evidence-dev/component-utilities/src/getDistinctValues.js
function getDistinctValues(data, column) {
  const set = new Set(data.map((val) => val[column]));
  return Array.from(set);
}

// ../../node_modules/@evidence-dev/component-utilities/src/getStackPercentages.js
function getStackPercentages(data, groupCol, valueCol) {
  let pctData;
  if (typeof valueCol !== "object") {
    pctData = tidy(
      data,
      groupBy(groupCol, mutateWithSummary({ xTotal: sum(valueCol) })),
      mutate({ percentOfX: rate(valueCol, "xTotal") }),
      rename({
        [valueCol]: valueCol + "_raw",
        percentOfX: valueCol + "_pct"
      })
    );
  } else {
    pctData = tidy(
      data,
      mutate({
        valueSum: 0
      })
    );
    for (let i = 0; i < pctData.length; i++) {
      pctData[i].valueSum = 0;
      for (let j = 0; j < valueCol.length; j++) {
        pctData[i].valueSum = pctData[i].valueSum + pctData[i][valueCol[j]];
      }
    }
    pctData = tidy(pctData, groupBy(groupCol, mutateWithSummary({ xTotal: sum("valueSum") })));
    for (let i = 0; i < valueCol.length; i++) {
      pctData = tidy(
        pctData,
        mutate({ percentOfX: rate(valueCol[i], "xTotal") }),
        rename({
          [valueCol[i]]: valueCol[i] + "_raw",
          percentOfX: valueCol[i] + "_pct"
        })
      );
    }
  }
  return pctData;
}

// ../../node_modules/@evidence-dev/component-utilities/src/getSortedData.js
function getSortedData(data, col, isAsc) {
  return [...data].sort((a, b) => {
    return (a[col] < b[col] ? -1 : 1) * (isAsc ? 1 : -1);
  });
}

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/ErrorChart.svelte
import { dev as dev4 } from "$app/environment";
var file60 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/viz/ErrorChart.svelte";
function create_if_block44(ctx) {
  let br;
  let a;
  let t;
  const block = {
    c: function create() {
      br = element("br");
      a = element("a");
      t = text("Addcredentials");
      this.h();
    },
    l: function claim(nodes) {
      br = claim_element(nodes, "BR", {});
      a = claim_element(nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      t = claim_text(a_nodes, "Addcredentials");
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(br, file60, 24, 4, 743);
      attr_dev(a, "class", "credentials-link");
      attr_dev(a, "href", "/settings");
      add_location(a, file60, 24, 10, 749);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, br, anchor);
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(br);
      if (detaching)
        detach_dev(a);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block44.name,
    type: "if",
    source: "(24:3) {#if dev && error === MissingCredentialsError}",
    ctx
  });
  return block;
}
function create_fragment69(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let if_block = dev4 && /*error*/
  ctx[0] === MissingCredentialsError && create_if_block44(ctx);
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*chartType*/
        ctx[1]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*error*/
        ctx[0]
      );
      t3 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { width: true, class: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*chartType*/
        ctx[1]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(
        div1_nodes,
        /*error*/
        ctx[0]
      );
      t3 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "font-bold text-center text-lg");
      add_location(div0, file60, 17, 2, 503);
      attr_dev(div1, "class", "text-center [word-wrap:break-work] text-xs");
      toggle_class(
        div1,
        "w-[7.8em]",
        /*chartType*/
        ctx[1].includes("Value")
      );
      add_location(div1, file60, 18, 2, 566);
      attr_dev(div2, "class", "m-auto w-full");
      add_location(div2, file60, 16, 1, 473);
      attr_dev(div3, "width", "100%");
      attr_dev(div3, "class", "grid grid-rows-auto box-content grid-cols-1 justify-center bg-red-50 text-grey-700 font-ui font-normal rounded border border-red-100 min-h-[150px] py-5 px-8 my-5 print:break-inside-avoid");
      add_location(div3, file60, 12, 0, 255);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div1, t3);
      if (if_block)
        if_block.m(div1, null);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*chartType*/
      2)
        set_data_dev(
          t0,
          /*chartType*/
          ctx2[1]
        );
      if (dirty & /*error*/
      1)
        set_data_dev(
          t2,
          /*error*/
          ctx2[0]
        );
      if (dev4 && /*error*/
      ctx2[0] === MissingCredentialsError) {
        if (if_block) {
        } else {
          if_block = create_if_block44(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*chartType*/
      2) {
        toggle_class(
          div1,
          "w-[7.8em]",
          /*chartType*/
          ctx2[1].includes("Value")
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude66 = true;
var MissingCredentialsError = "SQL Error: Missing database credentials";
function instance69($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ErrorChart", slots, []);
  let { error } = $$props;
  let { chartType } = $$props;
  $$self.$$.on_mount.push(function() {
    if (error === void 0 && !("error" in $$props || $$self.$$.bound[$$self.$$.props["error"]])) {
      console.warn("<ErrorChart> was created without expected prop 'error'");
    }
    if (chartType === void 0 && !("chartType" in $$props || $$self.$$.bound[$$self.$$.props["chartType"]])) {
      console.warn("<ErrorChart> was created without expected prop 'chartType'");
    }
  });
  const writable_props = ["error", "chartType"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ErrorChart> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("error" in $$props2)
      $$invalidate(0, error = $$props2.error);
    if ("chartType" in $$props2)
      $$invalidate(1, chartType = $$props2.chartType);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude66,
    dev: dev4,
    error,
    chartType,
    MissingCredentialsError
  });
  $$self.$inject_state = ($$props2) => {
    if ("error" in $$props2)
      $$invalidate(0, error = $$props2.error);
    if ("chartType" in $$props2)
      $$invalidate(1, chartType = $$props2.chartType);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [error, chartType];
}
var ErrorChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, { error: 0, chartType: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ErrorChart",
      options,
      id: create_fragment69.name
    });
  }
  get error() {
    throw new Error("<ErrorChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<ErrorChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chartType() {
    throw new Error("<ErrorChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chartType(value) {
    throw new Error("<ErrorChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ErrorChart_default = ErrorChart;

// ../../node_modules/@evidence-dev/component-utilities/src/checkInputs.js
function checkInputs(data, reqCols, optCols) {
  var _a, _b, _c, _d, _e;
  let columns = [];
  if (data == void 0) {
    throw Error("No dataset provided");
  } else if (typeof data !== "object") {
    throw Error(
      "'" + data + "' is not a recognized query result. Data should be provided in the format: data = {" + data.replace("data.", "") + "}"
    );
  } else if (data[0] == void 0) {
    throw Error(
      "Dataset is empty: query ran successfully, but no data was returned from the database"
    );
  }
  if (((_b = (_a = data[0]) == null ? void 0 : _a.error_object) == null ? void 0 : _b.error) != null) {
    throw Error("SQL Error: " + ((_e = (_d = (_c = data[0]) == null ? void 0 : _c.error_object) == null ? void 0 : _d.error) == null ? void 0 : _e.message));
  }
  if (reqCols != void 0) {
    if (!(reqCols instanceof Array)) {
      throw Error("reqCols must be passed in as an array");
    }
    for (var i = 0; i < reqCols.length; i++) {
      if (reqCols[i] == null) {
        throw Error("Missing required columns");
      }
    }
    for (const [key] of Object.entries(data[0])) {
      columns.push(key);
    }
    let currentCol;
    for (i = 0; i < reqCols.length; i++) {
      currentCol = reqCols[i];
      if (!columns.includes(currentCol)) {
        throw Error("'" + currentCol + "' is not a column in the dataset");
      }
    }
    if (optCols != void 0 && optCols[0] != null) {
      for (i = 0; i < optCols.length; i++) {
        currentCol = optCols[i];
        if (!columns.includes(currentCol)) {
          throw Error("'" + currentCol + "' is not a column in the dataset");
        }
      }
    }
  }
}

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/Chart.svelte
var { Error: Error_14, Object: Object_14, console: console_1 } = globals;
function create_else_block20(ctx) {
  let errorchart;
  let current;
  errorchart = new ErrorChart_default({
    props: {
      error: (
        /*error*/
        ctx[4]
      ),
      chartType: (
        /*chartType*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(errorchart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(errorchart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(errorchart, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const errorchart_changes = {};
      if (dirty[0] & /*error*/
      16)
        errorchart_changes.error = /*error*/
        ctx2[4];
      if (dirty[0] & /*chartType*/
      4)
        errorchart_changes.chartType = /*chartType*/
        ctx2[2];
      errorchart.$set(errorchart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(errorchart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(errorchart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(errorchart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block20.name,
    type: "else",
    source: "(825:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block45(ctx) {
  let t;
  let echarts;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[90].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[89],
    null
  );
  echarts = new ECharts_default({
    props: {
      config: (
        /*$config*/
        ctx[6]
      ),
      height: (
        /*height*/
        ctx[5]
      ),
      width: (
        /*width*/
        ctx[3]
      ),
      data: (
        /*data*/
        ctx[0]
      ),
      showAllXAxisLabels: (
        /*showAllXAxisLabels*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
      t = space();
      create_component(echarts.$$.fragment);
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
      t = claim_space(nodes);
      claim_component(echarts.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      mount_component(echarts, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[89],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[89]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[89],
              dirty,
              null
            ),
            null
          );
        }
      }
      const echarts_changes = {};
      if (dirty[0] & /*$config*/
      64)
        echarts_changes.config = /*$config*/
        ctx2[6];
      if (dirty[0] & /*height*/
      32)
        echarts_changes.height = /*height*/
        ctx2[5];
      if (dirty[0] & /*width*/
      8)
        echarts_changes.width = /*width*/
        ctx2[3];
      if (dirty[0] & /*data*/
      1)
        echarts_changes.data = /*data*/
        ctx2[0];
      if (dirty[0] & /*showAllXAxisLabels*/
      2)
        echarts_changes.showAllXAxisLabels = /*showAllXAxisLabels*/
        ctx2[1];
      echarts.$set(echarts_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(echarts.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(echarts.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(echarts, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block45.name,
    type: "if",
    source: "(822:0) {#if !error}",
    ctx
  });
  return block;
}
function create_fragment70(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block45, create_else_block20];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*error*/
    ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude67 = true;
function instance70($$self, $$props, $$invalidate) {
  let $config;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Chart", slots, ["default"]);
  let props = writable({});
  let config = writable({});
  validate_store(config, "config");
  component_subscribe($$self, config, (value) => $$invalidate(6, $config = value));
  let { data = void 0 } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { series = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { tooltipTitle = void 0 } = $$props;
  let { showAllXAxisLabels = false } = $$props;
  const ySet = y ? true : false;
  const xSet = x ? true : false;
  let { swapXY = false } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { chartType = "Chart" } = $$props;
  let { bubble = false } = $$props;
  let { hist = false } = $$props;
  let reqCols;
  let { xType = void 0 } = $$props;
  let { xAxisTitle = "false" } = $$props;
  let { xBaseline = true } = $$props;
  xBaseline = xBaseline === "true" || xBaseline === true;
  let { xTickMarks = false } = $$props;
  xTickMarks = xTickMarks === "true" || xTickMarks === true;
  let { xGridlines = false } = $$props;
  xGridlines = xGridlines === "true" || xGridlines === true;
  let { xAxisLabels = true } = $$props;
  xAxisLabels = xAxisLabels === "true" || xAxisLabels === true;
  let { sort = true } = $$props;
  sort = sort === "true" || sort === true;
  let { xFmt = void 0 } = $$props;
  let { yAxisTitle = "false" } = $$props;
  let { yBaseline = false } = $$props;
  yBaseline = yBaseline === "true" || yBaseline === true;
  let { yTickMarks = false } = $$props;
  yTickMarks = yTickMarks === "true" || yTickMarks === true;
  let { yGridlines = true } = $$props;
  yGridlines = yGridlines === "true" || yGridlines === true;
  let { yAxisLabels = true } = $$props;
  yAxisLabels = yAxisLabels === "true" || yAxisLabels === true;
  let { yMin = void 0 } = $$props;
  let { yMax = void 0 } = $$props;
  let { yFmt = void 0 } = $$props;
  let { sizeFmt = void 0 } = $$props;
  let { legend = void 0 } = $$props;
  let { options = void 0 } = $$props;
  let { stacked100 = false } = $$props;
  let { chartAreaHeight } = $$props;
  chartAreaHeight = Number(chartAreaHeight);
  if (isNaN(chartAreaHeight) || chartAreaHeight < 0) {
    chartAreaHeight = 180;
  }
  let columnSummary;
  let columnNames;
  let uColNames = [];
  let unusedColumns = [];
  let uColType;
  let uColName;
  let xDataType;
  let xMismatch;
  let xFormat;
  let yFormat;
  let sizeFormat;
  let xUnitSummary;
  let yUnitSummary;
  let xDistinct;
  let horizAxisConfig;
  let verticalAxisConfig;
  let horizAxisTitleConfig;
  let chartConfig;
  let hasTitle;
  let hasSubtitle;
  let hasLegend;
  let hasTopAxisTitle;
  let hasBottomAxisTitle;
  let titleFontSize;
  let subtitleFontSize;
  let titleBoxPadding;
  let titleBoxHeight;
  let chartAreaPaddingTop;
  let chartAreaPaddingBottom;
  let bottomAxisTitleSize;
  let topAxisTitleSize;
  let legendHeight;
  let legendPaddingTop;
  let legendTop;
  let chartTop;
  let chartBottom;
  let chartContainerHeight;
  let topAxisTitleTop;
  let horizAxisTitle;
  let maxBars;
  let barCount;
  let heightMultiplier;
  let height;
  let width;
  let missingCols = [];
  let originalRun = true;
  let inputCols = [];
  let optCols = [];
  let i;
  let error;
  let columnSummaryArray;
  let dateCols;
  $$self.$$.on_mount.push(function() {
    if (chartAreaHeight === void 0 && !("chartAreaHeight" in $$props || $$self.$$.bound[$$self.$$.props["chartAreaHeight"]])) {
      console_1.warn("<Chart> was created without expected prop 'chartAreaHeight'");
    }
  });
  const writable_props = [
    "data",
    "x",
    "y",
    "series",
    "size",
    "tooltipTitle",
    "showAllXAxisLabels",
    "swapXY",
    "title",
    "subtitle",
    "chartType",
    "bubble",
    "hist",
    "xType",
    "xAxisTitle",
    "xBaseline",
    "xTickMarks",
    "xGridlines",
    "xAxisLabels",
    "sort",
    "xFmt",
    "yAxisTitle",
    "yBaseline",
    "yTickMarks",
    "yGridlines",
    "yAxisLabels",
    "yMin",
    "yMax",
    "yFmt",
    "sizeFmt",
    "legend",
    "options",
    "stacked100",
    "chartAreaHeight"
  ];
  Object_14.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<Chart> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(8, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(9, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(25, series = $$props2.series);
    if ("size" in $$props2)
      $$invalidate(26, size = $$props2.size);
    if ("tooltipTitle" in $$props2)
      $$invalidate(27, tooltipTitle = $$props2.tooltipTitle);
    if ("showAllXAxisLabels" in $$props2)
      $$invalidate(1, showAllXAxisLabels = $$props2.showAllXAxisLabels);
    if ("swapXY" in $$props2)
      $$invalidate(10, swapXY = $$props2.swapXY);
    if ("title" in $$props2)
      $$invalidate(28, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(29, subtitle = $$props2.subtitle);
    if ("chartType" in $$props2)
      $$invalidate(2, chartType = $$props2.chartType);
    if ("bubble" in $$props2)
      $$invalidate(30, bubble = $$props2.bubble);
    if ("hist" in $$props2)
      $$invalidate(31, hist = $$props2.hist);
    if ("xType" in $$props2)
      $$invalidate(11, xType = $$props2.xType);
    if ("xAxisTitle" in $$props2)
      $$invalidate(12, xAxisTitle = $$props2.xAxisTitle);
    if ("xBaseline" in $$props2)
      $$invalidate(13, xBaseline = $$props2.xBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(14, xTickMarks = $$props2.xTickMarks);
    if ("xGridlines" in $$props2)
      $$invalidate(15, xGridlines = $$props2.xGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(16, xAxisLabels = $$props2.xAxisLabels);
    if ("sort" in $$props2)
      $$invalidate(17, sort = $$props2.sort);
    if ("xFmt" in $$props2)
      $$invalidate(32, xFmt = $$props2.xFmt);
    if ("yAxisTitle" in $$props2)
      $$invalidate(18, yAxisTitle = $$props2.yAxisTitle);
    if ("yBaseline" in $$props2)
      $$invalidate(19, yBaseline = $$props2.yBaseline);
    if ("yTickMarks" in $$props2)
      $$invalidate(20, yTickMarks = $$props2.yTickMarks);
    if ("yGridlines" in $$props2)
      $$invalidate(21, yGridlines = $$props2.yGridlines);
    if ("yAxisLabels" in $$props2)
      $$invalidate(22, yAxisLabels = $$props2.yAxisLabels);
    if ("yMin" in $$props2)
      $$invalidate(33, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(34, yMax = $$props2.yMax);
    if ("yFmt" in $$props2)
      $$invalidate(35, yFmt = $$props2.yFmt);
    if ("sizeFmt" in $$props2)
      $$invalidate(36, sizeFmt = $$props2.sizeFmt);
    if ("legend" in $$props2)
      $$invalidate(23, legend = $$props2.legend);
    if ("options" in $$props2)
      $$invalidate(37, options = $$props2.options);
    if ("stacked100" in $$props2)
      $$invalidate(38, stacked100 = $$props2.stacked100);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(24, chartAreaHeight = $$props2.chartAreaHeight);
    if ("$$scope" in $$props2)
      $$invalidate(89, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude67,
    writable,
    setContext,
    propKey,
    configKey,
    strictBuild,
    props,
    config,
    ECharts: ECharts_default,
    getColumnSummary,
    getDistinctValues,
    getStackPercentages,
    getSortedData,
    standardizeDateColumn,
    formatAxisValue,
    formatTitle,
    formatValue,
    getFormatObjectFromString,
    ErrorChart: ErrorChart_default,
    checkInputs,
    colours,
    data,
    x,
    y,
    series,
    size,
    tooltipTitle,
    showAllXAxisLabels,
    ySet,
    xSet,
    swapXY,
    title,
    subtitle,
    chartType,
    bubble,
    hist,
    reqCols,
    xType,
    xAxisTitle,
    xBaseline,
    xTickMarks,
    xGridlines,
    xAxisLabels,
    sort,
    xFmt,
    yAxisTitle,
    yBaseline,
    yTickMarks,
    yGridlines,
    yAxisLabels,
    yMin,
    yMax,
    yFmt,
    sizeFmt,
    legend,
    options,
    stacked100,
    chartAreaHeight,
    columnSummary,
    columnNames,
    uColNames,
    unusedColumns,
    uColType,
    uColName,
    xDataType,
    xMismatch,
    xFormat,
    yFormat,
    sizeFormat,
    xUnitSummary,
    yUnitSummary,
    xDistinct,
    horizAxisConfig,
    verticalAxisConfig,
    horizAxisTitleConfig,
    chartConfig,
    hasTitle,
    hasSubtitle,
    hasLegend,
    hasTopAxisTitle,
    hasBottomAxisTitle,
    titleFontSize,
    subtitleFontSize,
    titleBoxPadding,
    titleBoxHeight,
    chartAreaPaddingTop,
    chartAreaPaddingBottom,
    bottomAxisTitleSize,
    topAxisTitleSize,
    legendHeight,
    legendPaddingTop,
    legendTop,
    chartTop,
    chartBottom,
    chartContainerHeight,
    topAxisTitleTop,
    horizAxisTitle,
    maxBars,
    barCount,
    heightMultiplier,
    height,
    width,
    missingCols,
    originalRun,
    inputCols,
    optCols,
    i,
    error,
    columnSummaryArray,
    dateCols,
    $config
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(91, props = $$props2.props);
    if ("config" in $$props2)
      $$invalidate(7, config = $$props2.config);
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(8, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(9, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(25, series = $$props2.series);
    if ("size" in $$props2)
      $$invalidate(26, size = $$props2.size);
    if ("tooltipTitle" in $$props2)
      $$invalidate(27, tooltipTitle = $$props2.tooltipTitle);
    if ("showAllXAxisLabels" in $$props2)
      $$invalidate(1, showAllXAxisLabels = $$props2.showAllXAxisLabels);
    if ("swapXY" in $$props2)
      $$invalidate(10, swapXY = $$props2.swapXY);
    if ("title" in $$props2)
      $$invalidate(28, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(29, subtitle = $$props2.subtitle);
    if ("chartType" in $$props2)
      $$invalidate(2, chartType = $$props2.chartType);
    if ("bubble" in $$props2)
      $$invalidate(30, bubble = $$props2.bubble);
    if ("hist" in $$props2)
      $$invalidate(31, hist = $$props2.hist);
    if ("reqCols" in $$props2)
      $$invalidate(39, reqCols = $$props2.reqCols);
    if ("xType" in $$props2)
      $$invalidate(11, xType = $$props2.xType);
    if ("xAxisTitle" in $$props2)
      $$invalidate(12, xAxisTitle = $$props2.xAxisTitle);
    if ("xBaseline" in $$props2)
      $$invalidate(13, xBaseline = $$props2.xBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(14, xTickMarks = $$props2.xTickMarks);
    if ("xGridlines" in $$props2)
      $$invalidate(15, xGridlines = $$props2.xGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(16, xAxisLabels = $$props2.xAxisLabels);
    if ("sort" in $$props2)
      $$invalidate(17, sort = $$props2.sort);
    if ("xFmt" in $$props2)
      $$invalidate(32, xFmt = $$props2.xFmt);
    if ("yAxisTitle" in $$props2)
      $$invalidate(18, yAxisTitle = $$props2.yAxisTitle);
    if ("yBaseline" in $$props2)
      $$invalidate(19, yBaseline = $$props2.yBaseline);
    if ("yTickMarks" in $$props2)
      $$invalidate(20, yTickMarks = $$props2.yTickMarks);
    if ("yGridlines" in $$props2)
      $$invalidate(21, yGridlines = $$props2.yGridlines);
    if ("yAxisLabels" in $$props2)
      $$invalidate(22, yAxisLabels = $$props2.yAxisLabels);
    if ("yMin" in $$props2)
      $$invalidate(33, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(34, yMax = $$props2.yMax);
    if ("yFmt" in $$props2)
      $$invalidate(35, yFmt = $$props2.yFmt);
    if ("sizeFmt" in $$props2)
      $$invalidate(36, sizeFmt = $$props2.sizeFmt);
    if ("legend" in $$props2)
      $$invalidate(23, legend = $$props2.legend);
    if ("options" in $$props2)
      $$invalidate(37, options = $$props2.options);
    if ("stacked100" in $$props2)
      $$invalidate(38, stacked100 = $$props2.stacked100);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(24, chartAreaHeight = $$props2.chartAreaHeight);
    if ("columnSummary" in $$props2)
      $$invalidate(40, columnSummary = $$props2.columnSummary);
    if ("columnNames" in $$props2)
      $$invalidate(41, columnNames = $$props2.columnNames);
    if ("uColNames" in $$props2)
      $$invalidate(42, uColNames = $$props2.uColNames);
    if ("unusedColumns" in $$props2)
      $$invalidate(43, unusedColumns = $$props2.unusedColumns);
    if ("uColType" in $$props2)
      $$invalidate(44, uColType = $$props2.uColType);
    if ("uColName" in $$props2)
      $$invalidate(45, uColName = $$props2.uColName);
    if ("xDataType" in $$props2)
      $$invalidate(46, xDataType = $$props2.xDataType);
    if ("xMismatch" in $$props2)
      $$invalidate(47, xMismatch = $$props2.xMismatch);
    if ("xFormat" in $$props2)
      $$invalidate(48, xFormat = $$props2.xFormat);
    if ("yFormat" in $$props2)
      $$invalidate(49, yFormat = $$props2.yFormat);
    if ("sizeFormat" in $$props2)
      $$invalidate(50, sizeFormat = $$props2.sizeFormat);
    if ("xUnitSummary" in $$props2)
      $$invalidate(51, xUnitSummary = $$props2.xUnitSummary);
    if ("yUnitSummary" in $$props2)
      $$invalidate(52, yUnitSummary = $$props2.yUnitSummary);
    if ("xDistinct" in $$props2)
      $$invalidate(53, xDistinct = $$props2.xDistinct);
    if ("horizAxisConfig" in $$props2)
      $$invalidate(54, horizAxisConfig = $$props2.horizAxisConfig);
    if ("verticalAxisConfig" in $$props2)
      $$invalidate(55, verticalAxisConfig = $$props2.verticalAxisConfig);
    if ("horizAxisTitleConfig" in $$props2)
      $$invalidate(56, horizAxisTitleConfig = $$props2.horizAxisTitleConfig);
    if ("chartConfig" in $$props2)
      $$invalidate(57, chartConfig = $$props2.chartConfig);
    if ("hasTitle" in $$props2)
      $$invalidate(58, hasTitle = $$props2.hasTitle);
    if ("hasSubtitle" in $$props2)
      $$invalidate(59, hasSubtitle = $$props2.hasSubtitle);
    if ("hasLegend" in $$props2)
      $$invalidate(60, hasLegend = $$props2.hasLegend);
    if ("hasTopAxisTitle" in $$props2)
      $$invalidate(61, hasTopAxisTitle = $$props2.hasTopAxisTitle);
    if ("hasBottomAxisTitle" in $$props2)
      $$invalidate(62, hasBottomAxisTitle = $$props2.hasBottomAxisTitle);
    if ("titleFontSize" in $$props2)
      $$invalidate(63, titleFontSize = $$props2.titleFontSize);
    if ("subtitleFontSize" in $$props2)
      $$invalidate(64, subtitleFontSize = $$props2.subtitleFontSize);
    if ("titleBoxPadding" in $$props2)
      $$invalidate(65, titleBoxPadding = $$props2.titleBoxPadding);
    if ("titleBoxHeight" in $$props2)
      $$invalidate(66, titleBoxHeight = $$props2.titleBoxHeight);
    if ("chartAreaPaddingTop" in $$props2)
      $$invalidate(67, chartAreaPaddingTop = $$props2.chartAreaPaddingTop);
    if ("chartAreaPaddingBottom" in $$props2)
      $$invalidate(68, chartAreaPaddingBottom = $$props2.chartAreaPaddingBottom);
    if ("bottomAxisTitleSize" in $$props2)
      $$invalidate(69, bottomAxisTitleSize = $$props2.bottomAxisTitleSize);
    if ("topAxisTitleSize" in $$props2)
      $$invalidate(70, topAxisTitleSize = $$props2.topAxisTitleSize);
    if ("legendHeight" in $$props2)
      $$invalidate(71, legendHeight = $$props2.legendHeight);
    if ("legendPaddingTop" in $$props2)
      $$invalidate(72, legendPaddingTop = $$props2.legendPaddingTop);
    if ("legendTop" in $$props2)
      $$invalidate(73, legendTop = $$props2.legendTop);
    if ("chartTop" in $$props2)
      $$invalidate(74, chartTop = $$props2.chartTop);
    if ("chartBottom" in $$props2)
      $$invalidate(75, chartBottom = $$props2.chartBottom);
    if ("chartContainerHeight" in $$props2)
      $$invalidate(76, chartContainerHeight = $$props2.chartContainerHeight);
    if ("topAxisTitleTop" in $$props2)
      $$invalidate(77, topAxisTitleTop = $$props2.topAxisTitleTop);
    if ("horizAxisTitle" in $$props2)
      $$invalidate(78, horizAxisTitle = $$props2.horizAxisTitle);
    if ("maxBars" in $$props2)
      $$invalidate(79, maxBars = $$props2.maxBars);
    if ("barCount" in $$props2)
      $$invalidate(80, barCount = $$props2.barCount);
    if ("heightMultiplier" in $$props2)
      $$invalidate(81, heightMultiplier = $$props2.heightMultiplier);
    if ("height" in $$props2)
      $$invalidate(5, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("missingCols" in $$props2)
      $$invalidate(82, missingCols = $$props2.missingCols);
    if ("originalRun" in $$props2)
      $$invalidate(83, originalRun = $$props2.originalRun);
    if ("inputCols" in $$props2)
      $$invalidate(84, inputCols = $$props2.inputCols);
    if ("optCols" in $$props2)
      $$invalidate(85, optCols = $$props2.optCols);
    if ("i" in $$props2)
      $$invalidate(86, i = $$props2.i);
    if ("error" in $$props2)
      $$invalidate(4, error = $$props2.error);
    if ("columnSummaryArray" in $$props2)
      $$invalidate(87, columnSummaryArray = $$props2.columnSummaryArray);
    if ("dateCols" in $$props2)
      $$invalidate(88, dateCols = $$props2.dateCols);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*swapXY*/
    1024) {
      $:
        if (swapXY === "true" || swapXY === true) {
          $$invalidate(10, swapXY = true);
        } else {
          $$invalidate(10, swapXY = false);
        }
    }
    if ($$self.$$.dirty[0] & /*data, x, series, size, bubble, y, tooltipTitle, xType, swapXY, sort, xAxisTitle, yAxisTitle, legend, chartAreaHeight, chartType, yAxisLabels, yGridlines, yBaseline, yTickMarks, xGridlines, xBaseline, xTickMarks, xAxisLabels, title, subtitle, width, error*/
    2147483421 | $$self.$$.dirty[1] & /*columnSummary, columnNames, uColNames, uColName, uColType, unusedColumns, hist, reqCols, stacked100, xDataType, xFmt, yFmt, sizeFmt, xFormat, yFormat, sizeFormat, xMismatch, yMin, yUnitSummary, yMax, xUnitSummary, hasSubtitle, hasTitle, hasLegend, hasTopAxisTitle, xDistinct, horizAxisConfig, verticalAxisConfig, horizAxisTitleConfig, options, chartConfig*/
    2147483647 | $$self.$$.dirty[2] & /*missingCols, originalRun, inputCols, i, optCols, columnSummaryArray, dateCols, titleFontSize, subtitleFontSize, titleBoxPadding, legendHeight, legendPaddingTop, titleBoxHeight, legendTop, topAxisTitleSize, chartAreaPaddingTop, hasBottomAxisTitle, bottomAxisTitleSize, chartAreaPaddingBottom, chartTop, chartBottom, barCount, maxBars, chartContainerHeight, heightMultiplier, horizAxisTitle, topAxisTitleTop*/
    134217727) {
      $: {
        try {
          $$invalidate(4, error = void 0);
          $$invalidate(82, missingCols = []);
          $$invalidate(43, unusedColumns = []);
          $$invalidate(84, inputCols = []);
          $$invalidate(85, optCols = []);
          $$invalidate(45, uColName = []);
          checkInputs(data);
          $$invalidate(40, columnSummary = getColumnSummary(data));
          $$invalidate(41, columnNames = Object.keys(columnSummary));
          if (!xSet) {
            $$invalidate(8, x = columnNames[0]);
          }
          if (!ySet) {
            $$invalidate(42, uColNames = columnNames.filter(function(col) {
              return ![x, series, size].includes(col);
            }));
            for (let i2 = 0; i2 < uColNames.length; i2++) {
              $$invalidate(45, uColName = uColNames[i2]);
              $$invalidate(44, uColType = columnSummary[uColName].type);
              if (uColType === "number") {
                unusedColumns.push(uColName);
              }
            }
            $$invalidate(9, y = unusedColumns.length > 1 ? unusedColumns : unusedColumns[0]);
          }
          if (bubble) {
            $$invalidate(39, reqCols = { x, y, size });
          } else if (hist) {
            $$invalidate(39, reqCols = { x });
          } else {
            $$invalidate(39, reqCols = { x, y });
          }
          for (let property in reqCols) {
            if (reqCols[property] == null) {
              missingCols.push(property);
            }
          }
          if (missingCols.length === 1) {
            throw Error(new Intl.ListFormat().format(missingCols) + " is required");
          } else if (missingCols.length > 1) {
            throw Error(new Intl.ListFormat().format(missingCols) + " are required");
          }
          if (stacked100 === true && y.includes("_pct") && originalRun === false) {
            if (typeof y === "object") {
              for (let i2 = 0; i2 < y.length; i2++) {
                $$invalidate(9, y[i2] = y[i2].replace("_pct", ""), y);
              }
              $$invalidate(83, originalRun = false);
            } else {
              $$invalidate(9, y = y.replace("_pct", ""));
              $$invalidate(83, originalRun = false);
            }
          }
          if (x) {
            inputCols.push(x);
          }
          if (y) {
            if (typeof y === "object") {
              for ($$invalidate(86, i = 0); i < y.length; $$invalidate(86, i++, i)) {
                inputCols.push(y[i]);
              }
            } else {
              inputCols.push(y);
            }
          }
          if (size) {
            inputCols.push(size);
          }
          if (series) {
            optCols.push(series);
          }
          if (tooltipTitle) {
            optCols.push(tooltipTitle);
          }
          checkInputs(data, inputCols, optCols);
          if (stacked100 === true) {
            $$invalidate(0, data = getStackPercentages(data, x, y));
            if (typeof y === "object") {
              for (let i2 = 0; i2 < y.length; i2++) {
                $$invalidate(9, y[i2] = y[i2] + "_pct", y);
              }
              $$invalidate(83, originalRun = false);
            } else {
              $$invalidate(9, y = y + "_pct");
              $$invalidate(83, originalRun = false);
            }
            $$invalidate(40, columnSummary = getColumnSummary(data));
          }
          $$invalidate(46, xDataType = columnSummary[x].type);
          switch (xDataType) {
            case "number":
              $$invalidate(46, xDataType = "value");
              break;
            case "string":
              $$invalidate(46, xDataType = "category");
              break;
            case "date":
              $$invalidate(46, xDataType = "time");
              break;
            default:
              break;
          }
          $$invalidate(11, xType = xType === "category" ? "category" : xDataType);
          if (swapXY && xType !== "category") {
            throw Error("Horizontal charts do not support a value or time-based x-axis. You can either change your SQL query to output string values or set swapXY=false.");
          }
          if (swapXY) {
            $$invalidate(11, xType = "category");
          }
          $$invalidate(47, xMismatch = xDataType === "value" && xType === "category");
          $$invalidate(0, data = sort ? xDataType === "category" ? getSortedData(data, y, false) : getSortedData(data, x, true) : data);
          if (xDataType === "time") {
            $$invalidate(0, data = getSortedData(data, x, true));
          }
          $$invalidate(87, columnSummaryArray = getColumnSummary(data, "array"));
          $$invalidate(88, dateCols = columnSummaryArray.filter((d) => d.type === "date"));
          $$invalidate(88, dateCols = dateCols.map((d) => d.id));
          if (dateCols.length > 0) {
            for (let i2 = 0; i2 < dateCols.length; i2++) {
              $$invalidate(0, data = standardizeDateColumn(data, dateCols[i2]));
            }
          }
          if (xFmt) {
            $$invalidate(48, xFormat = getFormatObjectFromString(xFmt, columnSummary[x].format.valueType));
          } else {
            $$invalidate(48, xFormat = columnSummary[x].format);
          }
          if (!y) {
            $$invalidate(49, yFormat = "str");
          } else {
            if (yFmt) {
              if (typeof y === "object") {
                $$invalidate(49, yFormat = getFormatObjectFromString(yFmt, columnSummary[y[0]].format.valueType));
              } else {
                $$invalidate(49, yFormat = getFormatObjectFromString(yFmt, columnSummary[y].format.valueType));
              }
            } else {
              if (typeof y === "object") {
                $$invalidate(49, yFormat = columnSummary[y[0]].format);
              } else {
                $$invalidate(49, yFormat = columnSummary[y].format);
              }
            }
          }
          if (size) {
            if (sizeFmt) {
              $$invalidate(50, sizeFormat = getFormatObjectFromString(sizeFmt, columnSummary[size].format.valueType));
            } else {
              $$invalidate(50, sizeFormat = columnSummary[size].format);
            }
          }
          $$invalidate(51, xUnitSummary = columnSummary[x].columnUnitSummary);
          if (y) {
            if (typeof y === "object") {
              $$invalidate(52, yUnitSummary = columnSummary[y[0]].columnUnitSummary);
            } else {
              $$invalidate(52, yUnitSummary = columnSummary[y].columnUnitSummary);
            }
          }
          $$invalidate(12, xAxisTitle = xAxisTitle === "true" ? formatTitle(x, xFormat) : xAxisTitle === "false" ? "" : xAxisTitle);
          $$invalidate(18, yAxisTitle = yAxisTitle === "true" ? typeof y === "object" ? "" : formatTitle(y, yFormat) : yAxisTitle === "false" ? "" : yAxisTitle);
          if (legend !== void 0) {
            $$invalidate(23, legend = legend === "true" || legend === true);
          }
          $$invalidate(23, legend = legend ?? (series != void 0 || typeof y === "object"));
          props.update((d) => {
            return {
              ...d,
              data,
              x,
              y,
              series,
              swapXY,
              sort,
              xType,
              xFormat,
              yFormat,
              sizeFormat,
              xMismatch,
              size,
              yMin,
              columnSummary,
              xAxisTitle,
              yAxisTitle,
              tooltipTitle,
              chartAreaHeight,
              chartType
            };
          });
          $$invalidate(53, xDistinct = getDistinctValues(data, x));
          if (swapXY) {
            $$invalidate(54, horizAxisConfig = {
              type: "value",
              position: "top",
              axisLabel: {
                show: yAxisLabels,
                hideOverlap: true,
                showMaxLabel: true,
                formatter(value) {
                  return formatAxisValue(value, yFormat, yUnitSummary);
                },
                margin: 4
              },
              min: yMin,
              max: yMax,
              splitLine: { show: yGridlines },
              axisLine: { show: yBaseline, onZero: false },
              axisTick: { show: yTickMarks },
              boundaryGap: false,
              z: 2
            });
          } else {
            $$invalidate(54, horizAxisConfig = {
              type: xType,
              splitLine: { show: xGridlines },
              axisLine: { show: xBaseline },
              axisTick: { show: xTickMarks },
              axisLabel: {
                show: xAxisLabels,
                hideOverlap: true,
                showMaxLabel: xType === "category" || xType === "value",
                // max label for ECharts' time axis is a stub - default for that is false
                formatter: xType === "time" ? false : function(value) {
                  return formatAxisValue(value, xFormat, xUnitSummary);
                },
                margin: 6
              },
              scale: true,
              z: 2
            });
          }
          if (swapXY) {
            $$invalidate(55, verticalAxisConfig = {
              type: xType,
              inverse: "true",
              splitLine: { show: xGridlines },
              axisLine: { show: xBaseline },
              axisTick: { show: xTickMarks },
              axisLabel: { show: xAxisLabels, hideOverlap: true },
              // formatter:
              //     function(value){
              //         return formatAxisValue(value, xFormat, xUnitSummary)
              //     },
              scale: true,
              z: 2
            });
          } else {
            $$invalidate(55, verticalAxisConfig = {
              type: "value",
              splitLine: { show: yGridlines },
              axisLine: { show: yBaseline, onZero: false },
              axisTick: { show: yTickMarks },
              axisLabel: {
                show: yAxisLabels,
                hideOverlap: true,
                margin: 4,
                formatter(value) {
                  return formatAxisValue(value, yFormat, yUnitSummary);
                }
              },
              name: yAxisTitle,
              nameLocation: "end",
              nameTextStyle: {
                align: "left",
                verticalAlign: "top",
                backgroundColor: "white",
                padding: [0, 5, 0, 0]
              },
              nameGap: 6,
              min: yMin,
              max: yMax,
              boundaryGap: ["0%", "1%"],
              z: 2
            });
          }
          $$invalidate(58, hasTitle = title ? true : false);
          $$invalidate(59, hasSubtitle = subtitle ? true : false);
          $$invalidate(60, hasLegend = legend * (series !== null || typeof y === "object" && y.length > 1));
          $$invalidate(61, hasTopAxisTitle = yAxisTitle !== "" && swapXY);
          $$invalidate(62, hasBottomAxisTitle = xAxisTitle !== "" && !swapXY);
          $$invalidate(63, titleFontSize = 15);
          $$invalidate(64, subtitleFontSize = 13);
          $$invalidate(65, titleBoxPadding = 6 * hasSubtitle);
          $$invalidate(66, titleBoxHeight = hasTitle * titleFontSize + hasSubtitle * subtitleFontSize + titleBoxPadding * Math.max(hasTitle, hasSubtitle));
          $$invalidate(67, chartAreaPaddingTop = 10);
          $$invalidate(68, chartAreaPaddingBottom = 8);
          $$invalidate(69, bottomAxisTitleSize = 14);
          $$invalidate(70, topAxisTitleSize = 14 + 0);
          $$invalidate(71, legendHeight = 15);
          $$invalidate(71, legendHeight = legendHeight * hasLegend);
          $$invalidate(72, legendPaddingTop = 7);
          $$invalidate(72, legendPaddingTop = legendPaddingTop * Math.max(hasTitle, hasSubtitle));
          $$invalidate(73, legendTop = titleBoxHeight + legendPaddingTop);
          $$invalidate(74, chartTop = legendTop + legendHeight + topAxisTitleSize * hasTopAxisTitle + chartAreaPaddingTop);
          $$invalidate(75, chartBottom = hasBottomAxisTitle * bottomAxisTitleSize + chartAreaPaddingBottom);
          $$invalidate(76, chartContainerHeight = chartAreaHeight + chartTop + chartBottom);
          $$invalidate(77, topAxisTitleTop = legendTop + legendHeight + 7);
          $$invalidate(79, maxBars = 6);
          $$invalidate(81, heightMultiplier = 1);
          if (swapXY) {
            $$invalidate(80, barCount = xDistinct.length);
            $$invalidate(81, heightMultiplier = Math.max(1, barCount / maxBars));
          }
          $$invalidate(5, height = chartContainerHeight * heightMultiplier + "px");
          $$invalidate(3, width = "100%");
          $$invalidate(78, horizAxisTitle = swapXY ? yAxisTitle : xAxisTitle);
          if (horizAxisTitle !== "") {
            $$invalidate(78, horizAxisTitle = horizAxisTitle + " ");
          }
          $$invalidate(56, horizAxisTitleConfig = {
            id: "horiz-axis-title",
            type: "text",
            style: {
              text: horizAxisTitle,
              textAlign: "right",
              fill: colours.grey500
            },
            cursor: "auto",
            // Positioning (if swapXY, top right; otherwise bottom right)
            right: swapXY ? "2%" : "3%",
            top: swapXY ? topAxisTitleTop : null,
            bottom: swapXY ? null : "2%"
          });
          $$invalidate(57, chartConfig = {
            title: {
              text: title,
              subtext: subtitle,
              subtextStyle: { width }
            },
            tooltip: {
              trigger: "axis",
              // formatter function is overridden in ScatterPlot, BubbleChart, and Histogram
              formatter(params) {
                let output;
                let xVal;
                let yVal;
                let yCol;
                if (params.length > 1) {
                  xVal = params[0].value[swapXY ? 1 : 0];
                  output = `<span id="tooltip" style='font-weight: 600;'>${formatValue(xVal, xFormat)}</span>`;
                  for (let i2 = params.length - 1; i2 >= 0; i2--) {
                    yVal = params[i2].value[swapXY ? 0 : 1];
                    output = output + `<br> ${params[i2].marker} ${params[i2].seriesName} <span style='float:right; margin-left: 10px;'>${formatValue(yVal, yFormat)}</span>`;
                  }
                } else if (xType === "value") {
                  xVal = params[0].value[swapXY ? 1 : 0];
                  yVal = params[0].value[swapXY ? 0 : 1];
                  yCol = params[0].seriesName;
                  output = `<span id="tooltip" style='font-weight: 600;'>${formatTitle(x, xFormat)}: </span><span style='float:right; margin-left: 10px;'>${formatValue(xVal, xFormat)}</span><br/><span style='font-weight: 600;'>${formatTitle(yCol, yFormat)}: </span><span style='float:right; margin-left: 10px;'>${formatValue(yVal, yFormat)}</span>`;
                } else {
                  xVal = params[0].value[swapXY ? 1 : 0];
                  yVal = params[0].value[swapXY ? 0 : 1];
                  yCol = params[0].seriesName;
                  output = `<span id="tooltip" style='font-weight: 600;'>${formatValue(xVal, xFormat)}</span><br/><span>${formatTitle(yCol, yFormat)}: </span><span style='float:right; margin-left: 10px;'>${formatValue(yVal, yFormat)}</span>`;
                }
                return output;
              },
              confine: true,
              axisPointer: {
                // Use axis to trigger tooltip
                type: "shadow"
                // 'shadow' as default; can also be 'line' or 'shadow'
              },
              padding: 6,
              borderRadius: 4,
              borderWidth: 1,
              borderColor: colours.grey400,
              backgroundColor: "white",
              extraCssText: "box-shadow: 0 3px 6px rgba(0,0,0,.15); box-shadow: 0 2px 4px rgba(0,0,0,.12); z-index: 1;",
              textStyle: {
                color: colours.grey900,
                fontSize: 12,
                fontWeight: 400
              },
              order: "valueDesc"
            },
            legend: {
              show: legend,
              type: "scroll",
              top: legendTop,
              padding: [0, 0, 0, 0]
            },
            grid: {
              left: "0.5%",
              right: swapXY ? "4%" : "3%",
              bottom: chartBottom,
              top: chartTop,
              containLabel: true
            },
            xAxis: horizAxisConfig,
            yAxis: verticalAxisConfig,
            series: [],
            animation: true,
            graphic: horizAxisTitleConfig
          });
          if (options) {
            $$invalidate(57, chartConfig = { ...chartConfig, ...options });
          }
          config.update(() => {
            return chartConfig;
          });
        } catch (e) {
          $$invalidate(4, error = e.message);
          console.error(e);
          if (strictBuild) {
            throw error;
          }
          props.update((d) => {
            return { ...d, error };
          });
        }
      }
    }
    if ($$self.$$.dirty[0] & /*data*/
    1) {
      $:
        data;
    }
  };
  $:
    setContext(propKey, props);
  $:
    setContext(configKey, config);
  return [
    data,
    showAllXAxisLabels,
    chartType,
    width,
    error,
    height,
    $config,
    config,
    x,
    y,
    swapXY,
    xType,
    xAxisTitle,
    xBaseline,
    xTickMarks,
    xGridlines,
    xAxisLabels,
    sort,
    yAxisTitle,
    yBaseline,
    yTickMarks,
    yGridlines,
    yAxisLabels,
    legend,
    chartAreaHeight,
    series,
    size,
    tooltipTitle,
    title,
    subtitle,
    bubble,
    hist,
    xFmt,
    yMin,
    yMax,
    yFmt,
    sizeFmt,
    options,
    stacked100,
    reqCols,
    columnSummary,
    columnNames,
    uColNames,
    unusedColumns,
    uColType,
    uColName,
    xDataType,
    xMismatch,
    xFormat,
    yFormat,
    sizeFormat,
    xUnitSummary,
    yUnitSummary,
    xDistinct,
    horizAxisConfig,
    verticalAxisConfig,
    horizAxisTitleConfig,
    chartConfig,
    hasTitle,
    hasSubtitle,
    hasLegend,
    hasTopAxisTitle,
    hasBottomAxisTitle,
    titleFontSize,
    subtitleFontSize,
    titleBoxPadding,
    titleBoxHeight,
    chartAreaPaddingTop,
    chartAreaPaddingBottom,
    bottomAxisTitleSize,
    topAxisTitleSize,
    legendHeight,
    legendPaddingTop,
    legendTop,
    chartTop,
    chartBottom,
    chartContainerHeight,
    topAxisTitleTop,
    horizAxisTitle,
    maxBars,
    barCount,
    heightMultiplier,
    missingCols,
    originalRun,
    inputCols,
    optCols,
    i,
    columnSummaryArray,
    dateCols,
    $$scope,
    slots
  ];
}
var Chart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance70,
      create_fragment70,
      safe_not_equal,
      {
        data: 0,
        x: 8,
        y: 9,
        series: 25,
        size: 26,
        tooltipTitle: 27,
        showAllXAxisLabels: 1,
        swapXY: 10,
        title: 28,
        subtitle: 29,
        chartType: 2,
        bubble: 30,
        hist: 31,
        xType: 11,
        xAxisTitle: 12,
        xBaseline: 13,
        xTickMarks: 14,
        xGridlines: 15,
        xAxisLabels: 16,
        sort: 17,
        xFmt: 32,
        yAxisTitle: 18,
        yBaseline: 19,
        yTickMarks: 20,
        yGridlines: 21,
        yAxisLabels: 22,
        yMin: 33,
        yMax: 34,
        yFmt: 35,
        sizeFmt: 36,
        legend: 23,
        options: 37,
        stacked100: 38,
        chartAreaHeight: 24
      },
      null,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Chart",
      options,
      id: create_fragment70.name
    });
  }
  get data() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get series() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set series(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTitle() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTitle(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showAllXAxisLabels() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showAllXAxisLabels(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swapXY() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swapXY(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chartType() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chartType(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bubble() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bubble(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hist() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hist(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xType() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xType(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisTitle() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisTitle(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xBaseline() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xBaseline(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xTickMarks() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xTickMarks(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xGridlines() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xGridlines(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisLabels() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisLabels(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sort() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sort(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xFmt() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xFmt(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisTitle() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisTitle(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yBaseline() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yBaseline(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yTickMarks() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yTickMarks(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yGridlines() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yGridlines(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisLabels() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisLabels(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMin() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMin(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMax() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMax(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yFmt() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yFmt(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sizeFmt() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sizeFmt(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stacked100() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stacked100(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chartAreaHeight() {
    throw new Error_14("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chartAreaHeight(value) {
    throw new Error_14("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Chart_default = Chart;

// ../../node_modules/@evidence-dev/component-utilities/src/getSeriesConfig.js
function getSeriesConfig(data, x, y, series, swapXY, baseConfig, name, xMismatch, columnSummary, size = null, tooltipTitle = null) {
  function generateTempConfig(seriesData2, seriesName2, baseConfig2) {
    let tempConfig2 = {
      name: seriesName2,
      data: seriesData2
    };
    tempConfig2 = { ...baseConfig2, ...tempConfig2 };
    return tempConfig2;
  }
  let i;
  let j;
  let tempConfig;
  let seriesConfig = [];
  let seriesData;
  let filteredData;
  let seriesName;
  let seriesDistinct;
  if (series != null && typeof y !== "object") {
    seriesDistinct = getDistinctValues(data, series);
    for (i = 0; i < seriesDistinct.length; i++) {
      filteredData = data.filter((d) => d[series] === seriesDistinct[i]);
      if (swapXY) {
        seriesData = filteredData.map((d) => [d[y], xMismatch ? d[x].toString() : d[x]]);
      } else {
        seriesData = filteredData.map((d) => [xMismatch ? d[x].toString() : d[x], d[y]]);
      }
      if (size) {
        let sizeData = filteredData.map((d) => d[size]);
        seriesData.forEach((item, index) => item.push(sizeData[index]));
      }
      if (tooltipTitle) {
        let tooltipData = filteredData.map((d) => d[tooltipTitle]);
        seriesData.forEach((item, index) => item.push(tooltipData[index]));
      }
      seriesName = seriesDistinct[i] ?? "null";
      tempConfig = generateTempConfig(seriesData, seriesName, baseConfig);
      seriesConfig.push(tempConfig);
    }
  }
  if (series != null && typeof y === "object" && y.length > 1) {
    seriesDistinct = getDistinctValues(data, series);
    for (i = 0; i < seriesDistinct.length; i++) {
      filteredData = data.filter((d) => d[series] === seriesDistinct[i]);
      for (j = 0; j < y.length; j++) {
        if (swapXY) {
          seriesData = filteredData.map((d) => [d[y[j]], xMismatch ? d[x].toString() : d[x]]);
        } else {
          seriesData = filteredData.map((d) => [xMismatch ? d[x].toString() : d[x], d[y[j]]]);
        }
        if (size) {
          let sizeData = filteredData.map((d) => d[size]);
          seriesData.forEach((item, index) => item.push(sizeData[index]));
        }
        if (tooltipTitle) {
          let tooltipData = filteredData.map((d) => d[tooltipTitle]);
          seriesData.forEach((item, index) => item.push(tooltipData[index]));
        }
        seriesName = (seriesDistinct[i] ?? "null") + " - " + columnSummary[y[j]].title;
        tempConfig = generateTempConfig(seriesData, seriesName, baseConfig);
        seriesConfig.push(tempConfig);
      }
    }
  }
  if (series == null && typeof y === "object" && y.length > 1) {
    for (i = 0; i < y.length; i++) {
      if (swapXY) {
        seriesData = data.map((d) => [d[y[i]], xMismatch ? d[x].toString() : d[x]]);
      } else {
        seriesData = data.map((d) => [xMismatch ? d[x].toString() : d[x], d[y[i]]]);
      }
      if (size) {
        let sizeData = data.map((d) => d[size]);
        seriesData.forEach((item, index) => item.push(sizeData[index]));
      }
      if (tooltipTitle) {
        let tooltipData = data.map((d) => d[tooltipTitle]);
        seriesData.forEach((item, index) => item.push(tooltipData[index]));
      }
      seriesName = columnSummary[y[i]].title;
      tempConfig = generateTempConfig(seriesData, seriesName, baseConfig);
      seriesConfig.push(tempConfig);
    }
  }
  if (series == null && typeof y !== "object") {
    if (swapXY) {
      seriesData = data.map((d) => [d[y], xMismatch ? d[x].toString() : d[x]]);
    } else {
      seriesData = data.map((d) => [xMismatch ? d[x].toString() : d[x], d[y]]);
    }
    if (size) {
      let sizeData = data.map((d) => d[size]);
      seriesData.forEach((item, index) => item.push(sizeData[index]));
    }
    if (tooltipTitle) {
      let tooltipData = data.map((d) => d[tooltipTitle]);
      seriesData.forEach((item, index) => item.push(tooltipData[index]));
    }
    seriesName = columnSummary[y].title;
    tempConfig = generateTempConfig(seriesData, seriesName, baseConfig);
    seriesConfig.push(tempConfig);
  }
  return seriesConfig;
}

// ../../node_modules/@evidence-dev/component-utilities/src/replaceNulls.js
function replaceNulls(data, columns) {
  let colObj = {};
  if (typeof columns === "object") {
    for (let i = 0; i < columns.length; i++) {
      colObj[columns[i]] = 0;
    }
  } else {
    colObj[columns] = 0;
  }
  data = tidy(data, replaceNully(colObj));
  return data;
}

// ../../node_modules/@evidence-dev/component-utilities/src/helpers/getCompletedData.helpers.js
function getDiffs(arr) {
  let diffs = [];
  for (let i = 1; i < arr.length; i++)
    diffs.push(arr[i] - arr[i - 1]);
  return diffs;
}
function gcd(a, b) {
  if (typeof a !== "number" || isNaN(a))
    a = 0;
  if (typeof b !== "number" || isNaN(b))
    b = 0;
  a = Math.abs(a);
  b = Math.abs(b);
  if (b <= 0.01) {
    return a;
  } else {
    return gcd(b, a % b);
  }
}
function extent(values, valueof) {
  if (!Array.isArray(values))
    throw new TypeError("Cannot calculate extent of non-array value.");
  let min2;
  let max2;
  if (valueof === void 0) {
    for (const value of values) {
      if (typeof value !== "number")
        continue;
      if (min2 === void 0) {
        if (value >= value)
          min2 = max2 = value;
      } else {
        if (min2 > value)
          min2 = value;
        if (max2 < value)
          max2 = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (typeof value !== "number")
        continue;
      if ((value = valueof(value, ++index, values)) != null) {
        if (min2 === void 0) {
          if (value >= value)
            min2 = max2 = value;
        } else {
          if (min2 > value)
            min2 = value;
          if (max2 < value)
            max2 = value;
        }
      }
    }
  }
  return [min2, max2];
}
function vectorSeq(values, period) {
  let [min2, max2] = extent(values);
  const sequence = [];
  let value = min2;
  while (value <= max2) {
    sequence.push(Math.round((value + Number.EPSILON) * 1e8) / 1e8);
    value += period;
  }
  return sequence;
}
function findInterval(arr) {
  if (arr.length <= 1) {
    return;
  }
  arr.sort(function(a, b) {
    return a - b;
  });
  arr = arr.map(function(x) {
    return x * 1e8;
  });
  arr = getDiffs(arr);
  let interval = arr.reduce((a, b) => gcd(a, b)) / 1e8;
  interval = Math.round((interval + Number.EPSILON) * 1e8) / 1e8;
  return interval;
}

// ../../node_modules/@evidence-dev/component-utilities/src/getCompletedData.js
function getCompletedData(data, x, y, series, nullsZero = false, fillX = false) {
  var _a, _b;
  const groups = Array.from(data).reduce((a, v) => {
    if (series) {
      if (!a[v[series]])
        a[v[series]] = [];
      a[v[series]].push(v);
    } else {
      if (!a.default)
        a.default = [];
      a.default.push(v);
    }
    return a;
  }, {});
  const expandKeys = {};
  const xIsDate = ((_a = data[0]) == null ? void 0 : _a[x]) instanceof Date;
  let xDistinct;
  const exampleX = (_b = data[0]) == null ? void 0 : _b[x];
  switch (typeof exampleX) {
    case "object":
      if (!(exampleX instanceof Date)) {
        throw new Error("Unexpected object property, expected string, date, or number");
      }
      xDistinct = getDistinctValues(
        data.map((d) => ({ [x]: d[x].getTime() })),
        x
      );
      break;
    case "number":
      xDistinct = getDistinctValues(data, x);
      if (fillX) {
        const interval = findInterval(xDistinct);
        expandKeys[x] = vectorSeq(xDistinct, interval);
      }
      break;
    case "string":
      xDistinct = getDistinctValues(data, x);
      expandKeys[x] = xDistinct;
      break;
  }
  const output = [];
  for (const value of Object.values(groups)) {
    const nullySpec = series ? { [series]: null } : {};
    if (nullsZero) {
      nullySpec[y] = 0;
    } else {
      nullySpec[y] = null;
    }
    if (series) {
      expandKeys[series] = series;
    }
    const tidyFuncs = [];
    if (Object.keys(expandKeys).length === 0) {
      tidyFuncs.push(complete([x], nullySpec));
    } else {
      tidyFuncs.push(complete(expandKeys, nullySpec));
    }
    if (xIsDate) {
      tidyFuncs.push(
        mutate({
          [x]: (val) => new Date(val[x])
        })
      );
    }
    output.push(tidy(value, ...tidyFuncs));
  }
  return output.flat();
}

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/Area.svelte
function create_fragment71(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude68 = true;
function instance71($$self, $$props, $$invalidate) {
  let data;
  let x;
  let swapXY;
  let xType;
  let xMismatch;
  let columnSummary;
  let baseConfig;
  let seriesConfig;
  let chartOverrides;
  let $props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Area", slots, []);
  let props = getContext(propKey);
  validate_store(props, "props");
  component_subscribe($$self, props, (value) => $$invalidate(22, $props = value));
  let config = getContext(configKey);
  let { y = void 0 } = $$props;
  const ySet = y ? true : false;
  let { series = void 0 } = $$props;
  const seriesSet = series ? true : false;
  let { options = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { type = "stacked" } = $$props;
  let { fillColor = void 0 } = $$props;
  let { lineColor = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { line = true } = $$props;
  let { handleMissing = "gap" } = $$props;
  let { step = false } = $$props;
  let { stepPosition = "end" } = $$props;
  let stackName;
  beforeUpdate(() => {
    config.update((d) => {
      d.tooltip = { ...d.tooltip, order: "seriesDesc" };
      if (swapXY) {
        d.yAxis = { ...d.yAxis, ...chartOverrides.xAxis };
        d.xAxis = { ...d.xAxis, ...chartOverrides.yAxis };
      } else {
        d.yAxis = { ...d.yAxis, ...chartOverrides.yAxis };
        d.xAxis = { ...d.xAxis, ...chartOverrides.xAxis };
      }
      if (type === "stacked100") {
        if (swapXY) {
          d.xAxis = { ...d.xAxis, max: 1 };
        } else {
          d.yAxis = { ...d.yAxis, max: 1 };
        }
      }
      return d;
    });
  });
  const writable_props = [
    "y",
    "series",
    "options",
    "name",
    "type",
    "fillColor",
    "lineColor",
    "fillOpacity",
    "line",
    "handleMissing",
    "step",
    "stepPosition"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Area> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(2, series = $$props2.series);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
    if ("name" in $$props2)
      $$invalidate(3, name = $$props2.name);
    if ("type" in $$props2)
      $$invalidate(7, type = $$props2.type);
    if ("fillColor" in $$props2)
      $$invalidate(8, fillColor = $$props2.fillColor);
    if ("lineColor" in $$props2)
      $$invalidate(9, lineColor = $$props2.lineColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(10, fillOpacity = $$props2.fillOpacity);
    if ("line" in $$props2)
      $$invalidate(4, line = $$props2.line);
    if ("handleMissing" in $$props2)
      $$invalidate(11, handleMissing = $$props2.handleMissing);
    if ("step" in $$props2)
      $$invalidate(5, step = $$props2.step);
    if ("stepPosition" in $$props2)
      $$invalidate(12, stepPosition = $$props2.stepPosition);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude68,
    getContext,
    beforeUpdate,
    propKey,
    configKey,
    props,
    config,
    getSeriesConfig,
    formatTitle,
    replaceNulls,
    getCompletedData,
    y,
    ySet,
    series,
    seriesSet,
    options,
    name,
    type,
    fillColor,
    lineColor,
    fillOpacity,
    line,
    handleMissing,
    step,
    stepPosition,
    stackName,
    swapXY,
    chartOverrides,
    xType,
    seriesConfig,
    columnSummary,
    xMismatch,
    baseConfig,
    x,
    data,
    $props
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("config" in $$props2)
      $$invalidate(24, config = $$props2.config);
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(2, series = $$props2.series);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
    if ("name" in $$props2)
      $$invalidate(3, name = $$props2.name);
    if ("type" in $$props2)
      $$invalidate(7, type = $$props2.type);
    if ("fillColor" in $$props2)
      $$invalidate(8, fillColor = $$props2.fillColor);
    if ("lineColor" in $$props2)
      $$invalidate(9, lineColor = $$props2.lineColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(10, fillOpacity = $$props2.fillOpacity);
    if ("line" in $$props2)
      $$invalidate(4, line = $$props2.line);
    if ("handleMissing" in $$props2)
      $$invalidate(11, handleMissing = $$props2.handleMissing);
    if ("step" in $$props2)
      $$invalidate(5, step = $$props2.step);
    if ("stepPosition" in $$props2)
      $$invalidate(12, stepPosition = $$props2.stepPosition);
    if ("stackName" in $$props2)
      $$invalidate(13, stackName = $$props2.stackName);
    if ("swapXY" in $$props2)
      $$invalidate(14, swapXY = $$props2.swapXY);
    if ("chartOverrides" in $$props2)
      chartOverrides = $$props2.chartOverrides;
    if ("xType" in $$props2)
      $$invalidate(15, xType = $$props2.xType);
    if ("seriesConfig" in $$props2)
      $$invalidate(16, seriesConfig = $$props2.seriesConfig);
    if ("columnSummary" in $$props2)
      $$invalidate(17, columnSummary = $$props2.columnSummary);
    if ("xMismatch" in $$props2)
      $$invalidate(18, xMismatch = $$props2.xMismatch);
    if ("baseConfig" in $$props2)
      $$invalidate(19, baseConfig = $$props2.baseConfig);
    if ("x" in $$props2)
      $$invalidate(20, x = $$props2.x);
    if ("data" in $$props2)
      $$invalidate(21, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*line*/
    16) {
      $:
        $$invalidate(4, line = line === "true" || line === true);
    }
    if ($$self.$$.dirty & /*step*/
    32) {
      $:
        $$invalidate(5, step = step === "true" || step === true);
    }
    if ($$self.$$.dirty & /*$props*/
    4194304) {
      $:
        $$invalidate(21, data = $props.data);
    }
    if ($$self.$$.dirty & /*$props*/
    4194304) {
      $:
        $$invalidate(20, x = $props.x);
    }
    if ($$self.$$.dirty & /*y, $props*/
    4194306) {
      $:
        $$invalidate(1, y = ySet ? y : $props.y);
    }
    if ($$self.$$.dirty & /*$props*/
    4194304) {
      $:
        $$invalidate(14, swapXY = $props.swapXY);
    }
    if ($$self.$$.dirty & /*$props*/
    4194304) {
      $:
        $$invalidate(15, xType = $props.xType);
    }
    if ($$self.$$.dirty & /*$props*/
    4194304) {
      $:
        $$invalidate(18, xMismatch = $props.xMismatch);
    }
    if ($$self.$$.dirty & /*$props*/
    4194304) {
      $:
        $$invalidate(17, columnSummary = $props.columnSummary);
    }
    if ($$self.$$.dirty & /*series, $props*/
    4194308) {
      $:
        $$invalidate(2, series = seriesSet ? series : $props.series);
    }
    if ($$self.$$.dirty & /*series, y, name, columnSummary, data, x, xType*/
    3309582) {
      $:
        if (!series && typeof y !== "object") {
          $$invalidate(3, name = name ?? formatTitle(y, columnSummary[y].title));
        } else {
          $$invalidate(13, stackName = "area");
          $$invalidate(21, data = getCompletedData(data, x, y, series, false, xType === "value"));
          $$invalidate(21, data = replaceNulls(data, y));
          $$invalidate(15, xType = xType === "value" ? "category" : xType);
        }
    }
    if ($$self.$$.dirty & /*handleMissing, data, y*/
    2099202) {
      $:
        if (handleMissing === "zero") {
          $$invalidate(21, data = replaceNulls(data, y));
        }
    }
    if ($$self.$$.dirty & /*stackName, fillColor, fillOpacity, handleMissing, line, lineColor, step, stepPosition*/
    16176) {
      $:
        $$invalidate(19, baseConfig = {
          type: "line",
          stack: stackName,
          areaStyle: { color: fillColor, opacity: fillOpacity },
          connectNulls: handleMissing === "connect",
          lineStyle: { width: line ? 1 : 0, color: lineColor },
          label: { show: false },
          labelLayout: { hideOverlap: true },
          emphasis: { focus: "series" },
          step: step ? stepPosition : false
        });
    }
    if ($$self.$$.dirty & /*data, x, y, series, swapXY, baseConfig, name, xMismatch, columnSummary*/
    4079630) {
      $:
        $$invalidate(16, seriesConfig = getSeriesConfig(data, x, y, series, swapXY, baseConfig, name, xMismatch, columnSummary));
    }
    if ($$self.$$.dirty & /*seriesConfig*/
    65536) {
      $:
        config.update((d) => {
          d.series.push(...seriesConfig);
          return d;
        });
    }
    if ($$self.$$.dirty & /*options*/
    64) {
      $:
        if (options) {
          config.update((d) => {
            return { ...d, ...options };
          });
        }
    }
    if ($$self.$$.dirty & /*xType*/
    32768) {
      $:
        chartOverrides = {
          yAxis: { boundaryGap: ["0%", "1%"] },
          xAxis: { boundaryGap: ["4%", "4%"], type: xType }
        };
    }
  };
  return [
    props,
    y,
    series,
    name,
    line,
    step,
    options,
    type,
    fillColor,
    lineColor,
    fillOpacity,
    handleMissing,
    stepPosition,
    stackName,
    swapXY,
    xType,
    seriesConfig,
    columnSummary,
    xMismatch,
    baseConfig,
    x,
    data,
    $props
  ];
}
var Area = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, {
      y: 1,
      series: 2,
      options: 6,
      name: 3,
      type: 7,
      fillColor: 8,
      lineColor: 9,
      fillOpacity: 10,
      line: 4,
      handleMissing: 11,
      step: 5,
      stepPosition: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Area",
      options,
      id: create_fragment71.name
    });
  }
  get y() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get series() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set series(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillColor() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillColor(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineColor() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineColor(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get line() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set line(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleMissing() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handleMissing(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepPosition() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepPosition(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Area_default = Area;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/AreaChart.svelte
function create_default_slot6(ctx) {
  let area;
  let t;
  let current;
  area = new Area_default({
    props: {
      line: (
        /*line*/
        ctx[22]
      ),
      fillColor: (
        /*fillColor*/
        ctx[23]
      ),
      lineColor: (
        /*lineColor*/
        ctx[24]
      ),
      fillOpacity: (
        /*fillOpacity*/
        ctx[25]
      ),
      handleMissing: (
        /*handleMissing*/
        ctx[27]
      ),
      type: (
        /*type*/
        ctx[31]
      ),
      step: (
        /*step*/
        ctx[28]
      ),
      stepPosition: (
        /*stepPosition*/
        ctx[29]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[34].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    null
  );
  const block = {
    c: function create() {
      create_component(area.$$.fragment);
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(area.$$.fragment, nodes);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(area, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const area_changes = {};
      if (dirty[0] & /*line*/
      4194304)
        area_changes.line = /*line*/
        ctx2[22];
      if (dirty[0] & /*fillColor*/
      8388608)
        area_changes.fillColor = /*fillColor*/
        ctx2[23];
      if (dirty[0] & /*lineColor*/
      16777216)
        area_changes.lineColor = /*lineColor*/
        ctx2[24];
      if (dirty[0] & /*fillOpacity*/
      33554432)
        area_changes.fillOpacity = /*fillOpacity*/
        ctx2[25];
      if (dirty[0] & /*handleMissing*/
      134217728)
        area_changes.handleMissing = /*handleMissing*/
        ctx2[27];
      if (dirty[1] & /*type*/
      1)
        area_changes.type = /*type*/
        ctx2[31];
      if (dirty[0] & /*step*/
      268435456)
        area_changes.step = /*step*/
        ctx2[28];
      if (dirty[0] & /*stepPosition*/
      536870912)
        area_changes.stepPosition = /*stepPosition*/
        ctx2[29];
      area.$set(area_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(area.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(area.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(area, detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(53:0) <Chart  {data}  {x}  {y}  {xFmt}  {yFmt}  {series}  {xType}  {legend}  {xAxisTitle}  {yAxisTitle}  {xGridlines}  {yGridlines}  {xAxisLabels}  {yAxisLabels}  {xBaseline}  {yBaseline}  {xTickMarks}  {yTickMarks}  {yMin}  {yMax}  {title}  {subtitle}  {chartType}  {sort}  {stacked100}  {chartAreaHeight} >",
    ctx
  });
  return block;
}
function create_fragment72(ctx) {
  let chart;
  let current;
  chart = new Chart_default({
    props: {
      data: (
        /*data*/
        ctx[0]
      ),
      x: (
        /*x*/
        ctx[1]
      ),
      y: (
        /*y*/
        ctx[2]
      ),
      xFmt: (
        /*xFmt*/
        ctx[6]
      ),
      yFmt: (
        /*yFmt*/
        ctx[5]
      ),
      series: (
        /*series*/
        ctx[3]
      ),
      xType: (
        /*xType*/
        ctx[4]
      ),
      legend: (
        /*legend*/
        ctx[9]
      ),
      xAxisTitle: (
        /*xAxisTitle*/
        ctx[10]
      ),
      yAxisTitle: (
        /*yAxisTitle*/
        ctx[11]
      ),
      xGridlines: (
        /*xGridlines*/
        ctx[12]
      ),
      yGridlines: (
        /*yGridlines*/
        ctx[13]
      ),
      xAxisLabels: (
        /*xAxisLabels*/
        ctx[14]
      ),
      yAxisLabels: (
        /*yAxisLabels*/
        ctx[15]
      ),
      xBaseline: (
        /*xBaseline*/
        ctx[16]
      ),
      yBaseline: (
        /*yBaseline*/
        ctx[17]
      ),
      xTickMarks: (
        /*xTickMarks*/
        ctx[18]
      ),
      yTickMarks: (
        /*yTickMarks*/
        ctx[19]
      ),
      yMin: (
        /*yMin*/
        ctx[20]
      ),
      yMax: (
        /*yMax*/
        ctx[21]
      ),
      title: (
        /*title*/
        ctx[7]
      ),
      subtitle: (
        /*subtitle*/
        ctx[8]
      ),
      chartType: (
        /*chartType*/
        ctx[33]
      ),
      sort: (
        /*sort*/
        ctx[30]
      ),
      stacked100: (
        /*stacked100*/
        ctx[32]
      ),
      chartAreaHeight: (
        /*chartAreaHeight*/
        ctx[26]
      ),
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chart, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chart_changes = {};
      if (dirty[0] & /*data*/
      1)
        chart_changes.data = /*data*/
        ctx2[0];
      if (dirty[0] & /*x*/
      2)
        chart_changes.x = /*x*/
        ctx2[1];
      if (dirty[0] & /*y*/
      4)
        chart_changes.y = /*y*/
        ctx2[2];
      if (dirty[0] & /*xFmt*/
      64)
        chart_changes.xFmt = /*xFmt*/
        ctx2[6];
      if (dirty[0] & /*yFmt*/
      32)
        chart_changes.yFmt = /*yFmt*/
        ctx2[5];
      if (dirty[0] & /*series*/
      8)
        chart_changes.series = /*series*/
        ctx2[3];
      if (dirty[0] & /*xType*/
      16)
        chart_changes.xType = /*xType*/
        ctx2[4];
      if (dirty[0] & /*legend*/
      512)
        chart_changes.legend = /*legend*/
        ctx2[9];
      if (dirty[0] & /*xAxisTitle*/
      1024)
        chart_changes.xAxisTitle = /*xAxisTitle*/
        ctx2[10];
      if (dirty[0] & /*yAxisTitle*/
      2048)
        chart_changes.yAxisTitle = /*yAxisTitle*/
        ctx2[11];
      if (dirty[0] & /*xGridlines*/
      4096)
        chart_changes.xGridlines = /*xGridlines*/
        ctx2[12];
      if (dirty[0] & /*yGridlines*/
      8192)
        chart_changes.yGridlines = /*yGridlines*/
        ctx2[13];
      if (dirty[0] & /*xAxisLabels*/
      16384)
        chart_changes.xAxisLabels = /*xAxisLabels*/
        ctx2[14];
      if (dirty[0] & /*yAxisLabels*/
      32768)
        chart_changes.yAxisLabels = /*yAxisLabels*/
        ctx2[15];
      if (dirty[0] & /*xBaseline*/
      65536)
        chart_changes.xBaseline = /*xBaseline*/
        ctx2[16];
      if (dirty[0] & /*yBaseline*/
      131072)
        chart_changes.yBaseline = /*yBaseline*/
        ctx2[17];
      if (dirty[0] & /*xTickMarks*/
      262144)
        chart_changes.xTickMarks = /*xTickMarks*/
        ctx2[18];
      if (dirty[0] & /*yTickMarks*/
      524288)
        chart_changes.yTickMarks = /*yTickMarks*/
        ctx2[19];
      if (dirty[0] & /*yMin*/
      1048576)
        chart_changes.yMin = /*yMin*/
        ctx2[20];
      if (dirty[0] & /*yMax*/
      2097152)
        chart_changes.yMax = /*yMax*/
        ctx2[21];
      if (dirty[0] & /*title*/
      128)
        chart_changes.title = /*title*/
        ctx2[7];
      if (dirty[0] & /*subtitle*/
      256)
        chart_changes.subtitle = /*subtitle*/
        ctx2[8];
      if (dirty[0] & /*sort*/
      1073741824)
        chart_changes.sort = /*sort*/
        ctx2[30];
      if (dirty[0] & /*chartAreaHeight*/
      67108864)
        chart_changes.chartAreaHeight = /*chartAreaHeight*/
        ctx2[26];
      if (dirty[0] & /*line, fillColor, lineColor, fillOpacity, handleMissing, step, stepPosition*/
      1002438656 | dirty[1] & /*$$scope, type*/
      17) {
        chart_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chart.$set(chart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude69 = true;
function instance72($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AreaChart", slots, ["default"]);
  let { data = void 0 } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { series = void 0 } = $$props;
  let { xType = void 0 } = $$props;
  let { yFmt = void 0 } = $$props;
  let { xFmt = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { legend = void 0 } = $$props;
  let { xAxisTitle = void 0 } = $$props;
  let { yAxisTitle = void 0 } = $$props;
  let { xGridlines = void 0 } = $$props;
  let { yGridlines = void 0 } = $$props;
  let { xAxisLabels = void 0 } = $$props;
  let { yAxisLabels = void 0 } = $$props;
  let { xBaseline = void 0 } = $$props;
  let { yBaseline = void 0 } = $$props;
  let { xTickMarks = void 0 } = $$props;
  let { yTickMarks = void 0 } = $$props;
  let { yMin = void 0 } = $$props;
  let { yMax = void 0 } = $$props;
  let { line = void 0 } = $$props;
  let { fillColor = void 0 } = $$props;
  let { lineColor = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { chartAreaHeight = void 0 } = $$props;
  let { handleMissing = void 0 } = $$props;
  let { step = void 0 } = $$props;
  let { stepPosition = void 0 } = $$props;
  let { sort = void 0 } = $$props;
  let { type = void 0 } = $$props;
  let stacked100 = type === "stacked100";
  let chartType = "Area Chart";
  const writable_props = [
    "data",
    "x",
    "y",
    "series",
    "xType",
    "yFmt",
    "xFmt",
    "title",
    "subtitle",
    "legend",
    "xAxisTitle",
    "yAxisTitle",
    "xGridlines",
    "yGridlines",
    "xAxisLabels",
    "yAxisLabels",
    "xBaseline",
    "yBaseline",
    "xTickMarks",
    "yTickMarks",
    "yMin",
    "yMax",
    "line",
    "fillColor",
    "lineColor",
    "fillOpacity",
    "chartAreaHeight",
    "handleMissing",
    "step",
    "stepPosition",
    "sort",
    "type"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AreaChart> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(3, series = $$props2.series);
    if ("xType" in $$props2)
      $$invalidate(4, xType = $$props2.xType);
    if ("yFmt" in $$props2)
      $$invalidate(5, yFmt = $$props2.yFmt);
    if ("xFmt" in $$props2)
      $$invalidate(6, xFmt = $$props2.xFmt);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(8, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(9, legend = $$props2.legend);
    if ("xAxisTitle" in $$props2)
      $$invalidate(10, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(11, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(12, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(13, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(14, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(15, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(16, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(17, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(18, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(19, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(20, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(21, yMax = $$props2.yMax);
    if ("line" in $$props2)
      $$invalidate(22, line = $$props2.line);
    if ("fillColor" in $$props2)
      $$invalidate(23, fillColor = $$props2.fillColor);
    if ("lineColor" in $$props2)
      $$invalidate(24, lineColor = $$props2.lineColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(25, fillOpacity = $$props2.fillOpacity);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(26, chartAreaHeight = $$props2.chartAreaHeight);
    if ("handleMissing" in $$props2)
      $$invalidate(27, handleMissing = $$props2.handleMissing);
    if ("step" in $$props2)
      $$invalidate(28, step = $$props2.step);
    if ("stepPosition" in $$props2)
      $$invalidate(29, stepPosition = $$props2.stepPosition);
    if ("sort" in $$props2)
      $$invalidate(30, sort = $$props2.sort);
    if ("type" in $$props2)
      $$invalidate(31, type = $$props2.type);
    if ("$$scope" in $$props2)
      $$invalidate(35, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude69,
    Chart: Chart_default,
    Area: Area_default,
    data,
    x,
    y,
    series,
    xType,
    yFmt,
    xFmt,
    title,
    subtitle,
    legend,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    line,
    fillColor,
    lineColor,
    fillOpacity,
    chartAreaHeight,
    handleMissing,
    step,
    stepPosition,
    sort,
    type,
    stacked100,
    chartType
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(3, series = $$props2.series);
    if ("xType" in $$props2)
      $$invalidate(4, xType = $$props2.xType);
    if ("yFmt" in $$props2)
      $$invalidate(5, yFmt = $$props2.yFmt);
    if ("xFmt" in $$props2)
      $$invalidate(6, xFmt = $$props2.xFmt);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(8, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(9, legend = $$props2.legend);
    if ("xAxisTitle" in $$props2)
      $$invalidate(10, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(11, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(12, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(13, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(14, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(15, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(16, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(17, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(18, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(19, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(20, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(21, yMax = $$props2.yMax);
    if ("line" in $$props2)
      $$invalidate(22, line = $$props2.line);
    if ("fillColor" in $$props2)
      $$invalidate(23, fillColor = $$props2.fillColor);
    if ("lineColor" in $$props2)
      $$invalidate(24, lineColor = $$props2.lineColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(25, fillOpacity = $$props2.fillOpacity);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(26, chartAreaHeight = $$props2.chartAreaHeight);
    if ("handleMissing" in $$props2)
      $$invalidate(27, handleMissing = $$props2.handleMissing);
    if ("step" in $$props2)
      $$invalidate(28, step = $$props2.step);
    if ("stepPosition" in $$props2)
      $$invalidate(29, stepPosition = $$props2.stepPosition);
    if ("sort" in $$props2)
      $$invalidate(30, sort = $$props2.sort);
    if ("type" in $$props2)
      $$invalidate(31, type = $$props2.type);
    if ("stacked100" in $$props2)
      $$invalidate(32, stacked100 = $$props2.stacked100);
    if ("chartType" in $$props2)
      $$invalidate(33, chartType = $$props2.chartType);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    data,
    x,
    y,
    series,
    xType,
    yFmt,
    xFmt,
    title,
    subtitle,
    legend,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    line,
    fillColor,
    lineColor,
    fillOpacity,
    chartAreaHeight,
    handleMissing,
    step,
    stepPosition,
    sort,
    type,
    stacked100,
    chartType,
    slots,
    $$scope
  ];
}
var AreaChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance72,
      create_fragment72,
      safe_not_equal,
      {
        data: 0,
        x: 1,
        y: 2,
        series: 3,
        xType: 4,
        yFmt: 5,
        xFmt: 6,
        title: 7,
        subtitle: 8,
        legend: 9,
        xAxisTitle: 10,
        yAxisTitle: 11,
        xGridlines: 12,
        yGridlines: 13,
        xAxisLabels: 14,
        yAxisLabels: 15,
        xBaseline: 16,
        yBaseline: 17,
        xTickMarks: 18,
        yTickMarks: 19,
        yMin: 20,
        yMax: 21,
        line: 22,
        fillColor: 23,
        lineColor: 24,
        fillOpacity: 25,
        chartAreaHeight: 26,
        handleMissing: 27,
        step: 28,
        stepPosition: 29,
        sort: 30,
        type: 31
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AreaChart",
      options,
      id: create_fragment72.name
    });
  }
  get data() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get series() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set series(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xType() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xType(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yFmt() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yFmt(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xFmt() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xFmt(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisTitle() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisTitle(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisTitle() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisTitle(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xGridlines() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xGridlines(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yGridlines() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yGridlines(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisLabels() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisLabels(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisLabels() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisLabels(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xBaseline() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xBaseline(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yBaseline() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yBaseline(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xTickMarks() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xTickMarks(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yTickMarks() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yTickMarks(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMin() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMin(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMax() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMax(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get line() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set line(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillColor() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillColor(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineColor() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineColor(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chartAreaHeight() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chartAreaHeight(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleMissing() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handleMissing(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepPosition() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepPosition(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sort() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sort(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AreaChart_default = AreaChart;

// ../../node_modules/@evidence-dev/component-utilities/src/getStackedData.js
function getStackedData(data, groupCol, valueCol) {
  let stackedData = tidy(data, groupBy(groupCol, [summarizeAt(valueCol, sum)]));
  if (typeof valueCol === "object") {
    for (let i = 0; i < stackedData.length; i++) {
      stackedData[i].stackTotal = 0;
      for (let j = 0; j < valueCol.length; j++) {
        stackedData[i].stackTotal = stackedData[i].stackTotal + stackedData[i][valueCol[j]];
      }
    }
  }
  return stackedData;
}

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/Bar.svelte
function create_fragment73(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude70 = true;
function instance73($$self, $$props, $$invalidate) {
  let props;
  let config;
  let data;
  let x;
  let swapXY;
  let xType;
  let xMismatch;
  let columnSummary;
  let sort;
  let baseConfig;
  let seriesConfig;
  let chartOverrides;
  let $props, $$unsubscribe_props = noop, $$subscribe_props = () => ($$unsubscribe_props(), $$unsubscribe_props = subscribe(props, ($$value) => $$invalidate(23, $props = $$value)), props);
  $$self.$$.on_destroy.push(() => $$unsubscribe_props());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Bar", slots, []);
  let { y = void 0 } = $$props;
  const ySet = y ? true : false;
  let { series = void 0 } = $$props;
  const seriesSet = series ? true : false;
  let { options = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { type = "stacked" } = $$props;
  let { stackName = void 0 } = $$props;
  let { fillColor = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { outlineColor = void 0 } = $$props;
  let { outlineWidth = void 0 } = $$props;
  let barMaxWidth = 60;
  let stackedData;
  let sortOrder;
  beforeUpdate(() => {
    if (options) {
      config.update((d) => {
        return { ...d, ...options };
      });
    }
    if (chartOverrides) {
      config.update((d) => {
        if (type.includes("stacked")) {
          d.tooltip = { ...d.tooltip, order: "seriesDesc" };
        } else {
          d.tooltip = { ...d.tooltip, order: "seriesAsc" };
        }
        if (type === "stacked100") {
          if (swapXY) {
            d.xAxis = { ...d.xAxis, max: 1 };
          } else {
            d.yAxis = { ...d.yAxis, max: 1 };
          }
        }
        if (swapXY) {
          d.yAxis = { ...d.yAxis, ...chartOverrides.xAxis };
          d.xAxis = { ...d.xAxis, ...chartOverrides.yAxis };
        } else {
          d.yAxis = { ...d.yAxis, ...chartOverrides.yAxis };
          d.xAxis = { ...d.xAxis, ...chartOverrides.xAxis };
        }
        return d;
      });
    }
  });
  const writable_props = [
    "y",
    "series",
    "options",
    "name",
    "type",
    "stackName",
    "fillColor",
    "fillOpacity",
    "outlineColor",
    "outlineWidth"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Bar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(2, series = $$props2.series);
    if ("options" in $$props2)
      $$invalidate(5, options = $$props2.options);
    if ("name" in $$props2)
      $$invalidate(3, name = $$props2.name);
    if ("type" in $$props2)
      $$invalidate(6, type = $$props2.type);
    if ("stackName" in $$props2)
      $$invalidate(4, stackName = $$props2.stackName);
    if ("fillColor" in $$props2)
      $$invalidate(7, fillColor = $$props2.fillColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(8, fillOpacity = $$props2.fillOpacity);
    if ("outlineColor" in $$props2)
      $$invalidate(9, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(10, outlineWidth = $$props2.outlineWidth);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude70,
    getContext,
    beforeUpdate,
    propKey,
    configKey,
    getSeriesConfig,
    getStackedData,
    getSortedData,
    formatTitle,
    getCompletedData,
    y,
    ySet,
    series,
    seriesSet,
    options,
    name,
    type,
    stackName,
    fillColor,
    fillOpacity,
    outlineColor,
    outlineWidth,
    barMaxWidth,
    stackedData,
    sortOrder,
    chartOverrides,
    swapXY,
    config,
    xType,
    seriesConfig,
    columnSummary,
    xMismatch,
    baseConfig,
    x,
    data,
    sort,
    props,
    $props
  });
  $$self.$inject_state = ($$props2) => {
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(2, series = $$props2.series);
    if ("options" in $$props2)
      $$invalidate(5, options = $$props2.options);
    if ("name" in $$props2)
      $$invalidate(3, name = $$props2.name);
    if ("type" in $$props2)
      $$invalidate(6, type = $$props2.type);
    if ("stackName" in $$props2)
      $$invalidate(4, stackName = $$props2.stackName);
    if ("fillColor" in $$props2)
      $$invalidate(7, fillColor = $$props2.fillColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(8, fillOpacity = $$props2.fillOpacity);
    if ("outlineColor" in $$props2)
      $$invalidate(9, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(10, outlineWidth = $$props2.outlineWidth);
    if ("barMaxWidth" in $$props2)
      $$invalidate(27, barMaxWidth = $$props2.barMaxWidth);
    if ("stackedData" in $$props2)
      $$invalidate(11, stackedData = $$props2.stackedData);
    if ("sortOrder" in $$props2)
      $$invalidate(12, sortOrder = $$props2.sortOrder);
    if ("chartOverrides" in $$props2)
      chartOverrides = $$props2.chartOverrides;
    if ("swapXY" in $$props2)
      $$invalidate(13, swapXY = $$props2.swapXY);
    if ("config" in $$props2)
      $$invalidate(14, config = $$props2.config);
    if ("xType" in $$props2)
      $$invalidate(15, xType = $$props2.xType);
    if ("seriesConfig" in $$props2)
      $$invalidate(16, seriesConfig = $$props2.seriesConfig);
    if ("columnSummary" in $$props2)
      $$invalidate(17, columnSummary = $$props2.columnSummary);
    if ("xMismatch" in $$props2)
      $$invalidate(18, xMismatch = $$props2.xMismatch);
    if ("baseConfig" in $$props2)
      $$invalidate(19, baseConfig = $$props2.baseConfig);
    if ("x" in $$props2)
      $$invalidate(20, x = $$props2.x);
    if ("data" in $$props2)
      $$invalidate(21, data = $$props2.data);
    if ("sort" in $$props2)
      $$invalidate(22, sort = $$props2.sort);
    if ("props" in $$props2)
      $$subscribe_props($$invalidate(0, props = $$props2.props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(21, data = $props.data);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(20, x = $props.x);
    }
    if ($$self.$$.dirty & /*y, $props*/
    8388610) {
      $:
        $$invalidate(1, y = ySet ? y : $props.y);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(13, swapXY = $props.swapXY);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(15, xType = $props.xType);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(18, xMismatch = $props.xMismatch);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(17, columnSummary = $props.columnSummary);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(22, sort = $props.sort);
    }
    if ($$self.$$.dirty & /*series, $props*/
    8388612) {
      $:
        $$invalidate(2, series = seriesSet ? series : $props.series);
    }
    if ($$self.$$.dirty & /*series, y, name, columnSummary, swapXY, xType, data, x, sort, stackedData, sortOrder, type, stackName*/
    7518302) {
      $:
        if (!series && typeof y !== "object") {
          $$invalidate(3, name = name ?? formatTitle(y, columnSummary[y].title));
          if (swapXY && xType !== "category") {
            $$invalidate(21, data = getCompletedData(data, x, y, series, true, xType !== "time"));
            $$invalidate(15, xType = "category");
          }
          $$invalidate(4, stackName = "stack1");
        } else {
          if (sort === true && xType === "category") {
            $$invalidate(11, stackedData = getStackedData(data, x, y));
            if (typeof y === "object") {
              $$invalidate(11, stackedData = getSortedData(stackedData, "stackTotal", false));
            } else {
              $$invalidate(11, stackedData = getSortedData(stackedData, y, false));
            }
            $$invalidate(12, sortOrder = stackedData.map((d) => d[x]));
            $$invalidate(21, data = [...data].sort(function(a, b) {
              return sortOrder.indexOf(a[x]) - sortOrder.indexOf(b[x]);
            }));
          }
          if (swapXY || (xType === "value" || xType === "category") && type.includes("stacked")) {
            $$invalidate(21, data = getCompletedData(data, x, y, series, true, xType === "value"));
            $$invalidate(15, xType = "category");
          } else if (xType === "time" && type.includes("stacked")) {
            $$invalidate(21, data = getCompletedData(data, x, y, series, true, true));
          }
          if (type.includes("stacked")) {
            $$invalidate(4, stackName = stackName ?? "stack1");
          } else {
            $$invalidate(4, stackName = void 0);
          }
        }
    }
    if ($$self.$$.dirty & /*stackName, fillColor, fillOpacity, outlineColor, outlineWidth*/
    1936) {
      $:
        $$invalidate(19, baseConfig = {
          type: "bar",
          stack: stackName,
          label: { show: false },
          labelLayout: { hideOverlap: true },
          emphasis: { focus: "series" },
          barMaxWidth,
          itemStyle: {
            color: fillColor,
            opacity: fillOpacity,
            borderColor: outlineColor,
            borderWidth: outlineWidth
          }
        });
    }
    if ($$self.$$.dirty & /*data, x, y, series, swapXY, baseConfig, name, xMismatch, columnSummary*/
    4071438) {
      $:
        $$invalidate(16, seriesConfig = getSeriesConfig(data, x, y, series, swapXY, baseConfig, name, xMismatch, columnSummary));
    }
    if ($$self.$$.dirty & /*config, seriesConfig*/
    81920) {
      $:
        config.update((d) => {
          d.series.push(...seriesConfig);
          return d;
        });
    }
    if ($$self.$$.dirty & /*xType*/
    32768) {
      $:
        chartOverrides = {
          // Evidence definition of axes (yAxis = dependent, xAxis = independent)
          xAxis: { boundaryGap: ["1%", "2%"], type: xType }
        };
    }
  };
  $:
    $$subscribe_props($$invalidate(0, props = getContext(propKey)));
  $:
    $$invalidate(14, config = getContext(configKey));
  return [
    props,
    y,
    series,
    name,
    stackName,
    options,
    type,
    fillColor,
    fillOpacity,
    outlineColor,
    outlineWidth,
    stackedData,
    sortOrder,
    swapXY,
    config,
    xType,
    seriesConfig,
    columnSummary,
    xMismatch,
    baseConfig,
    x,
    data,
    sort,
    $props
  ];
}
var Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment73, safe_not_equal, {
      y: 1,
      series: 2,
      options: 5,
      name: 3,
      type: 6,
      stackName: 4,
      fillColor: 7,
      fillOpacity: 8,
      outlineColor: 9,
      outlineWidth: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Bar",
      options,
      id: create_fragment73.name
    });
  }
  get y() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get series() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set series(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stackName() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stackName(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillColor() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillColor(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineColor() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineColor(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineWidth() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineWidth(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Bar_default = Bar;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/BarChart.svelte
function create_default_slot7(ctx) {
  let bar;
  let t;
  let current;
  bar = new Bar_default({
    props: {
      type: (
        /*type*/
        ctx[24]
      ),
      fillColor: (
        /*fillColor*/
        ctx[25]
      ),
      fillOpacity: (
        /*fillOpacity*/
        ctx[26]
      ),
      outlineColor: (
        /*outlineColor*/
        ctx[27]
      ),
      outlineWidth: (
        /*outlineWidth*/
        ctx[28]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[32].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[33],
    null
  );
  const block = {
    c: function create() {
      create_component(bar.$$.fragment);
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(bar.$$.fragment, nodes);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(bar, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const bar_changes = {};
      if (dirty[0] & /*type*/
      16777216)
        bar_changes.type = /*type*/
        ctx2[24];
      if (dirty[0] & /*fillColor*/
      33554432)
        bar_changes.fillColor = /*fillColor*/
        ctx2[25];
      if (dirty[0] & /*fillOpacity*/
      67108864)
        bar_changes.fillOpacity = /*fillOpacity*/
        ctx2[26];
      if (dirty[0] & /*outlineColor*/
      134217728)
        bar_changes.outlineColor = /*outlineColor*/
        ctx2[27];
      if (dirty[0] & /*outlineWidth*/
      268435456)
        bar_changes.outlineWidth = /*outlineWidth*/
        ctx2[28];
      bar.$set(bar_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[33],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[33]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[33],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(bar.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(bar.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(bar, detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: '(66:0) <Chart  {data}  {x}  {y}  {xFmt}  {yFmt}  {series}  {xType}  {legend}  {xAxisTitle}  {yAxisTitle}  {xGridlines}  {yGridlines}  {xAxisLabels}  {yAxisLabels}  {xBaseline}  {yBaseline}  {xTickMarks}  {yTickMarks}  {yMin}  {yMax}  {swapXY}  {title}  {subtitle}  chartType=\\"Bar Chart\\"  {sort}  {stacked100}  {chartAreaHeight}  {showAllXAxisLabels} >',
    ctx
  });
  return block;
}
function create_fragment74(ctx) {
  let chart;
  let current;
  chart = new Chart_default({
    props: {
      data: (
        /*data*/
        ctx[1]
      ),
      x: (
        /*x*/
        ctx[2]
      ),
      y: (
        /*y*/
        ctx[3]
      ),
      xFmt: (
        /*xFmt*/
        ctx[7]
      ),
      yFmt: (
        /*yFmt*/
        ctx[6]
      ),
      series: (
        /*series*/
        ctx[4]
      ),
      xType: (
        /*xType*/
        ctx[5]
      ),
      legend: (
        /*legend*/
        ctx[10]
      ),
      xAxisTitle: (
        /*xAxisTitle*/
        ctx[11]
      ),
      yAxisTitle: (
        /*yAxisTitle*/
        ctx[12]
      ),
      xGridlines: (
        /*xGridlines*/
        ctx[13]
      ),
      yGridlines: (
        /*yGridlines*/
        ctx[14]
      ),
      xAxisLabels: (
        /*xAxisLabels*/
        ctx[15]
      ),
      yAxisLabels: (
        /*yAxisLabels*/
        ctx[16]
      ),
      xBaseline: (
        /*xBaseline*/
        ctx[17]
      ),
      yBaseline: (
        /*yBaseline*/
        ctx[18]
      ),
      xTickMarks: (
        /*xTickMarks*/
        ctx[19]
      ),
      yTickMarks: (
        /*yTickMarks*/
        ctx[20]
      ),
      yMin: (
        /*yMin*/
        ctx[21]
      ),
      yMax: (
        /*yMax*/
        ctx[22]
      ),
      swapXY: (
        /*swapXY*/
        ctx[0]
      ),
      title: (
        /*title*/
        ctx[8]
      ),
      subtitle: (
        /*subtitle*/
        ctx[9]
      ),
      chartType: "Bar Chart",
      sort: (
        /*sort*/
        ctx[30]
      ),
      stacked100: (
        /*stacked100*/
        ctx[31]
      ),
      chartAreaHeight: (
        /*chartAreaHeight*/
        ctx[29]
      ),
      showAllXAxisLabels: (
        /*showAllXAxisLabels*/
        ctx[23]
      ),
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chart, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chart_changes = {};
      if (dirty[0] & /*data*/
      2)
        chart_changes.data = /*data*/
        ctx2[1];
      if (dirty[0] & /*x*/
      4)
        chart_changes.x = /*x*/
        ctx2[2];
      if (dirty[0] & /*y*/
      8)
        chart_changes.y = /*y*/
        ctx2[3];
      if (dirty[0] & /*xFmt*/
      128)
        chart_changes.xFmt = /*xFmt*/
        ctx2[7];
      if (dirty[0] & /*yFmt*/
      64)
        chart_changes.yFmt = /*yFmt*/
        ctx2[6];
      if (dirty[0] & /*series*/
      16)
        chart_changes.series = /*series*/
        ctx2[4];
      if (dirty[0] & /*xType*/
      32)
        chart_changes.xType = /*xType*/
        ctx2[5];
      if (dirty[0] & /*legend*/
      1024)
        chart_changes.legend = /*legend*/
        ctx2[10];
      if (dirty[0] & /*xAxisTitle*/
      2048)
        chart_changes.xAxisTitle = /*xAxisTitle*/
        ctx2[11];
      if (dirty[0] & /*yAxisTitle*/
      4096)
        chart_changes.yAxisTitle = /*yAxisTitle*/
        ctx2[12];
      if (dirty[0] & /*xGridlines*/
      8192)
        chart_changes.xGridlines = /*xGridlines*/
        ctx2[13];
      if (dirty[0] & /*yGridlines*/
      16384)
        chart_changes.yGridlines = /*yGridlines*/
        ctx2[14];
      if (dirty[0] & /*xAxisLabels*/
      32768)
        chart_changes.xAxisLabels = /*xAxisLabels*/
        ctx2[15];
      if (dirty[0] & /*yAxisLabels*/
      65536)
        chart_changes.yAxisLabels = /*yAxisLabels*/
        ctx2[16];
      if (dirty[0] & /*xBaseline*/
      131072)
        chart_changes.xBaseline = /*xBaseline*/
        ctx2[17];
      if (dirty[0] & /*yBaseline*/
      262144)
        chart_changes.yBaseline = /*yBaseline*/
        ctx2[18];
      if (dirty[0] & /*xTickMarks*/
      524288)
        chart_changes.xTickMarks = /*xTickMarks*/
        ctx2[19];
      if (dirty[0] & /*yTickMarks*/
      1048576)
        chart_changes.yTickMarks = /*yTickMarks*/
        ctx2[20];
      if (dirty[0] & /*yMin*/
      2097152)
        chart_changes.yMin = /*yMin*/
        ctx2[21];
      if (dirty[0] & /*yMax*/
      4194304)
        chart_changes.yMax = /*yMax*/
        ctx2[22];
      if (dirty[0] & /*swapXY*/
      1)
        chart_changes.swapXY = /*swapXY*/
        ctx2[0];
      if (dirty[0] & /*title*/
      256)
        chart_changes.title = /*title*/
        ctx2[8];
      if (dirty[0] & /*subtitle*/
      512)
        chart_changes.subtitle = /*subtitle*/
        ctx2[9];
      if (dirty[0] & /*sort*/
      1073741824)
        chart_changes.sort = /*sort*/
        ctx2[30];
      if (dirty[0] & /*chartAreaHeight*/
      536870912)
        chart_changes.chartAreaHeight = /*chartAreaHeight*/
        ctx2[29];
      if (dirty[0] & /*showAllXAxisLabels*/
      8388608)
        chart_changes.showAllXAxisLabels = /*showAllXAxisLabels*/
        ctx2[23];
      if (dirty[0] & /*type, fillColor, fillOpacity, outlineColor, outlineWidth*/
      520093696 | dirty[1] & /*$$scope*/
      4) {
        chart_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chart.$set(chart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude71 = true;
function instance74($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarChart", slots, ["default"]);
  let { data = void 0 } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { series = void 0 } = $$props;
  let { xType = void 0 } = $$props;
  let { yFmt = void 0 } = $$props;
  let { xFmt = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { legend = void 0 } = $$props;
  let { xAxisTitle = void 0 } = $$props;
  let { yAxisTitle = void 0 } = $$props;
  let { xGridlines = void 0 } = $$props;
  let { yGridlines = void 0 } = $$props;
  let { xAxisLabels = void 0 } = $$props;
  let { yAxisLabels = void 0 } = $$props;
  let { xBaseline = void 0 } = $$props;
  let { yBaseline = void 0 } = $$props;
  let { xTickMarks = void 0 } = $$props;
  let { yTickMarks = void 0 } = $$props;
  let { yMin = void 0 } = $$props;
  let { yMax = void 0 } = $$props;
  let { swapXY = false } = $$props;
  let xEvidenceType = void 0;
  onMount(() => {
    var _a, _b, _c;
    xEvidenceType = (_c = (_b = (_a = data == null ? void 0 : data[0]) == null ? void 0 : _a._evidenceColumnTypes) == null ? void 0 : _b.find((ect) => {
      var _a2;
      return ((_a2 = ect.name) == null ? void 0 : _a2.toLowerCase()) === (x == null ? void 0 : x.toLowerCase());
    })) == null ? void 0 : _c.evidenceType;
  });
  let { showAllXAxisLabels = xType === "category" || xEvidenceType === "string" } = $$props;
  let { type = void 0 } = $$props;
  let stacked100 = type === "stacked100";
  let { fillColor = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { outlineColor = void 0 } = $$props;
  let { outlineWidth = void 0 } = $$props;
  let { chartAreaHeight = void 0 } = $$props;
  let { sort = void 0 } = $$props;
  const writable_props = [
    "data",
    "x",
    "y",
    "series",
    "xType",
    "yFmt",
    "xFmt",
    "title",
    "subtitle",
    "legend",
    "xAxisTitle",
    "yAxisTitle",
    "xGridlines",
    "yGridlines",
    "xAxisLabels",
    "yAxisLabels",
    "xBaseline",
    "yBaseline",
    "xTickMarks",
    "yTickMarks",
    "yMin",
    "yMax",
    "swapXY",
    "showAllXAxisLabels",
    "type",
    "fillColor",
    "fillOpacity",
    "outlineColor",
    "outlineWidth",
    "chartAreaHeight",
    "sort"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BarChart> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(2, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(3, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(4, series = $$props2.series);
    if ("xType" in $$props2)
      $$invalidate(5, xType = $$props2.xType);
    if ("yFmt" in $$props2)
      $$invalidate(6, yFmt = $$props2.yFmt);
    if ("xFmt" in $$props2)
      $$invalidate(7, xFmt = $$props2.xFmt);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(9, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(10, legend = $$props2.legend);
    if ("xAxisTitle" in $$props2)
      $$invalidate(11, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(12, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(13, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(14, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(15, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(16, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(17, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(18, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(19, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(20, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(21, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(22, yMax = $$props2.yMax);
    if ("swapXY" in $$props2)
      $$invalidate(0, swapXY = $$props2.swapXY);
    if ("showAllXAxisLabels" in $$props2)
      $$invalidate(23, showAllXAxisLabels = $$props2.showAllXAxisLabels);
    if ("type" in $$props2)
      $$invalidate(24, type = $$props2.type);
    if ("fillColor" in $$props2)
      $$invalidate(25, fillColor = $$props2.fillColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(26, fillOpacity = $$props2.fillOpacity);
    if ("outlineColor" in $$props2)
      $$invalidate(27, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(28, outlineWidth = $$props2.outlineWidth);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(29, chartAreaHeight = $$props2.chartAreaHeight);
    if ("sort" in $$props2)
      $$invalidate(30, sort = $$props2.sort);
    if ("$$scope" in $$props2)
      $$invalidate(33, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude71,
    Chart: Chart_default,
    Bar: Bar_default,
    onMount,
    data,
    x,
    y,
    series,
    xType,
    yFmt,
    xFmt,
    title,
    subtitle,
    legend,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    swapXY,
    xEvidenceType,
    showAllXAxisLabels,
    type,
    stacked100,
    fillColor,
    fillOpacity,
    outlineColor,
    outlineWidth,
    chartAreaHeight,
    sort
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(2, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(3, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(4, series = $$props2.series);
    if ("xType" in $$props2)
      $$invalidate(5, xType = $$props2.xType);
    if ("yFmt" in $$props2)
      $$invalidate(6, yFmt = $$props2.yFmt);
    if ("xFmt" in $$props2)
      $$invalidate(7, xFmt = $$props2.xFmt);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(9, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(10, legend = $$props2.legend);
    if ("xAxisTitle" in $$props2)
      $$invalidate(11, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(12, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(13, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(14, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(15, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(16, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(17, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(18, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(19, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(20, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(21, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(22, yMax = $$props2.yMax);
    if ("swapXY" in $$props2)
      $$invalidate(0, swapXY = $$props2.swapXY);
    if ("xEvidenceType" in $$props2)
      xEvidenceType = $$props2.xEvidenceType;
    if ("showAllXAxisLabels" in $$props2)
      $$invalidate(23, showAllXAxisLabels = $$props2.showAllXAxisLabels);
    if ("type" in $$props2)
      $$invalidate(24, type = $$props2.type);
    if ("stacked100" in $$props2)
      $$invalidate(31, stacked100 = $$props2.stacked100);
    if ("fillColor" in $$props2)
      $$invalidate(25, fillColor = $$props2.fillColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(26, fillOpacity = $$props2.fillOpacity);
    if ("outlineColor" in $$props2)
      $$invalidate(27, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(28, outlineWidth = $$props2.outlineWidth);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(29, chartAreaHeight = $$props2.chartAreaHeight);
    if ("sort" in $$props2)
      $$invalidate(30, sort = $$props2.sort);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*swapXY*/
    1) {
      $: {
        if (swapXY === "true" || swapXY === true) {
          $$invalidate(0, swapXY = true);
        } else {
          $$invalidate(0, swapXY = false);
        }
      }
    }
  };
  return [
    swapXY,
    data,
    x,
    y,
    series,
    xType,
    yFmt,
    xFmt,
    title,
    subtitle,
    legend,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    showAllXAxisLabels,
    type,
    fillColor,
    fillOpacity,
    outlineColor,
    outlineWidth,
    chartAreaHeight,
    sort,
    stacked100,
    slots,
    $$scope
  ];
}
var BarChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance74,
      create_fragment74,
      safe_not_equal,
      {
        data: 1,
        x: 2,
        y: 3,
        series: 4,
        xType: 5,
        yFmt: 6,
        xFmt: 7,
        title: 8,
        subtitle: 9,
        legend: 10,
        xAxisTitle: 11,
        yAxisTitle: 12,
        xGridlines: 13,
        yGridlines: 14,
        xAxisLabels: 15,
        yAxisLabels: 16,
        xBaseline: 17,
        yBaseline: 18,
        xTickMarks: 19,
        yTickMarks: 20,
        yMin: 21,
        yMax: 22,
        swapXY: 0,
        showAllXAxisLabels: 23,
        type: 24,
        fillColor: 25,
        fillOpacity: 26,
        outlineColor: 27,
        outlineWidth: 28,
        chartAreaHeight: 29,
        sort: 30
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarChart",
      options,
      id: create_fragment74.name
    });
  }
  get data() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get series() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set series(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xType() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xType(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yFmt() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yFmt(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xFmt() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xFmt(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisTitle() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisTitle(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisTitle() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisTitle(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xGridlines() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xGridlines(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yGridlines() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yGridlines(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisLabels() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisLabels(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisLabels() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisLabels(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xBaseline() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xBaseline(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yBaseline() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yBaseline(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xTickMarks() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xTickMarks(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yTickMarks() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yTickMarks(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMin() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMin(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMax() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMax(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swapXY() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swapXY(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showAllXAxisLabels() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showAllXAxisLabels(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillColor() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillColor(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineColor() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineColor(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineWidth() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineWidth(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chartAreaHeight() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chartAreaHeight(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sort() {
    throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sort(value) {
    throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BarChart_default = BarChart;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/PulseNumber.svelte
var file61 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/viz/PulseNumber.svelte";
function add_css51(target) {
  append_styles(target, "svelte-at40pe", "span.normal.svelte-at40pe{transition:all 1s}span.flash.svelte-at40pe{color:var(--blue-600)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHVsc2VOdW1iZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWtCQyxJQUFBLE9BQUEsY0FBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLEdBQUEsQ0FBQSxFQUFrQixBQUNuQixDQUFBLEFBQ0EsSUFBQSxNQUFBLGNBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJQdWxzZU51bWJlci5zdmVsdGUiXX0= */");
}
function create_fragment75(ctx) {
  let span;
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*value*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*value*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = null_to_empty(
        /*flash*/
        ctx[1] ? "flash" : "normal"
      ) + " svelte-at40pe");
      add_location(span, file61, 15, 0, 218);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*value*/
      1)
        set_data_dev(
          t,
          /*value*/
          ctx2[0]
        );
      if (dirty & /*flash*/
      2 && span_class_value !== (span_class_value = null_to_empty(
        /*flash*/
        ctx2[1] ? "flash" : "normal"
      ) + " svelte-at40pe")) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude72 = true;
function instance75($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PulseNumber", slots, []);
  let { value } = $$props;
  let flash = true;
  afterUpdate(() => {
    $$invalidate(1, flash = !flash);
  });
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<PulseNumber> was created without expected prop 'value'");
    }
  });
  const writable_props = ["value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PulseNumber> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude72,
    value,
    afterUpdate,
    flash
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("flash" in $$props2)
      $$invalidate(1, flash = $$props2.flash);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, flash];
}
var PulseNumber = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment75, safe_not_equal, { value: 0 }, add_css51);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PulseNumber",
      options,
      id: create_fragment75.name
    });
  }
  get value() {
    throw new Error("<PulseNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<PulseNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PulseNumber_default = PulseNumber;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/Value.svelte
var { Error: Error_15, Object: Object_15, console: console_12 } = globals;
var file62 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/viz/Value.svelte";
function add_css52(target) {
  append_styles(target, "svelte-17u4gxa", ".placeholder.svelte-17u4gxa.svelte-17u4gxa{display:inline;position:relative;cursor:help;color:blue}.placeholder.svelte-17u4gxa .error-msg.svelte-17u4gxa{display:none;position:absolute;top:-5px;left:105%;max-width:400px;min-width:150px;padding-left:5px;padding-right:5px;padding-top:2px;padding-bottom:1px;color:white;font-family:sans-serif;font-size:0.8em;background-color:var(--grey-900);opacity:0.85;border-radius:6px;z-index:1;word-wrap:break-word}.placeholder.svelte-17u4gxa:hover .error-msg.svelte-17u4gxa{display:inline}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmFsdWUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTBIQyxZQUFBLDhCQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsTUFBZSxDQUNmLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixNQUFBLENBQUEsSUFBWSxDQUNaLEtBQUEsQ0FBQSxJQUFXLEFBQ1osQ0FBQSxBQUVBLDJCQUFBLENBQUEsVUFBQSxlQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxDQUNiLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixHQUFBLENBQUEsSUFBUyxDQUNULElBQUEsQ0FBQSxJQUFVLENBQ1YsU0FBQSxDQUFBLEtBQWdCLENBQ2hCLFNBQUEsQ0FBQSxLQUFnQixDQUNoQixZQUFBLENBQUEsR0FBaUIsQ0FDakIsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLFdBQUEsQ0FBQSxHQUFnQixDQUNoQixjQUFBLENBQUEsR0FBbUIsQ0FDbkIsS0FBQSxDQUFBLEtBQVksQ0FDWixXQUFBLENBQUEsVUFBdUIsQ0FDdkIsU0FBQSxDQUFBLEtBQWdCLENBQ2hCLGdCQUFBLENBQUEsSUFBQSxVQUFBLENBQWlDLENBQ2pDLE9BQUEsQ0FBQSxJQUFhLENBQ2IsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLE9BQUEsQ0FBQSxDQUFVLENBQ1YsU0FBQSxDQUFBLFVBQXFCLEFBQ3RCLENBQUEsQUFFQSwyQkFBQSxNQUFBLENBQUEsVUFBQSxlQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsTUFBZSxBQUNoQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlZhbHVlLnN2ZWx0ZSJdfQ== */");
}
function create_else_block21(ctx) {
  let span2;
  let span0;
  let t0;
  let t1;
  let icon;
  let t2;
  let span1;
  let t3;
  let current;
  icon = new Icon_default({
    props: {
      src: HelpCircle,
      class: "w-6 h-6 text-gray-100 pb-0.5 pt-[1px]"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span2 = element("span");
      span0 = element("span");
      t0 = text("Error");
      t1 = space();
      create_component(icon.$$.fragment);
      t2 = space();
      span1 = element("span");
      t3 = text(
        /*error*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      span2 = claim_element(nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      span0 = claim_element(span2_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, "Error");
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(span2_nodes);
      claim_component(icon.$$.fragment, span2_nodes);
      t2 = claim_space(span2_nodes);
      span1 = claim_element(span2_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t3 = claim_text(
        span1_nodes,
        /*error*/
        ctx[1]
      );
      span1_nodes.forEach(detach_dev);
      span2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "inline pl-1");
      add_location(span0, file62, 112, 2, 2996);
      attr_dev(span1, "class", "hidden group-hover:inline absolute -top-1 left-[105%] text-sm z-10 px-2 py-1 bg-gray-800/80 leading-relaxed min-w-[150px] max-w-[400px] rounded-md");
      add_location(span1, file62, 114, 2, 3111);
      attr_dev(span2, "class", "group inline-flex gap-1 items-center relative cursor-help text-white font-sans text-sm bg-red-700 rounded-2xl pl-2 pr-[1px] mx-0.5");
      add_location(span2, file62, 109, 1, 2844);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span2, anchor);
      append_hydration_dev(span2, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(span2, t1);
      mount_component(icon, span2, null);
      append_hydration_dev(span2, t2);
      append_hydration_dev(span2, span1);
      append_hydration_dev(span1, t3);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*error*/
      2)
        set_data_dev(
          t3,
          /*error*/
          ctx2[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span2);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block21.name,
    type: "else",
    source: "(109:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_122(ctx) {
  let pulsenumber;
  let current;
  pulsenumber = new PulseNumber_default({
    props: {
      value: formatValue(
        /*selected_value*/
        ctx[3],
        /*format_object*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(pulsenumber.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(pulsenumber.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(pulsenumber, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const pulsenumber_changes = {};
      if (dirty & /*selected_value, format_object*/
      12)
        pulsenumber_changes.value = formatValue(
          /*selected_value*/
          ctx2[3],
          /*format_object*/
          ctx2[2]
        );
      pulsenumber.$set(pulsenumber_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pulsenumber.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pulsenumber.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(pulsenumber, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_122.name,
    type: "if",
    source: "(107:17) ",
    ctx
  });
  return block;
}
function create_if_block46(ctx) {
  let span1;
  let t0;
  let t1;
  let t2;
  let span0;
  let t3;
  const block = {
    c: function create() {
      span1 = element("span");
      t0 = text("[");
      t1 = text(
        /*placeholder*/
        ctx[0]
      );
      t2 = text("]");
      span0 = element("span");
      t3 = text("Placeholder: no data currently referenced.");
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t0 = claim_text(span1_nodes, "[");
      t1 = claim_text(
        span1_nodes,
        /*placeholder*/
        ctx[0]
      );
      t2 = claim_text(span1_nodes, "]");
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t3 = claim_text(span0_nodes, "Placeholder: no data currently referenced.");
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "error-msg svelte-17u4gxa");
      add_location(span0, file62, 104, 18, 2666);
      attr_dev(span1, "class", "placeholder svelte-17u4gxa");
      add_location(span1, file62, 103, 1, 2622);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t0);
      append_hydration_dev(span1, t1);
      append_hydration_dev(span1, t2);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t3);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*placeholder*/
      1)
        set_data_dev(
          t1,
          /*placeholder*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block46.name,
    type: "if",
    source: "(103:0) {#if placeholder}",
    ctx
  });
  return block;
}
function create_fragment76(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block46, create_if_block_122, create_else_block21];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*placeholder*/
      ctx2[0]
    )
      return 0;
    if (!/*error*/
    ctx2[1])
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude73 = true;
function instance76($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Value", slots, []);
  let { data = null } = $$props;
  let { row = 0 } = $$props;
  let { column = null } = $$props;
  let { value = null } = $$props;
  let { placeholder = null } = $$props;
  let { fmt = void 0 } = $$props;
  let format_object;
  let selected_value;
  let error;
  let columnSummary;
  const writable_props = ["data", "row", "column", "value", "placeholder", "fmt"];
  Object_15.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_12.warn(`<Value> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(4, data = $$props2.data);
    if ("row" in $$props2)
      $$invalidate(6, row = $$props2.row);
    if ("column" in $$props2)
      $$invalidate(5, column = $$props2.column);
    if ("value" in $$props2)
      $$invalidate(7, value = $$props2.value);
    if ("placeholder" in $$props2)
      $$invalidate(0, placeholder = $$props2.placeholder);
    if ("fmt" in $$props2)
      $$invalidate(8, fmt = $$props2.fmt);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude73,
    getColumnSummary,
    formatValue,
    getFormatObjectFromString,
    convertColumnToDate,
    checkInputs,
    Icon: Icon_default,
    HelpCircle,
    PulseNumber: PulseNumber_default,
    strictBuild,
    data,
    row,
    column,
    value,
    placeholder,
    fmt,
    format_object,
    selected_value,
    error,
    columnSummary
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(4, data = $$props2.data);
    if ("row" in $$props2)
      $$invalidate(6, row = $$props2.row);
    if ("column" in $$props2)
      $$invalidate(5, column = $$props2.column);
    if ("value" in $$props2)
      $$invalidate(7, value = $$props2.value);
    if ("placeholder" in $$props2)
      $$invalidate(0, placeholder = $$props2.placeholder);
    if ("fmt" in $$props2)
      $$invalidate(8, fmt = $$props2.fmt);
    if ("format_object" in $$props2)
      $$invalidate(2, format_object = $$props2.format_object);
    if ("selected_value" in $$props2)
      $$invalidate(3, selected_value = $$props2.selected_value);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("columnSummary" in $$props2)
      $$invalidate(9, columnSummary = $$props2.columnSummary);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*column, value*/
    160) {
      $:
        $$invalidate(5, column = column ?? value);
    }
    if ($$self.$$.dirty & /*placeholder, data, row, column, columnSummary, fmt, error*/
    883) {
      $: {
        try {
          $$invalidate(1, error = void 0);
          if (!placeholder) {
            if (data) {
              if (typeof data == "string") {
                throw Error(`Received: data=${data}, expected: data={${data}}`);
              }
              if (!Array.isArray(data)) {
                $$invalidate(4, data = [data]);
              }
              if (isNaN(row)) {
                throw Error("row must be a number (row=" + row + ")");
              }
              try {
                Object.keys(data[row])[0];
              } catch (e) {
                throw Error("Row " + row + " does not exist in the dataset");
              }
              $$invalidate(5, column = column ?? Object.keys(data[row])[0]);
              checkInputs(data, [column]);
              $$invalidate(9, columnSummary = getColumnSummary(data, "array"));
              let dateCols = columnSummary.filter((d) => d.type === "date");
              dateCols = dateCols.map((d) => d.id);
              if (dateCols.length > 0) {
                for (let i = 0; i < dateCols.length; i++) {
                  $$invalidate(4, data = convertColumnToDate(data, dateCols[i]));
                }
              }
              $$invalidate(3, selected_value = data[row][column]);
              $$invalidate(9, columnSummary = columnSummary.filter((d) => d.id === column));
              if (fmt) {
                $$invalidate(2, format_object = getFormatObjectFromString(fmt, columnSummary[0].format.valueType));
              } else {
                $$invalidate(2, format_object = columnSummary[0].format);
              }
            } else {
              throw Error("No data provided. If you referenced a query result, check that the name is correct.");
            }
          }
        } catch (e) {
          $$invalidate(1, error = e.message);
          if (strictBuild) {
            throw error;
          }
        }
      }
    }
    if ($$self.$$.dirty & /*value, column*/
    160) {
      $:
        if (value && column) {
          console.warn('Both "value" and "column" were supplied as props to Value. "value" will be ignored.');
        }
    }
  };
  return [
    placeholder,
    error,
    format_object,
    selected_value,
    data,
    column,
    row,
    value,
    fmt,
    columnSummary
  ];
}
var Value = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance76,
      create_fragment76,
      safe_not_equal,
      {
        data: 4,
        row: 6,
        column: 5,
        value: 7,
        placeholder: 0,
        fmt: 8
      },
      add_css52
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Value",
      options,
      id: create_fragment76.name
    });
  }
  get data() {
    throw new Error_15("<Value>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error_15("<Value>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get row() {
    throw new Error_15("<Value>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set row(value) {
    throw new Error_15("<Value>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get column() {
    throw new Error_15("<Value>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set column(value) {
    throw new Error_15("<Value>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error_15("<Value>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error_15("<Value>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error_15("<Value>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error_15("<Value>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fmt() {
    throw new Error_15("<Value>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fmt(value) {
    throw new Error_15("<Value>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Value_default = Value;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/BigValue.svelte
import { LinkedChart } from "svelte-tiny-linked-charts";
var { Error: Error_16 } = globals;
var file63 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/viz/BigValue.svelte";
function add_css53(target) {
  append_styles(target, "svelte-14akk3c", "div[data-viz='BigValue'].svelte-14akk3c svg{height:16px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmlnVmFsdWUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXFKQyxHQUFBLENBQUEsUUFBQSxDQUFBLFVBQUEsZ0JBQUEsQ0FBQSxBQUFBLEdBQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLElBQVksQUFDYixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJpZ1ZhbHVlLnN2ZWx0ZSJdfQ== */");
}
function create_else_block22(ctx) {
  let p;
  let t0;
  let t1;
  let div;
  let value_1;
  let t2;
  let t3;
  let if_block1_anchor;
  let current;
  value_1 = new Value_default({
    props: {
      data: (
        /*data*/
        ctx[0]
      ),
      column: (
        /*value*/
        ctx[3]
      ),
      fmt: (
        /*fmt*/
        ctx[6]
      )
    },
    $$inline: true
  });
  let if_block0 = (
    /*sparkline*/
    ctx[5] && create_if_block_216(ctx)
  );
  let if_block1 = (
    /*comparison*/
    ctx[4] && create_if_block_123(ctx)
  );
  const block = {
    c: function create() {
      p = element("p");
      t0 = text(
        /*title*/
        ctx[1]
      );
      t1 = space();
      div = element("div");
      create_component(value_1.$$.fragment);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      t0 = claim_text(
        p_nodes,
        /*title*/
        ctx[1]
      );
      p_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(value_1.$$.fragment, div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block0)
        if_block0.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "class", "text-sm font-medium text-grey-700 text-shadow shadow-white m-0");
      add_location(p, file63, 110, 2, 2740);
      attr_dev(div, "class", "relative");
      add_location(div, file63, 111, 2, 2828);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div, anchor);
      mount_component(value_1, div, null);
      append_hydration_dev(div, t2);
      if (if_block0)
        if_block0.m(div, null);
      insert_hydration_dev(target, t3, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*title*/
      2)
        set_data_dev(
          t0,
          /*title*/
          ctx2[1]
        );
      const value_1_changes = {};
      if (dirty & /*data*/
      1)
        value_1_changes.data = /*data*/
        ctx2[0];
      if (dirty & /*value*/
      8)
        value_1_changes.column = /*value*/
        ctx2[3];
      if (dirty & /*fmt*/
      64)
        value_1_changes.fmt = /*fmt*/
        ctx2[6];
      value_1.$set(value_1_changes);
      if (
        /*sparkline*/
        ctx2[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*sparkline*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_216(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*comparison*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*comparison*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_123(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(value_1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(value_1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(div);
      destroy_component(value_1);
      if (if_block0)
        if_block0.d();
      if (detaching)
        detach_dev(t3);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block22.name,
    type: "else",
    source: "(110:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block47(ctx) {
  let errorchart;
  let current;
  errorchart = new ErrorChart_default({
    props: {
      chartType: "Big Value",
      error: (
        /*error*/
        ctx[11].message
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(errorchart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(errorchart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(errorchart, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const errorchart_changes = {};
      if (dirty & /*error*/
      2048)
        errorchart_changes.error = /*error*/
        ctx2[11].message;
      errorchart.$set(errorchart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(errorchart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(errorchart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(errorchart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block47.name,
    type: "if",
    source: "(108:1) {#if error}",
    ctx
  });
  return block;
}
function create_if_block_216(ctx) {
  let show_if = (
    /*isLinkedChartReady*/
    ctx[14]()
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_37(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_216.name,
    type: "if",
    source: "(114:3) {#if sparkline}",
    ctx
  });
  return block;
}
function create_if_block_37(ctx) {
  let div;
  let switch_instance;
  let current;
  var switch_value = LinkedChart;
  function switch_props(ctx2) {
    return {
      props: {
        data: (
          /*sparklineData*/
          ctx2[13]
        ),
        type: "line",
        grow: true,
        barMinWidth: "1",
        gap: "0",
        fill: "var(--grey-400)",
        align: "left",
        hover: false,
        linked: "id",
        width: "75",
        tabindex: -1
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "inline-block");
      add_location(div, file63, 115, 5, 2947);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*sparklineData*/
      8192)
        switch_instance_changes.data = /*sparklineData*/
        ctx2[13];
      if (switch_value !== (switch_value = LinkedChart)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_37.name,
    type: "if",
    source: "(115:4) {#if isLinkedChartReady()}",
    ctx
  });
  return block;
}
function create_if_block_123(ctx) {
  let p;
  let html_tag;
  let raw_value = (
    /*positive*/
    ctx[10] ? "&#9650;" : "&#9660;"
  );
  let t0;
  let value_1;
  let t1;
  let span;
  let t2;
  let p_style_value;
  let current;
  value_1 = new Value_default({
    props: {
      data: (
        /*data*/
        ctx[0]
      ),
      column: (
        /*comparison*/
        ctx[4]
      ),
      fmt: (
        /*comparisonFmt*/
        ctx[7]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      p = element("p");
      html_tag = new HtmlTagHydration(false);
      t0 = space();
      create_component(value_1.$$.fragment);
      t1 = space();
      span = element("span");
      t2 = text(
        /*comparisonTitle*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { class: true, style: true });
      var p_nodes = children(p);
      html_tag = claim_html_tag(p_nodes, false);
      t0 = claim_space(p_nodes);
      claim_component(value_1.$$.fragment, p_nodes);
      t1 = claim_space(p_nodes);
      span = claim_element(p_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t2 = claim_text(
        span_nodes,
        /*comparisonTitle*/
        ctx[2]
      );
      span_nodes.forEach(detach_dev);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = t0;
      attr_dev(span, "class", "text-grey-700 font-normal");
      add_location(span, file63, 138, 4, 3517);
      attr_dev(p, "class", "m-0 text-xs font-medium font-ui");
      attr_dev(p, "style", p_style_value = `color:${/*comparisonColor*/
      ctx[12]}`);
      add_location(p, file63, 135, 3, 3328);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      html_tag.m(raw_value, p);
      append_hydration_dev(p, t0);
      mount_component(value_1, p, null);
      append_hydration_dev(p, t1);
      append_hydration_dev(p, span);
      append_hydration_dev(span, t2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*positive*/
      1024) && raw_value !== (raw_value = /*positive*/
      ctx2[10] ? "&#9650;" : "&#9660;"))
        html_tag.p(raw_value);
      const value_1_changes = {};
      if (dirty & /*data*/
      1)
        value_1_changes.data = /*data*/
        ctx2[0];
      if (dirty & /*comparison*/
      16)
        value_1_changes.column = /*comparison*/
        ctx2[4];
      if (dirty & /*comparisonFmt*/
      128)
        value_1_changes.fmt = /*comparisonFmt*/
        ctx2[7];
      value_1.$set(value_1_changes);
      if (!current || dirty & /*comparisonTitle*/
      4)
        set_data_dev(
          t2,
          /*comparisonTitle*/
          ctx2[2]
        );
      if (!current || dirty & /*comparisonColor*/
      4096 && p_style_value !== (p_style_value = `color:${/*comparisonColor*/
      ctx2[12]}`)) {
        attr_dev(p, "style", p_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(value_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(value_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      destroy_component(value_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_123.name,
    type: "if",
    source: "(135:2) {#if comparison}",
    ctx
  });
  return block;
}
function create_fragment77(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_style_value;
  let current;
  const if_block_creators = [create_if_block47, create_else_block22];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*error*/
      ctx2[11]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-viz": true,
        class: true,
        style: true
      });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "data-viz", "BigValue");
      attr_dev(div, "class", "inline-block font-ui py-3 pr-3 pl-0 mr-3 items-center align-top svelte-14akk3c");
      attr_dev(div, "style", div_style_value = `
        min-width: ${/*minWidth*/
      ctx[9]};
        max-width: ${/*maxWidth*/
      ctx[8]};
    `);
      add_location(div, file63, 99, 0, 2473);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*minWidth, maxWidth*/
      768 && div_style_value !== (div_style_value = `
        min-width: ${/*minWidth*/
      ctx2[9]};
        max-width: ${/*maxWidth*/
      ctx2[8]};
    `)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude74 = true;
function instance77($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BigValue", slots, []);
  let { data } = $$props;
  let { value = null } = $$props;
  let { comparison = null } = $$props;
  let { sparkline = null } = $$props;
  let { fmt = void 0 } = $$props;
  let { comparisonFmt = void 0 } = $$props;
  let { title = null } = $$props;
  let { comparisonTitle = null } = $$props;
  let { downIsGood = false } = $$props;
  let { maxWidth = "none" } = $$props;
  let { minWidth = "18%" } = $$props;
  let positive = true;
  let comparisonColor = "var(--grey-700)";
  let sparklineData = {};
  let error = void 0;
  function isLinkedChartReady() {
    try {
      if (LinkedChart) {
        return true;
      }
    } catch (e) {
      return false;
    }
    return false;
  }
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BigValue> was created without expected prop 'data'");
    }
  });
  const writable_props = [
    "data",
    "value",
    "comparison",
    "sparkline",
    "fmt",
    "comparisonFmt",
    "title",
    "comparisonTitle",
    "downIsGood",
    "maxWidth",
    "minWidth"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BigValue> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("value" in $$props2)
      $$invalidate(3, value = $$props2.value);
    if ("comparison" in $$props2)
      $$invalidate(4, comparison = $$props2.comparison);
    if ("sparkline" in $$props2)
      $$invalidate(5, sparkline = $$props2.sparkline);
    if ("fmt" in $$props2)
      $$invalidate(6, fmt = $$props2.fmt);
    if ("comparisonFmt" in $$props2)
      $$invalidate(7, comparisonFmt = $$props2.comparisonFmt);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("comparisonTitle" in $$props2)
      $$invalidate(2, comparisonTitle = $$props2.comparisonTitle);
    if ("downIsGood" in $$props2)
      $$invalidate(15, downIsGood = $$props2.downIsGood);
    if ("maxWidth" in $$props2)
      $$invalidate(8, maxWidth = $$props2.maxWidth);
    if ("minWidth" in $$props2)
      $$invalidate(9, minWidth = $$props2.minWidth);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude74,
    Value: Value_default,
    getColumnSummary,
    LinkedChart,
    getSortedData,
    checkInputs,
    ErrorChart: ErrorChart_default,
    strictBuild,
    data,
    value,
    comparison,
    sparkline,
    fmt,
    comparisonFmt,
    title,
    comparisonTitle,
    downIsGood,
    maxWidth,
    minWidth,
    positive,
    comparisonColor,
    sparklineData,
    error,
    isLinkedChartReady
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("value" in $$props2)
      $$invalidate(3, value = $$props2.value);
    if ("comparison" in $$props2)
      $$invalidate(4, comparison = $$props2.comparison);
    if ("sparkline" in $$props2)
      $$invalidate(5, sparkline = $$props2.sparkline);
    if ("fmt" in $$props2)
      $$invalidate(6, fmt = $$props2.fmt);
    if ("comparisonFmt" in $$props2)
      $$invalidate(7, comparisonFmt = $$props2.comparisonFmt);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("comparisonTitle" in $$props2)
      $$invalidate(2, comparisonTitle = $$props2.comparisonTitle);
    if ("downIsGood" in $$props2)
      $$invalidate(15, downIsGood = $$props2.downIsGood);
    if ("maxWidth" in $$props2)
      $$invalidate(8, maxWidth = $$props2.maxWidth);
    if ("minWidth" in $$props2)
      $$invalidate(9, minWidth = $$props2.minWidth);
    if ("positive" in $$props2)
      $$invalidate(10, positive = $$props2.positive);
    if ("comparisonColor" in $$props2)
      $$invalidate(12, comparisonColor = $$props2.comparisonColor);
    if ("sparklineData" in $$props2)
      $$invalidate(13, sparklineData = $$props2.sparklineData);
    if ("error" in $$props2)
      $$invalidate(11, error = $$props2.error);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, data, title, comparison, comparisonTitle, positive, downIsGood, sparkline, error*/
    35903) {
      $:
        try {
          $$invalidate(11, error = void 0);
          if (!value) {
            throw new Error("value is required");
          }
          if (!Array.isArray(data)) {
            $$invalidate(0, data = [data]);
          }
          checkInputs(data, [value]);
          let columnSummary = getColumnSummary(data, "array");
          let valueColumnSummary = columnSummary.find((d) => d.id === value);
          $$invalidate(1, title = title ?? (valueColumnSummary ? valueColumnSummary.title : null));
          if (comparison) {
            checkInputs(data, [comparison]);
            let comparisonColumnSummary = columnSummary.find((d) => d.id === comparison);
            $$invalidate(2, comparisonTitle = comparisonTitle ?? (comparisonColumnSummary ? comparisonColumnSummary.title : null));
          }
          if (data && comparison) {
            $$invalidate(10, positive = data[0][comparison] >= 0);
            $$invalidate(12, comparisonColor = positive && !downIsGood || !positive && downIsGood ? "var(--green-700)" : "var(--red-700)");
          }
          if (data && sparkline && value) {
            let sortedData = getSortedData(data, sparkline, true);
            for (let i = 0; i < sortedData.length; i++) {
              $$invalidate(13, sparklineData[sortedData[i][sparkline]] = sortedData[i][value], sparklineData);
            }
          }
        } catch (e) {
          $$invalidate(11, error = e);
          if (strictBuild) {
            throw error;
          }
        }
    }
  };
  return [
    data,
    title,
    comparisonTitle,
    value,
    comparison,
    sparkline,
    fmt,
    comparisonFmt,
    maxWidth,
    minWidth,
    positive,
    error,
    comparisonColor,
    sparklineData,
    isLinkedChartReady,
    downIsGood
  ];
}
var BigValue = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance77,
      create_fragment77,
      safe_not_equal,
      {
        data: 0,
        value: 3,
        comparison: 4,
        sparkline: 5,
        fmt: 6,
        comparisonFmt: 7,
        title: 1,
        comparisonTitle: 2,
        downIsGood: 15,
        maxWidth: 8,
        minWidth: 9
      },
      add_css53
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BigValue",
      options,
      id: create_fragment77.name
    });
  }
  get data() {
    throw new Error_16("<BigValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error_16("<BigValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error_16("<BigValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error_16("<BigValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get comparison() {
    throw new Error_16("<BigValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set comparison(value) {
    throw new Error_16("<BigValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sparkline() {
    throw new Error_16("<BigValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sparkline(value) {
    throw new Error_16("<BigValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fmt() {
    throw new Error_16("<BigValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fmt(value) {
    throw new Error_16("<BigValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get comparisonFmt() {
    throw new Error_16("<BigValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set comparisonFmt(value) {
    throw new Error_16("<BigValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error_16("<BigValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error_16("<BigValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get comparisonTitle() {
    throw new Error_16("<BigValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set comparisonTitle(value) {
    throw new Error_16("<BigValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get downIsGood() {
    throw new Error_16("<BigValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set downIsGood(value) {
    throw new Error_16("<BigValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxWidth() {
    throw new Error_16("<BigValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxWidth(value) {
    throw new Error_16("<BigValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minWidth() {
    throw new Error_16("<BigValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minWidth(value) {
    throw new Error_16("<BigValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BigValue_default = BigValue;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/Bubble.svelte
function create_fragment78(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude75 = true;
function instance78($$self, $$props, $$invalidate) {
  let data;
  let x;
  let swapXY;
  let xType;
  let xFormat;
  let yFormat;
  let sizeFormat;
  let xMismatch;
  let columnSummary;
  let sizeExtents;
  let maxData;
  let maxSizeSq;
  let seriesConfig;
  let chartOverrides;
  let $props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Bubble", slots, []);
  let props = getContext(propKey);
  validate_store(props, "props");
  component_subscribe($$self, props, (value) => $$invalidate(24, $props = value));
  let config = getContext(configKey);
  let { y = void 0 } = $$props;
  const ySet = y ? true : false;
  let { series = void 0 } = $$props;
  const seriesSet = series ? true : false;
  let { options = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { shape = void 0 } = $$props;
  let { fillColor = void 0 } = $$props;
  let { opacity = 0.7 } = $$props;
  let { outlineColor = void 0 } = $$props;
  let { outlineWidth = void 0 } = $$props;
  let maxSize = 35;
  let { scaleTo = 1 } = $$props;
  let { useTooltip = false } = $$props;
  let { tooltipTitle } = $$props;
  let multiSeries;
  let tooltipOutput;
  function bubbleSize(newPoint) {
    const newPointSize = newPoint[2];
    return Math.sqrt(newPointSize / maxData * maxSizeSq);
  }
  let baseConfig = {
    type: "scatter",
    label: { show: false },
    labelLayout: { hideOverlap: true },
    emphasis: { focus: "series" },
    symbolSize(newPoint) {
      return bubbleSize(newPoint);
    },
    symbol: shape,
    itemStyle: {
      color: fillColor,
      opacity,
      borderColor: outlineColor,
      borderWidth: outlineWidth
    }
  };
  let tooltipOpts;
  let tooltipOverride;
  if (useTooltip) {
    tooltipOpts = {
      tooltip: {
        formatter(params) {
          if (multiSeries) {
            if (tooltipTitle) {
              tooltipOutput = `<span id="tooltip" style='font-weight:600'>${formatValue(params.value[3], "0")}</span><br/>
                            ${formatTitle(series)}: <span style='float:right; margin-left: 15px;'>${formatValue(params.seriesName)}</span><br/>
                            ${formatTitle(x, xFormat)}: <span style='float:right; margin-left: 15px;'>${formatValue(params.value[0], xFormat)}</span><br/>
                            ${formatTitle(typeof y === "object" ? params.seriesName : y, yFormat)}: <span style='float:right; margin-left: 15px;'>${formatValue(params.value[1], yFormat)}</span><br/>
                            ${formatTitle(size, sizeFormat)} <span style='font-weight: 400; color:var(--grey-400);'> (size)</span>: <span style='float:right; margin-left: 15px;'>${formatValue(params.value[2], sizeFormat)}</span>`;
            } else {
              tooltipOutput = `<span id="tooltip" style='font-weight:600'>${formatValue(params.seriesName)}</span><br/>
                            ${formatTitle(x, xFormat)}: <span style='float:right; margin-left: 15px;'>${formatValue(params.value[0], xFormat)}</span><br/>
                            ${formatTitle(typeof y === "object" ? params.seriesName : y, yFormat)}: <span style='float:right; margin-left: 15px;'>${formatValue(params.value[1], yFormat)}</span><br/>
                            ${formatTitle(size, sizeFormat)} <span style='font-weight: 400; color:var(--grey-400);'> (size)</span>: <span style='float:right; margin-left: 15px;'>${formatValue(params.value[2], sizeFormat)}</span>`;
            }
          } else {
            if (tooltipTitle) {
              tooltipOutput = `<span id="tooltip" style='font-weight:600;'>${formatValue(params.value[3], "0")}</span><br/>
                            <span style='font-weight: 400;'>${formatTitle(x, xFormat)}:</span> <span style='float:right; margin-left: 15px;'>${formatValue(params.value[0], xFormat)}</span><br/>
                            <span style='font-weight: 400;'>${formatTitle(y, yFormat)}:</span> <span style='float:right; margin-left: 15px;'>${formatValue(params.value[1], yFormat)}</span><br/>
                            <span style='font-weight: 400;'>${formatTitle(size, sizeFormat)} <span style='font-weight: 400; color:var(--grey-400);'> (size)</span>:</span> <span style='float:right; margin-left: 15px;'>${formatValue(params.value[2], sizeFormat)}</span>`;
            } else {
              tooltipOutput = `<span id="tooltip" style='font-weight: 600;'>${formatTitle(x, xFormat)}:</span> <span style='float:right; margin-left: 15px;'>${formatValue(params.value[0], xFormat)}</span><br/>
                            <span style='font-weight: 600;'>${formatTitle(y, yFormat)}:</span> <span style='float:right; margin-left: 15px;'>${formatValue(params.value[1], yFormat)}</span><br/>
                            <span style='font-weight: 600;'>${formatTitle(size, sizeFormat)} <span style='font-weight: 400; color:var(--grey-400);'> (size)</span>:</span> <span style='float:right; margin-left: 15px;'>${formatValue(params.value[2], sizeFormat)}</span>`;
            }
          }
          return tooltipOutput;
        }
      }
    };
    baseConfig = { ...baseConfig, ...tooltipOpts };
    tooltipOverride = { tooltip: { trigger: "item" } };
  }
  beforeUpdate(() => {
    config.update((d) => {
      if (swapXY) {
        d.yAxis = { ...d.yAxis, ...chartOverrides.xAxis };
        d.xAxis = { ...d.xAxis, ...chartOverrides.yAxis };
      } else {
        d.yAxis = { ...d.yAxis, ...chartOverrides.yAxis };
        d.xAxis = { ...d.xAxis, ...chartOverrides.xAxis };
      }
      if (useTooltip) {
        d.tooltip = { ...d.tooltip, ...tooltipOverride.tooltip };
      }
      return d;
    });
  });
  $$self.$$.on_mount.push(function() {
    if (tooltipTitle === void 0 && !("tooltipTitle" in $$props || $$self.$$.bound[$$self.$$.props["tooltipTitle"]])) {
      console.warn("<Bubble> was created without expected prop 'tooltipTitle'");
    }
  });
  const writable_props = [
    "y",
    "series",
    "options",
    "size",
    "name",
    "shape",
    "fillColor",
    "opacity",
    "outlineColor",
    "outlineWidth",
    "scaleTo",
    "useTooltip",
    "tooltipTitle"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Bubble> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(2, series = $$props2.series);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
    if ("size" in $$props2)
      $$invalidate(3, size = $$props2.size);
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("shape" in $$props2)
      $$invalidate(7, shape = $$props2.shape);
    if ("fillColor" in $$props2)
      $$invalidate(8, fillColor = $$props2.fillColor);
    if ("opacity" in $$props2)
      $$invalidate(9, opacity = $$props2.opacity);
    if ("outlineColor" in $$props2)
      $$invalidate(10, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(11, outlineWidth = $$props2.outlineWidth);
    if ("scaleTo" in $$props2)
      $$invalidate(12, scaleTo = $$props2.scaleTo);
    if ("useTooltip" in $$props2)
      $$invalidate(13, useTooltip = $$props2.useTooltip);
    if ("tooltipTitle" in $$props2)
      $$invalidate(5, tooltipTitle = $$props2.tooltipTitle);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude75,
    getContext,
    beforeUpdate,
    propKey,
    configKey,
    props,
    config,
    getSeriesConfig,
    getColumnExtentsLegacy,
    formatTitle,
    formatValue,
    getCompletedData,
    y,
    ySet,
    series,
    seriesSet,
    options,
    size,
    name,
    shape,
    fillColor,
    opacity,
    outlineColor,
    outlineWidth,
    maxSize,
    scaleTo,
    useTooltip,
    tooltipTitle,
    multiSeries,
    tooltipOutput,
    bubbleSize,
    baseConfig,
    tooltipOpts,
    tooltipOverride,
    chartOverrides,
    swapXY,
    xType,
    seriesConfig,
    columnSummary,
    xMismatch,
    x,
    data,
    sizeFormat,
    yFormat,
    xFormat,
    maxSizeSq,
    maxData,
    sizeExtents,
    $props
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("config" in $$props2)
      $$invalidate(35, config = $$props2.config);
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(2, series = $$props2.series);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
    if ("size" in $$props2)
      $$invalidate(3, size = $$props2.size);
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("shape" in $$props2)
      $$invalidate(7, shape = $$props2.shape);
    if ("fillColor" in $$props2)
      $$invalidate(8, fillColor = $$props2.fillColor);
    if ("opacity" in $$props2)
      $$invalidate(9, opacity = $$props2.opacity);
    if ("outlineColor" in $$props2)
      $$invalidate(10, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(11, outlineWidth = $$props2.outlineWidth);
    if ("maxSize" in $$props2)
      $$invalidate(14, maxSize = $$props2.maxSize);
    if ("scaleTo" in $$props2)
      $$invalidate(12, scaleTo = $$props2.scaleTo);
    if ("useTooltip" in $$props2)
      $$invalidate(13, useTooltip = $$props2.useTooltip);
    if ("tooltipTitle" in $$props2)
      $$invalidate(5, tooltipTitle = $$props2.tooltipTitle);
    if ("multiSeries" in $$props2)
      multiSeries = $$props2.multiSeries;
    if ("tooltipOutput" in $$props2)
      tooltipOutput = $$props2.tooltipOutput;
    if ("baseConfig" in $$props2)
      $$invalidate(15, baseConfig = $$props2.baseConfig);
    if ("tooltipOpts" in $$props2)
      tooltipOpts = $$props2.tooltipOpts;
    if ("tooltipOverride" in $$props2)
      tooltipOverride = $$props2.tooltipOverride;
    if ("chartOverrides" in $$props2)
      chartOverrides = $$props2.chartOverrides;
    if ("swapXY" in $$props2)
      $$invalidate(16, swapXY = $$props2.swapXY);
    if ("xType" in $$props2)
      $$invalidate(17, xType = $$props2.xType);
    if ("seriesConfig" in $$props2)
      $$invalidate(18, seriesConfig = $$props2.seriesConfig);
    if ("columnSummary" in $$props2)
      $$invalidate(19, columnSummary = $$props2.columnSummary);
    if ("xMismatch" in $$props2)
      $$invalidate(20, xMismatch = $$props2.xMismatch);
    if ("x" in $$props2)
      $$invalidate(21, x = $$props2.x);
    if ("data" in $$props2)
      $$invalidate(22, data = $$props2.data);
    if ("sizeFormat" in $$props2)
      sizeFormat = $$props2.sizeFormat;
    if ("yFormat" in $$props2)
      yFormat = $$props2.yFormat;
    if ("xFormat" in $$props2)
      xFormat = $$props2.xFormat;
    if ("maxSizeSq" in $$props2)
      maxSizeSq = $$props2.maxSizeSq;
    if ("maxData" in $$props2)
      maxData = $$props2.maxData;
    if ("sizeExtents" in $$props2)
      $$invalidate(23, sizeExtents = $$props2.sizeExtents);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*maxSize, scaleTo*/
    20480) {
      $:
        $$invalidate(14, maxSize = maxSize * (scaleTo / 1));
    }
    if ($$self.$$.dirty[0] & /*$props*/
    16777216) {
      $:
        $$invalidate(22, data = $props.data);
    }
    if ($$self.$$.dirty[0] & /*$props*/
    16777216) {
      $:
        $$invalidate(21, x = $props.x);
    }
    if ($$self.$$.dirty[0] & /*$props*/
    16777216) {
      $:
        $$invalidate(16, swapXY = $props.swapXY);
    }
    if ($$self.$$.dirty[0] & /*$props*/
    16777216) {
      $:
        $$invalidate(17, xType = $props.xType);
    }
    if ($$self.$$.dirty[0] & /*$props*/
    16777216) {
      $:
        xFormat = $props.xFormat;
    }
    if ($$self.$$.dirty[0] & /*$props*/
    16777216) {
      $:
        yFormat = $props.yFormat;
    }
    if ($$self.$$.dirty[0] & /*$props*/
    16777216) {
      $:
        sizeFormat = $props.sizeFormat;
    }
    if ($$self.$$.dirty[0] & /*$props*/
    16777216) {
      $:
        $$invalidate(20, xMismatch = $props.xMismatch);
    }
    if ($$self.$$.dirty[0] & /*$props*/
    16777216) {
      $:
        $$invalidate(19, columnSummary = $props.columnSummary);
    }
    if ($$self.$$.dirty[0] & /*y, $props*/
    16777218) {
      $:
        $$invalidate(1, y = ySet ? y : $props.y);
    }
    if ($$self.$$.dirty[0] & /*series, $props*/
    16777220) {
      $:
        $$invalidate(2, series = seriesSet ? series : $props.series);
    }
    if ($$self.$$.dirty[0] & /*size, $props*/
    16777224) {
      $:
        $$invalidate(3, size = size ?? $props.size);
    }
    if ($$self.$$.dirty[0] & /*tooltipTitle, $props*/
    16777248) {
      $:
        $$invalidate(5, tooltipTitle = tooltipTitle ?? $props.tooltipTitle);
    }
    if ($$self.$$.dirty[0] & /*series, y, name, columnSummary, data, x*/
    6815766) {
      $:
        if (!series && typeof y !== "object") {
          $$invalidate(4, name = name ?? formatTitle(y, columnSummary[y].title));
          multiSeries = false;
        } else {
          $$invalidate(22, data = getCompletedData(data, x, y, series));
          multiSeries = true;
        }
    }
    if ($$self.$$.dirty[0] & /*data, size*/
    4194312) {
      $:
        $$invalidate(23, sizeExtents = getColumnExtentsLegacy(data, size));
    }
    if ($$self.$$.dirty[0] & /*sizeExtents*/
    8388608) {
      $:
        maxData = sizeExtents[1];
    }
    if ($$self.$$.dirty[0] & /*maxSize*/
    16384) {
      $:
        maxSizeSq = Math.pow(maxSize, 2);
    }
    if ($$self.$$.dirty[0] & /*options, baseConfig*/
    32832) {
      $:
        if (options) {
          $$invalidate(15, baseConfig = { ...baseConfig, ...options });
        }
    }
    if ($$self.$$.dirty[0] & /*data, x, y, series, swapXY, baseConfig, name, xMismatch, columnSummary, size, tooltipTitle*/
    7962686) {
      $:
        $$invalidate(18, seriesConfig = getSeriesConfig(data, x, y, series, swapXY, baseConfig, name, xMismatch, columnSummary, size, tooltipTitle));
    }
    if ($$self.$$.dirty[0] & /*seriesConfig*/
    262144) {
      $:
        config.update((d) => {
          d.series.push(...seriesConfig);
          return d;
        });
    }
    if ($$self.$$.dirty[0] & /*xType*/
    131072) {
      $:
        chartOverrides = {
          yAxis: { scale: true, boundaryGap: ["1%", "1%"] },
          xAxis: {
            boundaryGap: [xType === "time" ? "2%" : "1%", "2%"]
          }
        };
    }
  };
  return [
    props,
    y,
    series,
    size,
    name,
    tooltipTitle,
    options,
    shape,
    fillColor,
    opacity,
    outlineColor,
    outlineWidth,
    scaleTo,
    useTooltip,
    maxSize,
    baseConfig,
    swapXY,
    xType,
    seriesConfig,
    columnSummary,
    xMismatch,
    x,
    data,
    sizeExtents,
    $props
  ];
}
var Bubble = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance78,
      create_fragment78,
      safe_not_equal,
      {
        y: 1,
        series: 2,
        options: 6,
        size: 3,
        name: 4,
        shape: 7,
        fillColor: 8,
        opacity: 9,
        outlineColor: 10,
        outlineWidth: 11,
        scaleTo: 12,
        useTooltip: 13,
        tooltipTitle: 5
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Bubble",
      options,
      id: create_fragment78.name
    });
  }
  get y() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get series() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set series(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shape() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shape(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillColor() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillColor(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineColor() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineColor(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineWidth() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineWidth(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleTo() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleTo(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useTooltip() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useTooltip(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTitle() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTitle(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Bubble_default = Bubble;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/BubbleChart.svelte
function create_default_slot8(ctx) {
  let bubble_1;
  let t;
  let current;
  bubble_1 = new Bubble_default({
    props: {
      shape: (
        /*shape*/
        ctx[24]
      ),
      fillColor: (
        /*fillColor*/
        ctx[25]
      ),
      opacity: (
        /*opacity*/
        ctx[26]
      ),
      outlineColor: (
        /*outlineColor*/
        ctx[27]
      ),
      outlineWidth: (
        /*outlineWidth*/
        ctx[28]
      ),
      scaleTo: (
        /*scaleTo*/
        ctx[29]
      ),
      useTooltip: (
        /*useTooltip*/
        ctx[35]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[36].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    null
  );
  const block = {
    c: function create() {
      create_component(bubble_1.$$.fragment);
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(bubble_1.$$.fragment, nodes);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(bubble_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const bubble_1_changes = {};
      if (dirty[0] & /*shape*/
      16777216)
        bubble_1_changes.shape = /*shape*/
        ctx2[24];
      if (dirty[0] & /*fillColor*/
      33554432)
        bubble_1_changes.fillColor = /*fillColor*/
        ctx2[25];
      if (dirty[0] & /*opacity*/
      67108864)
        bubble_1_changes.opacity = /*opacity*/
        ctx2[26];
      if (dirty[0] & /*outlineColor*/
      134217728)
        bubble_1_changes.outlineColor = /*outlineColor*/
        ctx2[27];
      if (dirty[0] & /*outlineWidth*/
      268435456)
        bubble_1_changes.outlineWidth = /*outlineWidth*/
        ctx2[28];
      if (dirty[0] & /*scaleTo*/
      536870912)
        bubble_1_changes.scaleTo = /*scaleTo*/
        ctx2[29];
      bubble_1.$set(bubble_1_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(bubble_1.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(bubble_1.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(bubble_1, detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(54:0) <Chart  {data}  {x}  {y}  {size}  {xFmt}  {yFmt}  {sizeFmt}  {tooltipTitle}  {series}  {xType}  {legend}  {xAxisTitle}  {yAxisTitle}  {xGridlines}  {yGridlines}  {xAxisLabels}  {yAxisLabels}  {xBaseline}  {yBaseline}  {xTickMarks}  {yTickMarks}  {yMin}  {yMax}  {title}  {subtitle}  {chartType}  {bubble}  {sort}  {chartAreaHeight} >",
    ctx
  });
  return block;
}
function create_fragment79(ctx) {
  let chart;
  let current;
  chart = new Chart_default({
    props: {
      data: (
        /*data*/
        ctx[0]
      ),
      x: (
        /*x*/
        ctx[1]
      ),
      y: (
        /*y*/
        ctx[2]
      ),
      size: (
        /*size*/
        ctx[3]
      ),
      xFmt: (
        /*xFmt*/
        ctx[7]
      ),
      yFmt: (
        /*yFmt*/
        ctx[6]
      ),
      sizeFmt: (
        /*sizeFmt*/
        ctx[8]
      ),
      tooltipTitle: (
        /*tooltipTitle*/
        ctx[32]
      ),
      series: (
        /*series*/
        ctx[4]
      ),
      xType: (
        /*xType*/
        ctx[5]
      ),
      legend: (
        /*legend*/
        ctx[11]
      ),
      xAxisTitle: (
        /*xAxisTitle*/
        ctx[12]
      ),
      yAxisTitle: (
        /*yAxisTitle*/
        ctx[13]
      ),
      xGridlines: (
        /*xGridlines*/
        ctx[14]
      ),
      yGridlines: (
        /*yGridlines*/
        ctx[15]
      ),
      xAxisLabels: (
        /*xAxisLabels*/
        ctx[16]
      ),
      yAxisLabels: (
        /*yAxisLabels*/
        ctx[17]
      ),
      xBaseline: (
        /*xBaseline*/
        ctx[18]
      ),
      yBaseline: (
        /*yBaseline*/
        ctx[19]
      ),
      xTickMarks: (
        /*xTickMarks*/
        ctx[20]
      ),
      yTickMarks: (
        /*yTickMarks*/
        ctx[21]
      ),
      yMin: (
        /*yMin*/
        ctx[22]
      ),
      yMax: (
        /*yMax*/
        ctx[23]
      ),
      title: (
        /*title*/
        ctx[9]
      ),
      subtitle: (
        /*subtitle*/
        ctx[10]
      ),
      chartType: (
        /*chartType*/
        ctx[33]
      ),
      bubble: (
        /*bubble*/
        ctx[34]
      ),
      sort: (
        /*sort*/
        ctx[31]
      ),
      chartAreaHeight: (
        /*chartAreaHeight*/
        ctx[30]
      ),
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chart, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chart_changes = {};
      if (dirty[0] & /*data*/
      1)
        chart_changes.data = /*data*/
        ctx2[0];
      if (dirty[0] & /*x*/
      2)
        chart_changes.x = /*x*/
        ctx2[1];
      if (dirty[0] & /*y*/
      4)
        chart_changes.y = /*y*/
        ctx2[2];
      if (dirty[0] & /*size*/
      8)
        chart_changes.size = /*size*/
        ctx2[3];
      if (dirty[0] & /*xFmt*/
      128)
        chart_changes.xFmt = /*xFmt*/
        ctx2[7];
      if (dirty[0] & /*yFmt*/
      64)
        chart_changes.yFmt = /*yFmt*/
        ctx2[6];
      if (dirty[0] & /*sizeFmt*/
      256)
        chart_changes.sizeFmt = /*sizeFmt*/
        ctx2[8];
      if (dirty[1] & /*tooltipTitle*/
      2)
        chart_changes.tooltipTitle = /*tooltipTitle*/
        ctx2[32];
      if (dirty[0] & /*series*/
      16)
        chart_changes.series = /*series*/
        ctx2[4];
      if (dirty[0] & /*xType*/
      32)
        chart_changes.xType = /*xType*/
        ctx2[5];
      if (dirty[0] & /*legend*/
      2048)
        chart_changes.legend = /*legend*/
        ctx2[11];
      if (dirty[0] & /*xAxisTitle*/
      4096)
        chart_changes.xAxisTitle = /*xAxisTitle*/
        ctx2[12];
      if (dirty[0] & /*yAxisTitle*/
      8192)
        chart_changes.yAxisTitle = /*yAxisTitle*/
        ctx2[13];
      if (dirty[0] & /*xGridlines*/
      16384)
        chart_changes.xGridlines = /*xGridlines*/
        ctx2[14];
      if (dirty[0] & /*yGridlines*/
      32768)
        chart_changes.yGridlines = /*yGridlines*/
        ctx2[15];
      if (dirty[0] & /*xAxisLabels*/
      65536)
        chart_changes.xAxisLabels = /*xAxisLabels*/
        ctx2[16];
      if (dirty[0] & /*yAxisLabels*/
      131072)
        chart_changes.yAxisLabels = /*yAxisLabels*/
        ctx2[17];
      if (dirty[0] & /*xBaseline*/
      262144)
        chart_changes.xBaseline = /*xBaseline*/
        ctx2[18];
      if (dirty[0] & /*yBaseline*/
      524288)
        chart_changes.yBaseline = /*yBaseline*/
        ctx2[19];
      if (dirty[0] & /*xTickMarks*/
      1048576)
        chart_changes.xTickMarks = /*xTickMarks*/
        ctx2[20];
      if (dirty[0] & /*yTickMarks*/
      2097152)
        chart_changes.yTickMarks = /*yTickMarks*/
        ctx2[21];
      if (dirty[0] & /*yMin*/
      4194304)
        chart_changes.yMin = /*yMin*/
        ctx2[22];
      if (dirty[0] & /*yMax*/
      8388608)
        chart_changes.yMax = /*yMax*/
        ctx2[23];
      if (dirty[0] & /*title*/
      512)
        chart_changes.title = /*title*/
        ctx2[9];
      if (dirty[0] & /*subtitle*/
      1024)
        chart_changes.subtitle = /*subtitle*/
        ctx2[10];
      if (dirty[1] & /*sort*/
      1)
        chart_changes.sort = /*sort*/
        ctx2[31];
      if (dirty[0] & /*chartAreaHeight*/
      1073741824)
        chart_changes.chartAreaHeight = /*chartAreaHeight*/
        ctx2[30];
      if (dirty[0] & /*shape, fillColor, opacity, outlineColor, outlineWidth, scaleTo*/
      1056964608 | dirty[1] & /*$$scope*/
      64) {
        chart_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chart.$set(chart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude76 = true;
function instance79($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BubbleChart", slots, ["default"]);
  let { data = void 0 } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { series = void 0 } = $$props;
  let { xType = void 0 } = $$props;
  let { yFmt = void 0 } = $$props;
  let { xFmt = void 0 } = $$props;
  let { sizeFmt = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { legend = void 0 } = $$props;
  let { xAxisTitle = "true" } = $$props;
  let { yAxisTitle = "true" } = $$props;
  let { xGridlines = void 0 } = $$props;
  let { yGridlines = void 0 } = $$props;
  let { xAxisLabels = void 0 } = $$props;
  let { yAxisLabels = void 0 } = $$props;
  let { xBaseline = void 0 } = $$props;
  let { yBaseline = void 0 } = $$props;
  let { xTickMarks = void 0 } = $$props;
  let { yTickMarks = void 0 } = $$props;
  let { yMin = void 0 } = $$props;
  let { yMax = void 0 } = $$props;
  let { shape = void 0 } = $$props;
  let { fillColor = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { outlineColor = void 0 } = $$props;
  let { outlineWidth = void 0 } = $$props;
  let { scaleTo = void 0 } = $$props;
  let { chartAreaHeight = void 0 } = $$props;
  let { sort = void 0 } = $$props;
  let { tooltipTitle = void 0 } = $$props;
  let chartType = "Bubble Chart";
  let bubble = true;
  let useTooltip = true;
  const writable_props = [
    "data",
    "x",
    "y",
    "size",
    "series",
    "xType",
    "yFmt",
    "xFmt",
    "sizeFmt",
    "title",
    "subtitle",
    "legend",
    "xAxisTitle",
    "yAxisTitle",
    "xGridlines",
    "yGridlines",
    "xAxisLabels",
    "yAxisLabels",
    "xBaseline",
    "yBaseline",
    "xTickMarks",
    "yTickMarks",
    "yMin",
    "yMax",
    "shape",
    "fillColor",
    "opacity",
    "outlineColor",
    "outlineWidth",
    "scaleTo",
    "chartAreaHeight",
    "sort",
    "tooltipTitle"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BubbleChart> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y = $$props2.y);
    if ("size" in $$props2)
      $$invalidate(3, size = $$props2.size);
    if ("series" in $$props2)
      $$invalidate(4, series = $$props2.series);
    if ("xType" in $$props2)
      $$invalidate(5, xType = $$props2.xType);
    if ("yFmt" in $$props2)
      $$invalidate(6, yFmt = $$props2.yFmt);
    if ("xFmt" in $$props2)
      $$invalidate(7, xFmt = $$props2.xFmt);
    if ("sizeFmt" in $$props2)
      $$invalidate(8, sizeFmt = $$props2.sizeFmt);
    if ("title" in $$props2)
      $$invalidate(9, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(10, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(11, legend = $$props2.legend);
    if ("xAxisTitle" in $$props2)
      $$invalidate(12, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(13, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(14, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(15, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(16, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(17, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(18, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(19, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(20, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(21, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(22, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(23, yMax = $$props2.yMax);
    if ("shape" in $$props2)
      $$invalidate(24, shape = $$props2.shape);
    if ("fillColor" in $$props2)
      $$invalidate(25, fillColor = $$props2.fillColor);
    if ("opacity" in $$props2)
      $$invalidate(26, opacity = $$props2.opacity);
    if ("outlineColor" in $$props2)
      $$invalidate(27, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(28, outlineWidth = $$props2.outlineWidth);
    if ("scaleTo" in $$props2)
      $$invalidate(29, scaleTo = $$props2.scaleTo);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(30, chartAreaHeight = $$props2.chartAreaHeight);
    if ("sort" in $$props2)
      $$invalidate(31, sort = $$props2.sort);
    if ("tooltipTitle" in $$props2)
      $$invalidate(32, tooltipTitle = $$props2.tooltipTitle);
    if ("$$scope" in $$props2)
      $$invalidate(37, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude76,
    Chart: Chart_default,
    Bubble: Bubble_default,
    data,
    x,
    y,
    size,
    series,
    xType,
    yFmt,
    xFmt,
    sizeFmt,
    title,
    subtitle,
    legend,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    shape,
    fillColor,
    opacity,
    outlineColor,
    outlineWidth,
    scaleTo,
    chartAreaHeight,
    sort,
    tooltipTitle,
    chartType,
    bubble,
    useTooltip
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y = $$props2.y);
    if ("size" in $$props2)
      $$invalidate(3, size = $$props2.size);
    if ("series" in $$props2)
      $$invalidate(4, series = $$props2.series);
    if ("xType" in $$props2)
      $$invalidate(5, xType = $$props2.xType);
    if ("yFmt" in $$props2)
      $$invalidate(6, yFmt = $$props2.yFmt);
    if ("xFmt" in $$props2)
      $$invalidate(7, xFmt = $$props2.xFmt);
    if ("sizeFmt" in $$props2)
      $$invalidate(8, sizeFmt = $$props2.sizeFmt);
    if ("title" in $$props2)
      $$invalidate(9, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(10, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(11, legend = $$props2.legend);
    if ("xAxisTitle" in $$props2)
      $$invalidate(12, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(13, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(14, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(15, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(16, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(17, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(18, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(19, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(20, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(21, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(22, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(23, yMax = $$props2.yMax);
    if ("shape" in $$props2)
      $$invalidate(24, shape = $$props2.shape);
    if ("fillColor" in $$props2)
      $$invalidate(25, fillColor = $$props2.fillColor);
    if ("opacity" in $$props2)
      $$invalidate(26, opacity = $$props2.opacity);
    if ("outlineColor" in $$props2)
      $$invalidate(27, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(28, outlineWidth = $$props2.outlineWidth);
    if ("scaleTo" in $$props2)
      $$invalidate(29, scaleTo = $$props2.scaleTo);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(30, chartAreaHeight = $$props2.chartAreaHeight);
    if ("sort" in $$props2)
      $$invalidate(31, sort = $$props2.sort);
    if ("tooltipTitle" in $$props2)
      $$invalidate(32, tooltipTitle = $$props2.tooltipTitle);
    if ("chartType" in $$props2)
      $$invalidate(33, chartType = $$props2.chartType);
    if ("bubble" in $$props2)
      $$invalidate(34, bubble = $$props2.bubble);
    if ("useTooltip" in $$props2)
      $$invalidate(35, useTooltip = $$props2.useTooltip);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    data,
    x,
    y,
    size,
    series,
    xType,
    yFmt,
    xFmt,
    sizeFmt,
    title,
    subtitle,
    legend,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    shape,
    fillColor,
    opacity,
    outlineColor,
    outlineWidth,
    scaleTo,
    chartAreaHeight,
    sort,
    tooltipTitle,
    chartType,
    bubble,
    useTooltip,
    slots,
    $$scope
  ];
}
var BubbleChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance79,
      create_fragment79,
      safe_not_equal,
      {
        data: 0,
        x: 1,
        y: 2,
        size: 3,
        series: 4,
        xType: 5,
        yFmt: 6,
        xFmt: 7,
        sizeFmt: 8,
        title: 9,
        subtitle: 10,
        legend: 11,
        xAxisTitle: 12,
        yAxisTitle: 13,
        xGridlines: 14,
        yGridlines: 15,
        xAxisLabels: 16,
        yAxisLabels: 17,
        xBaseline: 18,
        yBaseline: 19,
        xTickMarks: 20,
        yTickMarks: 21,
        yMin: 22,
        yMax: 23,
        shape: 24,
        fillColor: 25,
        opacity: 26,
        outlineColor: 27,
        outlineWidth: 28,
        scaleTo: 29,
        chartAreaHeight: 30,
        sort: 31,
        tooltipTitle: 32
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BubbleChart",
      options,
      id: create_fragment79.name
    });
  }
  get data() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get series() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set series(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xType() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xType(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yFmt() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yFmt(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xFmt() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xFmt(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sizeFmt() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sizeFmt(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisTitle() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisTitle(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisTitle() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisTitle(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xGridlines() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xGridlines(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yGridlines() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yGridlines(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisLabels() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisLabels(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisLabels() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisLabels(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xBaseline() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xBaseline(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yBaseline() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yBaseline(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xTickMarks() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xTickMarks(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yTickMarks() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yTickMarks(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMin() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMin(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMax() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMax(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shape() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shape(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillColor() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillColor(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineColor() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineColor(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineWidth() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineWidth(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleTo() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleTo(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chartAreaHeight() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chartAreaHeight(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sort() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sort(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTitle() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTitle(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BubbleChart_default = BubbleChart;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/Column.svelte
var { Error: Error_17, Object: Object_16 } = globals;
function create_fragment80(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude77 = true;
function instance80($$self, $$props, $$invalidate) {
  let options;
  let $props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Column", slots, []);
  let props = getContext(propKey);
  validate_store(props, "props");
  component_subscribe($$self, props, (value) => $$invalidate(20, $props = value));
  let error;
  let { id } = $$props;
  function checkColumnName() {
    try {
      if (!Object.keys($props.data[0]).includes(id)) {
        error = "Error in table: " + id + " does not exist in the dataset";
        throw new Error(error);
      }
    } catch (e) {
      error = e.message;
      if (strictBuild) {
        throw error;
      }
    }
  }
  let { title = void 0 } = $$props;
  let { align = void 0 } = $$props;
  if (align === "centre") {
    align = "center";
  }
  let { wrap = false } = $$props;
  wrap = wrap === "true" || wrap === true;
  let { contentType = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { alt = void 0 } = $$props;
  let { openInNewTab = false } = $$props;
  openInNewTab = openInNewTab === "true" || openInNewTab === true;
  let { linkLabel = void 0 } = $$props;
  let { fmt = void 0 } = $$props;
  let { colorMax = void 0 } = $$props;
  let { colorMin = void 0 } = $$props;
  let { scaleColor = "green" } = $$props;
  let colorList = {
    green: "hsla(129, 33%, 57%,",
    red: "hsla(0, 56%, 56%,",
    blue: "hsla(198, 56%, 56%,"
  };
  let useColor = colorList[scaleColor];
  let { downIsGood = false } = $$props;
  downIsGood = downIsGood === "true" || downIsGood === true;
  let { showValue = true } = $$props;
  showValue = showValue === "true" || showValue === true;
  let { deltaSymbol = true } = $$props;
  deltaSymbol = deltaSymbol === "true" || deltaSymbol === true;
  const updateProps = () => {
    props.update((d) => {
      const matchingIndex = d.columns.findIndex((c) => c.id === id);
      if (matchingIndex === -1) {
        d.columns.push(options);
      } else {
        d.columns = [
          ...d.columns.slice(0, matchingIndex),
          options,
          ...d.columns.slice(matchingIndex + 1)
        ];
      }
      return d;
    });
  };
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Column> was created without expected prop 'id'");
    }
  });
  const writable_props = [
    "id",
    "title",
    "align",
    "wrap",
    "contentType",
    "height",
    "width",
    "alt",
    "openInNewTab",
    "linkLabel",
    "fmt",
    "colorMax",
    "colorMin",
    "scaleColor",
    "downIsGood",
    "showValue",
    "deltaSymbol"
  ];
  Object_16.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Column> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(7, id = $$props2.id);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
    if ("align" in $$props2)
      $$invalidate(1, align = $$props2.align);
    if ("wrap" in $$props2)
      $$invalidate(2, wrap = $$props2.wrap);
    if ("contentType" in $$props2)
      $$invalidate(9, contentType = $$props2.contentType);
    if ("height" in $$props2)
      $$invalidate(10, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(11, width = $$props2.width);
    if ("alt" in $$props2)
      $$invalidate(12, alt = $$props2.alt);
    if ("openInNewTab" in $$props2)
      $$invalidate(3, openInNewTab = $$props2.openInNewTab);
    if ("linkLabel" in $$props2)
      $$invalidate(13, linkLabel = $$props2.linkLabel);
    if ("fmt" in $$props2)
      $$invalidate(14, fmt = $$props2.fmt);
    if ("colorMax" in $$props2)
      $$invalidate(15, colorMax = $$props2.colorMax);
    if ("colorMin" in $$props2)
      $$invalidate(16, colorMin = $$props2.colorMin);
    if ("scaleColor" in $$props2)
      $$invalidate(17, scaleColor = $$props2.scaleColor);
    if ("downIsGood" in $$props2)
      $$invalidate(4, downIsGood = $$props2.downIsGood);
    if ("showValue" in $$props2)
      $$invalidate(5, showValue = $$props2.showValue);
    if ("deltaSymbol" in $$props2)
      $$invalidate(6, deltaSymbol = $$props2.deltaSymbol);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude77,
    getContext,
    propKey,
    strictBuild,
    props,
    error,
    id,
    checkColumnName,
    title,
    align,
    wrap,
    contentType,
    height,
    width,
    alt,
    openInNewTab,
    linkLabel,
    fmt,
    colorMax,
    colorMin,
    scaleColor,
    colorList,
    useColor,
    downIsGood,
    showValue,
    deltaSymbol,
    updateProps,
    options,
    $props
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("error" in $$props2)
      error = $$props2.error;
    if ("id" in $$props2)
      $$invalidate(7, id = $$props2.id);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
    if ("align" in $$props2)
      $$invalidate(1, align = $$props2.align);
    if ("wrap" in $$props2)
      $$invalidate(2, wrap = $$props2.wrap);
    if ("contentType" in $$props2)
      $$invalidate(9, contentType = $$props2.contentType);
    if ("height" in $$props2)
      $$invalidate(10, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(11, width = $$props2.width);
    if ("alt" in $$props2)
      $$invalidate(12, alt = $$props2.alt);
    if ("openInNewTab" in $$props2)
      $$invalidate(3, openInNewTab = $$props2.openInNewTab);
    if ("linkLabel" in $$props2)
      $$invalidate(13, linkLabel = $$props2.linkLabel);
    if ("fmt" in $$props2)
      $$invalidate(14, fmt = $$props2.fmt);
    if ("colorMax" in $$props2)
      $$invalidate(15, colorMax = $$props2.colorMax);
    if ("colorMin" in $$props2)
      $$invalidate(16, colorMin = $$props2.colorMin);
    if ("scaleColor" in $$props2)
      $$invalidate(17, scaleColor = $$props2.scaleColor);
    if ("colorList" in $$props2)
      colorList = $$props2.colorList;
    if ("useColor" in $$props2)
      $$invalidate(23, useColor = $$props2.useColor);
    if ("downIsGood" in $$props2)
      $$invalidate(4, downIsGood = $$props2.downIsGood);
    if ("showValue" in $$props2)
      $$invalidate(5, showValue = $$props2.showValue);
    if ("deltaSymbol" in $$props2)
      $$invalidate(6, deltaSymbol = $$props2.deltaSymbol);
    if ("options" in $$props2)
      $$invalidate(18, options = $$props2.options);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id, title, align, wrap, contentType, height, width, alt, openInNewTab, linkLabel, fmt, downIsGood, deltaSymbol, showValue, colorMax, colorMin*/
    131070) {
      $:
        $$invalidate(18, options = {
          id,
          title,
          align,
          wrap,
          contentType,
          height,
          width,
          alt,
          openInNewTab,
          linkLabel,
          fmt,
          downIsGood,
          deltaSymbol,
          showValue,
          colorMax,
          colorMin,
          useColor
        });
    }
    if ($$self.$$.dirty & /*options*/
    262144) {
      $:
        options, updateProps();
    }
  };
  $:
    checkColumnName();
  return [
    props,
    align,
    wrap,
    openInNewTab,
    downIsGood,
    showValue,
    deltaSymbol,
    id,
    title,
    contentType,
    height,
    width,
    alt,
    linkLabel,
    fmt,
    colorMax,
    colorMin,
    scaleColor,
    options
  ];
}
var Column = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment80, safe_not_equal, {
      id: 7,
      title: 8,
      align: 1,
      wrap: 2,
      contentType: 9,
      height: 10,
      width: 11,
      alt: 12,
      openInNewTab: 3,
      linkLabel: 13,
      fmt: 14,
      colorMax: 15,
      colorMin: 16,
      scaleColor: 17,
      downIsGood: 4,
      showValue: 5,
      deltaSymbol: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Column",
      options,
      id: create_fragment80.name
    });
  }
  get id() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrap() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrap(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentType() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentType(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openInNewTab() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openInNewTab(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get linkLabel() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linkLabel(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fmt() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fmt(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorMax() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorMax(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorMin() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorMin(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleColor() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleColor(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get downIsGood() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set downIsGood(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showValue() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showValue(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deltaSymbol() {
    throw new Error_17("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deltaSymbol(value) {
    throw new Error_17("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Column_default = Column;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/SearchBar.svelte
var file64 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/viz/SearchBar.svelte";
function add_css54(target) {
  append_styles(target, "svelte-155vek1", ".search-container.svelte-155vek1{width:30%;display:block;align-items:center;border:1px solid var(--grey-300);border-radius:4px;height:22px;position:relative;margin:25px 3px 10px 3px;box-sizing:content-box}.search-icon.svelte-155vek1{height:16px;width:16px;padding-left:3px;margin:0;position:absolute;top:50%;transform:translateY(-50%);-ms-transform:translateY(-50%);color:var(--grey-400);box-sizing:content-box}.search-bar.svelte-155vek1{margin:0;position:absolute;top:50%;transform:translateY(-50%);-ms-transform:translateY(-50%);border:none;padding-left:23px;color:var(--grey-600);font-size:9pt;width:calc(100% - 30px);font-family:Arial;line-height:normal}input.search-bar.svelte-155vek1::-moz-placeholder{color:var(--grey-700)}input.search-bar.svelte-155vek1::placeholder{color:var(--grey-700)}.svelte-155vek1:focus{outline:none}@media(max-width: 600px){.search-container.svelte-155vek1{width:98%;height:28px}.search-bar.svelte-155vek1{font-size:16px;width:calc(100% - 40px)}}@media print{.search-container.svelte-155vek1{visibility:hidden}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VhcmNoQmFyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEyQkMsaUJBQUEsZUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLEdBQVUsQ0FDVixPQUFBLENBQUEsS0FBYyxDQUNkLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQ0FDakMsYUFBQSxDQUFBLEdBQWtCLENBQ2xCLE1BQUEsQ0FBQSxJQUFZLENBQ1osUUFBQSxDQUFBLFFBQWtCLENBQ2xCLE1BQUEsQ0FBQSxJQUFBLENBQUEsR0FBQSxDQUFBLElBQUEsQ0FBQSxHQUF5QixDQUN6QixVQUFBLENBQUEsV0FBdUIsQUFDeEIsQ0FBQSxBQUVBLFlBQUEsZUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLElBQVksQ0FDWixLQUFBLENBQUEsSUFBVyxDQUNYLFlBQUEsQ0FBQSxHQUFpQixDQUNqQixNQUFBLENBQUEsQ0FBUyxDQUNULFFBQUEsQ0FBQSxRQUFrQixDQUNsQixHQUFBLENBQUEsR0FBUSxDQUNSLFNBQUEsQ0FBQSxXQUFBLElBQUEsQ0FBMkIsQ0FDM0IsYUFBQSxDQUFBLFdBQUEsSUFBQSxDQUErQixDQUMvQixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFVBQUEsQ0FBQSxXQUF1QixBQUN4QixDQUFBLEFBRUEsV0FBQSxlQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsQ0FBUyxDQUNULFFBQUEsQ0FBQSxRQUFrQixDQUNsQixHQUFBLENBQUEsR0FBUSxDQUNSLFNBQUEsQ0FBQSxXQUFBLElBQUEsQ0FBMkIsQ0FDM0IsYUFBQSxDQUFBLFdBQUEsSUFBQSxDQUErQixDQUUvQixNQUFBLENBQUEsSUFBWSxDQUNaLFlBQUEsQ0FBQSxJQUFrQixDQUVsQixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLFNBQUEsQ0FBQSxHQUFjLENBRWQsS0FBQSxDQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQXdCLENBRXhCLFdBQUEsQ0FBQSxLQUFrQixDQUNsQixXQUFBLENBQUEsTUFBbUIsQUFDcEIsQ0FBQSxBQUVBLEtBQUEsMEJBQUEsa0JBQUEsQUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBLEFBRUEsS0FBQSwwQkFBQSxhQUFBLEFBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLGVBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFFQSxNQUFBLEFBQUEsWUFBQSxLQUFBLENBQUEsQUFBQSxDQUFBLEFBQ0MsaUJBQUEsZUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLEdBQVUsQ0FDVixNQUFBLENBQUEsSUFBWSxBQUNiLENBQUEsQUFFQSxXQUFBLGVBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxJQUFlLENBQ2YsS0FBQSxDQUFBLEtBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQXdCLEFBQ3pCLENBQUEsQUFDRCxDQUFBLEFBRUEsT0FBQSxLQUFBLEFBQUEsQ0FBQSxBQUNDLGlCQUFBLGVBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxNQUFrQixBQUNuQixDQUFBLEFBQ0QsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTZWFyY2hCYXIuc3ZlbHRlIl19 */");
}
function create_fragment81(ctx) {
  let div1;
  let input;
  let t;
  let div0;
  let icon;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: { src: Search, class: "pl-0.5" },
    $$inline: true
  });
  const block = {
    c: function create() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      input = claim_element(div1_nodes, "INPUT", {
        class: true,
        type: true,
        placeholder: true
      });
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(icon.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "search-bar svelte-155vek1");
      attr_dev(input, "type", "text");
      attr_dev(
        input,
        "placeholder",
        /*placeholder*/
        ctx[1]
      );
      add_location(input, file64, 14, 1, 310);
      attr_dev(div0, "class", "search-icon svelte-155vek1");
      add_location(div0, file64, 21, 1, 427);
      attr_dev(div1, "class", "search-container svelte-155vek1");
      add_location(div1, file64, 13, 0, 278);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      mount_component(icon, div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[3]
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[4],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*placeholder*/
      2) {
        attr_dev(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[1]
        );
      }
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(icon);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude78 = true;
function instance81($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SearchBar", slots, []);
  let { placeholder = "Search" } = $$props;
  let { value } = $$props;
  let { searchFunction } = $$props;
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<SearchBar> was created without expected prop 'value'");
    }
    if (searchFunction === void 0 && !("searchFunction" in $$props || $$self.$$.bound[$$self.$$.props["searchFunction"]])) {
      console.warn("<SearchBar> was created without expected prop 'searchFunction'");
    }
  });
  const writable_props = ["placeholder", "value", "searchFunction"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SearchBar> was created with unknown prop '${key}'`);
  });
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  const keyup_handler = () => searchFunction(value);
  $$self.$$set = ($$props2) => {
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("searchFunction" in $$props2)
      $$invalidate(2, searchFunction = $$props2.searchFunction);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude78,
    Icon: Icon_default,
    Search,
    placeholder,
    value,
    searchFunction
  });
  $$self.$inject_state = ($$props2) => {
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("searchFunction" in $$props2)
      $$invalidate(2, searchFunction = $$props2.searchFunction);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, placeholder, searchFunction, input_input_handler, keyup_handler];
}
var SearchBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance81,
      create_fragment81,
      safe_not_equal,
      {
        placeholder: 1,
        value: 0,
        searchFunction: 2
      },
      add_css54
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SearchBar",
      options,
      id: create_fragment81.name
    });
  }
  get placeholder() {
    throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchFunction() {
    throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchFunction(value) {
    throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SearchBar_default = SearchBar;

// ../../node_modules/@evidence-dev/core-components/dist/atoms/InvisibleLinks.svelte
import { building } from "$app/environment";
var file65 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/atoms/InvisibleLinks.svelte";
function get_each_context23(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_if_block48(ctx) {
  let each_1_anchor;
  let each_value = Array.from(new Set(
    /*data*/
    ctx[0].map(
      /*func*/
      ctx[2]
    )
  ));
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block23(get_each_context23(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*Array, Set, data, link*/
      3) {
        each_value = Array.from(new Set(
          /*data*/
          ctx2[0].map(
            /*func*/
            ctx2[2]
          )
        ));
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context23(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block23(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block48.name,
    type: "if",
    source: "(11:0) {#if building}",
    ctx
  });
  return block;
}
function create_each_block23(ctx) {
  let a;
  let t_value = "";
  let t;
  let a_href_value;
  const block = {
    c: function create() {
      a = element("a");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        href: true,
        class: true,
        "aria-hidden": true
      });
      var a_nodes = children(a);
      t = claim_text(a_nodes, t_value);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = /*href*/
      ctx[3]);
      attr_dev(a, "class", "hidden");
      attr_dev(a, "aria-hidden", "true");
      add_location(a, file65, 12, 2, 317);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*data, link*/
      3 && a_href_value !== (a_href_value = /*href*/
      ctx2[3])) {
        attr_dev(a, "href", a_href_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block23.name,
    type: "each",
    source: "(12:1) {#each Array.from(new Set(data.map((row) => row[link]))) as href}",
    ctx
  });
  return block;
}
function create_fragment82(ctx) {
  let if_block_anchor;
  let if_block = building && create_if_block48(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (building)
        if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance82($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InvisibleLinks", slots, []);
  let { data } = $$props;
  let { link } = $$props;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<InvisibleLinks> was created without expected prop 'data'");
    }
    if (link === void 0 && !("link" in $$props || $$self.$$.bound[$$self.$$.props["link"]])) {
      console.warn("<InvisibleLinks> was created without expected prop 'link'");
    }
  });
  const writable_props = ["data", "link"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InvisibleLinks> was created with unknown prop '${key}'`);
  });
  const func3 = (row) => row[link];
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("link" in $$props2)
      $$invalidate(1, link = $$props2.link);
  };
  $$self.$capture_state = () => ({ building, data, link });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("link" in $$props2)
      $$invalidate(1, link = $$props2.link);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [data, link, func3];
}
var InvisibleLinks = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance82, create_fragment82, safe_not_equal, { data: 0, link: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InvisibleLinks",
      options,
      id: create_fragment82.name
    });
  }
  get data() {
    throw new Error("<InvisibleLinks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<InvisibleLinks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error("<InvisibleLinks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error("<InvisibleLinks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InvisibleLinks_default = InvisibleLinks;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/DataTable.svelte
var { Error: Error_18, console: console_13 } = globals;
var file66 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/viz/DataTable.svelte";
function add_css55(target) {
  append_styles(target, "svelte-m861qu", ".table-container.svelte-m861qu.svelte-m861qu{font-size:9.5pt;width:97%}.container.svelte-m861qu.svelte-m861qu{width:100%;overflow-x:auto;scrollbar-width:thin;scrollbar-color:var(--scrollbar-color) var(--scrollbar-track-color);background-color:white}:root{--scrollbar-track-color:transparent;--scrollbar-color:rgba(0, 0, 0, 0.2);--scrollbar-active-color:rgba(0, 0, 0, 0.4);--scrollbar-size:0.75rem;--scrollbar-minlength:1.5rem}.container.svelte-m861qu.svelte-m861qu::-webkit-scrollbar{height:var(--scrollbar-size);width:var(--scrollbar-size)}.container.svelte-m861qu.svelte-m861qu::-webkit-scrollbar-track{background-color:var(--scrollbar-track-color)}.container.svelte-m861qu.svelte-m861qu::-webkit-scrollbar-thumb{background-color:var(--scrollbar-color);border-radius:7px;background-clip:padding-box}.container.svelte-m861qu.svelte-m861qu::-webkit-scrollbar-thumb:hover{background-color:var(--scrollbar-active-color)}.container.svelte-m861qu.svelte-m861qu::-webkit-scrollbar-thumb:vertical{min-height:var(--scrollbar-minlength);border:3px solid transparent}.container.svelte-m861qu.svelte-m861qu::-webkit-scrollbar-thumb:horizontal{min-width:var(--scrollbar-minlength);border:3px solid transparent}table.svelte-m861qu.svelte-m861qu{display:table;font-family:sans-serif;width:100%;border-collapse:collapse;font-variant-numeric:tabular-nums}th.svelte-m861qu.svelte-m861qu,td.svelte-m861qu.svelte-m861qu{padding:2px 8px;white-space:nowrap;overflow:hidden}th.svelte-m861qu.svelte-m861qu{border-bottom:1px solid var(--grey-600)}.row-lines.svelte-m861qu.svelte-m861qu{border-bottom:thin solid var(--grey-200)}.shaded-row.svelte-m861qu.svelte-m861qu{background-color:var(--grey-100)}.string.svelte-m861qu.svelte-m861qu{text-align:left}.date.svelte-m861qu.svelte-m861qu{text-align:left}.number.svelte-m861qu.svelte-m861qu{text-align:right}.boolean.svelte-m861qu.svelte-m861qu{text-align:left}.sort-icon.svelte-m861qu.svelte-m861qu{width:12px;height:12px;vertical-align:middle}.icon-container.svelte-m861qu.svelte-m861qu{display:inline-flex;align-items:center}.page-changer.svelte-m861qu.svelte-m861qu{padding:0;color:var(--grey-400);height:1.1em;width:1.1em}.index.svelte-m861qu.svelte-m861qu{color:var(--grey-300);text-align:left;max-width:-moz-min-content;max-width:min-content}.pagination.svelte-m861qu.svelte-m861qu{font-size:12px;display:flex;align-items:center;justify-content:space-between;height:2em;font-family:var(--ui-font-family);color:var(--grey-500);-webkit-user-select:none;-moz-user-select:none;user-select:none;text-align:right;margin-top:0.5em;margin-bottom:1.8em;font-variant-numeric:tabular-nums}.page-labels.svelte-m861qu.svelte-m861qu{display:flex;justify-content:flex-start;align-items:center;gap:3px}.selected.svelte-m861qu.svelte-m861qu{background:var(--grey-200);border-radius:4px}.page-changer.svelte-m861qu.svelte-m861qu{font-size:20px;font-family:sans-serif;background:none;border:none;cursor:pointer;transition:color 200ms}.page-changer.hovering.svelte-m861qu.svelte-m861qu{color:var(--blue-600);transition:color 200ms}.page-changer.svelte-m861qu.svelte-m861qu:disabled{cursor:auto;color:var(--grey-300);-webkit-user-select:none;-moz-user-select:none;user-select:none;transition:color 200ms}.page-icon.svelte-m861qu.svelte-m861qu{height:1em;width:1em}.page-input.svelte-m861qu.svelte-m861qu{width:23px;text-align:center;padding:0;margin:0;border:1px solid transparent;border-radius:4px;font-size:12px;color:var(--grey-500)}.table-footer.svelte-m861qu.svelte-m861qu{display:flex;justify-content:flex-end;align-items:center;margin:10px 0px;font-size:12px;height:9px}.page-input.svelte-m861qu.svelte-m861qu::-webkit-outer-spin-button,.page-input.svelte-m861qu.svelte-m861qu::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}.page-input[type='number'].svelte-m861qu.svelte-m861qu{-moz-appearance:textfield;-webkit-appearance:textfield;appearance:textfield}.page-input.hovering.svelte-m861qu.svelte-m861qu{border:1px solid var(--grey-200)}.page-input.error.svelte-m861qu.svelte-m861qu{border:1px solid var(--red-600)}.page-input.svelte-m861qu.svelte-m861qu::-moz-placeholder{color:var(--grey-500)}.page-input.svelte-m861qu.svelte-m861qu::placeholder{color:var(--grey-500)}button.svelte-m861qu:enabled>.page-icon.svelte-m861qu:hover{color:var(--blue-800)}.svelte-m861qu.svelte-m861qu:focus{outline:none}.svelte-m861qu.svelte-m861qu::-moz-placeholder{color:var(--grey-400);opacity:1}.svelte-m861qu.svelte-m861qu::placeholder{color:var(--grey-400);opacity:1}.svelte-m861qu.svelte-m861qu:-ms-input-placeholder{color:var(--grey-400)}.svelte-m861qu.svelte-m861qu::-ms-input-placeholder{color:var(--grey-400)}th.svelte-m861qu.svelte-m861qu{-webkit-user-select:none;-moz-user-select:none;user-select:none}th.type-indicator.svelte-m861qu.svelte-m861qu{color:var(--grey-400);font-weight:normal;font-style:italic}.row-link.svelte-m861qu.svelte-m861qu{cursor:pointer}.row-link.svelte-m861qu.svelte-m861qu:hover{background-color:#f0f5fc}.noresults.svelte-m861qu.svelte-m861qu{display:none;color:var(--grey-400);font-family:sans-serif;text-align:center;margin-top:5px}.shownoresults.svelte-m861qu.svelte-m861qu{display:block}.print-page-count.svelte-m861qu.svelte-m861qu{display:none}@media(max-width: 600px){.page-changer.svelte-m861qu.svelte-m861qu{height:1.2em;width:1.2em}.page-icon.svelte-m861qu.svelte-m861qu{height:1.2em;width:1.2em}.page-count.svelte-m861qu.svelte-m861qu{font-size:1.1em}.page-input.svelte-m861qu.svelte-m861qu{font-size:1.1em}}@media print{.avoidbreaks.svelte-m861qu.svelte-m861qu{-moz-column-break-inside:avoid;break-inside:avoid}.pagination.svelte-m861qu.svelte-m861qu{-moz-column-break-inside:avoid;break-inside:avoid}.page-changer.svelte-m861qu.svelte-m861qu{display:none}.page-count.svelte-m861qu.svelte-m861qu{display:none}.print-page-count.svelte-m861qu.svelte-m861qu{display:inline}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0YVRhYmxlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE4a0JDLGdCQUFBLDRCQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsS0FBZ0IsQ0FDaEIsS0FBQSxDQUFBLEdBQVUsQUFDWCxDQUFBLEFBRUEsVUFBQSw0QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQVcsQ0FDWCxVQUFBLENBQUEsSUFBZ0IsQ0FFaEIsZUFBQSxDQUFBLElBQXFCLENBQ3JCLGVBQUEsQ0FBQSxJQUFBLGlCQUFBLENBQUEsQ0FBQSxJQUFBLHVCQUFBLENBQW9FLENBQ3BFLGdCQUFBLENBQUEsS0FBdUIsQUFDeEIsQ0FBQSxBQUVBLEtBQUEsQUFBQSxDQUFBLEFBQ0MsdUJBQUEsQ0FBQSxXQUFvQyxDQUNwQyxpQkFBQSxDQUFBLGtCQUFxQyxDQUNyQyx3QkFBQSxDQUFBLGtCQUE0QyxDQUM1QyxnQkFBQSxDQUFBLE9BQXlCLENBQ3pCLHFCQUFBLENBQUEsTUFBNkIsQUFDOUIsQ0FBQSxBQUVBLHNDQUFBLG1CQUFBLEFBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxJQUFBLGdCQUFBLENBQTZCLENBQzdCLEtBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQTRCLEFBQzdCLENBQUEsQUFDQSxzQ0FBQSx5QkFBQSxBQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQUEsdUJBQUEsQ0FBOEMsQUFDL0MsQ0FBQSxBQUNBLHNDQUFBLHlCQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxpQkFBQSxDQUF3QyxDQUN4QyxhQUFBLENBQUEsR0FBa0IsQ0FDbEIsZUFBQSxDQUFBLFdBQTRCLEFBQzdCLENBQUEsQUFDQSxzQ0FBQSx5QkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSx3QkFBQSxDQUErQyxBQUNoRCxDQUFBLEFBQ0Esc0NBQUEseUJBQUEsU0FBQSxBQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBQSxxQkFBQSxDQUFzQyxDQUN0QyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUE2QixBQUM5QixDQUFBLEFBQ0Esc0NBQUEseUJBQUEsV0FBQSxBQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsSUFBQSxxQkFBQSxDQUFxQyxDQUNyQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUE2QixBQUM5QixDQUFBLEFBRUEsS0FBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLEtBQWMsQ0FDZCxXQUFBLENBQUEsVUFBdUIsQ0FDdkIsS0FBQSxDQUFBLElBQVcsQ0FDWCxlQUFBLENBQUEsUUFBeUIsQ0FDekIsb0JBQUEsQ0FBQSxZQUFrQyxBQUNuQyxDQUFBLEFBRUEsOEJBQUEsZ0NBRUMsT0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFnQixDQUNoQixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsUUFBQSxDQUFBLE1BQWdCLEFBQ2pCLENBQUEsQUFFQSxFQUFBLDRCQUFBLENBQUEsQUFDQyxhQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBd0MsQUFDekMsQ0FBQSxBQUVBLFVBQUEsNEJBQUEsQ0FBQSxBQUNDLGFBQUEsQ0FBQSxJQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUF5QyxBQUMxQyxDQUFBLEFBRUEsV0FBQSw0QkFBQSxDQUFBLEFBQ0MsZ0JBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQUFDbEMsQ0FBQSxBQUVBLE9BQUEsNEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBRUEsS0FBQSw0QkFBQSxDQUFBLEFBQ0MsVUFBQSxDQUFBLElBQWdCLEFBQ2pCLENBQUEsQUFFQSxPQUFBLDRCQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsS0FBaUIsQUFDbEIsQ0FBQSxBQUVBLFFBQUEsNEJBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBRUEsVUFBQSw0QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQVcsQ0FDWCxNQUFBLENBQUEsSUFBWSxDQUNaLGNBQUEsQ0FBQSxNQUFzQixBQUN2QixDQUFBLEFBRUEsZUFBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLFdBQW9CLENBQ3BCLFdBQUEsQ0FBQSxNQUFtQixBQUNwQixDQUFBLEFBRUEsYUFBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLENBQVUsQ0FDVixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLENBQ3RCLE1BQUEsQ0FBQSxLQUFhLENBQ2IsS0FBQSxDQUFBLEtBQVksQUFDYixDQUFBLEFBRUEsTUFBQSw0QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixVQUFBLENBQUEsSUFBZ0IsQ0FDaEIsU0FBQSxDQUFBLGdCQUEyQixDQUMzQixTQUFBLENBQUEsV0FBc0IsQUFDdkIsQ0FBQSxBQUVBLFdBQUEsNEJBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxJQUFlLENBQ2YsT0FBQSxDQUFBLElBQWEsQ0FDYixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsZUFBQSxDQUFBLGFBQThCLENBQzlCLE1BQUEsQ0FBQSxHQUFXLENBQ1gsV0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBa0MsQ0FDbEMsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixtQkFBQSxDQUFBLElBQXlCLENBQ3RCLGdCQUFBLENBQUEsSUFBc0IsQ0FDakIsV0FBQSxDQUFBLElBQWlCLENBQ3pCLFVBQUEsQ0FBQSxLQUFpQixDQUNqQixVQUFBLENBQUEsS0FBaUIsQ0FDakIsYUFBQSxDQUFBLEtBQW9CLENBQ3BCLG9CQUFBLENBQUEsWUFBa0MsQUFDbkMsQ0FBQSxBQUVBLFlBQUEsNEJBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxJQUFhLENBQ2IsZUFBQSxDQUFBLFVBQTJCLENBQzNCLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixHQUFBLENBQUEsR0FBUSxBQUNULENBQUEsQUFFQSxTQUFBLDRCQUFBLENBQUEsQUFDQyxVQUFBLENBQUEsSUFBQSxVQUFBLENBQTJCLENBQzNCLGFBQUEsQ0FBQSxHQUFrQixBQUNuQixDQUFBLEFBRUEsYUFBQSw0QkFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLElBQWUsQ0FDZixXQUFBLENBQUEsVUFBdUIsQ0FDdkIsVUFBQSxDQUFBLElBQWdCLENBQ2hCLE1BQUEsQ0FBQSxJQUFZLENBQ1osTUFBQSxDQUFBLE9BQWUsQ0FDZixVQUFBLENBQUEsS0FBQSxDQUFBLEtBQXVCLEFBQ3hCLENBQUEsQUFFQSxhQUFBLFNBQUEsNEJBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsVUFBQSxDQUFBLEtBQUEsQ0FBQSxLQUF1QixBQUN4QixDQUFBLEFBRUEseUNBQUEsU0FBQSxBQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsSUFBWSxDQUNaLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsbUJBQUEsQ0FBQSxJQUF5QixDQUN0QixnQkFBQSxDQUFBLElBQXNCLENBQ2pCLFdBQUEsQ0FBQSxJQUFpQixDQUN6QixVQUFBLENBQUEsS0FBQSxDQUFBLEtBQXVCLEFBQ3hCLENBQUEsQUFFQSxVQUFBLDRCQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsR0FBVyxDQUNYLEtBQUEsQ0FBQSxHQUFVLEFBQ1gsQ0FBQSxBQUVBLFdBQUEsNEJBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFXLENBQ1gsVUFBQSxDQUFBLE1BQWtCLENBQ2xCLE9BQUEsQ0FBQSxDQUFVLENBQ1YsTUFBQSxDQUFBLENBQVMsQ0FDVCxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxXQUE2QixDQUM3QixhQUFBLENBQUEsR0FBa0IsQ0FDbEIsU0FBQSxDQUFBLElBQWUsQ0FDZixLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEsQUFFQSxhQUFBLDRCQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxDQUNiLGVBQUEsQ0FBQSxRQUF5QixDQUN6QixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsTUFBQSxDQUFBLElBQUEsQ0FBQSxHQUFnQixDQUNoQixTQUFBLENBQUEsSUFBZSxDQUNmLE1BQUEsQ0FBQSxHQUFXLEFBQ1osQ0FBQSxBQUdBLHVDQUFBLDJCQUFBLG9FQUVDLGtCQUFBLENBQUEsSUFBd0IsQ0FDeEIsTUFBQSxDQUFBLENBQVMsQUFDVixDQUFBLEFBR0EsV0FBQSxDQUFBLElBQUEsQ0FBQSxRQUFBLENBQUEsNEJBQUEsQ0FBQSxBQUNDLGVBQUEsQ0FBQSxTQUEwQixDQUMxQixrQkFBQSxDQUFBLFNBQTZCLENBQ3JCLFVBQUEsQ0FBQSxTQUFxQixBQUM5QixDQUFBLEFBRUEsV0FBQSxTQUFBLDRCQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBaUMsQUFDbEMsQ0FBQSxBQUVBLFdBQUEsTUFBQSw0QkFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxTQUFBLENBQWdDLEFBQ2pDLENBQUEsQUFFQSx1Q0FBQSxrQkFBQSxBQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBQSxVQUFBLENBQXNCLEFBQ3ZCLENBQUEsQUFFQSx1Q0FBQSxhQUFBLEFBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLG9CQUFBLFFBQUEsQ0FBQSx3QkFBQSxNQUFBLEFBQUEsQ0FBQSxBQUNDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLDRCQUFBLE1BQUEsQUFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQUFDZCxDQUFBLDRCQUVBLGtCQUFBLEFBQUEsQ0FBQSxBQUVDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsT0FBQSxDQUFBLENBQVUsQUFDWCxDQUFBLDRCQUVBLGFBQUEsQUFBQSxDQUFBLEFBRUMsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixPQUFBLENBQUEsQ0FBVSxBQUNYLENBQUEsNEJBRUEsc0JBQUEsQUFBQSxDQUFBLEFBRUMsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixBQUN2QixDQUFBLDRCQUVBLHVCQUFBLEFBQUEsQ0FBQSxBQUVDLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQUFDdkIsQ0FBQSxBQUVBLEVBQUEsNEJBQUEsQ0FBQSxBQUNDLG1CQUFBLENBQUEsSUFBeUIsQ0FDdEIsZ0JBQUEsQ0FBQSxJQUFzQixDQUNqQixXQUFBLENBQUEsSUFBaUIsQUFDMUIsQ0FBQSxBQUVBLEVBQUEsZUFBQSw0QkFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLElBQUEsVUFBQSxDQUFzQixDQUN0QixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsVUFBQSxDQUFBLE1BQWtCLEFBQ25CLENBQUEsQUFFQSxTQUFBLDRCQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsT0FBZSxBQUNoQixDQUFBLEFBRUEscUNBQUEsTUFBQSxBQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLE9BQXlCLEFBQzFCLENBQUEsQUFFQSxVQUFBLDRCQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxDQUNiLEtBQUEsQ0FBQSxJQUFBLFVBQUEsQ0FBc0IsQ0FDdEIsV0FBQSxDQUFBLFVBQXVCLENBQ3ZCLFVBQUEsQ0FBQSxNQUFrQixDQUNsQixVQUFBLENBQUEsR0FBZSxBQUNoQixDQUFBLEFBRUEsY0FBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLEtBQWMsQUFDZixDQUFBLEFBRUEsaUJBQUEsNEJBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxJQUFhLEFBQ2QsQ0FBQSxBQUVBLE1BQUEsQUFBQSxZQUFBLEtBQUEsQ0FBQSxBQUFBLENBQUEsQUFDQyxhQUFBLDRCQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsS0FBYSxDQUNiLEtBQUEsQ0FBQSxLQUFZLEFBQ2IsQ0FBQSxBQUNBLFVBQUEsNEJBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxLQUFhLENBQ2IsS0FBQSxDQUFBLEtBQVksQUFDYixDQUFBLEFBRUEsV0FBQSw0QkFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLEtBQWdCLEFBQ2pCLENBQUEsQUFFQSxXQUFBLDRCQUFBLENBQUEsQUFDQyxTQUFBLENBQUEsS0FBZ0IsQUFDakIsQ0FBQSxBQUNELENBQUEsQUFFQSxPQUFBLEtBQUEsQUFBQSxDQUFBLEFBQ0MsWUFBQSw0QkFBQSxDQUFBLEFBQ0Msd0JBQUEsQ0FBQSxLQUErQixDQUMxQixZQUFBLENBQUEsS0FBbUIsQUFDekIsQ0FBQSxBQUVBLFdBQUEsNEJBQUEsQ0FBQSxBQUNDLHdCQUFBLENBQUEsS0FBK0IsQ0FDMUIsWUFBQSxDQUFBLEtBQW1CLEFBQ3pCLENBQUEsQUFFQSxhQUFBLDRCQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFFQSxXQUFBLDRCQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxBQUNkLENBQUEsQUFFQSxpQkFBQSw0QkFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLE1BQWUsQUFDaEIsQ0FBQSxBQUNELENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRGF0YVRhYmxlLnN2ZWx0ZSJdfQ== */");
}
function get_each_context24(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[55] = list[i];
  child_ctx[57] = i;
  return child_ctx;
}
function get_each_context_23(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[58] = list[i];
  return child_ctx;
}
function get_each_context_16(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[58] = list[i];
  const constants_0 = (
    /*column*/
    child_ctx[58].colorMin ?? /*safeExtractColumn*/
    child_ctx[35](
      /*column*/
      child_ctx[58]
    ).columnUnitSummary.min
  );
  child_ctx[59] = constants_0;
  const constants_1 = (
    /*column*/
    child_ctx[58].colorMax ?? /*safeExtractColumn*/
    child_ctx[35](
      /*column*/
      child_ctx[58]
    ).columnUnitSummary.max
  );
  child_ctx[60] = constants_1;
  const constants_2 = (
    /*column_max*/
    child_ctx[60] - /*column_min*/
    child_ctx[59] !== 0 && !isNaN(
      /*column_max*/
      child_ctx[60]
    ) && !isNaN(
      /*column_min*/
      child_ctx[59]
    )
  );
  child_ctx[61] = constants_2;
  return child_ctx;
}
function get_each_context_42(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[58] = list[i];
  return child_ctx;
}
function get_each_context_33(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[58] = list[i];
  return child_ctx;
}
function get_each_context_52(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[58] = list[i];
  return child_ctx;
}
function create_else_block_7(ctx) {
  let errorchart;
  let current;
  errorchart = new ErrorChart_default({
    props: {
      error: (
        /*error*/
        ctx[12]
      ),
      chartType: "Data Table"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(errorchart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(errorchart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(errorchart, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const errorchart_changes = {};
      if (dirty[0] & /*error*/
      4096)
        errorchart_changes.error = /*error*/
        ctx2[12];
      errorchart.$set(errorchart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(errorchart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(errorchart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(errorchart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_7.name,
    type: "else",
    source: "(586:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block49(ctx) {
  let t0;
  let t1;
  let t2;
  let div2;
  let t3;
  let div0;
  let table;
  let thead;
  let tr;
  let t4;
  let current_block_type_index;
  let if_block3;
  let t5;
  let t6;
  let current_block_type_index_1;
  let if_block4;
  let t7;
  let div1;
  let t8;
  let div2_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[43].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[42],
    null
  );
  let if_block0 = (
    /*link*/
    ctx[8] && create_if_block_192(ctx)
  );
  let each_value_5 = (
    /*$props*/
    ctx[20].columns.filter(func2)
  );
  validate_each_argument(each_value_5);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks_1[i] = create_each_block_52(get_each_context_52(ctx, each_value_5, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let if_block1 = (
    /*search*/
    ctx[2] && create_if_block_182(ctx)
  );
  let if_block2 = (
    /*rowNumbers*/
    ctx[1] && create_if_block_172(ctx)
  );
  const if_block_creators = [create_if_block_142, create_else_block_6];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$props*/
      ctx2[20].columns.length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1]);
  if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let each_value = (
    /*displayedData*/
    ctx[18]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block24(get_each_context24(ctx, each_value, i));
  }
  const if_block_creators_1 = [create_if_block_125, create_else_block23];
  const if_blocks_1 = [];
  function select_block_type_7(ctx2, dirty) {
    if (
      /*paginated*/
      ctx2[11] && /*pageCount*/
      ctx2[24] > 1
    )
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_7(ctx, [-1, -1, -1]);
  if_block4 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      t3 = space();
      div0 = element("div");
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      if (if_block2)
        if_block2.c();
      t4 = space();
      if_block3.c();
      t5 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t6 = space();
      if_block4.c();
      t7 = space();
      div1 = element("div");
      t8 = text("No Results");
      this.h();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
      t0 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t1 = claim_space(nodes);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(nodes);
      }
      t2 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div2_nodes = children(div2);
      if (if_block1)
        if_block1.l(div2_nodes);
      t3 = claim_space(div2_nodes);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      table = claim_element(div0_nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", { class: true });
      var thead_nodes = children(thead);
      tr = claim_element(thead_nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      if (if_block2)
        if_block2.l(tr_nodes);
      t4 = claim_space(tr_nodes);
      if_block3.l(tr_nodes);
      tr_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t5 = claim_space(table_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(table_nodes);
      }
      table_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t6 = claim_space(div2_nodes);
      if_block4.l(div2_nodes);
      t7 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t8 = claim_text(div1_nodes, "No Results");
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "class", "svelte-m861qu");
      add_location(tr, file66, 311, 5, 9069);
      attr_dev(thead, "class", "svelte-m861qu");
      add_location(thead, file66, 310, 4, 9056);
      attr_dev(table, "class", "svelte-m861qu");
      add_location(table, file66, 309, 3, 9044);
      attr_dev(div0, "class", "container svelte-m861qu");
      add_location(div0, file66, 308, 2, 9017);
      attr_dev(div1, "class", "noresults svelte-m861qu");
      toggle_class(
        div1,
        "shownoresults",
        /*showNoResults*/
        ctx[22]
      );
      add_location(div1, file66, 583, 2, 17759);
      attr_dev(div2, "class", "table-container svelte-m861qu");
      set_style(
        div2,
        "margin-top",
        /*marginTop*/
        ctx[31]
      );
      set_style(
        div2,
        "margin-bottom",
        /*marginBottom*/
        ctx[32]
      );
      set_style(
        div2,
        "padding-bottom",
        /*paddingBottom*/
        ctx[33]
      );
      add_location(div2, file66, 298, 1, 8683);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(target, anchor);
      }
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, div2, anchor);
      if (if_block1)
        if_block1.m(div2, null);
      append_hydration_dev(div2, t3);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, table);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, tr);
      if (if_block2)
        if_block2.m(tr, null);
      append_hydration_dev(tr, t4);
      if_blocks[current_block_type_index].m(tr, null);
      append_hydration_dev(table, t5);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(table, null);
      }
      append_hydration_dev(div2, t6);
      if_blocks_1[current_block_type_index_1].m(div2, null);
      append_hydration_dev(div2, t7);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t8);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div2,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[53],
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[54],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[42],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[42]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[42],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*link*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*link*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_192(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*data, $props*/
      1048577) {
        each_value_5 = /*$props*/
        ctx2[20].columns.filter(func2);
        validate_each_argument(each_value_5);
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_52(ctx2, each_value_5, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_52(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i = each_value_5.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (
        /*search*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*search*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_182(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*rowNumbers*/
        ctx2[1]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_172(ctx2);
          if_block2.c();
          if_block2.m(tr, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block3 = if_blocks[current_block_type_index];
        if (!if_block3) {
          if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block3.c();
        } else {
          if_block3.p(ctx2, dirty);
        }
        transition_in(if_block3, 1);
        if_block3.m(tr, null);
      }
      if (dirty[0] & /*rowShading, link, displayedData, $props, rowLines, columnSummary, index, rowNumbers*/
      1335650 | dirty[1] & /*handleRowClick, safeExtractColumn*/
      24) {
        each_value = /*displayedData*/
        ctx2[18];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context24(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block24(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(table, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_7(ctx2, dirty);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block4 = if_blocks_1[current_block_type_index_1];
        if (!if_block4) {
          if_block4 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block4.c();
        } else {
          if_block4.p(ctx2, dirty);
        }
        transition_in(if_block4, 1);
        if_block4.m(div2, t7);
      }
      if (!current || dirty[0] & /*showNoResults*/
      4194304) {
        toggle_class(
          div1,
          "shownoresults",
          /*showNoResults*/
          ctx2[22]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block0);
      for (let i = 0; i < each_value_5.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      transition_in(if_block1);
      transition_in(if_block3);
      transition_in(if_block4);
      if (local) {
        add_render_callback(() => {
          if (!div2_transition)
            div2_transition = create_bidirectional_transition(div2, slide, {}, true);
          div2_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block0);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      transition_out(if_block1);
      transition_out(if_block3);
      transition_out(if_block4);
      if (local) {
        if (!div2_transition)
          div2_transition = create_bidirectional_transition(div2, slide, {}, false);
        div2_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      destroy_each(each_blocks_1, detaching);
      if (detaching)
        detach_dev(t2);
      if (detaching)
        detach_dev(div2);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if_blocks[current_block_type_index].d();
      destroy_each(each_blocks, detaching);
      if_blocks_1[current_block_type_index_1].d();
      if (detaching && div2_transition)
        div2_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block49.name,
    type: "if",
    source: "(289:0) {#if error === undefined}",
    ctx
  });
  return block;
}
function create_if_block_192(ctx) {
  let invisiblelinks;
  let current;
  invisiblelinks = new InvisibleLinks_default({
    props: {
      data: (
        /*data*/
        ctx[0]
      ),
      link: (
        /*link*/
        ctx[8]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(invisiblelinks.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(invisiblelinks.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(invisiblelinks, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const invisiblelinks_changes = {};
      if (dirty[0] & /*data*/
      1)
        invisiblelinks_changes.data = /*data*/
        ctx2[0];
      if (dirty[0] & /*link*/
      256)
        invisiblelinks_changes.link = /*link*/
        ctx2[8];
      invisiblelinks.$set(invisiblelinks_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(invisiblelinks.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(invisiblelinks.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(invisiblelinks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_192.name,
    type: "if",
    source: "(292:1) {#if link}",
    ctx
  });
  return block;
}
function create_each_block_52(ctx) {
  let invisiblelinks;
  let current;
  invisiblelinks = new InvisibleLinks_default({
    props: {
      data: (
        /*data*/
        ctx[0]
      ),
      link: (
        /*column*/
        ctx[58].id
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(invisiblelinks.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(invisiblelinks.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(invisiblelinks, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const invisiblelinks_changes = {};
      if (dirty[0] & /*data*/
      1)
        invisiblelinks_changes.data = /*data*/
        ctx2[0];
      if (dirty[0] & /*$props*/
      1048576)
        invisiblelinks_changes.link = /*column*/
        ctx2[58].id;
      invisiblelinks.$set(invisiblelinks_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(invisiblelinks.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(invisiblelinks.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(invisiblelinks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_52.name,
    type: "each",
    source: "(295:1) {#each $props.columns.filter((column) => column.contentType === 'link') as column}",
    ctx
  });
  return block;
}
function create_if_block_182(ctx) {
  let searchbar;
  let updating_value;
  let current;
  function searchbar_value_binding(value) {
    ctx[44](value);
  }
  let searchbar_props = { searchFunction: (
    /*runSearch*/
    ctx[29]
  ) };
  if (
    /*searchValue*/
    ctx[16] !== void 0
  ) {
    searchbar_props.value = /*searchValue*/
    ctx[16];
  }
  searchbar = new SearchBar_default({ props: searchbar_props, $$inline: true });
  binding_callbacks.push(() => bind(
    searchbar,
    "value",
    searchbar_value_binding,
    /*searchValue*/
    ctx[16]
  ));
  const block = {
    c: function create() {
      create_component(searchbar.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(searchbar.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(searchbar, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const searchbar_changes = {};
      if (dirty[0] & /*runSearch*/
      536870912)
        searchbar_changes.searchFunction = /*runSearch*/
        ctx2[29];
      if (!updating_value && dirty[0] & /*searchValue*/
      65536) {
        updating_value = true;
        searchbar_changes.value = /*searchValue*/
        ctx2[16];
        add_flush_callback(() => updating_value = false);
      }
      searchbar.$set(searchbar_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(searchbar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(searchbar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_182.name,
    type: "if",
    source: "(306:2) {#if search}",
    ctx
  });
  return block;
}
function create_if_block_172(ctx) {
  let th;
  const block = {
    c: function create() {
      th = element("th");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true, style: true });
      children(th).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "class", "index svelte-m861qu");
      set_style(th, "width", "2%");
      set_style(
        th,
        "background-color",
        /*headerColor*/
        ctx[9]
      );
      add_location(th, file66, 313, 7, 9104);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*headerColor*/
      512) {
        set_style(
          th,
          "background-color",
          /*headerColor*/
          ctx2[9]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_172.name,
    type: "if",
    source: "(313:6) {#if rowNumbers}",
    ctx
  });
  return block;
}
function create_else_block_6(ctx) {
  let each_1_anchor;
  let current;
  let each_value_4 = (
    /*columnSummary*/
    ctx[13].filter(func_12)
  );
  validate_each_argument(each_value_4);
  let each_blocks = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks[i] = create_each_block_42(get_each_context_42(ctx, each_value_4, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*columnSummary, headerFontColor, headerColor, sortable, sort, sortBy, formatColumnTitles*/
      665224) {
        each_value_4 = /*columnSummary*/
        ctx2[13].filter(func_12);
        validate_each_argument(each_value_4);
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_42(ctx2, each_value_4, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_42(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_4.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_4.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_6.name,
    type: "else",
    source: "(344:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_142(ctx) {
  let each_1_anchor;
  let current;
  let each_value_3 = (
    /*$props*/
    ctx[20].columns
  );
  validate_each_argument(each_value_3);
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_33(get_each_context_33(ctx, each_value_3, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$props, headerFontColor, headerColor, sortable, sort, sortBy, formatColumnTitles*/
      1705608 | dirty[1] & /*safeExtractColumn*/
      16) {
        each_value_3 = /*$props*/
        ctx2[20].columns;
        validate_each_argument(each_value_3);
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_33(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_33(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_142.name,
    type: "if",
    source: "(322:6) {#if $props.columns.length > 0}",
    ctx
  });
  return block;
}
function create_if_block_162(ctx) {
  let sorticon;
  let current;
  sorticon = new SortIcon_default({
    props: { ascending: (
      /*sortBy*/
      ctx[17].ascending
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(sorticon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(sorticon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(sorticon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const sorticon_changes = {};
      if (dirty[0] & /*sortBy*/
      131072)
        sorticon_changes.ascending = /*sortBy*/
        ctx2[17].ascending;
      sorticon.$set(sorticon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sorticon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sorticon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(sorticon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_162.name,
    type: "if",
    source: "(358:9) {#if sortBy.col === column.id}",
    ctx
  });
  return block;
}
function create_each_block_42(ctx) {
  let th;
  let span;
  let t0_value = (
    /*formatColumnTitles*/
    (ctx[7] ? (
      /*column*/
      ctx[58].title
    ) : (
      /*column*/
      ctx[58].id
    )) + ""
  );
  let t0;
  let t1;
  let t2;
  let th_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*sortBy*/
    ctx[17].col === /*column*/
    ctx[58].id && create_if_block_162(ctx)
  );
  const block = {
    c: function create() {
      th = element("th");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true, style: true });
      var th_nodes = children(th);
      span = claim_element(th_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(th_nodes);
      if (if_block)
        if_block.l(th_nodes);
      t2 = claim_space(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "col-header svelte-m861qu");
      add_location(span, file66, 354, 9, 10424);
      attr_dev(th, "class", th_class_value = null_to_empty(
        /*column*/
        ctx[58].type
      ) + " svelte-m861qu");
      set_style(
        th,
        "color",
        /*headerFontColor*/
        ctx[10]
      );
      set_style(
        th,
        "background-color",
        /*headerColor*/
        ctx[9]
      );
      set_style(
        th,
        "cursor",
        /*sortable*/
        ctx[3] ? "pointer" : "auto"
      );
      add_location(th, file66, 345, 8, 10129);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(th, t1);
      if (if_block)
        if_block.m(th, null);
      append_hydration_dev(th, t2);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          th,
          "click",
          function() {
            if (is_function(
              /*sortable*/
              ctx[3] ? (
                /*sort*/
                ctx[19](
                  /*column*/
                  ctx[58].id
                )
              ) : ""
            ))
              /*sortable*/
              (ctx[3] ? (
                /*sort*/
                ctx[19](
                  /*column*/
                  ctx[58].id
                )
              ) : "").apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*formatColumnTitles, columnSummary*/
      8320) && t0_value !== (t0_value = /*formatColumnTitles*/
      (ctx[7] ? (
        /*column*/
        ctx[58].title
      ) : (
        /*column*/
        ctx[58].id
      )) + ""))
        set_data_dev(t0, t0_value);
      if (
        /*sortBy*/
        ctx[17].col === /*column*/
        ctx[58].id
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*sortBy, columnSummary*/
          139264) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_162(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(th, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*columnSummary*/
      8192 && th_class_value !== (th_class_value = null_to_empty(
        /*column*/
        ctx[58].type
      ) + " svelte-m861qu")) {
        attr_dev(th, "class", th_class_value);
      }
      if (!current || dirty[0] & /*headerFontColor*/
      1024) {
        set_style(
          th,
          "color",
          /*headerFontColor*/
          ctx[10]
        );
      }
      if (!current || dirty[0] & /*headerColor*/
      512) {
        set_style(
          th,
          "background-color",
          /*headerColor*/
          ctx[9]
        );
      }
      if (!current || dirty[0] & /*sortable*/
      8) {
        set_style(
          th,
          "cursor",
          /*sortable*/
          ctx[3] ? "pointer" : "auto"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_42.name,
    type: "each",
    source: "(345:7) {#each columnSummary.filter((d) => d.show === true) as column}",
    ctx
  });
  return block;
}
function create_if_block_152(ctx) {
  let sorticon;
  let current;
  sorticon = new SortIcon_default({
    props: { ascending: (
      /*sortBy*/
      ctx[17].ascending
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(sorticon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(sorticon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(sorticon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const sorticon_changes = {};
      if (dirty[0] & /*sortBy*/
      131072)
        sorticon_changes.ascending = /*sortBy*/
        ctx2[17].ascending;
      sorticon.$set(sorticon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sorticon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sorticon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(sorticon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_152.name,
    type: "if",
    source: "(339:9) {#if sortBy.col === column.id}",
    ctx
  });
  return block;
}
function create_each_block_33(ctx) {
  let th;
  let t0_value = (
    /*column*/
    (ctx[58].title ? (
      /*column*/
      ctx[58].title
    ) : (
      /*formatColumnTitles*/
      ctx[7] ? (
        /*safeExtractColumn*/
        ctx[35](
          /*column*/
          ctx[58]
        ).title
      ) : (
        /*safeExtractColumn*/
        ctx[35](
          /*column*/
          ctx[58]
        ).id
      )
    )) + ""
  );
  let t0;
  let t1;
  let t2;
  let th_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*sortBy*/
    ctx[17].col === /*column*/
    ctx[58].id && create_if_block_152(ctx)
  );
  const block = {
    c: function create() {
      th = element("th");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true, style: true });
      var th_nodes = children(th);
      t0 = claim_text(th_nodes, t0_value);
      t1 = claim_space(th_nodes);
      if (if_block)
        if_block.l(th_nodes);
      t2 = claim_space(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "class", th_class_value = null_to_empty(
        /*safeExtractColumn*/
        ctx[35](
          /*column*/
          ctx[58]
        ).type
      ) + " svelte-m861qu");
      set_style(
        th,
        "text-align",
        /*column*/
        ctx[58].align
      );
      set_style(
        th,
        "color",
        /*headerFontColor*/
        ctx[10]
      );
      set_style(
        th,
        "background-color",
        /*headerColor*/
        ctx[9]
      );
      set_style(
        th,
        "cursor",
        /*sortable*/
        ctx[3] ? "pointer" : "auto"
      );
      add_location(th, file66, 323, 8, 9365);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, t0);
      append_hydration_dev(th, t1);
      if (if_block)
        if_block.m(th, null);
      append_hydration_dev(th, t2);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          th,
          "click",
          function() {
            if (is_function(
              /*sortable*/
              ctx[3] ? (
                /*sort*/
                ctx[19](
                  /*column*/
                  ctx[58].id
                )
              ) : ""
            ))
              /*sortable*/
              (ctx[3] ? (
                /*sort*/
                ctx[19](
                  /*column*/
                  ctx[58].id
                )
              ) : "").apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*$props, formatColumnTitles*/
      1048704) && t0_value !== (t0_value = /*column*/
      (ctx[58].title ? (
        /*column*/
        ctx[58].title
      ) : (
        /*formatColumnTitles*/
        ctx[7] ? (
          /*safeExtractColumn*/
          ctx[35](
            /*column*/
            ctx[58]
          ).title
        ) : (
          /*safeExtractColumn*/
          ctx[35](
            /*column*/
            ctx[58]
          ).id
        )
      )) + ""))
        set_data_dev(t0, t0_value);
      if (
        /*sortBy*/
        ctx[17].col === /*column*/
        ctx[58].id
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*sortBy, $props*/
          1179648) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_152(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(th, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*$props*/
      1048576 && th_class_value !== (th_class_value = null_to_empty(
        /*safeExtractColumn*/
        ctx[35](
          /*column*/
          ctx[58]
        ).type
      ) + " svelte-m861qu")) {
        attr_dev(th, "class", th_class_value);
      }
      if (!current || dirty[0] & /*$props*/
      1048576) {
        set_style(
          th,
          "text-align",
          /*column*/
          ctx[58].align
        );
      }
      if (!current || dirty[0] & /*headerFontColor*/
      1024) {
        set_style(
          th,
          "color",
          /*headerFontColor*/
          ctx[10]
        );
      }
      if (!current || dirty[0] & /*headerColor*/
      512) {
        set_style(
          th,
          "background-color",
          /*headerColor*/
          ctx[9]
        );
      }
      if (!current || dirty[0] & /*sortable*/
      8) {
        set_style(
          th,
          "cursor",
          /*sortable*/
          ctx[3] ? "pointer" : "auto"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_33.name,
    type: "each",
    source: "(323:7) {#each $props.columns as column}",
    ctx
  });
  return block;
}
function create_if_block_124(ctx) {
  let td;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*i*/
      ctx2[57] === 0
    )
      return create_if_block_132;
    return create_else_block_5;
  }
  let current_block_type = select_block_type_2(ctx, [-1, -1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      td = element("td");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true, style: true });
      var td_nodes = children(td);
      if_block.l(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", "index svelte-m861qu");
      set_style(td, "width", "2%");
      toggle_class(
        td,
        "row-lines",
        /*rowLines*/
        ctx[6]
      );
      add_location(td, file66, 373, 7, 10921);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if_block.m(td, null);
    },
    p: function update(ctx2, dirty) {
      if_block.p(ctx2, dirty);
      if (dirty[0] & /*rowLines*/
      64) {
        toggle_class(
          td,
          "row-lines",
          /*rowLines*/
          ctx2[6]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_124.name,
    type: "if",
    source: "(373:6) {#if rowNumbers}",
    ctx
  });
  return block;
}
function create_else_block_5(ctx) {
  let t_value = (
    /*index*/
    (ctx[14] + /*i*/
    ctx[57] + 1).toLocaleString() + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*index*/
      16384 && t_value !== (t_value = /*index*/
      (ctx2[14] + /*i*/
      ctx2[57] + 1).toLocaleString() + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_5.name,
    type: "else",
    source: "(383:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_132(ctx) {
  let t_value = (
    /*index*/
    (ctx[14] + /*i*/
    ctx[57] + 1).toLocaleString() + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*index*/
      16384 && t_value !== (t_value = /*index*/
      (ctx2[14] + /*i*/
      ctx2[57] + 1).toLocaleString() + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_132.name,
    type: "if",
    source: "(381:8) {#if i === 0}",
    ctx
  });
  return block;
}
function create_else_block_4(ctx) {
  let each_1_anchor;
  let each_value_2 = (
    /*columnSummary*/
    ctx[13].filter(func_22)
  );
  validate_each_argument(each_value_2);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_23(get_each_context_23(ctx, each_value_2, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*columnSummary, rowLines, displayedData*/
      270400) {
        each_value_2 = /*columnSummary*/
        ctx2[13].filter(func_22);
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_23(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_23(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_4.name,
    type: "else",
    source: "(498:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_46(ctx) {
  let each_1_anchor;
  let each_value_1 = (
    /*$props*/
    ctx[20].columns
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_16(get_each_context_16(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$props, displayedData, rowLines*/
      1310784 | dirty[1] & /*safeExtractColumn*/
      16) {
        each_value_1 = /*$props*/
        ctx2[20].columns;
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_16(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_16(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_46.name,
    type: "if",
    source: "(389:6) {#if $props.columns.length > 0}",
    ctx
  });
  return block;
}
function create_each_block_23(ctx) {
  let td;
  let t_value = formatValue(
    /*row*/
    ctx[55][
      /*column*/
      ctx[58].id
    ],
    /*column*/
    ctx[58].format,
    /*column*/
    ctx[58].columnUnitSummary
  ) + "";
  let t;
  let td_class_value;
  const block = {
    c: function create() {
      td = element("td");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      t = claim_text(td_nodes, t_value);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", td_class_value = null_to_empty(
        /*column*/
        ctx[58].type
      ) + " svelte-m861qu");
      toggle_class(
        td,
        "row-lines",
        /*rowLines*/
        ctx[6]
      );
      add_location(td, file66, 499, 8, 15331);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*displayedData, columnSummary*/
      270336 && t_value !== (t_value = formatValue(
        /*row*/
        ctx2[55][
          /*column*/
          ctx2[58].id
        ],
        /*column*/
        ctx2[58].format,
        /*column*/
        ctx2[58].columnUnitSummary
      ) + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*columnSummary*/
      8192 && td_class_value !== (td_class_value = null_to_empty(
        /*column*/
        ctx2[58].type
      ) + " svelte-m861qu")) {
        attr_dev(td, "class", td_class_value);
      }
      if (dirty[0] & /*columnSummary, rowLines*/
      8256) {
        toggle_class(
          td,
          "row-lines",
          /*rowLines*/
          ctx2[6]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_23.name,
    type: "each",
    source: "(499:7) {#each columnSummary.filter((d) => d.show === true) as column}",
    ctx
  });
  return block;
}
function create_else_block_32(ctx) {
  let t_value = formatValue(
    /*row*/
    ctx[55][
      /*column*/
      ctx[58].id
    ],
    /*column*/
    ctx[58].fmt ? getFormatObjectFromString(
      /*column*/
      ctx[58].fmt,
      /*safeExtractColumn*/
      ctx[35](
        /*column*/
        ctx[58]
      ).format.valueType
    ) : (
      /*safeExtractColumn*/
      ctx[35](
        /*column*/
        ctx[58]
      ).format
    ),
    /*safeExtractColumn*/
    ctx[35](
      /*column*/
      ctx[58]
    ).columnUnitSummary
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*displayedData, $props*/
      1310720 && t_value !== (t_value = formatValue(
        /*row*/
        ctx2[55][
          /*column*/
          ctx2[58].id
        ],
        /*column*/
        ctx2[58].fmt ? getFormatObjectFromString(
          /*column*/
          ctx2[58].fmt,
          /*safeExtractColumn*/
          ctx2[35](
            /*column*/
            ctx2[58]
          ).format.valueType
        ) : (
          /*safeExtractColumn*/
          ctx2[35](
            /*column*/
            ctx2[58]
          ).format
        ),
        /*safeExtractColumn*/
        ctx2[35](
          /*column*/
          ctx2[58]
        ).columnUnitSummary
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_32.name,
    type: "else",
    source: "(484:9) {:else}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let div1;
  let div0;
  let t;
  let div1_style_value;
  let if_block0 = (
    /*column*/
    ctx[58].showValue && create_if_block_11(ctx)
  );
  let if_block1 = (
    /*column*/
    ctx[58].deltaSymbol && create_if_block_10(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { style: true, class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(
        div0,
        "text-align",
        /*column*/
        ctx[58].align ?? "right"
      );
      attr_dev(div0, "class", "svelte-m861qu");
      add_location(div0, file66, 463, 11, 14165);
      attr_dev(div1, "class", "m-0 text-xs font-medium font-ui svelte-m861qu");
      attr_dev(div1, "style", div1_style_value = `color:${/*row*/
      ctx[55][
        /*column*/
        ctx[58].id
      ] >= 0 && !/*column*/
      ctx[58].downIsGood || /*row*/
      ctx[55][
        /*column*/
        ctx[58].id
      ] < 0 && /*column*/
      ctx[58].downIsGood ? "var(--green-700)" : "var(--red-700)"}`);
      add_location(div1, file66, 454, 10, 13864);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t);
      if (if_block1)
        if_block1.m(div0, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*column*/
        ctx2[58].showValue
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_11(ctx2);
          if_block0.c();
          if_block0.m(div0, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*column*/
        ctx2[58].deltaSymbol
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_10(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*$props*/
      1048576) {
        set_style(
          div0,
          "text-align",
          /*column*/
          ctx2[58].align ?? "right"
        );
      }
      if (dirty[0] & /*displayedData, $props*/
      1310720 && div1_style_value !== (div1_style_value = `color:${/*row*/
      ctx2[55][
        /*column*/
        ctx2[58].id
      ] >= 0 && !/*column*/
      ctx2[58].downIsGood || /*row*/
      ctx2[55][
        /*column*/
        ctx2[58].id
      ] < 0 && /*column*/
      ctx2[58].downIsGood ? "var(--green-700)" : "var(--red-700)"}`)) {
        attr_dev(div1, "style", div1_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(454:82) ",
    ctx
  });
  return block;
}
function create_if_block_65(ctx) {
  let a;
  let a_href_value;
  let a_target_value;
  function select_block_type_5(ctx2, dirty) {
    if (
      /*column*/
      ctx2[58].linkLabel != void 0
    )
      return create_if_block_73;
    return create_else_block_25;
  }
  let current_block_type = select_block_type_5(ctx, [-1, -1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      a = element("a");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, target: true, class: true });
      var a_nodes = children(a);
      if_block.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = /*row*/
      ctx[55][
        /*column*/
        ctx[58].id
      ]);
      attr_dev(a, "target", a_target_value = /*column*/
      ctx[58].openInNewTab ? "_blank" : "");
      attr_dev(a, "class", "svelte-m861qu");
      add_location(a, file66, 424, 10, 12764);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if_block.m(a, null);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_5(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(a, null);
        }
      }
      if (dirty[0] & /*displayedData, $props*/
      1310720 && a_href_value !== (a_href_value = /*row*/
      ctx2[55][
        /*column*/
        ctx2[58].id
      ])) {
        attr_dev(a, "href", a_href_value);
      }
      if (dirty[0] & /*$props*/
      1048576 && a_target_value !== (a_target_value = /*column*/
      ctx2[58].openInNewTab ? "_blank" : "")) {
        attr_dev(a, "target", a_target_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_65.name,
    type: "if",
    source: "(424:81) ",
    ctx
  });
  return block;
}
function create_if_block_55(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", {
        src: true,
        alt: true,
        style: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img.src, img_src_value = /*row*/
      ctx[55][
        /*column*/
        ctx[58].id
      ]))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", img_alt_value = /*column*/
      ctx[58].alt ? (
        /*row*/
        ctx[55][
          /*column*/
          ctx[58].alt
        ]
      ) : (
        /*row*/
        ctx[55][
          /*column*/
          ctx[58].id
        ].replace(/^(.*[/])/g, "").replace(/[.][^.]+$/g, "")
      ));
      set_style(img, "margin", "0.5em auto 0.5em auto");
      set_style(
        img,
        "height",
        /*column*/
        ctx[58].height
      );
      set_style(
        img,
        "width",
        /*column*/
        ctx[58].width
      );
      attr_dev(img, "class", "svelte-m861qu");
      add_location(img, file66, 412, 10, 12288);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*displayedData, $props*/
      1310720 && !src_url_equal(img.src, img_src_value = /*row*/
      ctx2[55][
        /*column*/
        ctx2[58].id
      ])) {
        attr_dev(img, "src", img_src_value);
      }
      if (dirty[0] & /*$props, displayedData*/
      1310720 && img_alt_value !== (img_alt_value = /*column*/
      ctx2[58].alt ? (
        /*row*/
        ctx2[55][
          /*column*/
          ctx2[58].alt
        ]
      ) : (
        /*row*/
        ctx2[55][
          /*column*/
          ctx2[58].id
        ].replace(/^(.*[/])/g, "").replace(/[.][^.]+$/g, "")
      ))) {
        attr_dev(img, "alt", img_alt_value);
      }
      if (dirty[0] & /*$props*/
      1048576) {
        set_style(
          img,
          "height",
          /*column*/
          ctx2[58].height
        );
      }
      if (dirty[0] & /*$props*/
      1048576) {
        set_style(
          img,
          "width",
          /*column*/
          ctx2[58].width
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_55.name,
    type: "if",
    source: "(412:9) {#if column.contentType === 'image' && row[column.id] !== undefined}",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let span;
  let t_value = formatValue(
    /*row*/
    ctx[55][
      /*column*/
      ctx[58].id
    ],
    /*column*/
    ctx[58].fmt ? getFormatObjectFromString(
      /*column*/
      ctx[58].fmt,
      /*safeExtractColumn*/
      ctx[35](
        /*column*/
        ctx[58]
      ).format.valueType
    ) : (
      /*safeExtractColumn*/
      ctx[35](
        /*column*/
        ctx[58]
      ).format
    ),
    /*safeExtractColumn*/
    ctx[35](
      /*column*/
      ctx[58]
    ).columnUnitSummary
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "svelte-m861qu");
      add_location(span, file66, 465, 13, 14266);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*displayedData, $props*/
      1310720 && t_value !== (t_value = formatValue(
        /*row*/
        ctx2[55][
          /*column*/
          ctx2[58].id
        ],
        /*column*/
        ctx2[58].fmt ? getFormatObjectFromString(
          /*column*/
          ctx2[58].fmt,
          /*safeExtractColumn*/
          ctx2[35](
            /*column*/
            ctx2[58]
          ).format.valueType
        ) : (
          /*safeExtractColumn*/
          ctx2[35](
            /*column*/
            ctx2[58]
          ).format
        ),
        /*safeExtractColumn*/
        ctx2[35](
          /*column*/
          ctx2[58]
        ).columnUnitSummary
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(465:12) {#if column.showValue}",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let span;
  let raw_value = (
    /*row*/
    ctx[55][
      /*column*/
      ctx[58].id
    ] >= 0 ? "&#9650;" : "&#9660;"
  );
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "svelte-m861qu");
      add_location(span, file66, 479, 13, 14731);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      span.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*displayedData, $props*/
      1310720 && raw_value !== (raw_value = /*row*/
      ctx2[55][
        /*column*/
        ctx2[58].id
      ] >= 0 ? "&#9650;" : "&#9660;"))
        span.innerHTML = raw_value;
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(479:12) {#if column.deltaSymbol}",
    ctx
  });
  return block;
}
function create_else_block_25(ctx) {
  let t_value = formatValue(
    /*row*/
    ctx[55][
      /*column*/
      ctx[58].id
    ],
    /*column*/
    ctx[58].fmt ? getFormatObjectFromString(
      /*column*/
      ctx[58].fmt,
      /*safeExtractColumn*/
      ctx[35](
        /*column*/
        ctx[58]
      ).format.valueType
    ) : (
      /*safeExtractColumn*/
      ctx[35](
        /*column*/
        ctx[58]
      ).format
    ),
    /*safeExtractColumn*/
    ctx[35](
      /*column*/
      ctx[58]
    ).columnUnitSummary
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*displayedData, $props*/
      1310720 && t_value !== (t_value = formatValue(
        /*row*/
        ctx2[55][
          /*column*/
          ctx2[58].id
        ],
        /*column*/
        ctx2[58].fmt ? getFormatObjectFromString(
          /*column*/
          ctx2[58].fmt,
          /*safeExtractColumn*/
          ctx2[35](
            /*column*/
            ctx2[58]
          ).format.valueType
        ) : (
          /*safeExtractColumn*/
          ctx2[35](
            /*column*/
            ctx2[58]
          ).format
        ),
        /*safeExtractColumn*/
        ctx2[35](
          /*column*/
          ctx2[58]
        ).columnUnitSummary
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_25.name,
    type: "else",
    source: "(441:11) {:else}",
    ctx
  });
  return block;
}
function create_if_block_73(ctx) {
  let if_block_anchor;
  function select_block_type_6(ctx2, dirty) {
    if (
      /*row*/
      ctx2[55][
        /*column*/
        ctx2[58].linkLabel
      ] != void 0
    )
      return create_if_block_82;
    return create_else_block_110;
  }
  let current_block_type = select_block_type_6(ctx, [-1, -1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_6(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_73.name,
    type: "if",
    source: "(426:11) {#if column.linkLabel != undefined}",
    ctx
  });
  return block;
}
function create_else_block_110(ctx) {
  let t_value = (
    /*column*/
    ctx[58].linkLabel + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$props*/
      1048576 && t_value !== (t_value = /*column*/
      ctx2[58].linkLabel + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_110.name,
    type: "else",
    source: "(438:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_82(ctx) {
  let t_value = formatValue(
    /*row*/
    ctx[55][
      /*column*/
      ctx[58].linkLabel
    ],
    /*column*/
    ctx[58].fmt ? getFormatObjectFromString(
      /*column*/
      ctx[58].fmt,
      /*safeExtractColumn*/
      ctx[35](
        /*column*/
        ctx[58]
      ).format.valueType
    ) : (
      /*safeExtractColumn*/
      ctx[35](
        /*column*/
        ctx[58]
      ).format
    ),
    /*safeExtractColumn*/
    ctx[35](
      /*column*/
      ctx[58]
    ).columnUnitSummary
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*displayedData, $props*/
      1310720 && t_value !== (t_value = formatValue(
        /*row*/
        ctx2[55][
          /*column*/
          ctx2[58].linkLabel
        ],
        /*column*/
        ctx2[58].fmt ? getFormatObjectFromString(
          /*column*/
          ctx2[58].fmt,
          /*safeExtractColumn*/
          ctx2[35](
            /*column*/
            ctx2[58]
          ).format.valueType
        ) : (
          /*safeExtractColumn*/
          ctx2[35](
            /*column*/
            ctx2[58]
          ).format
        ),
        /*safeExtractColumn*/
        ctx2[35](
          /*column*/
          ctx2[58]
        ).columnUnitSummary
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_82.name,
    type: "if",
    source: "(427:12) {#if row[column.linkLabel] != undefined}",
    ctx
  });
  return block;
}
function create_each_block_16(ctx) {
  let td;
  let t;
  let td_class_value;
  let td_style_value;
  function select_block_type_4(ctx2, dirty) {
    if (
      /*column*/
      ctx2[58].contentType === "image" && /*row*/
      ctx2[55][
        /*column*/
        ctx2[58].id
      ] !== void 0
    )
      return create_if_block_55;
    if (
      /*column*/
      ctx2[58].contentType === "link" && /*row*/
      ctx2[55][
        /*column*/
        ctx2[58].id
      ] !== void 0
    )
      return create_if_block_65;
    if (
      /*column*/
      ctx2[58].contentType === "delta" && /*row*/
      ctx2[55][
        /*column*/
        ctx2[58].id
      ] !== void 0
    )
      return create_if_block_9;
    return create_else_block_32;
  }
  let current_block_type = select_block_type_4(ctx, [-1, -1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      td = element("td");
      if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true, style: true });
      var td_nodes = children(td);
      if_block.l(td_nodes);
      t = claim_space(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", td_class_value = null_to_empty(
        /*safeExtractColumn*/
        ctx[35](
          /*column*/
          ctx[58]
        ).type
      ) + " svelte-m861qu");
      attr_dev(td, "style", td_style_value = "text-align: " + /*column*/
      ctx[58].align + "; height: " + /*column*/
      ctx[58].height + "; width: " + /*column*/
      ctx[58].width + "; white-space: " + /*column*/
      (ctx[58].wrap ? "normal" : "nowrap") + "; " + /*column*/
      (ctx[58].contentType === "colorscale" && /*is_nonzero*/
      ctx[61] ? ` background-color: ${/*column*/
      ctx[58].useColor} ${/*row*/
      (ctx[55][
        /*column*/
        ctx[58].id
      ] - /*column_min*/
      ctx[59]) / /*column_max*/
      (ctx[60] - /*column_min*/
      ctx[59])})` : ""));
      toggle_class(
        td,
        "row-lines",
        /*rowLines*/
        ctx[6]
      );
      add_location(td, file66, 396, 8, 11628);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if_block.m(td, null);
      append_hydration_dev(td, t);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_4(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(td, t);
        }
      }
      if (dirty[0] & /*$props*/
      1048576 && td_class_value !== (td_class_value = null_to_empty(
        /*safeExtractColumn*/
        ctx2[35](
          /*column*/
          ctx2[58]
        ).type
      ) + " svelte-m861qu")) {
        attr_dev(td, "class", td_class_value);
      }
      if (dirty[0] & /*$props, displayedData*/
      1310720 && td_style_value !== (td_style_value = "text-align: " + /*column*/
      ctx2[58].align + "; height: " + /*column*/
      ctx2[58].height + "; width: " + /*column*/
      ctx2[58].width + "; white-space: " + /*column*/
      (ctx2[58].wrap ? "normal" : "nowrap") + "; " + /*column*/
      (ctx2[58].contentType === "colorscale" && /*is_nonzero*/
      ctx2[61] ? ` background-color: ${/*column*/
      ctx2[58].useColor} ${/*row*/
      (ctx2[55][
        /*column*/
        ctx2[58].id
      ] - /*column_min*/
      ctx2[59]) / /*column_max*/
      (ctx2[60] - /*column_min*/
      ctx2[59])})` : ""))) {
        attr_dev(td, "style", td_style_value);
      }
      if (dirty[0] & /*$props, rowLines*/
      1048640) {
        toggle_class(
          td,
          "row-lines",
          /*rowLines*/
          ctx2[6]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_16.name,
    type: "each",
    source: "(390:7) {#each $props.columns as column}",
    ctx
  });
  return block;
}
function create_each_block24(ctx) {
  let tr;
  let t0;
  let t1;
  let mounted;
  let dispose;
  let if_block0 = (
    /*rowNumbers*/
    ctx[1] && create_if_block_124(ctx)
  );
  function select_block_type_3(ctx2, dirty) {
    if (
      /*$props*/
      ctx2[20].columns.length > 0
    )
      return create_if_block_46;
    return create_else_block_4;
  }
  let current_block_type = select_block_type_3(ctx, [-1, -1, -1]);
  let if_block1 = current_block_type(ctx);
  function click_handler() {
    return (
      /*click_handler*/
      ctx[45](
        /*row*/
        ctx[55]
      )
    );
  }
  const block = {
    c: function create() {
      tr = element("tr");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      if (if_block0)
        if_block0.l(tr_nodes);
      t0 = claim_space(tr_nodes);
      if_block1.l(tr_nodes);
      t1 = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "class", "svelte-m861qu");
      toggle_class(
        tr,
        "shaded-row",
        /*rowShading*/
        ctx[5] && /*i*/
        ctx[57] % 2 === 0
      );
      toggle_class(
        tr,
        "row-link",
        /*link*/
        ctx[8] != void 0
      );
      add_location(tr, file66, 367, 5, 10739);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      if (if_block0)
        if_block0.m(tr, null);
      append_hydration_dev(tr, t0);
      if_block1.m(tr, null);
      append_hydration_dev(tr, t1);
      if (!mounted) {
        dispose = listen_dev(tr, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*rowNumbers*/
        ctx[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_124(ctx);
          if_block0.c();
          if_block0.m(tr, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_3(ctx, dirty)) && if_block1) {
        if_block1.p(ctx, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx);
        if (if_block1) {
          if_block1.c();
          if_block1.m(tr, t1);
        }
      }
      if (dirty[0] & /*rowShading*/
      32) {
        toggle_class(
          tr,
          "shaded-row",
          /*rowShading*/
          ctx[5] && /*i*/
          ctx[57] % 2 === 0
        );
      }
      if (dirty[0] & /*link*/
      256) {
        toggle_class(
          tr,
          "row-link",
          /*link*/
          ctx[8] != void 0
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      if (if_block0)
        if_block0.d();
      if_block1.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block24.name,
    type: "each",
    source: "(367:4) {#each displayedData as row, i}",
    ctx
  });
  return block;
}
function create_else_block23(ctx) {
  let div;
  let current;
  let if_block = (
    /*downloadable*/
    ctx[4] && create_if_block_38(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "table-footer svelte-m861qu");
      add_location(div, file66, 576, 3, 17596);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*downloadable*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*downloadable*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_38(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block23.name,
    type: "else",
    source: "(576:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_125(ctx) {
  let div5;
  let div4;
  let button0;
  let div0;
  let icon0;
  let button0_disabled_value;
  let t0;
  let button1;
  let div1;
  let icon1;
  let button1_disabled_value;
  let t1;
  let span1;
  let t2;
  let input;
  let t3;
  let span0;
  let t4_value = (
    /*pageCount*/
    ctx[24].toLocaleString() + ""
  );
  let t4;
  let t5;
  let span2;
  let t6_value = (
    /*displayedPageLength*/
    ctx[26].toLocaleString() + ""
  );
  let t6;
  let t7;
  let t8_value = (
    /*totalRows*/
    ctx[23].toLocaleString() + ""
  );
  let t8;
  let t9;
  let t10;
  let button2;
  let div2;
  let icon2;
  let button2_disabled_value;
  let t11;
  let button3;
  let div3;
  let icon3;
  let button3_disabled_value;
  let t12;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({
    props: { src: ChevronsLeft },
    $$inline: true
  });
  icon1 = new Icon_default({
    props: { src: ChevronLeft, class: "h-[0.83em]" },
    $$inline: true
  });
  icon2 = new Icon_default({
    props: { src: ChevronRight, class: "h-[0.83em]" },
    $$inline: true
  });
  icon3 = new Icon_default({
    props: { src: ChevronsRight },
    $$inline: true
  });
  let if_block = (
    /*downloadable*/
    ctx[4] && create_if_block_217(ctx)
  );
  const block = {
    c: function create() {
      div5 = element("div");
      div4 = element("div");
      button0 = element("button");
      div0 = element("div");
      create_component(icon0.$$.fragment);
      t0 = space();
      button1 = element("button");
      div1 = element("div");
      create_component(icon1.$$.fragment);
      t1 = space();
      span1 = element("span");
      t2 = text("Page ");
      input = element("input");
      t3 = text("\n						/\n						");
      span0 = element("span");
      t4 = text(t4_value);
      t5 = space();
      span2 = element("span");
      t6 = text(t6_value);
      t7 = text(" of ");
      t8 = text(t8_value);
      t9 = text(" records");
      t10 = space();
      button2 = element("button");
      div2 = element("div");
      create_component(icon2.$$.fragment);
      t11 = space();
      button3 = element("button");
      div3 = element("div");
      create_component(icon3.$$.fragment);
      t12 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div5 = claim_element(nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      div4 = claim_element(div5_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      button0 = claim_element(div4_nodes, "BUTTON", { "aria-label": true, class: true });
      var button0_nodes = children(button0);
      div0 = claim_element(button0_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(icon0.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      button0_nodes.forEach(detach_dev);
      t0 = claim_space(div4_nodes);
      button1 = claim_element(div4_nodes, "BUTTON", { "aria-label": true, class: true });
      var button1_nodes = children(button1);
      div1 = claim_element(button1_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(icon1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      button1_nodes.forEach(detach_dev);
      t1 = claim_space(div4_nodes);
      span1 = claim_element(div4_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, "Page ");
      input = claim_element(span1_nodes, "INPUT", {
        class: true,
        type: true,
        placeholder: true
      });
      t3 = claim_text(span1_nodes, "\n						/\n						");
      span0 = claim_element(span1_nodes, "SPAN", { class: true, style: true });
      var span0_nodes = children(span0);
      t4 = claim_text(span0_nodes, t4_value);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      t5 = claim_space(div4_nodes);
      span2 = claim_element(div4_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      t6 = claim_text(span2_nodes, t6_value);
      t7 = claim_text(span2_nodes, " of ");
      t8 = claim_text(span2_nodes, t8_value);
      t9 = claim_text(span2_nodes, " records");
      span2_nodes.forEach(detach_dev);
      t10 = claim_space(div4_nodes);
      button2 = claim_element(div4_nodes, "BUTTON", { "aria-label": true, class: true });
      var button2_nodes = children(button2);
      div2 = claim_element(button2_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      claim_component(icon2.$$.fragment, div2_nodes);
      div2_nodes.forEach(detach_dev);
      button2_nodes.forEach(detach_dev);
      t11 = claim_space(div4_nodes);
      button3 = claim_element(div4_nodes, "BUTTON", { "aria-label": true, class: true });
      var button3_nodes = children(button3);
      div3 = claim_element(button3_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      claim_component(icon3.$$.fragment, div3_nodes);
      div3_nodes.forEach(detach_dev);
      button3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      t12 = claim_space(div5_nodes);
      if (if_block)
        if_block.l(div5_nodes);
      div5_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "page-icon flex items-center svelte-m861qu");
      add_location(div0, file66, 518, 7, 15810);
      attr_dev(button0, "aria-label", "first-page");
      attr_dev(button0, "class", "page-changer svelte-m861qu");
      button0.disabled = button0_disabled_value = /*currentPage*/
      ctx[25] === 1;
      toggle_class(
        button0,
        "hovering",
        /*hovering*/
        ctx[21]
      );
      add_location(button0, file66, 512, 5, 15647);
      attr_dev(div1, "class", "page-icon h-[0.83em] flex items-center svelte-m861qu");
      add_location(div1, file66, 528, 7, 16100);
      attr_dev(button1, "aria-label", "previous-page");
      attr_dev(button1, "class", "page-changer svelte-m861qu");
      button1.disabled = button1_disabled_value = /*currentPage*/
      ctx[25] === 1;
      toggle_class(
        button1,
        "hovering",
        /*hovering*/
        ctx[21]
      );
      add_location(button1, file66, 522, 5, 15920);
      attr_dev(input, "class", "page-input svelte-m861qu");
      attr_dev(input, "type", "number");
      attr_dev(
        input,
        "placeholder",
        /*currentPage*/
        ctx[25]
      );
      toggle_class(
        input,
        "hovering",
        /*hovering*/
        ctx[21]
      );
      toggle_class(
        input,
        "error",
        /*inputPage*/
        ctx[15] > /*pageCount*/
        ctx[24]
      );
      add_location(input, file66, 533, 12, 16276);
      attr_dev(span0, "class", "page-count svelte-m861qu");
      set_style(span0, "margin-left", "4px");
      add_location(span0, file66, 544, 6, 16592);
      attr_dev(span1, "class", "page-count svelte-m861qu");
      add_location(span1, file66, 532, 5, 16239);
      attr_dev(span2, "class", "print-page-count svelte-m861qu");
      add_location(span2, file66, 547, 5, 16704);
      attr_dev(div2, "class", "page-icon h-[0.83em] flex items-center svelte-m861qu");
      add_location(div2, file66, 556, 7, 17019);
      attr_dev(button2, "aria-label", "next-page");
      attr_dev(button2, "class", "page-changer svelte-m861qu");
      button2.disabled = button2_disabled_value = /*currentPage*/
      ctx[25] === /*pageCount*/
      ctx[24];
      toggle_class(
        button2,
        "hovering",
        /*hovering*/
        ctx[21]
      );
      add_location(button2, file66, 550, 5, 16839);
      attr_dev(div3, "class", "page-icon flex items-center svelte-m861qu");
      add_location(div3, file66, 566, 7, 17341);
      attr_dev(button3, "aria-label", "last-page");
      attr_dev(button3, "class", "page-changer svelte-m861qu");
      button3.disabled = button3_disabled_value = /*currentPage*/
      ctx[25] === /*pageCount*/
      ctx[24];
      toggle_class(
        button3,
        "hovering",
        /*hovering*/
        ctx[21]
      );
      add_location(button3, file66, 560, 5, 17159);
      attr_dev(div4, "class", "page-labels svelte-m861qu");
      add_location(div4, file66, 511, 4, 15616);
      attr_dev(div5, "class", "pagination svelte-m861qu");
      add_location(div5, file66, 510, 3, 15587);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div5, anchor);
      append_hydration_dev(div5, div4);
      append_hydration_dev(div4, button0);
      append_hydration_dev(button0, div0);
      mount_component(icon0, div0, null);
      append_hydration_dev(div4, t0);
      append_hydration_dev(div4, button1);
      append_hydration_dev(button1, div1);
      mount_component(icon1, div1, null);
      append_hydration_dev(div4, t1);
      append_hydration_dev(div4, span1);
      append_hydration_dev(span1, t2);
      append_hydration_dev(span1, input);
      set_input_value(
        input,
        /*inputPage*/
        ctx[15]
      );
      append_hydration_dev(span1, t3);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t4);
      append_hydration_dev(div4, t5);
      append_hydration_dev(div4, span2);
      append_hydration_dev(span2, t6);
      append_hydration_dev(span2, t7);
      append_hydration_dev(span2, t8);
      append_hydration_dev(span2, t9);
      append_hydration_dev(div4, t10);
      append_hydration_dev(div4, button2);
      append_hydration_dev(button2, div2);
      mount_component(icon2, div2, null);
      append_hydration_dev(div4, t11);
      append_hydration_dev(div4, button3);
      append_hydration_dev(button3, div3);
      mount_component(icon3, div3, null);
      append_hydration_dev(div5, t12);
      if (if_block)
        if_block.m(div5, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler_1*/
            ctx[46],
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_2*/
            ctx[47],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[48]
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[49],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[50],
            false,
            false,
            false
          ),
          listen_dev(
            button2,
            "click",
            /*click_handler_3*/
            ctx[51],
            false,
            false,
            false
          ),
          listen_dev(
            button3,
            "click",
            /*click_handler_4*/
            ctx[52],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*currentPage*/
      33554432 && button0_disabled_value !== (button0_disabled_value = /*currentPage*/
      ctx2[25] === 1)) {
        prop_dev(button0, "disabled", button0_disabled_value);
      }
      if (!current || dirty[0] & /*hovering*/
      2097152) {
        toggle_class(
          button0,
          "hovering",
          /*hovering*/
          ctx2[21]
        );
      }
      if (!current || dirty[0] & /*currentPage*/
      33554432 && button1_disabled_value !== (button1_disabled_value = /*currentPage*/
      ctx2[25] === 1)) {
        prop_dev(button1, "disabled", button1_disabled_value);
      }
      if (!current || dirty[0] & /*hovering*/
      2097152) {
        toggle_class(
          button1,
          "hovering",
          /*hovering*/
          ctx2[21]
        );
      }
      if (!current || dirty[0] & /*currentPage*/
      33554432) {
        attr_dev(
          input,
          "placeholder",
          /*currentPage*/
          ctx2[25]
        );
      }
      if (dirty[0] & /*inputPage*/
      32768 && to_number(input.value) !== /*inputPage*/
      ctx2[15]) {
        set_input_value(
          input,
          /*inputPage*/
          ctx2[15]
        );
      }
      if (!current || dirty[0] & /*hovering*/
      2097152) {
        toggle_class(
          input,
          "hovering",
          /*hovering*/
          ctx2[21]
        );
      }
      if (!current || dirty[0] & /*inputPage, pageCount*/
      16809984) {
        toggle_class(
          input,
          "error",
          /*inputPage*/
          ctx2[15] > /*pageCount*/
          ctx2[24]
        );
      }
      if ((!current || dirty[0] & /*pageCount*/
      16777216) && t4_value !== (t4_value = /*pageCount*/
      ctx2[24].toLocaleString() + ""))
        set_data_dev(t4, t4_value);
      if ((!current || dirty[0] & /*displayedPageLength*/
      67108864) && t6_value !== (t6_value = /*displayedPageLength*/
      ctx2[26].toLocaleString() + ""))
        set_data_dev(t6, t6_value);
      if ((!current || dirty[0] & /*totalRows*/
      8388608) && t8_value !== (t8_value = /*totalRows*/
      ctx2[23].toLocaleString() + ""))
        set_data_dev(t8, t8_value);
      if (!current || dirty[0] & /*currentPage, pageCount*/
      50331648 && button2_disabled_value !== (button2_disabled_value = /*currentPage*/
      ctx2[25] === /*pageCount*/
      ctx2[24])) {
        prop_dev(button2, "disabled", button2_disabled_value);
      }
      if (!current || dirty[0] & /*hovering*/
      2097152) {
        toggle_class(
          button2,
          "hovering",
          /*hovering*/
          ctx2[21]
        );
      }
      if (!current || dirty[0] & /*currentPage, pageCount*/
      50331648 && button3_disabled_value !== (button3_disabled_value = /*currentPage*/
      ctx2[25] === /*pageCount*/
      ctx2[24])) {
        prop_dev(button3, "disabled", button3_disabled_value);
      }
      if (!current || dirty[0] & /*hovering*/
      2097152) {
        toggle_class(
          button3,
          "hovering",
          /*hovering*/
          ctx2[21]
        );
      }
      if (
        /*downloadable*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*downloadable*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_217(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div5, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      transition_in(icon3.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      transition_out(icon3.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div5);
      destroy_component(icon0);
      destroy_component(icon1);
      destroy_component(icon2);
      destroy_component(icon3);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_125.name,
    type: "if",
    source: "(510:2) {#if paginated && pageCount > 1}",
    ctx
  });
  return block;
}
function create_if_block_38(ctx) {
  let downloaddata;
  let current;
  downloaddata = new DownloadData_default({
    props: {
      class: "download-button",
      data: (
        /*tableData*/
        ctx[27]
      ),
      display: (
        /*hovering*/
        ctx[21]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(downloaddata.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(downloaddata.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(downloaddata, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const downloaddata_changes = {};
      if (dirty[0] & /*tableData*/
      134217728)
        downloaddata_changes.data = /*tableData*/
        ctx2[27];
      if (dirty[0] & /*hovering*/
      2097152)
        downloaddata_changes.display = /*hovering*/
        ctx2[21];
      downloaddata.$set(downloaddata_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(downloaddata.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(downloaddata.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(downloaddata, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_38.name,
    type: "if",
    source: "(578:4) {#if downloadable}",
    ctx
  });
  return block;
}
function create_if_block_217(ctx) {
  let downloaddata;
  let current;
  downloaddata = new DownloadData_default({
    props: {
      class: "download-button",
      data: (
        /*tableData*/
        ctx[27]
      ),
      display: (
        /*hovering*/
        ctx[21]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(downloaddata.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(downloaddata.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(downloaddata, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const downloaddata_changes = {};
      if (dirty[0] & /*tableData*/
      134217728)
        downloaddata_changes.data = /*tableData*/
        ctx2[27];
      if (dirty[0] & /*hovering*/
      2097152)
        downloaddata_changes.display = /*hovering*/
        ctx2[21];
      downloaddata.$set(downloaddata_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(downloaddata.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(downloaddata.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(downloaddata, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_217.name,
    type: "if",
    source: "(572:4) {#if downloadable}",
    ctx
  });
  return block;
}
function create_fragment83(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block49, create_else_block_7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*error*/
      ctx2[12] === void 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude79 = true;
function dataSubset(data, selectedCols) {
  return data.map((obj) => {
    var toReturn = {};
    selectedCols.forEach((key) => toReturn[key] = obj[key]);
    return toReturn;
  });
}
var func2 = (column) => column.contentType === "link";
var func_12 = (d) => d.show === true;
var func_22 = (d) => d.show === true;
function instance83($$self, $$props, $$invalidate) {
  let runSearch;
  let sort;
  let goToPage;
  let $props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DataTable", slots, ["default"]);
  let props = writable({});
  validate_store(props, "props");
  component_subscribe($$self, props, (value) => $$invalidate(20, $props = value));
  setContext(propKey, props);
  let { data } = $$props;
  let { rows = 10 } = $$props;
  rows = Number.parseInt(rows);
  let paginated;
  let { rowNumbers = false } = $$props;
  rowNumbers = rowNumbers === "true" || rowNumbers === true;
  let hovering = false;
  let marginTop = "1.5em";
  let marginBottom = "1em";
  let paddingBottom = "0em";
  let { search = false } = $$props;
  search = search === "true" || search === true;
  let { sortable = true } = $$props;
  sortable = sortable === "true" || sortable === true;
  let { downloadable = true } = $$props;
  downloadable = downloadable === "true" || downloadable === true;
  let { link = void 0 } = $$props;
  function handleRowClick(url) {
    if (link) {
      window.location = url;
    }
  }
  let { showLinkCol = false } = $$props;
  showLinkCol = showLinkCol === "true" || showLinkCol === true;
  let error = void 0;
  props.update((d) => {
    return { ...d, data, columns: [] };
  });
  let { rowShading = false } = $$props;
  rowShading = rowShading === "true" || rowShading === true;
  let { rowLines = true } = $$props;
  rowLines = rowLines === "true" || rowLines === true;
  let { headerColor } = $$props;
  let { headerFontColor = "var(--grey-900)" } = $$props;
  let { formatColumnTitles = true } = $$props;
  formatColumnTitles = formatColumnTitles === "true" || formatColumnTitles === true;
  let columnSummary;
  let index = 0;
  let inputPage = null;
  let searchValue = "";
  let filteredData;
  let thisRow;
  let thisValue;
  let showNoResults = false;
  let sortBy = { col: null, ascending: null };
  let totalRows;
  let displayedData = filteredData;
  let pageCount;
  let currentPage = 1;
  let max2;
  let displayedPageLength = 0;
  function safeExtractColumn(column) {
    const foundCols = columnSummary.filter((d) => d.id === column.id);
    if (foundCols === void 0 || foundCols.length !== 1) {
      $$invalidate(12, error = column.id === void 0 ? new Error(`please add an "id" property to all the <Column ... />`) : new Error(`column with id: "${column.id}" not found`));
      if (strictBuild) {
        throw error;
      }
      console.warn(error.message);
      return "";
    }
    return foundCols[0];
  }
  let tableData;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console_13.warn("<DataTable> was created without expected prop 'data'");
    }
    if (headerColor === void 0 && !("headerColor" in $$props || $$self.$$.bound[$$self.$$.props["headerColor"]])) {
      console_13.warn("<DataTable> was created without expected prop 'headerColor'");
    }
  });
  const writable_props = [
    "data",
    "rows",
    "rowNumbers",
    "search",
    "sortable",
    "downloadable",
    "link",
    "showLinkCol",
    "rowShading",
    "rowLines",
    "headerColor",
    "headerFontColor",
    "formatColumnTitles"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_13.warn(`<DataTable> was created with unknown prop '${key}'`);
  });
  function searchbar_value_binding(value) {
    searchValue = value;
    $$invalidate(16, searchValue);
  }
  const click_handler = (row) => handleRowClick(row[link]);
  const click_handler_1 = () => goToPage(0);
  const click_handler_2 = () => goToPage(currentPage - 2);
  function input_input_handler() {
    inputPage = to_number(this.value);
    $$invalidate(15, inputPage), $$invalidate(0, data), $$invalidate(13, columnSummary), $$invalidate(39, thisRow), $$invalidate(40, thisValue), $$invalidate(38, filteredData), $$invalidate(36, rows), $$invalidate(14, index), $$invalidate(41, max2), $$invalidate(37, showLinkCol), $$invalidate(8, link), $$invalidate(12, error), $$invalidate(17, sortBy);
  }
  const keyup_handler = () => goToPage((inputPage ?? 1) - 1);
  const change_handler = () => goToPage((inputPage ?? 1) - 1);
  const click_handler_3 = () => goToPage(currentPage);
  const click_handler_4 = () => goToPage(pageCount - 1);
  const mouseenter_handler = () => $$invalidate(21, hovering = true);
  const mouseleave_handler = () => $$invalidate(21, hovering = false);
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("rows" in $$props2)
      $$invalidate(36, rows = $$props2.rows);
    if ("rowNumbers" in $$props2)
      $$invalidate(1, rowNumbers = $$props2.rowNumbers);
    if ("search" in $$props2)
      $$invalidate(2, search = $$props2.search);
    if ("sortable" in $$props2)
      $$invalidate(3, sortable = $$props2.sortable);
    if ("downloadable" in $$props2)
      $$invalidate(4, downloadable = $$props2.downloadable);
    if ("link" in $$props2)
      $$invalidate(8, link = $$props2.link);
    if ("showLinkCol" in $$props2)
      $$invalidate(37, showLinkCol = $$props2.showLinkCol);
    if ("rowShading" in $$props2)
      $$invalidate(5, rowShading = $$props2.rowShading);
    if ("rowLines" in $$props2)
      $$invalidate(6, rowLines = $$props2.rowLines);
    if ("headerColor" in $$props2)
      $$invalidate(9, headerColor = $$props2.headerColor);
    if ("headerFontColor" in $$props2)
      $$invalidate(10, headerFontColor = $$props2.headerFontColor);
    if ("formatColumnTitles" in $$props2)
      $$invalidate(7, formatColumnTitles = $$props2.formatColumnTitles);
    if ("$$scope" in $$props2)
      $$invalidate(42, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude79,
    writable,
    setContext,
    slide,
    propKey,
    strictBuild,
    getColumnSummary,
    convertColumnToDate,
    formatValue,
    getFormatObjectFromString,
    ErrorChart: ErrorChart_default,
    SearchBar: SearchBar_default,
    checkInputs,
    DownloadData: DownloadData_default,
    SortIcon: SortIcon_default,
    InvisibleLinks: InvisibleLinks_default,
    ChevronsLeft,
    ChevronsRight,
    ChevronLeft,
    ChevronRight,
    Icon: Icon_default,
    props,
    data,
    rows,
    paginated,
    rowNumbers,
    hovering,
    marginTop,
    marginBottom,
    paddingBottom,
    search,
    sortable,
    downloadable,
    link,
    handleRowClick,
    showLinkCol,
    error,
    rowShading,
    rowLines,
    headerColor,
    headerFontColor,
    formatColumnTitles,
    columnSummary,
    index,
    inputPage,
    searchValue,
    filteredData,
    thisRow,
    thisValue,
    showNoResults,
    sortBy,
    totalRows,
    displayedData,
    pageCount,
    currentPage,
    max: max2,
    displayedPageLength,
    dataSubset,
    safeExtractColumn,
    tableData,
    goToPage,
    sort,
    runSearch,
    $props
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(30, props = $$props2.props);
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("rows" in $$props2)
      $$invalidate(36, rows = $$props2.rows);
    if ("paginated" in $$props2)
      $$invalidate(11, paginated = $$props2.paginated);
    if ("rowNumbers" in $$props2)
      $$invalidate(1, rowNumbers = $$props2.rowNumbers);
    if ("hovering" in $$props2)
      $$invalidate(21, hovering = $$props2.hovering);
    if ("marginTop" in $$props2)
      $$invalidate(31, marginTop = $$props2.marginTop);
    if ("marginBottom" in $$props2)
      $$invalidate(32, marginBottom = $$props2.marginBottom);
    if ("paddingBottom" in $$props2)
      $$invalidate(33, paddingBottom = $$props2.paddingBottom);
    if ("search" in $$props2)
      $$invalidate(2, search = $$props2.search);
    if ("sortable" in $$props2)
      $$invalidate(3, sortable = $$props2.sortable);
    if ("downloadable" in $$props2)
      $$invalidate(4, downloadable = $$props2.downloadable);
    if ("link" in $$props2)
      $$invalidate(8, link = $$props2.link);
    if ("showLinkCol" in $$props2)
      $$invalidate(37, showLinkCol = $$props2.showLinkCol);
    if ("error" in $$props2)
      $$invalidate(12, error = $$props2.error);
    if ("rowShading" in $$props2)
      $$invalidate(5, rowShading = $$props2.rowShading);
    if ("rowLines" in $$props2)
      $$invalidate(6, rowLines = $$props2.rowLines);
    if ("headerColor" in $$props2)
      $$invalidate(9, headerColor = $$props2.headerColor);
    if ("headerFontColor" in $$props2)
      $$invalidate(10, headerFontColor = $$props2.headerFontColor);
    if ("formatColumnTitles" in $$props2)
      $$invalidate(7, formatColumnTitles = $$props2.formatColumnTitles);
    if ("columnSummary" in $$props2)
      $$invalidate(13, columnSummary = $$props2.columnSummary);
    if ("index" in $$props2)
      $$invalidate(14, index = $$props2.index);
    if ("inputPage" in $$props2)
      $$invalidate(15, inputPage = $$props2.inputPage);
    if ("searchValue" in $$props2)
      $$invalidate(16, searchValue = $$props2.searchValue);
    if ("filteredData" in $$props2)
      $$invalidate(38, filteredData = $$props2.filteredData);
    if ("thisRow" in $$props2)
      $$invalidate(39, thisRow = $$props2.thisRow);
    if ("thisValue" in $$props2)
      $$invalidate(40, thisValue = $$props2.thisValue);
    if ("showNoResults" in $$props2)
      $$invalidate(22, showNoResults = $$props2.showNoResults);
    if ("sortBy" in $$props2)
      $$invalidate(17, sortBy = $$props2.sortBy);
    if ("totalRows" in $$props2)
      $$invalidate(23, totalRows = $$props2.totalRows);
    if ("displayedData" in $$props2)
      $$invalidate(18, displayedData = $$props2.displayedData);
    if ("pageCount" in $$props2)
      $$invalidate(24, pageCount = $$props2.pageCount);
    if ("currentPage" in $$props2)
      $$invalidate(25, currentPage = $$props2.currentPage);
    if ("max" in $$props2)
      $$invalidate(41, max2 = $$props2.max);
    if ("displayedPageLength" in $$props2)
      $$invalidate(26, displayedPageLength = $$props2.displayedPageLength);
    if ("tableData" in $$props2)
      $$invalidate(27, tableData = $$props2.tableData);
    if ("goToPage" in $$props2)
      $$invalidate(28, goToPage = $$props2.goToPage);
    if ("sort" in $$props2)
      $$invalidate(19, sort = $$props2.sort);
    if ("runSearch" in $$props2)
      $$invalidate(29, runSearch = $$props2.runSearch);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*data, columnSummary, link, error*/
    12545 | $$self.$$.dirty[1] & /*showLinkCol*/
    64) {
      $:
        try {
          $$invalidate(12, error = void 0);
          checkInputs(data);
          $$invalidate(13, columnSummary = getColumnSummary(data, "array"));
          let dateCols = columnSummary.filter((d) => d.type === "date");
          dateCols = dateCols.map((d) => d.id);
          if (dateCols.length > 0) {
            for (let i = 0; i < dateCols.length; i++) {
              $$invalidate(0, data = convertColumnToDate(data, dateCols[i]));
            }
          }
          for (let i = 0; i < columnSummary.length; i++) {
            $$invalidate(
              13,
              columnSummary[i].show = showLinkCol === false && columnSummary[i].id === link ? false : true,
              columnSummary
            );
          }
        } catch (e) {
          $$invalidate(12, error = e.message);
          if (strictBuild) {
            throw error;
          }
        }
    }
    if ($$self.$$.dirty[0] & /*data*/
    1 | $$self.$$.dirty[1] & /*rows*/
    32) {
      $:
        data, rows, $$invalidate(11, paginated = data.length > rows);
    }
    if ($$self.$$.dirty[0] & /*data*/
    1) {
      $:
        $$invalidate(38, filteredData = data);
    }
    if ($$self.$$.dirty[0] & /*data, columnSummary*/
    8193 | $$self.$$.dirty[1] & /*thisRow, thisValue, filteredData*/
    896) {
      $:
        $$invalidate(29, runSearch = (searchValue2) => {
          if (searchValue2 !== "") {
            $$invalidate(38, filteredData = []);
            $$invalidate(14, index = 0);
            $$invalidate(15, inputPage = null);
            for (let i = 0; i < data.length; i++) {
              $$invalidate(39, thisRow = data[i]);
              for (let j = 0; j < columnSummary.length; j++) {
                if (columnSummary[j].type === "date" && thisRow[columnSummary[j].id] != null) {
                  $$invalidate(40, thisValue = thisRow[columnSummary[j].id].toISOString());
                } else {
                  $$invalidate(40, thisValue = (thisRow[columnSummary[j].id] ?? "").toString().toLowerCase());
                }
                if (thisValue.indexOf(searchValue2.toLowerCase()) != -1 && thisValue != null) {
                  filteredData.push(thisRow);
                  break;
                }
              }
            }
            $$invalidate(22, showNoResults = filteredData.length === 0);
          } else {
            $$invalidate(38, filteredData = data);
            $$invalidate(22, showNoResults = false);
            $$invalidate(14, index = 0);
            $$invalidate(15, inputPage = null);
          }
        });
    }
    if ($$self.$$.dirty[0] & /*sortBy, data*/
    131073 | $$self.$$.dirty[1] & /*filteredData*/
    128) {
      $:
        $$invalidate(19, sort = (column) => {
          if (sortBy.col == column) {
            $$invalidate(17, sortBy.ascending = !sortBy.ascending, sortBy);
          } else {
            $$invalidate(17, sortBy.col = column, sortBy);
            $$invalidate(17, sortBy.ascending = true, sortBy);
          }
          const sortModifier = sortBy.ascending ? 1 : -1;
          const forceTopOfAscending = (val) => val === void 0 || val === null || typeof val === "number" && isNaN(val);
          const sort2 = (a, b) => forceTopOfAscending(a[column]) && !forceTopOfAscending(b[column]) || a[column] < b[column] ? -1 * sortModifier : forceTopOfAscending(b[column]) && !forceTopOfAscending(a[column]) || a[column] > b[column] ? 1 * sortModifier : 0;
          data.sort(sort2);
          $$invalidate(38, filteredData = filteredData.sort(sort2));
        });
    }
    if ($$self.$$.dirty[0] & /*data*/
    1) {
      $:
        data, $$invalidate(17, sortBy = { col: null, ascending: null });
    }
    if ($$self.$$.dirty[1] & /*filteredData*/
    128) {
      $:
        $$invalidate(23, totalRows = filteredData.length);
    }
    if ($$self.$$.dirty[0] & /*index, inputPage*/
    49152 | $$self.$$.dirty[1] & /*rows, max, filteredData*/
    1184) {
      $:
        $$invalidate(28, goToPage = (pageNumber) => {
          $$invalidate(14, index = pageNumber * rows);
          $$invalidate(41, max2 = index + rows);
          $$invalidate(25, currentPage = Math.ceil(max2 / rows));
          if (inputPage) {
            $$invalidate(15, inputPage = Math.ceil(max2 / rows));
          }
          $$invalidate(23, totalRows = filteredData.length);
          $$invalidate(18, displayedData = filteredData.slice(index, index + rows));
        });
    }
    if ($$self.$$.dirty[0] & /*index*/
    16384 | $$self.$$.dirty[1] & /*rows*/
    32) {
      $:
        $$invalidate(25, currentPage = Math.ceil((index + rows) / rows));
    }
    if ($$self.$$.dirty[0] & /*paginated, index, displayedData*/
    280576 | $$self.$$.dirty[1] & /*filteredData, rows*/
    160) {
      $:
        if (paginated) {
          $$invalidate(24, pageCount = Math.ceil(filteredData.length / rows));
          $$invalidate(18, displayedData = filteredData.slice(index, index + rows));
          $$invalidate(26, displayedPageLength = displayedData.length);
        } else {
          $$invalidate(25, currentPage = 1);
          $$invalidate(18, displayedData = filteredData);
        }
    }
    if ($$self.$$.dirty[0] & /*$props, data*/
    1048577) {
      $:
        $$invalidate(27, tableData = $props.columns.length > 0 ? dataSubset(data, $props.columns.map((d) => d.id)) : data);
    }
  };
  return [
    data,
    rowNumbers,
    search,
    sortable,
    downloadable,
    rowShading,
    rowLines,
    formatColumnTitles,
    link,
    headerColor,
    headerFontColor,
    paginated,
    error,
    columnSummary,
    index,
    inputPage,
    searchValue,
    sortBy,
    displayedData,
    sort,
    $props,
    hovering,
    showNoResults,
    totalRows,
    pageCount,
    currentPage,
    displayedPageLength,
    tableData,
    goToPage,
    runSearch,
    props,
    marginTop,
    marginBottom,
    paddingBottom,
    handleRowClick,
    safeExtractColumn,
    rows,
    showLinkCol,
    filteredData,
    thisRow,
    thisValue,
    max2,
    $$scope,
    slots,
    searchbar_value_binding,
    click_handler,
    click_handler_1,
    click_handler_2,
    input_input_handler,
    keyup_handler,
    change_handler,
    click_handler_3,
    click_handler_4,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var DataTable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance83,
      create_fragment83,
      safe_not_equal,
      {
        data: 0,
        rows: 36,
        rowNumbers: 1,
        search: 2,
        sortable: 3,
        downloadable: 4,
        link: 8,
        showLinkCol: 37,
        rowShading: 5,
        rowLines: 6,
        headerColor: 9,
        headerFontColor: 10,
        formatColumnTitles: 7
      },
      add_css55,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DataTable",
      options,
      id: create_fragment83.name
    });
  }
  get data() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowNumbers() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowNumbers(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get search() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set search(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get downloadable() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set downloadable(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLinkCol() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLinkCol(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowShading() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowShading(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowLines() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowLines(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerColor() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerColor(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerFontColor() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerFontColor(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatColumnTitles() {
    throw new Error_18("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatColumnTitles(value) {
    throw new Error_18("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DataTable_default = DataTable;

// ../../node_modules/@evidence-dev/component-utilities/src/usStateMap.json
var usStateMap_default = {
  type: "FeatureCollection",
  features: [
    {
      type: "Feature",
      id: "01",
      properties: { name: "Alabama", abbrev: "AL" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-87.359296, 35.00118],
            [-85.606675, 34.984749],
            [-85.431413, 34.124869],
            [-85.184951, 32.859696],
            [-85.069935, 32.580372],
            [-84.960397, 32.421541],
            [-85.004212, 32.322956],
            [-84.889196, 32.262709],
            [-85.058981, 32.13674],
            [-85.053504, 32.01077],
            [-85.141136, 31.840985],
            [-85.042551, 31.539753],
            [-85.113751, 31.27686],
            [-85.004212, 31.003013],
            [-85.497137, 30.997536],
            [-87.600282, 30.997536],
            [-87.633143, 30.86609],
            [-87.408589, 30.674397],
            [-87.446927, 30.510088],
            [-87.37025, 30.427934],
            [-87.518128, 30.280057],
            [-87.655051, 30.247195],
            [-87.90699, 30.411504],
            [-87.934375, 30.657966],
            [-88.011052, 30.685351],
            [-88.10416, 30.499135],
            [-88.137022, 30.318396],
            [-88.394438, 30.367688],
            [-88.471115, 31.895754],
            [-88.241084, 33.796253],
            [-88.098683, 34.891641],
            [-88.202745, 34.995703],
            [-87.359296, 35.00118]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "04",
      properties: { name: "Arizona", abbrev: "AZ" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-109.042503, 37.000263],
            [-109.04798, 31.331629],
            [-111.074448, 31.331629],
            [-112.246513, 31.704061],
            [-114.815198, 32.492741],
            [-114.72209, 32.717295],
            [-114.524921, 32.755634],
            [-114.470151, 32.843265],
            [-114.524921, 33.029481],
            [-114.661844, 33.034958],
            [-114.727567, 33.40739],
            [-114.524921, 33.54979],
            [-114.497536, 33.697668],
            [-114.535874, 33.933176],
            [-114.415382, 34.108438],
            [-114.256551, 34.174162],
            [-114.136058, 34.305608],
            [-114.333228, 34.448009],
            [-114.470151, 34.710902],
            [-114.634459, 34.87521],
            [-114.634459, 35.00118],
            [-114.574213, 35.138103],
            [-114.596121, 35.324319],
            [-114.678275, 35.516012],
            [-114.738521, 36.102045],
            [-114.371566, 36.140383],
            [-114.251074, 36.01989],
            [-114.152489, 36.025367],
            [-114.048427, 36.195153],
            [-114.048427, 37.000263],
            [-110.499369, 37.00574],
            [-109.042503, 37.000263]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "05",
      properties: { name: "Arkansas", abbrev: "AR" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-94.473842, 36.501861],
            [-90.152536, 36.496384],
            [-90.064905, 36.304691],
            [-90.218259, 36.184199],
            [-90.377091, 35.997983],
            [-89.730812, 35.997983],
            [-89.763673, 35.811767],
            [-89.911551, 35.756997],
            [-89.944412, 35.603643],
            [-90.130628, 35.439335],
            [-90.114197, 35.198349],
            [-90.212782, 35.023087],
            [-90.311367, 34.995703],
            [-90.251121, 34.908072],
            [-90.409952, 34.831394],
            [-90.481152, 34.661609],
            [-90.585214, 34.617794],
            [-90.568783, 34.420624],
            [-90.749522, 34.365854],
            [-90.744046, 34.300131],
            [-90.952169, 34.135823],
            [-90.891923, 34.026284],
            [-91.072662, 33.867453],
            [-91.231493, 33.560744],
            [-91.056231, 33.429298],
            [-91.143862, 33.347144],
            [-91.089093, 33.13902],
            [-91.16577, 33.002096],
            [-93.608485, 33.018527],
            [-94.041164, 33.018527],
            [-94.041164, 33.54979],
            [-94.183564, 33.593606],
            [-94.380734, 33.544313],
            [-94.484796, 33.637421],
            [-94.430026, 35.395519],
            [-94.616242, 36.501861],
            [-94.473842, 36.501861]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "06",
      properties: { name: "California", abbrev: "CA" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-123.233256, 42.006186],
            [-122.378853, 42.011663],
            [-121.037003, 41.995232],
            [-120.001861, 41.995232],
            [-119.996384, 40.264519],
            [-120.001861, 38.999346],
            [-118.71478, 38.101128],
            [-117.498899, 37.21934],
            [-116.540435, 36.501861],
            [-115.85034, 35.970598],
            [-114.634459, 35.00118],
            [-114.634459, 34.87521],
            [-114.470151, 34.710902],
            [-114.333228, 34.448009],
            [-114.136058, 34.305608],
            [-114.256551, 34.174162],
            [-114.415382, 34.108438],
            [-114.535874, 33.933176],
            [-114.497536, 33.697668],
            [-114.524921, 33.54979],
            [-114.727567, 33.40739],
            [-114.661844, 33.034958],
            [-114.524921, 33.029481],
            [-114.470151, 32.843265],
            [-114.524921, 32.755634],
            [-114.72209, 32.717295],
            [-116.04751, 32.624187],
            [-117.126467, 32.536556],
            [-117.24696, 32.668003],
            [-117.252437, 32.876127],
            [-117.329114, 33.122589],
            [-117.471515, 33.297851],
            [-117.7837, 33.538836],
            [-118.183517, 33.763391],
            [-118.260194, 33.703145],
            [-118.413548, 33.741483],
            [-118.391641, 33.840068],
            [-118.566903, 34.042715],
            [-118.802411, 33.998899],
            [-119.218659, 34.146777],
            [-119.278905, 34.26727],
            [-119.558229, 34.415147],
            [-119.875891, 34.40967],
            [-120.138784, 34.475393],
            [-120.472878, 34.448009],
            [-120.64814, 34.579455],
            [-120.609801, 34.858779],
            [-120.670048, 34.902595],
            [-120.631709, 35.099764],
            [-120.894602, 35.247642],
            [-120.905556, 35.450289],
            [-121.004141, 35.461243],
            [-121.168449, 35.636505],
            [-121.283465, 35.674843],
            [-121.332757, 35.784382],
            [-121.716143, 36.195153],
            [-121.896882, 36.315645],
            [-121.935221, 36.638785],
            [-121.858544, 36.6114],
            [-121.787344, 36.803093],
            [-121.929744, 36.978355],
            [-122.105006, 36.956447],
            [-122.335038, 37.115279],
            [-122.417192, 37.241248],
            [-122.400761, 37.361741],
            [-122.515777, 37.520572],
            [-122.515777, 37.783465],
            [-122.329561, 37.783465],
            [-122.406238, 38.15042],
            [-122.488392, 38.112082],
            [-122.504823, 37.931343],
            [-122.701993, 37.893004],
            [-122.937501, 38.029928],
            [-122.97584, 38.265436],
            [-123.129194, 38.451652],
            [-123.331841, 38.566668],
            [-123.44138, 38.698114],
            [-123.737134, 38.95553],
            [-123.687842, 39.032208],
            [-123.824765, 39.366301],
            [-123.764519, 39.552517],
            [-123.85215, 39.831841],
            [-124.109566, 40.105688],
            [-124.361506, 40.259042],
            [-124.410798, 40.439781],
            [-124.158859, 40.877937],
            [-124.109566, 41.025814],
            [-124.158859, 41.14083],
            [-124.065751, 41.442061],
            [-124.147905, 41.715908],
            [-124.257444, 41.781632],
            [-124.213628, 42.000709],
            [-123.233256, 42.006186]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "08",
      properties: { name: "Colorado", abbrev: "CO" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-107.919731, 41.003906],
            [-105.728954, 40.998429],
            [-104.053011, 41.003906],
            [-102.053927, 41.003906],
            [-102.053927, 40.001626],
            [-102.042974, 36.994786],
            [-103.001438, 37.000263],
            [-104.337812, 36.994786],
            [-106.868158, 36.994786],
            [-107.421329, 37.000263],
            [-109.042503, 37.000263],
            [-109.042503, 38.166851],
            [-109.058934, 38.27639],
            [-109.053457, 39.125316],
            [-109.04798, 40.998429],
            [-107.919731, 41.003906]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "09",
      properties: { name: "Connecticut", abbrev: "CT" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-73.053528, 42.039048],
            [-71.799309, 42.022617],
            [-71.799309, 42.006186],
            [-71.799309, 41.414677],
            [-71.859555, 41.321569],
            [-71.947186, 41.338],
            [-72.385341, 41.261322],
            [-72.905651, 41.28323],
            [-73.130205, 41.146307],
            [-73.371191, 41.102491],
            [-73.655992, 40.987475],
            [-73.727192, 41.102491],
            [-73.48073, 41.21203],
            [-73.55193, 41.294184],
            [-73.486206, 42.050002],
            [-73.053528, 42.039048]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "10",
      properties: { name: "Delaware", abbrev: "DE" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-75.414089, 39.804456],
            [-75.507197, 39.683964],
            [-75.611259, 39.61824],
            [-75.589352, 39.459409],
            [-75.441474, 39.311532],
            [-75.403136, 39.065069],
            [-75.189535, 38.807653],
            [-75.09095, 38.796699],
            [-75.047134, 38.451652],
            [-75.693413, 38.462606],
            [-75.786521, 39.722302],
            [-75.616736, 39.831841],
            [-75.414089, 39.804456]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "11",
      properties: { name: "District of Columbia", abbrev: "DC" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-77.035264, 38.993869],
            [-76.909294, 38.895284],
            [-77.040741, 38.791222],
            [-77.117418, 38.933623],
            [-77.035264, 38.993869]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "12",
      properties: { name: "Florida", abbrev: "FL" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-85.497137, 30.997536],
            [-85.004212, 31.003013],
            [-84.867289, 30.712735],
            [-83.498053, 30.647012],
            [-82.216449, 30.570335],
            [-82.167157, 30.356734],
            [-82.046664, 30.362211],
            [-82.002849, 30.564858],
            [-82.041187, 30.751074],
            [-81.948079, 30.827751],
            [-81.718048, 30.745597],
            [-81.444201, 30.707258],
            [-81.383954, 30.27458],
            [-81.257985, 29.787132],
            [-80.967707, 29.14633],
            [-80.524075, 28.461713],
            [-80.589798, 28.41242],
            [-80.56789, 28.094758],
            [-80.381674, 27.738757],
            [-80.091397, 27.021277],
            [-80.03115, 26.796723],
            [-80.036627, 26.566691],
            [-80.146166, 25.739673],
            [-80.239274, 25.723243],
            [-80.337859, 25.465826],
            [-80.304997, 25.383672],
            [-80.49669, 25.197456],
            [-80.573367, 25.241272],
            [-80.759583, 25.164595],
            [-81.077246, 25.120779],
            [-81.170354, 25.224841],
            [-81.126538, 25.378195],
            [-81.351093, 25.821827],
            [-81.526355, 25.903982],
            [-81.679709, 25.843735],
            [-81.800202, 26.090198],
            [-81.833064, 26.292844],
            [-82.041187, 26.517399],
            [-82.09048, 26.665276],
            [-82.057618, 26.878877],
            [-82.172634, 26.917216],
            [-82.145249, 26.791246],
            [-82.249311, 26.758384],
            [-82.566974, 27.300601],
            [-82.692943, 27.437525],
            [-82.391711, 27.837342],
            [-82.588881, 27.815434],
            [-82.720328, 27.689464],
            [-82.851774, 27.886634],
            [-82.676512, 28.434328],
            [-82.643651, 28.888914],
            [-82.764143, 28.998453],
            [-82.802482, 29.14633],
            [-82.994175, 29.179192],
            [-83.218729, 29.420177],
            [-83.399469, 29.518762],
            [-83.410422, 29.66664],
            [-83.536392, 29.721409],
            [-83.640454, 29.885717],
            [-84.02384, 30.104795],
            [-84.357933, 30.055502],
            [-84.341502, 29.902148],
            [-84.451041, 29.929533],
            [-84.867289, 29.743317],
            [-85.310921, 29.699501],
            [-85.299967, 29.80904],
            [-85.404029, 29.940487],
            [-85.924338, 30.236241],
            [-86.29677, 30.362211],
            [-86.630863, 30.395073],
            [-86.910187, 30.373165],
            [-87.518128, 30.280057],
            [-87.37025, 30.427934],
            [-87.446927, 30.510088],
            [-87.408589, 30.674397],
            [-87.633143, 30.86609],
            [-87.600282, 30.997536],
            [-85.497137, 30.997536]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "13",
      properties: { name: "Georgia", abbrev: "GA" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-83.109191, 35.00118],
            [-83.322791, 34.787579],
            [-83.339222, 34.683517],
            [-83.005129, 34.469916],
            [-82.901067, 34.486347],
            [-82.747713, 34.26727],
            [-82.714851, 34.152254],
            [-82.55602, 33.94413],
            [-82.325988, 33.81816],
            [-82.194542, 33.631944],
            [-81.926172, 33.462159],
            [-81.937125, 33.347144],
            [-81.761863, 33.160928],
            [-81.493493, 33.007573],
            [-81.42777, 32.843265],
            [-81.416816, 32.629664],
            [-81.279893, 32.558464],
            [-81.121061, 32.290094],
            [-81.115584, 32.120309],
            [-80.885553, 32.032678],
            [-81.132015, 31.693108],
            [-81.175831, 31.517845],
            [-81.279893, 31.364491],
            [-81.290846, 31.20566],
            [-81.400385, 31.13446],
            [-81.444201, 30.707258],
            [-81.718048, 30.745597],
            [-81.948079, 30.827751],
            [-82.041187, 30.751074],
            [-82.002849, 30.564858],
            [-82.046664, 30.362211],
            [-82.167157, 30.356734],
            [-82.216449, 30.570335],
            [-83.498053, 30.647012],
            [-84.867289, 30.712735],
            [-85.004212, 31.003013],
            [-85.113751, 31.27686],
            [-85.042551, 31.539753],
            [-85.141136, 31.840985],
            [-85.053504, 32.01077],
            [-85.058981, 32.13674],
            [-84.889196, 32.262709],
            [-85.004212, 32.322956],
            [-84.960397, 32.421541],
            [-85.069935, 32.580372],
            [-85.184951, 32.859696],
            [-85.431413, 34.124869],
            [-85.606675, 34.984749],
            [-84.319594, 34.990226],
            [-83.618546, 34.984749],
            [-83.109191, 35.00118]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "16",
      properties: { name: "Idaho", abbrev: "ID" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-116.04751, 49.000239],
            [-116.04751, 47.976051],
            [-115.724371, 47.696727],
            [-115.718894, 47.42288],
            [-115.527201, 47.302388],
            [-115.324554, 47.258572],
            [-115.302646, 47.187372],
            [-114.930214, 46.919002],
            [-114.886399, 46.809463],
            [-114.623506, 46.705401],
            [-114.612552, 46.639678],
            [-114.322274, 46.645155],
            [-114.464674, 46.272723],
            [-114.492059, 46.037214],
            [-114.387997, 45.88386],
            [-114.568736, 45.774321],
            [-114.497536, 45.670259],
            [-114.546828, 45.560721],
            [-114.333228, 45.456659],
            [-114.086765, 45.593582],
            [-113.98818, 45.703121],
            [-113.807441, 45.604536],
            [-113.834826, 45.522382],
            [-113.736241, 45.330689],
            [-113.571933, 45.128042],
            [-113.45144, 45.056842],
            [-113.456917, 44.865149],
            [-113.341901, 44.782995],
            [-113.133778, 44.772041],
            [-113.002331, 44.448902],
            [-112.887315, 44.394132],
            [-112.783254, 44.48724],
            [-112.471068, 44.481763],
            [-112.241036, 44.569394],
            [-112.104113, 44.520102],
            [-111.868605, 44.563917],
            [-111.819312, 44.509148],
            [-111.616665, 44.547487],
            [-111.386634, 44.75561],
            [-111.227803, 44.580348],
            [-111.047063, 44.476286],
            [-111.047063, 42.000709],
            [-112.164359, 41.995232],
            [-114.04295, 41.995232],
            [-117.027882, 42.000709],
            [-117.027882, 43.830007],
            [-116.896436, 44.158624],
            [-116.97859, 44.240778],
            [-117.170283, 44.257209],
            [-117.241483, 44.394132],
            [-117.038836, 44.750133],
            [-116.934774, 44.782995],
            [-116.830713, 44.930872],
            [-116.847143, 45.02398],
            [-116.732128, 45.144473],
            [-116.671881, 45.319735],
            [-116.463758, 45.61549],
            [-116.545912, 45.752413],
            [-116.78142, 45.823614],
            [-116.918344, 45.993399],
            [-116.92382, 46.168661],
            [-117.055267, 46.343923],
            [-117.038836, 46.426077],
            [-117.044313, 47.762451],
            [-117.033359, 49.000239],
            [-116.04751, 49.000239]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "17",
      properties: { name: "Illinois", abbrev: "IL" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-90.639984, 42.510065],
            [-88.788778, 42.493634],
            [-87.802929, 42.493634],
            [-87.83579, 42.301941],
            [-87.682436, 42.077386],
            [-87.523605, 41.710431],
            [-87.529082, 39.34987],
            [-87.63862, 39.169131],
            [-87.512651, 38.95553],
            [-87.49622, 38.780268],
            [-87.62219, 38.637868],
            [-87.655051, 38.506421],
            [-87.83579, 38.292821],
            [-87.950806, 38.27639],
            [-87.923421, 38.15042],
            [-88.000098, 38.101128],
            [-88.060345, 37.865619],
            [-88.027483, 37.799896],
            [-88.15893, 37.657496],
            [-88.065822, 37.482234],
            [-88.476592, 37.389126],
            [-88.514931, 37.285064],
            [-88.421823, 37.153617],
            [-88.547792, 37.071463],
            [-88.914747, 37.224817],
            [-89.029763, 37.213863],
            [-89.183118, 37.038601],
            [-89.133825, 36.983832],
            [-89.292656, 36.994786],
            [-89.517211, 37.279587],
            [-89.435057, 37.34531],
            [-89.517211, 37.537003],
            [-89.517211, 37.690357],
            [-89.84035, 37.903958],
            [-89.949889, 37.88205],
            [-90.059428, 38.013497],
            [-90.355183, 38.216144],
            [-90.349706, 38.374975],
            [-90.179921, 38.632391],
            [-90.207305, 38.725499],
            [-90.10872, 38.845992],
            [-90.251121, 38.917192],
            [-90.470199, 38.961007],
            [-90.585214, 38.867899],
            [-90.661891, 38.928146],
            [-90.727615, 39.256762],
            [-91.061708, 39.470363],
            [-91.368417, 39.727779],
            [-91.494386, 40.034488],
            [-91.50534, 40.237135],
            [-91.417709, 40.379535],
            [-91.401278, 40.560274],
            [-91.121954, 40.669813],
            [-91.09457, 40.823167],
            [-90.963123, 40.921752],
            [-90.946692, 41.097014],
            [-91.111001, 41.239415],
            [-91.045277, 41.414677],
            [-90.656414, 41.463969],
            [-90.344229, 41.589939],
            [-90.311367, 41.743293],
            [-90.179921, 41.809016],
            [-90.141582, 42.000709],
            [-90.168967, 42.126679],
            [-90.393521, 42.225264],
            [-90.420906, 42.329326],
            [-90.639984, 42.510065]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "18",
      properties: { name: "Indiana", abbrev: "IN" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-85.990061, 41.759724],
            [-84.807042, 41.759724],
            [-84.807042, 41.694001],
            [-84.801565, 40.500028],
            [-84.817996, 39.103408],
            [-84.894673, 39.059592],
            [-84.812519, 38.785745],
            [-84.987781, 38.780268],
            [-85.173997, 38.68716],
            [-85.431413, 38.730976],
            [-85.42046, 38.533806],
            [-85.590245, 38.451652],
            [-85.655968, 38.325682],
            [-85.83123, 38.27639],
            [-85.924338, 38.024451],
            [-86.039354, 37.958727],
            [-86.263908, 38.051835],
            [-86.302247, 38.166851],
            [-86.521325, 38.040881],
            [-86.504894, 37.931343],
            [-86.729448, 37.893004],
            [-86.795172, 37.991589],
            [-87.047111, 37.893004],
            [-87.129265, 37.788942],
            [-87.381204, 37.93682],
            [-87.512651, 37.903958],
            [-87.600282, 37.975158],
            [-87.682436, 37.903958],
            [-87.934375, 37.893004],
            [-88.027483, 37.799896],
            [-88.060345, 37.865619],
            [-88.000098, 38.101128],
            [-87.923421, 38.15042],
            [-87.950806, 38.27639],
            [-87.83579, 38.292821],
            [-87.655051, 38.506421],
            [-87.62219, 38.637868],
            [-87.49622, 38.780268],
            [-87.512651, 38.95553],
            [-87.63862, 39.169131],
            [-87.529082, 39.34987],
            [-87.523605, 41.710431],
            [-87.42502, 41.644708],
            [-87.118311, 41.644708],
            [-86.822556, 41.759724],
            [-85.990061, 41.759724]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "19",
      properties: { name: "Iowa", abbrev: "IA" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-91.368417, 43.501391],
            [-91.215062, 43.501391],
            [-91.204109, 43.353514],
            [-91.056231, 43.254929],
            [-91.176724, 43.134436],
            [-91.143862, 42.909881],
            [-91.067185, 42.75105],
            [-90.711184, 42.636034],
            [-90.639984, 42.510065],
            [-90.420906, 42.329326],
            [-90.393521, 42.225264],
            [-90.168967, 42.126679],
            [-90.141582, 42.000709],
            [-90.179921, 41.809016],
            [-90.311367, 41.743293],
            [-90.344229, 41.589939],
            [-90.656414, 41.463969],
            [-91.045277, 41.414677],
            [-91.111001, 41.239415],
            [-90.946692, 41.097014],
            [-90.963123, 40.921752],
            [-91.09457, 40.823167],
            [-91.121954, 40.669813],
            [-91.401278, 40.560274],
            [-91.417709, 40.379535],
            [-91.527248, 40.412397],
            [-91.729895, 40.615043],
            [-91.833957, 40.609566],
            [-93.257961, 40.582182],
            [-94.632673, 40.571228],
            [-95.7664, 40.587659],
            [-95.881416, 40.719105],
            [-95.826646, 40.976521],
            [-95.925231, 41.201076],
            [-95.919754, 41.453015],
            [-96.095016, 41.540646],
            [-96.122401, 41.67757],
            [-96.062155, 41.798063],
            [-96.127878, 41.973325],
            [-96.264801, 42.039048],
            [-96.44554, 42.488157],
            [-96.631756, 42.707235],
            [-96.544125, 42.855112],
            [-96.511264, 43.052282],
            [-96.434587, 43.123482],
            [-96.560556, 43.222067],
            [-96.527695, 43.397329],
            [-96.582464, 43.479483],
            [-96.451017, 43.501391],
            [-91.368417, 43.501391]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "20",
      properties: { name: "Kansas", abbrev: "KS" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-101.90605, 40.001626],
            [-95.306337, 40.001626],
            [-95.207752, 39.908518],
            [-94.884612, 39.831841],
            [-95.109167, 39.541563],
            [-94.983197, 39.442978],
            [-94.824366, 39.20747],
            [-94.610765, 39.158177],
            [-94.616242, 37.000263],
            [-100.087706, 37.000263],
            [-102.042974, 36.994786],
            [-102.053927, 40.001626],
            [-101.90605, 40.001626]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "21",
      properties: { name: "Kentucky", abbrev: "KY" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-83.903347, 38.769315],
            [-83.678792, 38.632391],
            [-83.519961, 38.703591],
            [-83.142052, 38.626914],
            [-83.032514, 38.725499],
            [-82.890113, 38.758361],
            [-82.846298, 38.588575],
            [-82.731282, 38.561191],
            [-82.594358, 38.424267],
            [-82.621743, 38.123036],
            [-82.50125, 37.931343],
            [-82.342419, 37.783465],
            [-82.293127, 37.668449],
            [-82.101434, 37.553434],
            [-81.969987, 37.537003],
            [-82.353373, 37.268633],
            [-82.720328, 37.120755],
            [-82.720328, 37.044078],
            [-82.868205, 36.978355],
            [-82.879159, 36.890724],
            [-83.070852, 36.852385],
            [-83.136575, 36.742847],
            [-83.673316, 36.600446],
            [-83.689746, 36.584015],
            [-84.544149, 36.594969],
            [-85.289013, 36.627831],
            [-85.486183, 36.616877],
            [-86.592525, 36.655216],
            [-87.852221, 36.633308],
            [-88.071299, 36.677123],
            [-88.054868, 36.496384],
            [-89.298133, 36.507338],
            [-89.418626, 36.496384],
            [-89.363857, 36.622354],
            [-89.215979, 36.578538],
            [-89.133825, 36.983832],
            [-89.183118, 37.038601],
            [-89.029763, 37.213863],
            [-88.914747, 37.224817],
            [-88.547792, 37.071463],
            [-88.421823, 37.153617],
            [-88.514931, 37.285064],
            [-88.476592, 37.389126],
            [-88.065822, 37.482234],
            [-88.15893, 37.657496],
            [-88.027483, 37.799896],
            [-87.934375, 37.893004],
            [-87.682436, 37.903958],
            [-87.600282, 37.975158],
            [-87.512651, 37.903958],
            [-87.381204, 37.93682],
            [-87.129265, 37.788942],
            [-87.047111, 37.893004],
            [-86.795172, 37.991589],
            [-86.729448, 37.893004],
            [-86.504894, 37.931343],
            [-86.521325, 38.040881],
            [-86.302247, 38.166851],
            [-86.263908, 38.051835],
            [-86.039354, 37.958727],
            [-85.924338, 38.024451],
            [-85.83123, 38.27639],
            [-85.655968, 38.325682],
            [-85.590245, 38.451652],
            [-85.42046, 38.533806],
            [-85.431413, 38.730976],
            [-85.173997, 38.68716],
            [-84.987781, 38.780268],
            [-84.812519, 38.785745],
            [-84.894673, 39.059592],
            [-84.817996, 39.103408],
            [-84.43461, 39.103408],
            [-84.231963, 38.895284],
            [-84.215533, 38.807653],
            [-83.903347, 38.769315]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "22",
      properties: { name: "Louisiana", abbrev: "LA" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-93.608485, 33.018527],
            [-91.16577, 33.002096],
            [-91.072662, 32.887081],
            [-91.143862, 32.843265],
            [-91.154816, 32.640618],
            [-91.006939, 32.514649],
            [-90.985031, 32.218894],
            [-91.105524, 31.988862],
            [-91.341032, 31.846462],
            [-91.401278, 31.621907],
            [-91.499863, 31.643815],
            [-91.516294, 31.27686],
            [-91.636787, 31.265906],
            [-91.565587, 31.068736],
            [-91.636787, 30.997536],
            [-89.747242, 30.997536],
            [-89.845827, 30.66892],
            [-89.681519, 30.449842],
            [-89.643181, 30.285534],
            [-89.522688, 30.181472],
            [-89.818443, 30.044549],
            [-89.84035, 29.945964],
            [-89.599365, 29.88024],
            [-89.495303, 30.039072],
            [-89.287179, 29.88024],
            [-89.30361, 29.754271],
            [-89.424103, 29.699501],
            [-89.648657, 29.748794],
            [-89.621273, 29.655686],
            [-89.69795, 29.513285],
            [-89.506257, 29.387316],
            [-89.199548, 29.348977],
            [-89.09001, 29.2011],
            [-89.002379, 29.179192],
            [-89.16121, 29.009407],
            [-89.336472, 29.042268],
            [-89.484349, 29.217531],
            [-89.851304, 29.310638],
            [-89.851304, 29.480424],
            [-90.032043, 29.425654],
            [-90.021089, 29.283254],
            [-90.103244, 29.151807],
            [-90.23469, 29.129899],
            [-90.333275, 29.277777],
            [-90.563307, 29.283254],
            [-90.645461, 29.129899],
            [-90.798815, 29.086084],
            [-90.963123, 29.179192],
            [-91.09457, 29.190146],
            [-91.220539, 29.436608],
            [-91.445094, 29.546147],
            [-91.532725, 29.529716],
            [-91.620356, 29.73784],
            [-91.883249, 29.710455],
            [-91.888726, 29.836425],
            [-92.146142, 29.715932],
            [-92.113281, 29.622824],
            [-92.31045, 29.535193],
            [-92.617159, 29.579009],
            [-92.97316, 29.715932],
            [-93.2251, 29.776178],
            [-93.767317, 29.726886],
            [-93.838517, 29.688547],
            [-93.926148, 29.787132],
            [-93.690639, 30.143133],
            [-93.767317, 30.334826],
            [-93.696116, 30.438888],
            [-93.728978, 30.575812],
            [-93.630393, 30.679874],
            [-93.526331, 30.93729],
            [-93.542762, 31.15089],
            [-93.816609, 31.556184],
            [-93.822086, 31.775262],
            [-94.041164, 31.994339],
            [-94.041164, 33.018527],
            [-93.608485, 33.018527]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "23",
      properties: { name: "Maine", abbrev: "ME" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-70.703921, 43.057759],
            [-70.824413, 43.128959],
            [-70.807983, 43.227544],
            [-70.966814, 43.34256],
            [-71.032537, 44.657025],
            [-71.08183, 45.303304],
            [-70.649151, 45.440228],
            [-70.720352, 45.511428],
            [-70.556043, 45.664782],
            [-70.386258, 45.735983],
            [-70.41912, 45.796229],
            [-70.260289, 45.889337],
            [-70.309581, 46.064599],
            [-70.210996, 46.327492],
            [-70.057642, 46.415123],
            [-69.997395, 46.694447],
            [-69.225147, 47.461219],
            [-69.044408, 47.428357],
            [-69.033454, 47.242141],
            [-68.902007, 47.176418],
            [-68.578868, 47.285957],
            [-68.376221, 47.285957],
            [-68.233821, 47.357157],
            [-67.954497, 47.198326],
            [-67.790188, 47.066879],
            [-67.779235, 45.944106],
            [-67.801142, 45.675736],
            [-67.456095, 45.604536],
            [-67.505388, 45.48952],
            [-67.417757, 45.379982],
            [-67.488957, 45.281397],
            [-67.346556, 45.128042],
            [-67.16034, 45.160904],
            [-66.979601, 44.804903],
            [-67.187725, 44.646072],
            [-67.308218, 44.706318],
            [-67.406803, 44.596779],
            [-67.549203, 44.624164],
            [-67.565634, 44.531056],
            [-67.75185, 44.54201],
            [-68.047605, 44.328409],
            [-68.118805, 44.476286],
            [-68.222867, 44.48724],
            [-68.173574, 44.328409],
            [-68.403606, 44.251732],
            [-68.458375, 44.377701],
            [-68.567914, 44.311978],
            [-68.82533, 44.311978],
            [-68.830807, 44.459856],
            [-68.984161, 44.426994],
            [-68.956777, 44.322932],
            [-69.099177, 44.103854],
            [-69.071793, 44.043608],
            [-69.258008, 43.923115],
            [-69.444224, 43.966931],
            [-69.553763, 43.840961],
            [-69.707118, 43.82453],
            [-69.833087, 43.720469],
            [-69.986442, 43.742376],
            [-70.030257, 43.851915],
            [-70.254812, 43.676653],
            [-70.194565, 43.567114],
            [-70.358873, 43.528776],
            [-70.369827, 43.435668],
            [-70.556043, 43.320652],
            [-70.703921, 43.057759]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "24",
      properties: { name: "Maryland", abbrev: "MD" },
      geometry: {
        type: "MultiPolygon",
        coordinates: [
          [
            [
              [-75.994645, 37.95325],
              [-76.016553, 37.95325],
              [-76.043938, 37.95325],
              [-75.994645, 37.95325]
            ]
          ],
          [
            [
              [-79.477979, 39.722302],
              [-75.786521, 39.722302],
              [-75.693413, 38.462606],
              [-75.047134, 38.451652],
              [-75.244304, 38.029928],
              [-75.397659, 38.013497],
              [-75.671506, 37.95325],
              [-75.885106, 37.909435],
              [-75.879629, 38.073743],
              [-75.961783, 38.139466],
              [-75.846768, 38.210667],
              [-76.000122, 38.374975],
              [-76.049415, 38.303775],
              [-76.257538, 38.320205],
              [-76.328738, 38.500944],
              [-76.263015, 38.500944],
              [-76.257538, 38.736453],
              [-76.191815, 38.829561],
              [-76.279446, 39.147223],
              [-76.169907, 39.333439],
              [-76.000122, 39.366301],
              [-75.972737, 39.557994],
              [-76.098707, 39.536086],
              [-76.104184, 39.437501],
              [-76.367077, 39.311532],
              [-76.443754, 39.196516],
              [-76.460185, 38.906238],
              [-76.55877, 38.769315],
              [-76.514954, 38.539283],
              [-76.383508, 38.380452],
              [-76.399939, 38.259959],
              [-76.317785, 38.139466],
              [-76.3616, 38.057312],
              [-76.591632, 38.216144],
              [-76.920248, 38.292821],
              [-77.018833, 38.446175],
              [-77.205049, 38.358544],
              [-77.276249, 38.479037],
              [-77.128372, 38.632391],
              [-77.040741, 38.791222],
              [-76.909294, 38.895284],
              [-77.035264, 38.993869],
              [-77.117418, 38.933623],
              [-77.248864, 39.026731],
              [-77.456988, 39.076023],
              [-77.456988, 39.223901],
              [-77.566527, 39.306055],
              [-77.719881, 39.322485],
              [-77.834897, 39.601809],
              [-78.004682, 39.601809],
              [-78.174467, 39.694917],
              [-78.267575, 39.61824],
              [-78.431884, 39.623717],
              [-78.470222, 39.514178],
              [-78.765977, 39.585379],
              [-78.963147, 39.437501],
              [-79.094593, 39.470363],
              [-79.291763, 39.300578],
              [-79.488933, 39.20747],
              [-79.477979, 39.722302]
            ]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "25",
      properties: { name: "Massachusetts", abbrev: "MA" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-70.917521, 42.887974],
            [-70.818936, 42.871543],
            [-70.780598, 42.696281],
            [-70.824413, 42.55388],
            [-70.983245, 42.422434],
            [-70.988722, 42.269079],
            [-70.769644, 42.247172],
            [-70.638197, 42.08834],
            [-70.660105, 41.962371],
            [-70.550566, 41.929509],
            [-70.539613, 41.814493],
            [-70.260289, 41.715908],
            [-69.937149, 41.809016],
            [-70.008349, 41.672093],
            [-70.484843, 41.5516],
            [-70.660105, 41.546123],
            [-70.764167, 41.639231],
            [-70.928475, 41.611847],
            [-70.933952, 41.540646],
            [-71.120168, 41.496831],
            [-71.196845, 41.67757],
            [-71.22423, 41.710431],
            [-71.328292, 41.781632],
            [-71.383061, 42.01714],
            [-71.530939, 42.01714],
            [-71.799309, 42.006186],
            [-71.799309, 42.022617],
            [-73.053528, 42.039048],
            [-73.486206, 42.050002],
            [-73.508114, 42.08834],
            [-73.267129, 42.745573],
            [-72.456542, 42.729142],
            [-71.29543, 42.696281],
            [-71.185891, 42.789389],
            [-70.917521, 42.887974]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "26",
      properties: { name: "Michigan", abbrev: "MI" },
      geometry: {
        type: "MultiPolygon",
        coordinates: [
          [
            [
              [-83.454238, 41.732339],
              [-84.807042, 41.694001],
              [-84.807042, 41.759724],
              [-85.990061, 41.759724],
              [-86.822556, 41.759724],
              [-86.619909, 41.891171],
              [-86.482986, 42.115725],
              [-86.357016, 42.252649],
              [-86.263908, 42.444341],
              [-86.209139, 42.718189],
              [-86.231047, 43.013943],
              [-86.526801, 43.594499],
              [-86.433693, 43.813577],
              [-86.499417, 44.07647],
              [-86.269385, 44.34484],
              [-86.220093, 44.569394],
              [-86.252954, 44.689887],
              [-86.088646, 44.73918],
              [-86.066738, 44.903488],
              [-85.809322, 44.947303],
              [-85.612152, 45.128042],
              [-85.628583, 44.766564],
              [-85.524521, 44.750133],
              [-85.393075, 44.930872],
              [-85.387598, 45.237581],
              [-85.305444, 45.314258],
              [-85.031597, 45.363551],
              [-85.119228, 45.577151],
              [-84.938489, 45.75789],
              [-84.713934, 45.768844],
              [-84.461995, 45.653829],
              [-84.215533, 45.637398],
              [-84.09504, 45.494997],
              [-83.908824, 45.484043],
              [-83.596638, 45.352597],
              [-83.4871, 45.358074],
              [-83.317314, 45.144473],
              [-83.454238, 45.029457],
              [-83.322791, 44.88158],
              [-83.273499, 44.711795],
              [-83.333745, 44.339363],
              [-83.536392, 44.246255],
              [-83.585684, 44.054562],
              [-83.82667, 43.988839],
              [-83.958116, 43.758807],
              [-83.908824, 43.671176],
              [-83.667839, 43.589022],
              [-83.481623, 43.714992],
              [-83.262545, 43.972408],
              [-82.917498, 44.070993],
              [-82.747713, 43.994316],
              [-82.643651, 43.851915],
              [-82.539589, 43.435668],
              [-82.523158, 43.227544],
              [-82.413619, 42.975605],
              [-82.517681, 42.614127],
              [-82.681989, 42.559357],
              [-82.687466, 42.690804],
              [-82.797005, 42.652465],
              [-82.922975, 42.351234],
              [-83.125621, 42.236218],
              [-83.185868, 42.006186],
              [-83.437807, 41.814493],
              [-83.454238, 41.732339]
            ]
          ],
          [
            [
              [-85.508091, 45.730506],
              [-85.49166, 45.610013],
              [-85.623106, 45.588105],
              [-85.568337, 45.75789],
              [-85.508091, 45.730506]
            ]
          ],
          [
            [
              [-87.589328, 45.095181],
              [-87.742682, 45.199243],
              [-87.649574, 45.341643],
              [-87.885083, 45.363551],
              [-87.791975, 45.500474],
              [-87.781021, 45.675736],
              [-87.989145, 45.796229],
              [-88.10416, 45.922199],
              [-88.531362, 46.020784],
              [-88.662808, 45.987922],
              [-89.09001, 46.135799],
              [-90.119674, 46.338446],
              [-90.229213, 46.508231],
              [-90.415429, 46.568478],
              [-90.026566, 46.672539],
              [-89.851304, 46.793032],
              [-89.413149, 46.842325],
              [-89.128348, 46.990202],
              [-88.996902, 46.995679],
              [-88.887363, 47.099741],
              [-88.575177, 47.247618],
              [-88.416346, 47.373588],
              [-88.180837, 47.455742],
              [-87.956283, 47.384542],
              [-88.350623, 47.077833],
              [-88.443731, 46.973771],
              [-88.438254, 46.787555],
              [-88.246561, 46.929956],
              [-87.901513, 46.908048],
              [-87.633143, 46.809463],
              [-87.392158, 46.535616],
              [-87.260711, 46.486323],
              [-87.008772, 46.530139],
              [-86.948526, 46.469893],
              [-86.696587, 46.437031],
              [-86.159846, 46.667063],
              [-85.880522, 46.68897],
              [-85.508091, 46.678016],
              [-85.256151, 46.754694],
              [-85.064458, 46.760171],
              [-85.02612, 46.480847],
              [-84.82895, 46.442508],
              [-84.63178, 46.486323],
              [-84.549626, 46.4206],
              [-84.418179, 46.502754],
              [-84.127902, 46.530139],
              [-84.122425, 46.179615],
              [-83.990978, 46.031737],
              [-83.793808, 45.993399],
              [-83.7719, 46.091984],
              [-83.580208, 46.091984],
              [-83.476146, 45.987922],
              [-83.563777, 45.911245],
              [-84.111471, 45.976968],
              [-84.374364, 45.933153],
              [-84.659165, 46.053645],
              [-84.741319, 45.944106],
              [-84.70298, 45.850998],
              [-84.82895, 45.872906],
              [-85.015166, 46.00983],
              [-85.338305, 46.091984],
              [-85.502614, 46.097461],
              [-85.661445, 45.966014],
              [-85.924338, 45.933153],
              [-86.209139, 45.960537],
              [-86.324155, 45.905768],
              [-86.351539, 45.796229],
              [-86.663725, 45.703121],
              [-86.647294, 45.834568],
              [-86.784218, 45.861952],
              [-86.838987, 45.725029],
              [-87.069019, 45.719552],
              [-87.17308, 45.659305],
              [-87.326435, 45.423797],
              [-87.611236, 45.122565],
              [-87.589328, 45.095181]
            ]
          ],
          [
            [
              [-88.805209, 47.976051],
              [-89.057148, 47.850082],
              [-89.188594, 47.833651],
              [-89.177641, 47.937713],
              [-88.547792, 48.173221],
              [-88.668285, 48.008913],
              [-88.805209, 47.976051]
            ]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "27",
      properties: { name: "Minnesota", abbrev: "MN" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-92.014696, 46.705401],
            [-92.091373, 46.749217],
            [-92.29402, 46.667063],
            [-92.29402, 46.075553],
            [-92.354266, 46.015307],
            [-92.639067, 45.933153],
            [-92.869098, 45.719552],
            [-92.885529, 45.577151],
            [-92.770513, 45.566198],
            [-92.644544, 45.440228],
            [-92.75956, 45.286874],
            [-92.737652, 45.117088],
            [-92.808852, 44.750133],
            [-92.545959, 44.569394],
            [-92.337835, 44.552964],
            [-92.233773, 44.443425],
            [-91.927065, 44.333886],
            [-91.877772, 44.202439],
            [-91.592971, 44.032654],
            [-91.43414, 43.994316],
            [-91.242447, 43.775238],
            [-91.269832, 43.616407],
            [-91.215062, 43.501391],
            [-91.368417, 43.501391],
            [-96.451017, 43.501391],
            [-96.451017, 45.297827],
            [-96.681049, 45.412843],
            [-96.856311, 45.604536],
            [-96.582464, 45.818137],
            [-96.560556, 45.933153],
            [-96.598895, 46.332969],
            [-96.719387, 46.437031],
            [-96.801542, 46.656109],
            [-96.785111, 46.924479],
            [-96.823449, 46.968294],
            [-96.856311, 47.609096],
            [-97.053481, 47.948667],
            [-97.130158, 48.140359],
            [-97.16302, 48.545653],
            [-97.097296, 48.682577],
            [-97.228743, 49.000239],
            [-95.152983, 49.000239],
            [-95.152983, 49.383625],
            [-94.955813, 49.372671],
            [-94.824366, 49.295994],
            [-94.69292, 48.775685],
            [-94.588858, 48.715438],
            [-94.260241, 48.699007],
            [-94.221903, 48.649715],
            [-93.838517, 48.627807],
            [-93.794701, 48.518268],
            [-93.466085, 48.545653],
            [-93.466085, 48.589469],
            [-93.208669, 48.644238],
            [-92.984114, 48.62233],
            [-92.726698, 48.540176],
            [-92.655498, 48.436114],
            [-92.50762, 48.447068],
            [-92.370697, 48.222514],
            [-92.304974, 48.315622],
            [-92.053034, 48.359437],
            [-92.009219, 48.266329],
            [-91.713464, 48.200606],
            [-91.713464, 48.112975],
            [-91.565587, 48.041775],
            [-91.264355, 48.080113],
            [-91.083616, 48.178698],
            [-90.837154, 48.238944],
            [-90.749522, 48.091067],
            [-90.579737, 48.123929],
            [-90.377091, 48.091067],
            [-90.141582, 48.112975],
            [-89.873212, 47.987005],
            [-89.615796, 48.008913],
            [-89.637704, 47.954144],
            [-89.971797, 47.828174],
            [-90.437337, 47.729589],
            [-90.738569, 47.625527],
            [-91.171247, 47.368111],
            [-91.357463, 47.20928],
            [-91.642264, 47.028541],
            [-92.091373, 46.787555],
            [-92.014696, 46.705401]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "28",
      properties: { name: "Mississippi", abbrev: "MS" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-88.471115, 34.995703],
            [-88.202745, 34.995703],
            [-88.098683, 34.891641],
            [-88.241084, 33.796253],
            [-88.471115, 31.895754],
            [-88.394438, 30.367688],
            [-88.503977, 30.323872],
            [-88.744962, 30.34578],
            [-88.843547, 30.411504],
            [-89.084533, 30.367688],
            [-89.418626, 30.252672],
            [-89.522688, 30.181472],
            [-89.643181, 30.285534],
            [-89.681519, 30.449842],
            [-89.845827, 30.66892],
            [-89.747242, 30.997536],
            [-91.636787, 30.997536],
            [-91.565587, 31.068736],
            [-91.636787, 31.265906],
            [-91.516294, 31.27686],
            [-91.499863, 31.643815],
            [-91.401278, 31.621907],
            [-91.341032, 31.846462],
            [-91.105524, 31.988862],
            [-90.985031, 32.218894],
            [-91.006939, 32.514649],
            [-91.154816, 32.640618],
            [-91.143862, 32.843265],
            [-91.072662, 32.887081],
            [-91.16577, 33.002096],
            [-91.089093, 33.13902],
            [-91.143862, 33.347144],
            [-91.056231, 33.429298],
            [-91.231493, 33.560744],
            [-91.072662, 33.867453],
            [-90.891923, 34.026284],
            [-90.952169, 34.135823],
            [-90.744046, 34.300131],
            [-90.749522, 34.365854],
            [-90.568783, 34.420624],
            [-90.585214, 34.617794],
            [-90.481152, 34.661609],
            [-90.409952, 34.831394],
            [-90.251121, 34.908072],
            [-90.311367, 34.995703],
            [-88.471115, 34.995703]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "29",
      properties: { name: "Missouri", abbrev: "MO" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-91.833957, 40.609566],
            [-91.729895, 40.615043],
            [-91.527248, 40.412397],
            [-91.417709, 40.379535],
            [-91.50534, 40.237135],
            [-91.494386, 40.034488],
            [-91.368417, 39.727779],
            [-91.061708, 39.470363],
            [-90.727615, 39.256762],
            [-90.661891, 38.928146],
            [-90.585214, 38.867899],
            [-90.470199, 38.961007],
            [-90.251121, 38.917192],
            [-90.10872, 38.845992],
            [-90.207305, 38.725499],
            [-90.179921, 38.632391],
            [-90.349706, 38.374975],
            [-90.355183, 38.216144],
            [-90.059428, 38.013497],
            [-89.949889, 37.88205],
            [-89.84035, 37.903958],
            [-89.517211, 37.690357],
            [-89.517211, 37.537003],
            [-89.435057, 37.34531],
            [-89.517211, 37.279587],
            [-89.292656, 36.994786],
            [-89.133825, 36.983832],
            [-89.215979, 36.578538],
            [-89.363857, 36.622354],
            [-89.418626, 36.496384],
            [-89.484349, 36.496384],
            [-89.539119, 36.496384],
            [-89.533642, 36.249922],
            [-89.730812, 35.997983],
            [-90.377091, 35.997983],
            [-90.218259, 36.184199],
            [-90.064905, 36.304691],
            [-90.152536, 36.496384],
            [-94.473842, 36.501861],
            [-94.616242, 36.501861],
            [-94.616242, 37.000263],
            [-94.610765, 39.158177],
            [-94.824366, 39.20747],
            [-94.983197, 39.442978],
            [-95.109167, 39.541563],
            [-94.884612, 39.831841],
            [-95.207752, 39.908518],
            [-95.306337, 40.001626],
            [-95.552799, 40.264519],
            [-95.7664, 40.587659],
            [-94.632673, 40.571228],
            [-93.257961, 40.582182],
            [-91.833957, 40.609566]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "30",
      properties: { name: "Montana", abbrev: "MT" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-104.047534, 49.000239],
            [-104.042057, 47.861036],
            [-104.047534, 45.944106],
            [-104.042057, 44.996596],
            [-104.058488, 44.996596],
            [-105.91517, 45.002073],
            [-109.080842, 45.002073],
            [-111.05254, 45.002073],
            [-111.047063, 44.476286],
            [-111.227803, 44.580348],
            [-111.386634, 44.75561],
            [-111.616665, 44.547487],
            [-111.819312, 44.509148],
            [-111.868605, 44.563917],
            [-112.104113, 44.520102],
            [-112.241036, 44.569394],
            [-112.471068, 44.481763],
            [-112.783254, 44.48724],
            [-112.887315, 44.394132],
            [-113.002331, 44.448902],
            [-113.133778, 44.772041],
            [-113.341901, 44.782995],
            [-113.456917, 44.865149],
            [-113.45144, 45.056842],
            [-113.571933, 45.128042],
            [-113.736241, 45.330689],
            [-113.834826, 45.522382],
            [-113.807441, 45.604536],
            [-113.98818, 45.703121],
            [-114.086765, 45.593582],
            [-114.333228, 45.456659],
            [-114.546828, 45.560721],
            [-114.497536, 45.670259],
            [-114.568736, 45.774321],
            [-114.387997, 45.88386],
            [-114.492059, 46.037214],
            [-114.464674, 46.272723],
            [-114.322274, 46.645155],
            [-114.612552, 46.639678],
            [-114.623506, 46.705401],
            [-114.886399, 46.809463],
            [-114.930214, 46.919002],
            [-115.302646, 47.187372],
            [-115.324554, 47.258572],
            [-115.527201, 47.302388],
            [-115.718894, 47.42288],
            [-115.724371, 47.696727],
            [-116.04751, 47.976051],
            [-116.04751, 49.000239],
            [-111.50165, 48.994762],
            [-109.453274, 49.000239],
            [-104.047534, 49.000239]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "31",
      properties: { name: "Nebraska", abbrev: "NE" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-103.324578, 43.002989],
            [-101.626726, 42.997512],
            [-98.499393, 42.997512],
            [-98.466531, 42.94822],
            [-97.951699, 42.767481],
            [-97.831206, 42.866066],
            [-97.688806, 42.844158],
            [-97.217789, 42.844158],
            [-96.692003, 42.657942],
            [-96.626279, 42.515542],
            [-96.44554, 42.488157],
            [-96.264801, 42.039048],
            [-96.127878, 41.973325],
            [-96.062155, 41.798063],
            [-96.122401, 41.67757],
            [-96.095016, 41.540646],
            [-95.919754, 41.453015],
            [-95.925231, 41.201076],
            [-95.826646, 40.976521],
            [-95.881416, 40.719105],
            [-95.7664, 40.587659],
            [-95.552799, 40.264519],
            [-95.306337, 40.001626],
            [-101.90605, 40.001626],
            [-102.053927, 40.001626],
            [-102.053927, 41.003906],
            [-104.053011, 41.003906],
            [-104.053011, 43.002989],
            [-103.324578, 43.002989]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "32",
      properties: { name: "Nevada", abbrev: "NV" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-117.027882, 42.000709],
            [-114.04295, 41.995232],
            [-114.048427, 37.000263],
            [-114.048427, 36.195153],
            [-114.152489, 36.025367],
            [-114.251074, 36.01989],
            [-114.371566, 36.140383],
            [-114.738521, 36.102045],
            [-114.678275, 35.516012],
            [-114.596121, 35.324319],
            [-114.574213, 35.138103],
            [-114.634459, 35.00118],
            [-115.85034, 35.970598],
            [-116.540435, 36.501861],
            [-117.498899, 37.21934],
            [-118.71478, 38.101128],
            [-120.001861, 38.999346],
            [-119.996384, 40.264519],
            [-120.001861, 41.995232],
            [-118.698349, 41.989755],
            [-117.027882, 42.000709]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "33",
      properties: { name: "New Hampshire", abbrev: "NH" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-71.08183, 45.303304],
            [-71.032537, 44.657025],
            [-70.966814, 43.34256],
            [-70.807983, 43.227544],
            [-70.824413, 43.128959],
            [-70.703921, 43.057759],
            [-70.818936, 42.871543],
            [-70.917521, 42.887974],
            [-71.185891, 42.789389],
            [-71.29543, 42.696281],
            [-72.456542, 42.729142],
            [-72.544173, 42.80582],
            [-72.533219, 42.953697],
            [-72.445588, 43.008466],
            [-72.456542, 43.150867],
            [-72.379864, 43.572591],
            [-72.204602, 43.769761],
            [-72.116971, 43.994316],
            [-72.02934, 44.07647],
            [-72.034817, 44.322932],
            [-71.700724, 44.41604],
            [-71.536416, 44.585825],
            [-71.629524, 44.750133],
            [-71.4926, 44.914442],
            [-71.503554, 45.013027],
            [-71.361154, 45.270443],
            [-71.131122, 45.243058],
            [-71.08183, 45.303304]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "34",
      properties: { name: "New Jersey", abbrev: "NJ" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-74.236547, 41.14083],
            [-73.902454, 40.998429],
            [-74.022947, 40.708151],
            [-74.187255, 40.642428],
            [-74.274886, 40.489074],
            [-74.001039, 40.412397],
            [-73.979131, 40.297381],
            [-74.099624, 39.760641],
            [-74.411809, 39.360824],
            [-74.614456, 39.245808],
            [-74.795195, 38.993869],
            [-74.888303, 39.158177],
            [-75.178581, 39.240331],
            [-75.534582, 39.459409],
            [-75.55649, 39.607286],
            [-75.561967, 39.629194],
            [-75.507197, 39.683964],
            [-75.414089, 39.804456],
            [-75.145719, 39.88661],
            [-75.129289, 39.963288],
            [-74.82258, 40.127596],
            [-74.773287, 40.215227],
            [-75.058088, 40.417874],
            [-75.069042, 40.543843],
            [-75.195012, 40.576705],
            [-75.205966, 40.691721],
            [-75.052611, 40.866983],
            [-75.134765, 40.971045],
            [-74.882826, 41.179168],
            [-74.828057, 41.288707],
            [-74.69661, 41.359907],
            [-74.236547, 41.14083]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "35",
      properties: { name: "New Mexico", abbrev: "NM" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-107.421329, 37.000263],
            [-106.868158, 36.994786],
            [-104.337812, 36.994786],
            [-103.001438, 37.000263],
            [-103.001438, 36.501861],
            [-103.039777, 36.501861],
            [-103.045254, 34.01533],
            [-103.067161, 33.002096],
            [-103.067161, 31.999816],
            [-106.616219, 31.999816],
            [-106.643603, 31.901231],
            [-106.528588, 31.786216],
            [-108.210008, 31.786216],
            [-108.210008, 31.331629],
            [-109.04798, 31.331629],
            [-109.042503, 37.000263],
            [-107.421329, 37.000263]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "36",
      properties: { name: "New York", abbrev: "NY" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-73.343806, 45.013027],
            [-73.332852, 44.804903],
            [-73.387622, 44.618687],
            [-73.294514, 44.437948],
            [-73.321898, 44.246255],
            [-73.436914, 44.043608],
            [-73.349283, 43.769761],
            [-73.404052, 43.687607],
            [-73.245221, 43.523299],
            [-73.278083, 42.833204],
            [-73.267129, 42.745573],
            [-73.508114, 42.08834],
            [-73.486206, 42.050002],
            [-73.55193, 41.294184],
            [-73.48073, 41.21203],
            [-73.727192, 41.102491],
            [-73.655992, 40.987475],
            [-73.22879, 40.905321],
            [-73.141159, 40.965568],
            [-72.774204, 40.965568],
            [-72.587988, 40.998429],
            [-72.28128, 41.157261],
            [-72.259372, 41.042245],
            [-72.100541, 40.992952],
            [-72.467496, 40.845075],
            [-73.239744, 40.625997],
            [-73.562884, 40.582182],
            [-73.776484, 40.593136],
            [-73.935316, 40.543843],
            [-74.022947, 40.708151],
            [-73.902454, 40.998429],
            [-74.236547, 41.14083],
            [-74.69661, 41.359907],
            [-74.740426, 41.431108],
            [-74.89378, 41.436584],
            [-75.074519, 41.60637],
            [-75.052611, 41.754247],
            [-75.173104, 41.869263],
            [-75.249781, 41.863786],
            [-75.35932, 42.000709],
            [-79.76278, 42.000709],
            [-79.76278, 42.252649],
            [-79.76278, 42.269079],
            [-79.149363, 42.55388],
            [-79.050778, 42.690804],
            [-78.853608, 42.783912],
            [-78.930285, 42.953697],
            [-79.012439, 42.986559],
            [-79.072686, 43.260406],
            [-78.486653, 43.375421],
            [-77.966344, 43.369944],
            [-77.75822, 43.34256],
            [-77.533665, 43.233021],
            [-77.391265, 43.276836],
            [-76.958587, 43.271359],
            [-76.695693, 43.34256],
            [-76.41637, 43.523299],
            [-76.235631, 43.528776],
            [-76.230154, 43.802623],
            [-76.137046, 43.961454],
            [-76.3616, 44.070993],
            [-76.312308, 44.196962],
            [-75.912491, 44.366748],
            [-75.764614, 44.514625],
            [-75.282643, 44.848718],
            [-74.828057, 45.018503],
            [-74.148916, 44.991119],
            [-73.343806, 45.013027]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "37",
      properties: { name: "North Carolina", abbrev: "NC" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-80.978661, 36.562108],
            [-80.294043, 36.545677],
            [-79.510841, 36.5402],
            [-75.868676, 36.551154],
            [-75.75366, 36.151337],
            [-76.032984, 36.189676],
            [-76.071322, 36.140383],
            [-76.410893, 36.080137],
            [-76.460185, 36.025367],
            [-76.68474, 36.008937],
            [-76.673786, 35.937736],
            [-76.399939, 35.987029],
            [-76.3616, 35.943213],
            [-76.060368, 35.992506],
            [-75.961783, 35.899398],
            [-75.781044, 35.937736],
            [-75.715321, 35.696751],
            [-75.775568, 35.581735],
            [-75.89606, 35.570781],
            [-76.147999, 35.324319],
            [-76.482093, 35.313365],
            [-76.536862, 35.14358],
            [-76.394462, 34.973795],
            [-76.279446, 34.940933],
            [-76.493047, 34.661609],
            [-76.673786, 34.694471],
            [-76.991448, 34.667086],
            [-77.210526, 34.60684],
            [-77.555573, 34.415147],
            [-77.82942, 34.163208],
            [-77.971821, 33.845545],
            [-78.179944, 33.916745],
            [-78.541422, 33.851022],
            [-79.675149, 34.80401],
            [-80.797922, 34.820441],
            [-80.781491, 34.935456],
            [-80.934845, 35.105241],
            [-81.038907, 35.044995],
            [-81.044384, 35.149057],
            [-82.276696, 35.198349],
            [-82.550543, 35.160011],
            [-82.764143, 35.066903],
            [-83.109191, 35.00118],
            [-83.618546, 34.984749],
            [-84.319594, 34.990226],
            [-84.29221, 35.225734],
            [-84.09504, 35.247642],
            [-84.018363, 35.41195],
            [-83.7719, 35.559827],
            [-83.498053, 35.565304],
            [-83.251591, 35.718659],
            [-82.994175, 35.773428],
            [-82.775097, 35.997983],
            [-82.638174, 36.063706],
            [-82.610789, 35.965121],
            [-82.216449, 36.156814],
            [-82.03571, 36.118475],
            [-81.909741, 36.304691],
            [-81.723525, 36.353984],
            [-81.679709, 36.589492],
            [-80.978661, 36.562108]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "38",
      properties: { name: "North Dakota", abbrev: "ND" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-97.228743, 49.000239],
            [-97.097296, 48.682577],
            [-97.16302, 48.545653],
            [-97.130158, 48.140359],
            [-97.053481, 47.948667],
            [-96.856311, 47.609096],
            [-96.823449, 46.968294],
            [-96.785111, 46.924479],
            [-96.801542, 46.656109],
            [-96.719387, 46.437031],
            [-96.598895, 46.332969],
            [-96.560556, 45.933153],
            [-104.047534, 45.944106],
            [-104.042057, 47.861036],
            [-104.047534, 49.000239],
            [-97.228743, 49.000239]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "39",
      properties: { name: "Ohio", abbrev: "OH" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-80.518598, 41.978802],
            [-80.518598, 40.636951],
            [-80.666475, 40.582182],
            [-80.595275, 40.472643],
            [-80.600752, 40.319289],
            [-80.737675, 40.078303],
            [-80.830783, 39.711348],
            [-81.219646, 39.388209],
            [-81.345616, 39.344393],
            [-81.455155, 39.410117],
            [-81.57017, 39.267716],
            [-81.685186, 39.273193],
            [-81.811156, 39.0815],
            [-81.783771, 38.966484],
            [-81.887833, 38.873376],
            [-82.03571, 39.026731],
            [-82.221926, 38.785745],
            [-82.172634, 38.632391],
            [-82.293127, 38.577622],
            [-82.331465, 38.446175],
            [-82.594358, 38.424267],
            [-82.731282, 38.561191],
            [-82.846298, 38.588575],
            [-82.890113, 38.758361],
            [-83.032514, 38.725499],
            [-83.142052, 38.626914],
            [-83.519961, 38.703591],
            [-83.678792, 38.632391],
            [-83.903347, 38.769315],
            [-84.215533, 38.807653],
            [-84.231963, 38.895284],
            [-84.43461, 39.103408],
            [-84.817996, 39.103408],
            [-84.801565, 40.500028],
            [-84.807042, 41.694001],
            [-83.454238, 41.732339],
            [-83.065375, 41.595416],
            [-82.933929, 41.513262],
            [-82.835344, 41.589939],
            [-82.616266, 41.431108],
            [-82.479343, 41.381815],
            [-82.013803, 41.513262],
            [-81.739956, 41.485877],
            [-81.444201, 41.672093],
            [-81.011523, 41.852832],
            [-80.518598, 41.978802],
            [-80.518598, 41.978802]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "40",
      properties: { name: "Oklahoma", abbrev: "OK" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-100.087706, 37.000263],
            [-94.616242, 37.000263],
            [-94.616242, 36.501861],
            [-94.430026, 35.395519],
            [-94.484796, 33.637421],
            [-94.868182, 33.74696],
            [-94.966767, 33.861976],
            [-95.224183, 33.960561],
            [-95.289906, 33.87293],
            [-95.547322, 33.878407],
            [-95.602092, 33.933176],
            [-95.8376, 33.834591],
            [-95.936185, 33.889361],
            [-96.149786, 33.840068],
            [-96.346956, 33.686714],
            [-96.423633, 33.774345],
            [-96.631756, 33.845545],
            [-96.850834, 33.845545],
            [-96.922034, 33.960561],
            [-97.173974, 33.736006],
            [-97.256128, 33.861976],
            [-97.371143, 33.823637],
            [-97.458774, 33.905791],
            [-97.694283, 33.982469],
            [-97.869545, 33.851022],
            [-97.946222, 33.987946],
            [-98.088623, 34.004376],
            [-98.170777, 34.113915],
            [-98.36247, 34.157731],
            [-98.488439, 34.064623],
            [-98.570593, 34.146777],
            [-98.767763, 34.135823],
            [-98.986841, 34.223454],
            [-99.189488, 34.2125],
            [-99.260688, 34.404193],
            [-99.57835, 34.415147],
            [-99.698843, 34.382285],
            [-99.923398, 34.573978],
            [-100.000075, 34.563024],
            [-100.000075, 36.501861],
            [-101.812942, 36.501861],
            [-103.001438, 36.501861],
            [-103.001438, 37.000263],
            [-102.042974, 36.994786],
            [-100.087706, 37.000263]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "41",
      properties: { name: "Oregon", abbrev: "OR" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-123.211348, 46.174138],
            [-123.11824, 46.185092],
            [-122.904639, 46.08103],
            [-122.811531, 45.960537],
            [-122.762239, 45.659305],
            [-122.247407, 45.549767],
            [-121.809251, 45.708598],
            [-121.535404, 45.725029],
            [-121.217742, 45.670259],
            [-121.18488, 45.604536],
            [-120.637186, 45.746937],
            [-120.505739, 45.697644],
            [-120.209985, 45.725029],
            [-119.963522, 45.823614],
            [-119.525367, 45.911245],
            [-119.125551, 45.933153],
            [-118.988627, 45.998876],
            [-116.918344, 45.993399],
            [-116.78142, 45.823614],
            [-116.545912, 45.752413],
            [-116.463758, 45.61549],
            [-116.671881, 45.319735],
            [-116.732128, 45.144473],
            [-116.847143, 45.02398],
            [-116.830713, 44.930872],
            [-116.934774, 44.782995],
            [-117.038836, 44.750133],
            [-117.241483, 44.394132],
            [-117.170283, 44.257209],
            [-116.97859, 44.240778],
            [-116.896436, 44.158624],
            [-117.027882, 43.830007],
            [-117.027882, 42.000709],
            [-118.698349, 41.989755],
            [-120.001861, 41.995232],
            [-121.037003, 41.995232],
            [-122.378853, 42.011663],
            [-123.233256, 42.006186],
            [-124.213628, 42.000709],
            [-124.356029, 42.115725],
            [-124.432706, 42.438865],
            [-124.416275, 42.663419],
            [-124.553198, 42.838681],
            [-124.454613, 43.002989],
            [-124.383413, 43.271359],
            [-124.235536, 43.55616],
            [-124.169813, 43.8081],
            [-124.060274, 44.657025],
            [-124.076705, 44.772041],
            [-123.97812, 45.144473],
            [-123.939781, 45.659305],
            [-123.994551, 45.944106],
            [-123.945258, 46.113892],
            [-123.545441, 46.261769],
            [-123.370179, 46.146753],
            [-123.211348, 46.174138]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "42",
      properties: { name: "Pennsylvania", abbrev: "PA" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-79.76278, 42.252649],
            [-79.76278, 42.000709],
            [-75.35932, 42.000709],
            [-75.249781, 41.863786],
            [-75.173104, 41.869263],
            [-75.052611, 41.754247],
            [-75.074519, 41.60637],
            [-74.89378, 41.436584],
            [-74.740426, 41.431108],
            [-74.69661, 41.359907],
            [-74.828057, 41.288707],
            [-74.882826, 41.179168],
            [-75.134765, 40.971045],
            [-75.052611, 40.866983],
            [-75.205966, 40.691721],
            [-75.195012, 40.576705],
            [-75.069042, 40.543843],
            [-75.058088, 40.417874],
            [-74.773287, 40.215227],
            [-74.82258, 40.127596],
            [-75.129289, 39.963288],
            [-75.145719, 39.88661],
            [-75.414089, 39.804456],
            [-75.616736, 39.831841],
            [-75.786521, 39.722302],
            [-79.477979, 39.722302],
            [-80.518598, 39.722302],
            [-80.518598, 40.636951],
            [-80.518598, 41.978802],
            [-80.518598, 41.978802],
            [-80.332382, 42.033571],
            [-79.76278, 42.269079],
            [-79.76278, 42.252649]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "44",
      properties: { name: "Rhode Island", abbrev: "RI" },
      geometry: {
        type: "MultiPolygon",
        coordinates: [
          [
            [
              [-71.196845, 41.67757],
              [-71.120168, 41.496831],
              [-71.317338, 41.474923],
              [-71.196845, 41.67757]
            ]
          ],
          [
            [
              [-71.530939, 42.01714],
              [-71.383061, 42.01714],
              [-71.328292, 41.781632],
              [-71.22423, 41.710431],
              [-71.344723, 41.726862],
              [-71.448785, 41.578985],
              [-71.481646, 41.370861],
              [-71.859555, 41.321569],
              [-71.799309, 41.414677],
              [-71.799309, 42.006186],
              [-71.530939, 42.01714]
            ]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "45",
      properties: { name: "South Carolina", abbrev: "SC" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-82.764143, 35.066903],
            [-82.550543, 35.160011],
            [-82.276696, 35.198349],
            [-81.044384, 35.149057],
            [-81.038907, 35.044995],
            [-80.934845, 35.105241],
            [-80.781491, 34.935456],
            [-80.797922, 34.820441],
            [-79.675149, 34.80401],
            [-78.541422, 33.851022],
            [-78.716684, 33.80173],
            [-78.935762, 33.637421],
            [-79.149363, 33.380005],
            [-79.187701, 33.171881],
            [-79.357487, 33.007573],
            [-79.582041, 33.007573],
            [-79.631334, 32.887081],
            [-79.866842, 32.755634],
            [-79.998289, 32.613234],
            [-80.206412, 32.552987],
            [-80.430967, 32.399633],
            [-80.452875, 32.328433],
            [-80.660998, 32.246279],
            [-80.885553, 32.032678],
            [-81.115584, 32.120309],
            [-81.121061, 32.290094],
            [-81.279893, 32.558464],
            [-81.416816, 32.629664],
            [-81.42777, 32.843265],
            [-81.493493, 33.007573],
            [-81.761863, 33.160928],
            [-81.937125, 33.347144],
            [-81.926172, 33.462159],
            [-82.194542, 33.631944],
            [-82.325988, 33.81816],
            [-82.55602, 33.94413],
            [-82.714851, 34.152254],
            [-82.747713, 34.26727],
            [-82.901067, 34.486347],
            [-83.005129, 34.469916],
            [-83.339222, 34.683517],
            [-83.322791, 34.787579],
            [-83.109191, 35.00118],
            [-82.764143, 35.066903]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "46",
      properties: { name: "South Dakota", abbrev: "SD" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-104.047534, 45.944106],
            [-96.560556, 45.933153],
            [-96.582464, 45.818137],
            [-96.856311, 45.604536],
            [-96.681049, 45.412843],
            [-96.451017, 45.297827],
            [-96.451017, 43.501391],
            [-96.582464, 43.479483],
            [-96.527695, 43.397329],
            [-96.560556, 43.222067],
            [-96.434587, 43.123482],
            [-96.511264, 43.052282],
            [-96.544125, 42.855112],
            [-96.631756, 42.707235],
            [-96.44554, 42.488157],
            [-96.626279, 42.515542],
            [-96.692003, 42.657942],
            [-97.217789, 42.844158],
            [-97.688806, 42.844158],
            [-97.831206, 42.866066],
            [-97.951699, 42.767481],
            [-98.466531, 42.94822],
            [-98.499393, 42.997512],
            [-101.626726, 42.997512],
            [-103.324578, 43.002989],
            [-104.053011, 43.002989],
            [-104.058488, 44.996596],
            [-104.042057, 44.996596],
            [-104.047534, 45.944106]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "47",
      properties: { name: "Tennessee", abbrev: "TN" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-88.054868, 36.496384],
            [-88.071299, 36.677123],
            [-87.852221, 36.633308],
            [-86.592525, 36.655216],
            [-85.486183, 36.616877],
            [-85.289013, 36.627831],
            [-84.544149, 36.594969],
            [-83.689746, 36.584015],
            [-83.673316, 36.600446],
            [-81.679709, 36.589492],
            [-81.723525, 36.353984],
            [-81.909741, 36.304691],
            [-82.03571, 36.118475],
            [-82.216449, 36.156814],
            [-82.610789, 35.965121],
            [-82.638174, 36.063706],
            [-82.775097, 35.997983],
            [-82.994175, 35.773428],
            [-83.251591, 35.718659],
            [-83.498053, 35.565304],
            [-83.7719, 35.559827],
            [-84.018363, 35.41195],
            [-84.09504, 35.247642],
            [-84.29221, 35.225734],
            [-84.319594, 34.990226],
            [-85.606675, 34.984749],
            [-87.359296, 35.00118],
            [-88.202745, 34.995703],
            [-88.471115, 34.995703],
            [-90.311367, 34.995703],
            [-90.212782, 35.023087],
            [-90.114197, 35.198349],
            [-90.130628, 35.439335],
            [-89.944412, 35.603643],
            [-89.911551, 35.756997],
            [-89.763673, 35.811767],
            [-89.730812, 35.997983],
            [-89.533642, 36.249922],
            [-89.539119, 36.496384],
            [-89.484349, 36.496384],
            [-89.418626, 36.496384],
            [-89.298133, 36.507338],
            [-88.054868, 36.496384]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "48",
      properties: { name: "Texas", abbrev: "TX" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-101.812942, 36.501861],
            [-100.000075, 36.501861],
            [-100.000075, 34.563024],
            [-99.923398, 34.573978],
            [-99.698843, 34.382285],
            [-99.57835, 34.415147],
            [-99.260688, 34.404193],
            [-99.189488, 34.2125],
            [-98.986841, 34.223454],
            [-98.767763, 34.135823],
            [-98.570593, 34.146777],
            [-98.488439, 34.064623],
            [-98.36247, 34.157731],
            [-98.170777, 34.113915],
            [-98.088623, 34.004376],
            [-97.946222, 33.987946],
            [-97.869545, 33.851022],
            [-97.694283, 33.982469],
            [-97.458774, 33.905791],
            [-97.371143, 33.823637],
            [-97.256128, 33.861976],
            [-97.173974, 33.736006],
            [-96.922034, 33.960561],
            [-96.850834, 33.845545],
            [-96.631756, 33.845545],
            [-96.423633, 33.774345],
            [-96.346956, 33.686714],
            [-96.149786, 33.840068],
            [-95.936185, 33.889361],
            [-95.8376, 33.834591],
            [-95.602092, 33.933176],
            [-95.547322, 33.878407],
            [-95.289906, 33.87293],
            [-95.224183, 33.960561],
            [-94.966767, 33.861976],
            [-94.868182, 33.74696],
            [-94.484796, 33.637421],
            [-94.380734, 33.544313],
            [-94.183564, 33.593606],
            [-94.041164, 33.54979],
            [-94.041164, 33.018527],
            [-94.041164, 31.994339],
            [-93.822086, 31.775262],
            [-93.816609, 31.556184],
            [-93.542762, 31.15089],
            [-93.526331, 30.93729],
            [-93.630393, 30.679874],
            [-93.728978, 30.575812],
            [-93.696116, 30.438888],
            [-93.767317, 30.334826],
            [-93.690639, 30.143133],
            [-93.926148, 29.787132],
            [-93.838517, 29.688547],
            [-94.002825, 29.68307],
            [-94.523134, 29.546147],
            [-94.70935, 29.622824],
            [-94.742212, 29.787132],
            [-94.873659, 29.672117],
            [-94.966767, 29.699501],
            [-95.016059, 29.557101],
            [-94.911997, 29.496854],
            [-94.895566, 29.310638],
            [-95.081782, 29.113469],
            [-95.383014, 28.867006],
            [-95.985477, 28.604113],
            [-96.045724, 28.647929],
            [-96.226463, 28.582205],
            [-96.23194, 28.642452],
            [-96.478402, 28.598636],
            [-96.593418, 28.724606],
            [-96.664618, 28.697221],
            [-96.401725, 28.439805],
            [-96.593418, 28.357651],
            [-96.774157, 28.406943],
            [-96.801542, 28.226204],
            [-97.026096, 28.039988],
            [-97.256128, 27.694941],
            [-97.404005, 27.333463],
            [-97.513544, 27.360848],
            [-97.540929, 27.229401],
            [-97.425913, 27.262263],
            [-97.480682, 26.99937],
            [-97.557359, 26.988416],
            [-97.562836, 26.840538],
            [-97.469728, 26.758384],
            [-97.442344, 26.457153],
            [-97.332805, 26.353091],
            [-97.30542, 26.161398],
            [-97.217789, 25.991613],
            [-97.524498, 25.887551],
            [-97.650467, 26.018997],
            [-97.885976, 26.06829],
            [-98.198161, 26.057336],
            [-98.466531, 26.221644],
            [-98.669178, 26.238075],
            [-98.822533, 26.369522],
            [-99.030656, 26.413337],
            [-99.173057, 26.539307],
            [-99.266165, 26.840538],
            [-99.446904, 27.021277],
            [-99.424996, 27.174632],
            [-99.50715, 27.33894],
            [-99.479765, 27.48134],
            [-99.605735, 27.640172],
            [-99.709797, 27.656603],
            [-99.879582, 27.799003],
            [-99.934351, 27.979742],
            [-100.082229, 28.14405],
            [-100.29583, 28.280974],
            [-100.399891, 28.582205],
            [-100.498476, 28.66436],
            [-100.629923, 28.905345],
            [-100.673738, 29.102515],
            [-100.799708, 29.244915],
            [-101.013309, 29.370885],
            [-101.062601, 29.458516],
            [-101.259771, 29.535193],
            [-101.413125, 29.754271],
            [-101.851281, 29.803563],
            [-102.114174, 29.792609],
            [-102.338728, 29.869286],
            [-102.388021, 29.765225],
            [-102.629006, 29.732363],
            [-102.809745, 29.524239],
            [-102.919284, 29.190146],
            [-102.97953, 29.184669],
            [-103.116454, 28.987499],
            [-103.280762, 28.982022],
            [-103.527224, 29.135376],
            [-104.146119, 29.381839],
            [-104.266611, 29.513285],
            [-104.507597, 29.639255],
            [-104.677382, 29.924056],
            [-104.688336, 30.181472],
            [-104.858121, 30.389596],
            [-104.896459, 30.570335],
            [-105.005998, 30.685351],
            [-105.394861, 30.855136],
            [-105.602985, 31.085167],
            [-105.77277, 31.167321],
            [-105.953509, 31.364491],
            [-106.205448, 31.468553],
            [-106.38071, 31.731446],
            [-106.528588, 31.786216],
            [-106.643603, 31.901231],
            [-106.616219, 31.999816],
            [-103.067161, 31.999816],
            [-103.067161, 33.002096],
            [-103.045254, 34.01533],
            [-103.039777, 36.501861],
            [-103.001438, 36.501861],
            [-101.812942, 36.501861]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "49",
      properties: { name: "Utah", abbrev: "UT" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-112.164359, 41.995232],
            [-111.047063, 42.000709],
            [-111.047063, 40.998429],
            [-109.04798, 40.998429],
            [-109.053457, 39.125316],
            [-109.058934, 38.27639],
            [-109.042503, 38.166851],
            [-109.042503, 37.000263],
            [-110.499369, 37.00574],
            [-114.048427, 37.000263],
            [-114.04295, 41.995232],
            [-112.164359, 41.995232]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "50",
      properties: { name: "Vermont", abbrev: "VT" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-71.503554, 45.013027],
            [-71.4926, 44.914442],
            [-71.629524, 44.750133],
            [-71.536416, 44.585825],
            [-71.700724, 44.41604],
            [-72.034817, 44.322932],
            [-72.02934, 44.07647],
            [-72.116971, 43.994316],
            [-72.204602, 43.769761],
            [-72.379864, 43.572591],
            [-72.456542, 43.150867],
            [-72.445588, 43.008466],
            [-72.533219, 42.953697],
            [-72.544173, 42.80582],
            [-72.456542, 42.729142],
            [-73.267129, 42.745573],
            [-73.278083, 42.833204],
            [-73.245221, 43.523299],
            [-73.404052, 43.687607],
            [-73.349283, 43.769761],
            [-73.436914, 44.043608],
            [-73.321898, 44.246255],
            [-73.294514, 44.437948],
            [-73.387622, 44.618687],
            [-73.332852, 44.804903],
            [-73.343806, 45.013027],
            [-72.308664, 45.002073],
            [-71.503554, 45.013027]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "51",
      properties: { name: "Virginia", abbrev: "VA" },
      geometry: {
        type: "MultiPolygon",
        coordinates: [
          [
            [
              [-75.397659, 38.013497],
              [-75.244304, 38.029928],
              [-75.375751, 37.860142],
              [-75.512674, 37.799896],
              [-75.594828, 37.569865],
              [-75.802952, 37.197433],
              [-75.972737, 37.120755],
              [-76.027507, 37.257679],
              [-75.939876, 37.564388],
              [-75.671506, 37.95325],
              [-75.397659, 38.013497]
            ]
          ],
          [
            [
              [-76.016553, 37.95325],
              [-75.994645, 37.95325],
              [-76.043938, 37.95325],
              [-76.016553, 37.95325]
            ]
          ],
          [
            [
              [-78.349729, 39.464886],
              [-77.82942, 39.130793],
              [-77.719881, 39.322485],
              [-77.566527, 39.306055],
              [-77.456988, 39.223901],
              [-77.456988, 39.076023],
              [-77.248864, 39.026731],
              [-77.117418, 38.933623],
              [-77.040741, 38.791222],
              [-77.128372, 38.632391],
              [-77.248864, 38.588575],
              [-77.325542, 38.446175],
              [-77.281726, 38.342113],
              [-77.013356, 38.374975],
              [-76.964064, 38.216144],
              [-76.613539, 38.15042],
              [-76.514954, 38.024451],
              [-76.235631, 37.887527],
              [-76.3616, 37.608203],
              [-76.246584, 37.389126],
              [-76.383508, 37.285064],
              [-76.399939, 37.159094],
              [-76.273969, 37.082417],
              [-76.410893, 36.961924],
              [-76.619016, 37.120755],
              [-76.668309, 37.065986],
              [-76.48757, 36.95097],
              [-75.994645, 36.923586],
              [-75.868676, 36.551154],
              [-79.510841, 36.5402],
              [-80.294043, 36.545677],
              [-80.978661, 36.562108],
              [-81.679709, 36.589492],
              [-83.673316, 36.600446],
              [-83.136575, 36.742847],
              [-83.070852, 36.852385],
              [-82.879159, 36.890724],
              [-82.868205, 36.978355],
              [-82.720328, 37.044078],
              [-82.720328, 37.120755],
              [-82.353373, 37.268633],
              [-81.969987, 37.537003],
              [-81.986418, 37.454849],
              [-81.849494, 37.285064],
              [-81.679709, 37.20291],
              [-81.55374, 37.208387],
              [-81.362047, 37.339833],
              [-81.225123, 37.235771],
              [-80.967707, 37.290541],
              [-80.513121, 37.482234],
              [-80.474782, 37.421987],
              [-80.29952, 37.509618],
              [-80.294043, 37.690357],
              [-80.184505, 37.849189],
              [-79.998289, 37.997066],
              [-79.921611, 38.177805],
              [-79.724442, 38.364021],
              [-79.647764, 38.594052],
              [-79.477979, 38.457129],
              [-79.313671, 38.413313],
              [-79.209609, 38.495467],
              [-78.996008, 38.851469],
              [-78.870039, 38.763838],
              [-78.404499, 39.169131],
              [-78.349729, 39.464886]
            ]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "53",
      properties: { name: "Washington", abbrev: "WA" },
      geometry: {
        type: "MultiPolygon",
        coordinates: [
          [
            [
              [-117.033359, 49.000239],
              [-117.044313, 47.762451],
              [-117.038836, 46.426077],
              [-117.055267, 46.343923],
              [-116.92382, 46.168661],
              [-116.918344, 45.993399],
              [-118.988627, 45.998876],
              [-119.125551, 45.933153],
              [-119.525367, 45.911245],
              [-119.963522, 45.823614],
              [-120.209985, 45.725029],
              [-120.505739, 45.697644],
              [-120.637186, 45.746937],
              [-121.18488, 45.604536],
              [-121.217742, 45.670259],
              [-121.535404, 45.725029],
              [-121.809251, 45.708598],
              [-122.247407, 45.549767],
              [-122.762239, 45.659305],
              [-122.811531, 45.960537],
              [-122.904639, 46.08103],
              [-123.11824, 46.185092],
              [-123.211348, 46.174138],
              [-123.370179, 46.146753],
              [-123.545441, 46.261769],
              [-123.72618, 46.300108],
              [-123.874058, 46.239861],
              [-124.065751, 46.327492],
              [-124.027412, 46.464416],
              [-123.895966, 46.535616],
              [-124.098612, 46.74374],
              [-124.235536, 47.285957],
              [-124.31769, 47.357157],
              [-124.427229, 47.740543],
              [-124.624399, 47.88842],
              [-124.706553, 48.184175],
              [-124.597014, 48.381345],
              [-124.394367, 48.288237],
              [-123.983597, 48.162267],
              [-123.704273, 48.167744],
              [-123.424949, 48.118452],
              [-123.162056, 48.167744],
              [-123.036086, 48.080113],
              [-122.800578, 48.08559],
              [-122.636269, 47.866512],
              [-122.515777, 47.882943],
              [-122.493869, 47.587189],
              [-122.422669, 47.318818],
              [-122.324084, 47.346203],
              [-122.422669, 47.576235],
              [-122.395284, 47.800789],
              [-122.230976, 48.030821],
              [-122.362422, 48.123929],
              [-122.373376, 48.288237],
              [-122.471961, 48.468976],
              [-122.422669, 48.600422],
              [-122.488392, 48.753777],
              [-122.647223, 48.775685],
              [-122.795101, 48.8907],
              [-122.756762, 49.000239],
              [-117.033359, 49.000239]
            ]
          ],
          [
            [
              [-122.718423, 48.310145],
              [-122.586977, 48.35396],
              [-122.608885, 48.151313],
              [-122.767716, 48.227991],
              [-122.718423, 48.310145]
            ]
          ],
          [
            [
              [-123.025132, 48.583992],
              [-122.915593, 48.715438],
              [-122.767716, 48.556607],
              [-122.811531, 48.419683],
              [-123.041563, 48.458022],
              [-123.025132, 48.583992]
            ]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "54",
      properties: { name: "West Virginia", abbrev: "WV" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-80.518598, 40.636951],
            [-80.518598, 39.722302],
            [-79.477979, 39.722302],
            [-79.488933, 39.20747],
            [-79.291763, 39.300578],
            [-79.094593, 39.470363],
            [-78.963147, 39.437501],
            [-78.765977, 39.585379],
            [-78.470222, 39.514178],
            [-78.431884, 39.623717],
            [-78.267575, 39.61824],
            [-78.174467, 39.694917],
            [-78.004682, 39.601809],
            [-77.834897, 39.601809],
            [-77.719881, 39.322485],
            [-77.82942, 39.130793],
            [-78.349729, 39.464886],
            [-78.404499, 39.169131],
            [-78.870039, 38.763838],
            [-78.996008, 38.851469],
            [-79.209609, 38.495467],
            [-79.313671, 38.413313],
            [-79.477979, 38.457129],
            [-79.647764, 38.594052],
            [-79.724442, 38.364021],
            [-79.921611, 38.177805],
            [-79.998289, 37.997066],
            [-80.184505, 37.849189],
            [-80.294043, 37.690357],
            [-80.29952, 37.509618],
            [-80.474782, 37.421987],
            [-80.513121, 37.482234],
            [-80.967707, 37.290541],
            [-81.225123, 37.235771],
            [-81.362047, 37.339833],
            [-81.55374, 37.208387],
            [-81.679709, 37.20291],
            [-81.849494, 37.285064],
            [-81.986418, 37.454849],
            [-81.969987, 37.537003],
            [-82.101434, 37.553434],
            [-82.293127, 37.668449],
            [-82.342419, 37.783465],
            [-82.50125, 37.931343],
            [-82.621743, 38.123036],
            [-82.594358, 38.424267],
            [-82.331465, 38.446175],
            [-82.293127, 38.577622],
            [-82.172634, 38.632391],
            [-82.221926, 38.785745],
            [-82.03571, 39.026731],
            [-81.887833, 38.873376],
            [-81.783771, 38.966484],
            [-81.811156, 39.0815],
            [-81.685186, 39.273193],
            [-81.57017, 39.267716],
            [-81.455155, 39.410117],
            [-81.345616, 39.344393],
            [-81.219646, 39.388209],
            [-80.830783, 39.711348],
            [-80.737675, 40.078303],
            [-80.600752, 40.319289],
            [-80.595275, 40.472643],
            [-80.666475, 40.582182],
            [-80.518598, 40.636951]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "55",
      properties: { name: "Wisconsin", abbrev: "WI" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-90.415429, 46.568478],
            [-90.229213, 46.508231],
            [-90.119674, 46.338446],
            [-89.09001, 46.135799],
            [-88.662808, 45.987922],
            [-88.531362, 46.020784],
            [-88.10416, 45.922199],
            [-87.989145, 45.796229],
            [-87.781021, 45.675736],
            [-87.791975, 45.500474],
            [-87.885083, 45.363551],
            [-87.649574, 45.341643],
            [-87.742682, 45.199243],
            [-87.589328, 45.095181],
            [-87.627666, 44.974688],
            [-87.819359, 44.95278],
            [-87.983668, 44.722749],
            [-88.043914, 44.563917],
            [-87.928898, 44.536533],
            [-87.775544, 44.640595],
            [-87.611236, 44.837764],
            [-87.403112, 44.914442],
            [-87.238804, 45.166381],
            [-87.03068, 45.22115],
            [-87.047111, 45.089704],
            [-87.189511, 44.969211],
            [-87.468835, 44.552964],
            [-87.545512, 44.322932],
            [-87.540035, 44.158624],
            [-87.644097, 44.103854],
            [-87.737205, 43.8793],
            [-87.704344, 43.687607],
            [-87.791975, 43.561637],
            [-87.912467, 43.249452],
            [-87.885083, 43.002989],
            [-87.76459, 42.783912],
            [-87.802929, 42.493634],
            [-88.788778, 42.493634],
            [-90.639984, 42.510065],
            [-90.711184, 42.636034],
            [-91.067185, 42.75105],
            [-91.143862, 42.909881],
            [-91.176724, 43.134436],
            [-91.056231, 43.254929],
            [-91.204109, 43.353514],
            [-91.215062, 43.501391],
            [-91.269832, 43.616407],
            [-91.242447, 43.775238],
            [-91.43414, 43.994316],
            [-91.592971, 44.032654],
            [-91.877772, 44.202439],
            [-91.927065, 44.333886],
            [-92.233773, 44.443425],
            [-92.337835, 44.552964],
            [-92.545959, 44.569394],
            [-92.808852, 44.750133],
            [-92.737652, 45.117088],
            [-92.75956, 45.286874],
            [-92.644544, 45.440228],
            [-92.770513, 45.566198],
            [-92.885529, 45.577151],
            [-92.869098, 45.719552],
            [-92.639067, 45.933153],
            [-92.354266, 46.015307],
            [-92.29402, 46.075553],
            [-92.29402, 46.667063],
            [-92.091373, 46.749217],
            [-92.014696, 46.705401],
            [-91.790141, 46.694447],
            [-91.09457, 46.864232],
            [-90.837154, 46.95734],
            [-90.749522, 46.88614],
            [-90.886446, 46.754694],
            [-90.55783, 46.584908],
            [-90.415429, 46.568478]
          ]
        ]
      }
    },
    {
      type: "Feature",
      id: "56",
      properties: { name: "Wyoming", abbrev: "WY" },
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [-109.080842, 45.002073],
            [-105.91517, 45.002073],
            [-104.058488, 44.996596],
            [-104.053011, 43.002989],
            [-104.053011, 41.003906],
            [-105.728954, 40.998429],
            [-107.919731, 41.003906],
            [-109.04798, 40.998429],
            [-111.047063, 40.998429],
            [-111.047063, 42.000709],
            [-111.047063, 44.476286],
            [-111.05254, 45.002073],
            [-109.080842, 45.002073]
          ]
        ]
      }
    }
  ]
};

// ../../node_modules/@evidence-dev/component-utilities/src/echartsMap.js
var echartsMap_default = (node, option) => {
  registerMap("US", usStateMap_default);
  let hasLink = option.hasLink;
  const chart = init2(node, "none", { renderer: "svg" });
  chart.setOption(option.config);
  let resizeObserver;
  const containerElement = document.querySelector("div.content > article");
  const resizeChart = () => {
    chart.resize({
      animation: {
        duration: 500
      }
    });
  };
  if (hasLink) {
    chart.on("click", function(params) {
      if (params.data && params.data.link) {
        window.location = params.data.link;
      }
    });
  }
  if (window.ResizeObserver && containerElement) {
    resizeObserver = new ResizeObserver(resizeChart);
    resizeObserver.observe(containerElement);
  } else {
    window.addEventListener("resize", resizeChart);
  }
  return {
    update(option2) {
      chart.setOption(option2.config, true, true);
    },
    destroy() {
      if (resizeObserver) {
        resizeObserver.unobserve(containerElement);
      } else {
        window.removeEventListener("resize", resizeChart);
      }
      chart.dispose();
    }
  };
};

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/EChartsMap.svelte
var file67 = "Users/tompeterson/github_public/lifespan/node_modules/@evidence-dev/core-components/dist/unsorted/viz/EChartsMap.svelte";
function add_css56(target) {
  append_styles(target, "svelte-1czor19", "@media print{.chart.svelte-1czor19{-moz-column-break-inside:avoid;break-inside:avoid}.chart-container.svelte-1czor19{padding:0}}@media screen and (max-width: 480px){.chart.svelte-1czor19{height:190px}}@media screen and (max-width: 600px) and (min-width: 480px){.chart.svelte-1czor19{height:240px}}@media screen and (min-width: 600px){.chart.svelte-1czor19{height:330px}}.chart.svelte-1czor19{-moz-user-select:none;-webkit-user-select:none;-o-user-select:none;user-select:none}.chart-footer.svelte-1czor19{display:flex;justify-content:flex-end;align-items:center;margin:3px 12px;font-size:12px;height:9px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRUNoYXJ0c01hcC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBa0hDLE9BQUEsS0FBQSxBQUFBLENBQUEsQUFDQyxNQUFBLGVBQUEsQ0FBQSxBQUNDLHdCQUFBLENBQUEsS0FBK0IsQ0FDMUIsWUFBQSxDQUFBLEtBQW1CLEFBQ3pCLENBQUEsQUFFQSxnQkFBQSxlQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsQ0FBVSxBQUNYLENBQUEsQUFDRCxDQUFBLEFBRUEsT0FBQSxNQUFBLENBQUEsR0FBQSxDQUFBLFlBQUEsS0FBQSxDQUFBLEFBQUEsQ0FBQSxBQUNDLE1BQUEsZUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLEtBQWEsQUFDZCxDQUFBLEFBQ0QsQ0FBQSxBQUVBLE9BQUEsTUFBQSxDQUFBLEdBQUEsQ0FBQSxZQUFBLEtBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxZQUFBLEtBQUEsQ0FBQSxBQUFBLENBQUEsQUFDQyxNQUFBLGVBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxLQUFhLEFBQ2QsQ0FBQSxBQUNELENBQUEsQUFFQSxPQUFBLE1BQUEsQ0FBQSxHQUFBLENBQUEsWUFBQSxLQUFBLENBQUEsQUFBQSxDQUFBLEFBQ0MsTUFBQSxlQUFBLENBQUEsQUFDQyxNQUFBLENBQUEsS0FBYSxBQUNkLENBQUEsQUFDRCxDQUFBLEFBRUEsTUFBQSxlQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLElBQXNCLENBQ3RCLG1CQUFBLENBQUEsSUFBeUIsQ0FDekIsY0FBQSxDQUFBLElBQW9CLENBQ3BCLFdBQUEsQ0FBQSxJQUFpQixBQUNsQixDQUFBLEFBRUEsYUFBQSxlQUFBLENBQUEsQUFDQyxPQUFBLENBQUEsSUFBYSxDQUNiLGVBQUEsQ0FBQSxRQUF5QixDQUN6QixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsTUFBQSxDQUFBLEdBQUEsQ0FBQSxJQUFnQixDQUNoQixTQUFBLENBQUEsSUFBZSxDQUNmLE1BQUEsQ0FBQSxHQUFXLEFBQ1osQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJFQ2hhcnRzTWFwLnN2ZWx0ZSJdfQ== */");
}
function create_if_block_218(ctx) {
  let div;
  let echartsMap_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "chart svelte-1czor19");
      set_style(
        div,
        "height",
        /*height*/
        ctx[1]
      );
      set_style(
        div,
        "width",
        /*width*/
        ctx[2]
      );
      set_style(div, "margin-left", "0");
      set_style(div, "margin-top", "15px");
      set_style(div, "margin-bottom", "10px");
      set_style(div, "overflow", "visible");
      set_style(
        div,
        "display",
        /*copying*/
        ctx[6] ? "none" : "inherit"
      );
      add_location(div, file67, 46, 2, 1093);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(echartsMap_action = echartsMap_default.call(null, div, {
          config: (
            /*config*/
            ctx[0]
          ),
          hasLink: (
            /*hasLink*/
            ctx[4]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*height*/
      2) {
        set_style(
          div,
          "height",
          /*height*/
          ctx2[1]
        );
      }
      if (dirty & /*width*/
      4) {
        set_style(
          div,
          "width",
          /*width*/
          ctx2[2]
        );
      }
      if (dirty & /*copying*/
      64) {
        set_style(
          div,
          "display",
          /*copying*/
          ctx2[6] ? "none" : "inherit"
        );
      }
      if (echartsMap_action && is_function(echartsMap_action.update) && dirty & /*config, hasLink*/
      17)
        echartsMap_action.update.call(null, {
          config: (
            /*config*/
            ctx2[0]
          ),
          hasLink: (
            /*hasLink*/
            ctx2[4]
          )
        });
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_218.name,
    type: "if",
    source: "(46:1) {#if !printing}",
    ctx
  });
  return block;
}
function create_default_slot9(ctx) {
  let svg;
  let rect;
  let circle;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      circle = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      add_location(rect, file67, 85, 5, 1946);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "8.5");
      attr_dev(circle, "r", "1.5");
      add_location(circle, file67, 85, 55, 1996);
      attr_dev(path, "d", "M20.4 14.5L16 10 4 20");
      add_location(path, file67, 85, 91, 2032);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "stroke", "#000");
      attr_dev(svg, "stroke-width", "2");
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      add_location(svg, file67, 75, 3, 1732);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: '(65:2) <DownloadData    text=\\"Save image\\"    class=\\"download-button\\"    downloadData={() => {     downloadChart = true;     setTimeout(() => {      downloadChart = false;     }, 0);    }}    display={hovering}   >',
    ctx
  });
  return block;
}
function create_if_block_126(ctx) {
  let downloaddata;
  let current;
  downloaddata = new DownloadData_default({
    props: {
      text: "Download data",
      data: (
        /*data*/
        ctx[3]
      ),
      class: "download-button",
      display: (
        /*hovering*/
        ctx[8]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(downloaddata.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(downloaddata.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(downloaddata, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const downloaddata_changes = {};
      if (dirty & /*data*/
      8)
        downloaddata_changes.data = /*data*/
        ctx2[3];
      if (dirty & /*hovering*/
      256)
        downloaddata_changes.display = /*hovering*/
        ctx2[8];
      downloaddata.$set(downloaddata_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(downloaddata.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(downloaddata.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(downloaddata, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_126.name,
    type: "if",
    source: "(91:2) {#if data}",
    ctx
  });
  return block;
}
function create_if_block50(ctx) {
  let div;
  let echartsCanvasDownload_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "chart svelte-1czor19");
      set_style(div, "display", "none");
      set_style(div, "visibility", "visible");
      set_style(
        div,
        "height",
        /*height*/
        ctx[1]
      );
      set_style(div, "width", "666px");
      set_style(div, "margin-left", "0");
      set_style(div, "margin-top", "15px");
      set_style(div, "margin-bottom", "15px");
      set_style(div, "overflow", "visible");
      add_location(div, file67, 97, 1, 2253);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(echartsCanvasDownload_action = echartsCanvasDownload_default.call(
          null,
          div,
          /*config*/
          ctx[0]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*height*/
      2) {
        set_style(
          div,
          "height",
          /*height*/
          ctx2[1]
        );
      }
      if (echartsCanvasDownload_action && is_function(echartsCanvasDownload_action.update) && dirty & /*config*/
      1)
        echartsCanvasDownload_action.update.call(
          null,
          /*config*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block50.name,
    type: "if",
    source: "(97:0) {#if downloadChart}",
    ctx
  });
  return block;
}
function create_fragment84(ctx) {
  let div1;
  let t0;
  let echartscopytarget;
  let t1;
  let div0;
  let downloaddata;
  let t2;
  let t3;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !/*printing*/
  ctx[7] && create_if_block_218(ctx);
  echartscopytarget = new EchartsCopyTarget_default({
    props: {
      config: (
        /*config*/
        ctx[0]
      ),
      height: (
        /*height*/
        ctx[1]
      ),
      width: (
        /*width*/
        ctx[2]
      ),
      copying: (
        /*copying*/
        ctx[6]
      ),
      printing: (
        /*printing*/
        ctx[7]
      )
    },
    $$inline: true
  });
  downloaddata = new DownloadData_default({
    props: {
      text: "Save image",
      class: "download-button",
      downloadData: (
        /*func*/
        ctx[14]
      ),
      display: (
        /*hovering*/
        ctx[8]
      ),
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block1 = (
    /*data*/
    ctx[3] && create_if_block_126(ctx)
  );
  let if_block2 = (
    /*downloadChart*/
    ctx[5] && create_if_block50(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(echartscopytarget.$$.fragment);
      t1 = space();
      div0 = element("div");
      create_component(downloaddata.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      claim_component(echartscopytarget.$$.fragment, div1_nodes);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(downloaddata.$$.fragment, div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "chart-footer svelte-1czor19");
      add_location(div0, file67, 63, 1, 1493);
      attr_dev(div1, "class", "chart-container svelte-1czor19");
      add_location(div1, file67, 40, 0, 959);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      mount_component(echartscopytarget, div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      mount_component(downloaddata, div0, null);
      append_hydration_dev(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      insert_hydration_dev(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "copy",
            /*copy_handler*/
            ctx[9],
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "beforeprint",
            /*beforeprint_handler*/
            ctx[10],
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "afterprint",
            /*afterprint_handler*/
            ctx[11],
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "export-beforeprint",
            /*export_beforeprint_handler*/
            ctx[12],
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "export-afterprint",
            /*export_afterprint_handler*/
            ctx[13],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[15],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[16],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*printing*/
      ctx2[7]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_218(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const echartscopytarget_changes = {};
      if (dirty & /*config*/
      1)
        echartscopytarget_changes.config = /*config*/
        ctx2[0];
      if (dirty & /*height*/
      2)
        echartscopytarget_changes.height = /*height*/
        ctx2[1];
      if (dirty & /*width*/
      4)
        echartscopytarget_changes.width = /*width*/
        ctx2[2];
      if (dirty & /*copying*/
      64)
        echartscopytarget_changes.copying = /*copying*/
        ctx2[6];
      if (dirty & /*printing*/
      128)
        echartscopytarget_changes.printing = /*printing*/
        ctx2[7];
      echartscopytarget.$set(echartscopytarget_changes);
      const downloaddata_changes = {};
      if (dirty & /*downloadChart*/
      32)
        downloaddata_changes.downloadData = /*func*/
        ctx2[14];
      if (dirty & /*hovering*/
      256)
        downloaddata_changes.display = /*hovering*/
        ctx2[8];
      if (dirty & /*$$scope*/
      131072) {
        downloaddata_changes.$$scope = { dirty, ctx: ctx2 };
      }
      downloaddata.$set(downloaddata_changes);
      if (
        /*data*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*data*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_126(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*downloadChart*/
        ctx2[5]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block50(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(echartscopytarget.$$.fragment, local);
      transition_in(downloaddata.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(echartscopytarget.$$.fragment, local);
      transition_out(downloaddata.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      destroy_component(echartscopytarget);
      destroy_component(downloaddata);
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach_dev(t3);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude80 = true;
function instance84($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EChartsMap", slots, []);
  let { config = void 0 } = $$props;
  let { height = "310px" } = $$props;
  let { width = "100%" } = $$props;
  let { data } = $$props;
  let { hasLink = false } = $$props;
  let downloadChart = false;
  let copying = false;
  let printing = false;
  let hovering = false;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<EChartsMap> was created without expected prop 'data'");
    }
  });
  const writable_props = ["config", "height", "width", "data", "hasLink"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EChartsMap> was created with unknown prop '${key}'`);
  });
  const copy_handler = () => {
    $$invalidate(6, copying = true);
    flush();
    setTimeout(
      () => {
        $$invalidate(6, copying = false);
      },
      0
    );
  };
  const beforeprint_handler = () => $$invalidate(7, printing = true);
  const afterprint_handler = () => $$invalidate(7, printing = false);
  const export_beforeprint_handler = () => $$invalidate(7, printing = true);
  const export_afterprint_handler = () => $$invalidate(7, printing = false);
  const func3 = () => {
    $$invalidate(5, downloadChart = true);
    setTimeout(
      () => {
        $$invalidate(5, downloadChart = false);
      },
      0
    );
  };
  const mouseenter_handler = () => $$invalidate(8, hovering = true);
  const mouseleave_handler = () => $$invalidate(8, hovering = false);
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("hasLink" in $$props2)
      $$invalidate(4, hasLink = $$props2.hasLink);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude80,
    echartsMap: echartsMap_default,
    echartsCanvasDownload: echartsCanvasDownload_default,
    EchartsCopyTarget: EchartsCopyTarget_default,
    DownloadData: DownloadData_default,
    flush,
    config,
    height,
    width,
    data,
    hasLink,
    downloadChart,
    copying,
    printing,
    hovering
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("hasLink" in $$props2)
      $$invalidate(4, hasLink = $$props2.hasLink);
    if ("downloadChart" in $$props2)
      $$invalidate(5, downloadChart = $$props2.downloadChart);
    if ("copying" in $$props2)
      $$invalidate(6, copying = $$props2.copying);
    if ("printing" in $$props2)
      $$invalidate(7, printing = $$props2.printing);
    if ("hovering" in $$props2)
      $$invalidate(8, hovering = $$props2.hovering);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    config,
    height,
    width,
    data,
    hasLink,
    downloadChart,
    copying,
    printing,
    hovering,
    copy_handler,
    beforeprint_handler,
    afterprint_handler,
    export_beforeprint_handler,
    export_afterprint_handler,
    func3,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var EChartsMap = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance84,
      create_fragment84,
      safe_not_equal,
      {
        config: 0,
        height: 1,
        width: 2,
        data: 3,
        hasLink: 4
      },
      add_css56
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EChartsMap",
      options,
      id: create_fragment84.name
    });
  }
  get config() {
    throw new Error("<EChartsMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<EChartsMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<EChartsMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<EChartsMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<EChartsMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<EChartsMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<EChartsMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<EChartsMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasLink() {
    throw new Error("<EChartsMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasLink(value) {
    throw new Error("<EChartsMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EChartsMap_default = EChartsMap;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/FunnelChart.svelte
function create_fragment85(ctx) {
  let echarts;
  let current;
  echarts = new ECharts_default({
    props: {
      config: (
        /*config*/
        ctx[2]
      ),
      width: (
        /*width*/
        ctx[0]
      ),
      height: (
        /*height*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(echarts.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(echarts.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(echarts, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const echarts_changes = {};
      if (dirty[0] & /*config*/
      4)
        echarts_changes.config = /*config*/
        ctx2[2];
      if (dirty[0] & /*width*/
      1)
        echarts_changes.width = /*width*/
        ctx2[0];
      if (dirty[0] & /*height*/
      2)
        echarts_changes.height = /*height*/
        ctx2[1];
      echarts.$set(echarts_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(echarts.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(echarts.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(echarts, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude81 = true;
function instance85($$self, $$props, $$invalidate) {
  let name;
  let seriesConfig;
  let config;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FunnelChart", slots, []);
  let { data = void 0 } = $$props;
  let { nameCol = void 0 } = $$props;
  let { valueCol = void 0 } = $$props;
  let { valueFmt = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { legend = true } = $$props;
  legend = legend === "true" || legend === true;
  let { outlineColor = void 0 } = $$props;
  let { outlineWidth = void 0 } = $$props;
  let { labelPosition = "inside" } = $$props;
  let { funnelAlign = "center" } = $$props;
  let { funnelSort = "none" } = $$props;
  let columnSummary;
  let nameColFormat;
  let chartAreaHeight;
  let hasTitle;
  let hasSubtitle;
  let hasLegend;
  let titleFontSize;
  let subtitleFontSize;
  let titleBoxPadding;
  let titleBoxHeight;
  let chartAreaTopPosition;
  let chartAreaPaddingTop;
  let chartAreaPaddingBottom;
  let legendHeight;
  let legendPaddingTop;
  let legendTop;
  let chartTop;
  let chartBottom;
  let chartContainerHeight;
  let height;
  let width;
  let min2 = 0;
  let max2;
  let valueColFormat;
  chartAreaHeight = 220;
  hasTitle = title ? true : false;
  hasSubtitle = subtitle ? true : false;
  hasLegend = legend;
  titleFontSize = 15;
  subtitleFontSize = 13;
  titleBoxPadding = 10 * hasSubtitle;
  titleBoxHeight = hasTitle * titleFontSize + hasSubtitle * subtitleFontSize + titleBoxPadding * Math.max(hasTitle, hasSubtitle);
  chartAreaTopPosition = (hasLegend ? 30 : 10) + hasTitle * 23 + (hasTitle ? hasSubtitle * 25 : hasSubtitle * 30);
  chartAreaPaddingTop = 2;
  chartAreaPaddingBottom = 8;
  legendHeight = 15;
  legendHeight = legendHeight * hasLegend;
  legendPaddingTop = 7;
  legendPaddingTop = legendPaddingTop * Math.max(hasTitle, hasSubtitle);
  legendTop = titleBoxHeight + legendPaddingTop;
  chartTop = legendTop + legendHeight + chartAreaPaddingTop;
  chartBottom = chartAreaPaddingBottom;
  chartContainerHeight = chartAreaHeight + chartTop + chartBottom;
  height = chartContainerHeight + "px";
  width = "100%";
  const writable_props = [
    "data",
    "nameCol",
    "valueCol",
    "valueFmt",
    "title",
    "subtitle",
    "legend",
    "outlineColor",
    "outlineWidth",
    "labelPosition",
    "funnelAlign",
    "funnelSort"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FunnelChart> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(4, data = $$props2.data);
    if ("nameCol" in $$props2)
      $$invalidate(5, nameCol = $$props2.nameCol);
    if ("valueCol" in $$props2)
      $$invalidate(6, valueCol = $$props2.valueCol);
    if ("valueFmt" in $$props2)
      $$invalidate(7, valueFmt = $$props2.valueFmt);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(9, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(3, legend = $$props2.legend);
    if ("outlineColor" in $$props2)
      $$invalidate(10, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(11, outlineWidth = $$props2.outlineWidth);
    if ("labelPosition" in $$props2)
      $$invalidate(12, labelPosition = $$props2.labelPosition);
    if ("funnelAlign" in $$props2)
      $$invalidate(13, funnelAlign = $$props2.funnelAlign);
    if ("funnelSort" in $$props2)
      $$invalidate(14, funnelSort = $$props2.funnelSort);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude81,
    ECharts: ECharts_default,
    formatTitle,
    formatValue,
    getFormatObjectFromString,
    getColumnSummary,
    colours,
    data,
    nameCol,
    valueCol,
    valueFmt,
    title,
    subtitle,
    legend,
    outlineColor,
    outlineWidth,
    labelPosition,
    funnelAlign,
    funnelSort,
    columnSummary,
    nameColFormat,
    chartAreaHeight,
    hasTitle,
    hasSubtitle,
    hasLegend,
    titleFontSize,
    subtitleFontSize,
    titleBoxPadding,
    titleBoxHeight,
    chartAreaTopPosition,
    chartAreaPaddingTop,
    chartAreaPaddingBottom,
    legendHeight,
    legendPaddingTop,
    legendTop,
    chartTop,
    chartBottom,
    chartContainerHeight,
    height,
    width,
    min: min2,
    max: max2,
    valueColFormat,
    seriesConfig,
    config,
    name
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(4, data = $$props2.data);
    if ("nameCol" in $$props2)
      $$invalidate(5, nameCol = $$props2.nameCol);
    if ("valueCol" in $$props2)
      $$invalidate(6, valueCol = $$props2.valueCol);
    if ("valueFmt" in $$props2)
      $$invalidate(7, valueFmt = $$props2.valueFmt);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(9, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(3, legend = $$props2.legend);
    if ("outlineColor" in $$props2)
      $$invalidate(10, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(11, outlineWidth = $$props2.outlineWidth);
    if ("labelPosition" in $$props2)
      $$invalidate(12, labelPosition = $$props2.labelPosition);
    if ("funnelAlign" in $$props2)
      $$invalidate(13, funnelAlign = $$props2.funnelAlign);
    if ("funnelSort" in $$props2)
      $$invalidate(14, funnelSort = $$props2.funnelSort);
    if ("columnSummary" in $$props2)
      $$invalidate(15, columnSummary = $$props2.columnSummary);
    if ("nameColFormat" in $$props2)
      $$invalidate(16, nameColFormat = $$props2.nameColFormat);
    if ("chartAreaHeight" in $$props2)
      chartAreaHeight = $$props2.chartAreaHeight;
    if ("hasTitle" in $$props2)
      hasTitle = $$props2.hasTitle;
    if ("hasSubtitle" in $$props2)
      hasSubtitle = $$props2.hasSubtitle;
    if ("hasLegend" in $$props2)
      hasLegend = $$props2.hasLegend;
    if ("titleFontSize" in $$props2)
      titleFontSize = $$props2.titleFontSize;
    if ("subtitleFontSize" in $$props2)
      subtitleFontSize = $$props2.subtitleFontSize;
    if ("titleBoxPadding" in $$props2)
      titleBoxPadding = $$props2.titleBoxPadding;
    if ("titleBoxHeight" in $$props2)
      titleBoxHeight = $$props2.titleBoxHeight;
    if ("chartAreaTopPosition" in $$props2)
      $$invalidate(17, chartAreaTopPosition = $$props2.chartAreaTopPosition);
    if ("chartAreaPaddingTop" in $$props2)
      chartAreaPaddingTop = $$props2.chartAreaPaddingTop;
    if ("chartAreaPaddingBottom" in $$props2)
      chartAreaPaddingBottom = $$props2.chartAreaPaddingBottom;
    if ("legendHeight" in $$props2)
      legendHeight = $$props2.legendHeight;
    if ("legendPaddingTop" in $$props2)
      legendPaddingTop = $$props2.legendPaddingTop;
    if ("legendTop" in $$props2)
      $$invalidate(18, legendTop = $$props2.legendTop);
    if ("chartTop" in $$props2)
      chartTop = $$props2.chartTop;
    if ("chartBottom" in $$props2)
      chartBottom = $$props2.chartBottom;
    if ("chartContainerHeight" in $$props2)
      chartContainerHeight = $$props2.chartContainerHeight;
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("min" in $$props2)
      $$invalidate(38, min2 = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(19, max2 = $$props2.max);
    if ("valueColFormat" in $$props2)
      $$invalidate(20, valueColFormat = $$props2.valueColFormat);
    if ("seriesConfig" in $$props2)
      $$invalidate(21, seriesConfig = $$props2.seriesConfig);
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
    if ("name" in $$props2)
      $$invalidate(22, name = $$props2.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*data*/
    16) {
      $:
        $$invalidate(15, columnSummary = getColumnSummary(data));
    }
    if ($$self.$$.dirty[0] & /*name, valueCol, columnSummary, nameCol*/
    4227168) {
      $:
        $$invalidate(22, name = name ?? formatTitle(valueCol, columnSummary[nameCol].title));
    }
    if ($$self.$$.dirty[0] & /*columnSummary, nameCol*/
    32800) {
      $:
        $$invalidate(16, nameColFormat = columnSummary[nameCol].format);
    }
    if ($$self.$$.dirty[0] & /*valueFmt, columnSummary, valueCol*/
    32960) {
      $:
        if (valueFmt) {
          $$invalidate(20, valueColFormat = getFormatObjectFromString(valueFmt, columnSummary[valueCol].format.valueType));
        } else {
          $$invalidate(20, valueColFormat = columnSummary[valueCol].format);
        }
    }
    if ($$self.$$.dirty[0] & /*data, max, valueCol*/
    524368) {
      $:
        data.forEach((item) => {
          if (max2 < item[valueCol] || !max2)
            $$invalidate(19, max2 = item[valueCol]);
        });
    }
    if ($$self.$$.dirty[0] & /*name, funnelAlign, chartAreaTopPosition, max, funnelSort, labelPosition, valueColFormat, outlineColor, outlineWidth, nameColFormat, data, nameCol, valueCol*/
    5995632) {
      $:
        $$invalidate(21, seriesConfig = {
          type: "funnel",
          name,
          left: funnelAlign === "center" ? "10%" : "",
          top: chartAreaTopPosition,
          bottom: 10,
          width: "80%",
          min: min2,
          max: max2,
          minSize: "30%",
          maxSize: "90%",
          gap: 2,
          funnelAlign,
          sort: funnelSort,
          labelLine: {
            length: 10,
            lineStyle: { width: 1, type: "solid" }
          },
          label: {
            show: true,
            position: labelPosition,
            formatter(params) {
              return formatValue(params.value, valueColFormat);
            }
          },
          labelLayout: { hideOverlap: true },
          emphasis: { focus: "series" },
          itemStyle: {
            borderColor: outlineColor,
            borderWidth: outlineWidth
          },
          tooltip: {
            formatter(params) {
              return `<span style='font-weight:600;'>${formatValue(params.name, nameColFormat)}</span></br><span>${name}:</span><span style='margin-left: 4px;'> ${params.value}</span>`;
            },
            padding: 6,
            borderRadius: 4,
            borderWidth: 1,
            borderColor: colours.grey400,
            backgroundColor: "white",
            extraCssText: "box-shadow: 0 3px 6px rgba(0,0,0,.15); box-shadow: 0 2px 4px rgba(0,0,0,.12); z-index: 1;",
            textStyle: {
              color: colours.grey900,
              fontSize: 12,
              fontWeight: 400
            },
            order: "valueDesc"
          },
          data: data.map((d) => ({ name: d[nameCol], value: d[valueCol] }))
        });
    }
    if ($$self.$$.dirty[0] & /*title, subtitle, width, legend, legendTop, seriesConfig*/
    2360073) {
      $:
        $$invalidate(2, config = {
          title: {
            text: title,
            subtext: subtitle,
            subtextStyle: { width }
          },
          tooltip: { trigger: "item" },
          legend: {
            show: legend,
            orient: "horizontal",
            type: "scroll",
            top: legendTop,
            padding: [0, 0, 0, 0]
          },
          series: [seriesConfig]
        });
    }
  };
  return [
    width,
    height,
    config,
    legend,
    data,
    nameCol,
    valueCol,
    valueFmt,
    title,
    subtitle,
    outlineColor,
    outlineWidth,
    labelPosition,
    funnelAlign,
    funnelSort,
    columnSummary,
    nameColFormat,
    chartAreaTopPosition,
    legendTop,
    max2,
    valueColFormat,
    seriesConfig,
    name
  ];
}
var FunnelChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance85,
      create_fragment85,
      safe_not_equal,
      {
        data: 4,
        nameCol: 5,
        valueCol: 6,
        valueFmt: 7,
        title: 8,
        subtitle: 9,
        legend: 3,
        outlineColor: 10,
        outlineWidth: 11,
        labelPosition: 12,
        funnelAlign: 13,
        funnelSort: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FunnelChart",
      options,
      id: create_fragment85.name
    });
  }
  get data() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nameCol() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nameCol(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueCol() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueCol(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueFmt() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueFmt(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineColor() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineColor(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineWidth() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineWidth(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPosition() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPosition(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get funnelAlign() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set funnelAlign(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get funnelSort() {
    throw new Error("<FunnelChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set funnelSort(value) {
    throw new Error("<FunnelChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FunnelChart_default = FunnelChart;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/Hist.svelte
var import_echarts_stat = __toESM(require_echarts_stat());
function create_fragment86(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude82 = true;
function instance86($$self, $$props, $$invalidate) {
  let data;
  let xFormat;
  let xDistinct;
  let xMax;
  let histData;
  let firstBinMin;
  let firstBinCount;
  let seriesConfig;
  let chartOverrides;
  let $props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Hist", slots, []);
  let props = getContext(propKey);
  validate_store(props, "props");
  component_subscribe($$self, props, (value) => $$invalidate(14, $props = value));
  let config = getContext(configKey);
  let { x = void 0 } = $$props;
  const xSet = x ? true : false;
  let { fillColor = void 0 } = $$props;
  let { fillOpacity = 1 } = $$props;
  let method;
  const writable_props = ["x", "fillColor", "fillOpacity"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Hist> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("fillColor" in $$props2)
      $$invalidate(2, fillColor = $$props2.fillColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(3, fillOpacity = $$props2.fillOpacity);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude82,
    getContext,
    propKey,
    configKey,
    props,
    config,
    ecStat: import_echarts_stat.default,
    getDistinctValues,
    formatValue,
    x,
    xSet,
    fillColor,
    fillOpacity,
    method,
    chartOverrides,
    histData,
    seriesConfig,
    xFormat,
    firstBinCount,
    firstBinMin,
    data,
    xMax,
    xDistinct,
    $props
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("config" in $$props2)
      $$invalidate(15, config = $$props2.config);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("fillColor" in $$props2)
      $$invalidate(2, fillColor = $$props2.fillColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(3, fillOpacity = $$props2.fillOpacity);
    if ("method" in $$props2)
      $$invalidate(4, method = $$props2.method);
    if ("chartOverrides" in $$props2)
      $$invalidate(5, chartOverrides = $$props2.chartOverrides);
    if ("histData" in $$props2)
      $$invalidate(6, histData = $$props2.histData);
    if ("seriesConfig" in $$props2)
      $$invalidate(7, seriesConfig = $$props2.seriesConfig);
    if ("xFormat" in $$props2)
      $$invalidate(8, xFormat = $$props2.xFormat);
    if ("firstBinCount" in $$props2)
      $$invalidate(9, firstBinCount = $$props2.firstBinCount);
    if ("firstBinMin" in $$props2)
      $$invalidate(10, firstBinMin = $$props2.firstBinMin);
    if ("data" in $$props2)
      $$invalidate(11, data = $$props2.data);
    if ("xMax" in $$props2)
      $$invalidate(12, xMax = $$props2.xMax);
    if ("xDistinct" in $$props2)
      $$invalidate(13, xDistinct = $$props2.xDistinct);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$props*/
    16384) {
      $:
        $$invalidate(11, data = $props.data);
    }
    if ($$self.$$.dirty & /*x, $props*/
    16386) {
      $:
        $$invalidate(1, x = x ?? $props.x);
    }
    if ($$self.$$.dirty & /*x, $props*/
    16386) {
      $:
        $$invalidate(1, x = xSet ? x : $props.x);
    }
    if ($$self.$$.dirty & /*$props*/
    16384) {
      $:
        $$invalidate(8, xFormat = $props.xFormat);
    }
    if ($$self.$$.dirty & /*data, x*/
    2050) {
      $:
        $$invalidate(11, data = data.map((d) => d[x]));
    }
    if ($$self.$$.dirty & /*data, x*/
    2050) {
      $:
        $$invalidate(13, xDistinct = getDistinctValues(data, x).filter(function(x2) {
          return x2 != null;
        }));
    }
    if ($$self.$$.dirty & /*xDistinct*/
    8192) {
      $:
        $$invalidate(12, xMax = Math.max(...xDistinct));
    }
    if ($$self.$$.dirty & /*xDistinct, xMax*/
    12288) {
      $:
        if (xDistinct.length <= 1) {
          $$invalidate(4, method = "squareRoot");
        } else if (xMax < 10) {
          $$invalidate(4, method = "freedmanDiaconis");
        } else if (xMax < 40) {
          $$invalidate(4, method = "sturges");
        } else {
          $$invalidate(4, method = "squareRoot");
        }
    }
    if ($$self.$$.dirty & /*data, method*/
    2064) {
      $:
        $$invalidate(6, histData = import_echarts_stat.default.histogram(data, method));
    }
    if ($$self.$$.dirty & /*histData*/
    64) {
      $:
        $$invalidate(10, firstBinMin = histData.data[0][2]);
    }
    if ($$self.$$.dirty & /*histData*/
    64) {
      $:
        $$invalidate(9, firstBinCount = histData.data[0][1]);
    }
    if ($$self.$$.dirty & /*firstBinMin, firstBinCount, histData*/
    1600) {
      $:
        if (firstBinMin < 0 && firstBinCount === 0) {
          histData.data.shift();
        }
    }
    if ($$self.$$.dirty & /*fillColor, fillOpacity, histData, xFormat*/
    332) {
      $:
        $$invalidate(7, seriesConfig = {
          type: "custom",
          label: { show: true },
          renderItem(params, api) {
            let yValue = api.value(1);
            let start = api.coord([api.value(2), yValue]);
            let size = api.size([api.value(3) - api.value(2), yValue]);
            let barColor = api.visual("color");
            return {
              type: "rect",
              shape: {
                x: start[0],
                y: start[1],
                width: size[0] - 1,
                // 1 is the gap between bars. Possibly turn this into variable for changing.
                height: size[1]
              },
              style: {
                fill: fillColor ?? barColor,
                opacity: fillOpacity
              }
            };
          },
          data: histData.data,
          encode: {
            tooltip: [1],
            // y column from shape{} above,
            itemName: 4
            // data at index 4 of api.value() - min and max of bin separated by hyphen
          },
          tooltip: {
            formatter(params) {
              return `<span style='font-weight:600;'>${formatValue(params.value[2], xFormat)} - ${formatValue(params.value[3], xFormat)}</span> <span style='margin-left: 10px;'> ${params.value[1]}</span>`;
            }
          },
          z: 3
        });
    }
    if ($$self.$$.dirty & /*seriesConfig*/
    128) {
      $:
        config.update((d) => {
          d.series.push(seriesConfig);
          return d;
        });
    }
    if ($$self.$$.dirty & /*histData*/
    64) {
      $:
        $$invalidate(5, chartOverrides = {
          yAxis: {
            // vertical axis
            boundaryGap: ["0%", "1%"],
            axisLabel: { formatter: null }
          },
          xAxis: {
            // horizontal axis
            boundaryGap: ["1%", "1%"],
            scale: false,
            min: histData.data[0][2]
            // min of bin for first bin in hist dataset
          },
          tooltip: { trigger: "item" }
        });
    }
    if ($$self.$$.dirty & /*chartOverrides*/
    32) {
      $:
        if (chartOverrides) {
          config.update((d) => {
            d.yAxis = { ...d.yAxis, ...chartOverrides.yAxis };
            d.xAxis = { ...d.xAxis, ...chartOverrides.xAxis };
            d.tooltip = { ...d.tooltip, ...chartOverrides.tooltip };
            return d;
          });
        }
    }
  };
  return [
    props,
    x,
    fillColor,
    fillOpacity,
    method,
    chartOverrides,
    histData,
    seriesConfig,
    xFormat,
    firstBinCount,
    firstBinMin,
    data,
    xMax,
    xDistinct,
    $props
  ];
}
var Hist = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment86, safe_not_equal, { x: 1, fillColor: 2, fillOpacity: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Hist",
      options,
      id: create_fragment86.name
    });
  }
  get x() {
    throw new Error("<Hist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Hist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillColor() {
    throw new Error("<Hist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillColor(value) {
    throw new Error("<Hist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<Hist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<Hist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Hist_default = Hist;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/Histogram.svelte
function create_default_slot10(ctx) {
  let hist;
  let t;
  let current;
  hist = new Hist_default({
    props: {
      fillColor: (
        /*fillColor*/
        ctx[19]
      ),
      fillOpacity: (
        /*fillOpacity*/
        ctx[20]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  const block = {
    c: function create() {
      create_component(hist.$$.fragment);
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(hist.$$.fragment, nodes);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hist, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hist_changes = {};
      if (dirty & /*fillColor*/
      524288)
        hist_changes.fillColor = /*fillColor*/
        ctx2[19];
      if (dirty & /*fillOpacity*/
      1048576)
        hist_changes.fillOpacity = /*fillOpacity*/
        ctx2[20];
      hist.$set(hist_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hist.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hist.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hist, detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: '(35:0) <Chart  {data}  {x}  {xFmt}  {legend}  {xAxisTitle}  {yAxisTitle}  {xGridlines}  {yGridlines}  {xAxisLabels}  {yAxisLabels}  {xBaseline}  {yBaseline}  {xTickMarks}  {yTickMarks}  {yMin}  {yMax}  {title}  {subtitle}  chartType=\\"Histogram\\"  hist=\\"true\\"  {chartAreaHeight} >',
    ctx
  });
  return block;
}
function create_fragment87(ctx) {
  let chart;
  let current;
  chart = new Chart_default({
    props: {
      data: (
        /*data*/
        ctx[0]
      ),
      x: (
        /*x*/
        ctx[1]
      ),
      xFmt: (
        /*xFmt*/
        ctx[3]
      ),
      legend: (
        /*legend*/
        ctx[2]
      ),
      xAxisTitle: (
        /*xAxisTitle*/
        ctx[6]
      ),
      yAxisTitle: (
        /*yAxisTitle*/
        ctx[7]
      ),
      xGridlines: (
        /*xGridlines*/
        ctx[8]
      ),
      yGridlines: (
        /*yGridlines*/
        ctx[9]
      ),
      xAxisLabels: (
        /*xAxisLabels*/
        ctx[10]
      ),
      yAxisLabels: (
        /*yAxisLabels*/
        ctx[11]
      ),
      xBaseline: (
        /*xBaseline*/
        ctx[12]
      ),
      yBaseline: (
        /*yBaseline*/
        ctx[13]
      ),
      xTickMarks: (
        /*xTickMarks*/
        ctx[14]
      ),
      yTickMarks: (
        /*yTickMarks*/
        ctx[15]
      ),
      yMin: (
        /*yMin*/
        ctx[16]
      ),
      yMax: (
        /*yMax*/
        ctx[17]
      ),
      title: (
        /*title*/
        ctx[4]
      ),
      subtitle: (
        /*subtitle*/
        ctx[5]
      ),
      chartType: "Histogram",
      hist: "true",
      chartAreaHeight: (
        /*chartAreaHeight*/
        ctx[18]
      ),
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const chart_changes = {};
      if (dirty & /*data*/
      1)
        chart_changes.data = /*data*/
        ctx2[0];
      if (dirty & /*x*/
      2)
        chart_changes.x = /*x*/
        ctx2[1];
      if (dirty & /*xFmt*/
      8)
        chart_changes.xFmt = /*xFmt*/
        ctx2[3];
      if (dirty & /*legend*/
      4)
        chart_changes.legend = /*legend*/
        ctx2[2];
      if (dirty & /*xAxisTitle*/
      64)
        chart_changes.xAxisTitle = /*xAxisTitle*/
        ctx2[6];
      if (dirty & /*yAxisTitle*/
      128)
        chart_changes.yAxisTitle = /*yAxisTitle*/
        ctx2[7];
      if (dirty & /*xGridlines*/
      256)
        chart_changes.xGridlines = /*xGridlines*/
        ctx2[8];
      if (dirty & /*yGridlines*/
      512)
        chart_changes.yGridlines = /*yGridlines*/
        ctx2[9];
      if (dirty & /*xAxisLabels*/
      1024)
        chart_changes.xAxisLabels = /*xAxisLabels*/
        ctx2[10];
      if (dirty & /*yAxisLabels*/
      2048)
        chart_changes.yAxisLabels = /*yAxisLabels*/
        ctx2[11];
      if (dirty & /*xBaseline*/
      4096)
        chart_changes.xBaseline = /*xBaseline*/
        ctx2[12];
      if (dirty & /*yBaseline*/
      8192)
        chart_changes.yBaseline = /*yBaseline*/
        ctx2[13];
      if (dirty & /*xTickMarks*/
      16384)
        chart_changes.xTickMarks = /*xTickMarks*/
        ctx2[14];
      if (dirty & /*yTickMarks*/
      32768)
        chart_changes.yTickMarks = /*yTickMarks*/
        ctx2[15];
      if (dirty & /*yMin*/
      65536)
        chart_changes.yMin = /*yMin*/
        ctx2[16];
      if (dirty & /*yMax*/
      131072)
        chart_changes.yMax = /*yMax*/
        ctx2[17];
      if (dirty & /*title*/
      16)
        chart_changes.title = /*title*/
        ctx2[4];
      if (dirty & /*subtitle*/
      32)
        chart_changes.subtitle = /*subtitle*/
        ctx2[5];
      if (dirty & /*chartAreaHeight*/
      262144)
        chart_changes.chartAreaHeight = /*chartAreaHeight*/
        ctx2[18];
      if (dirty & /*$$scope, fillColor, fillOpacity*/
      5767168) {
        chart_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chart.$set(chart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude83 = true;
function instance87($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Histogram", slots, ["default"]);
  let { data = void 0 } = $$props;
  let { x = void 0 } = $$props;
  let { legend = false } = $$props;
  let { xFmt } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { xAxisTitle = void 0 } = $$props;
  let { yAxisTitle = void 0 } = $$props;
  let { xGridlines = void 0 } = $$props;
  let { yGridlines = void 0 } = $$props;
  let { xAxisLabels = void 0 } = $$props;
  let { yAxisLabels = void 0 } = $$props;
  let { xBaseline = void 0 } = $$props;
  let { yBaseline = void 0 } = $$props;
  let { xTickMarks = void 0 } = $$props;
  let { yTickMarks = void 0 } = $$props;
  let { yMin = 0 } = $$props;
  let { yMax = void 0 } = $$props;
  let { chartAreaHeight = void 0 } = $$props;
  let { fillColor = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (xFmt === void 0 && !("xFmt" in $$props || $$self.$$.bound[$$self.$$.props["xFmt"]])) {
      console.warn("<Histogram> was created without expected prop 'xFmt'");
    }
  });
  const writable_props = [
    "data",
    "x",
    "legend",
    "xFmt",
    "title",
    "subtitle",
    "xAxisTitle",
    "yAxisTitle",
    "xGridlines",
    "yGridlines",
    "xAxisLabels",
    "yAxisLabels",
    "xBaseline",
    "yBaseline",
    "xTickMarks",
    "yTickMarks",
    "yMin",
    "yMax",
    "chartAreaHeight",
    "fillColor",
    "fillOpacity"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Histogram> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("legend" in $$props2)
      $$invalidate(2, legend = $$props2.legend);
    if ("xFmt" in $$props2)
      $$invalidate(3, xFmt = $$props2.xFmt);
    if ("title" in $$props2)
      $$invalidate(4, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(5, subtitle = $$props2.subtitle);
    if ("xAxisTitle" in $$props2)
      $$invalidate(6, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(7, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(8, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(9, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(10, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(11, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(12, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(13, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(14, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(15, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(16, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(17, yMax = $$props2.yMax);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(18, chartAreaHeight = $$props2.chartAreaHeight);
    if ("fillColor" in $$props2)
      $$invalidate(19, fillColor = $$props2.fillColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(20, fillOpacity = $$props2.fillOpacity);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude83,
    Chart: Chart_default,
    Hist: Hist_default,
    data,
    x,
    legend,
    xFmt,
    title,
    subtitle,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    chartAreaHeight,
    fillColor,
    fillOpacity
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("legend" in $$props2)
      $$invalidate(2, legend = $$props2.legend);
    if ("xFmt" in $$props2)
      $$invalidate(3, xFmt = $$props2.xFmt);
    if ("title" in $$props2)
      $$invalidate(4, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(5, subtitle = $$props2.subtitle);
    if ("xAxisTitle" in $$props2)
      $$invalidate(6, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(7, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(8, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(9, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(10, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(11, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(12, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(13, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(14, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(15, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(16, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(17, yMax = $$props2.yMax);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(18, chartAreaHeight = $$props2.chartAreaHeight);
    if ("fillColor" in $$props2)
      $$invalidate(19, fillColor = $$props2.fillColor);
    if ("fillOpacity" in $$props2)
      $$invalidate(20, fillOpacity = $$props2.fillOpacity);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    data,
    x,
    legend,
    xFmt,
    title,
    subtitle,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    chartAreaHeight,
    fillColor,
    fillOpacity,
    slots,
    $$scope
  ];
}
var Histogram = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance87, create_fragment87, safe_not_equal, {
      data: 0,
      x: 1,
      legend: 2,
      xFmt: 3,
      title: 4,
      subtitle: 5,
      xAxisTitle: 6,
      yAxisTitle: 7,
      xGridlines: 8,
      yGridlines: 9,
      xAxisLabels: 10,
      yAxisLabels: 11,
      xBaseline: 12,
      yBaseline: 13,
      xTickMarks: 14,
      yTickMarks: 15,
      yMin: 16,
      yMax: 17,
      chartAreaHeight: 18,
      fillColor: 19,
      fillOpacity: 20
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Histogram",
      options,
      id: create_fragment87.name
    });
  }
  get data() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xFmt() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xFmt(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisTitle() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisTitle(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisTitle() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisTitle(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xGridlines() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xGridlines(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yGridlines() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yGridlines(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisLabels() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisLabels(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisLabels() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisLabels(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xBaseline() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xBaseline(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yBaseline() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yBaseline(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xTickMarks() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xTickMarks(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yTickMarks() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yTickMarks(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMin() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMin(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMax() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMax(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chartAreaHeight() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chartAreaHeight(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillColor() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillColor(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<Histogram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<Histogram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Histogram_default = Histogram;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/Line.svelte
function create_fragment88(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude84 = true;
function instance88($$self, $$props, $$invalidate) {
  let data;
  let x;
  let swapXY;
  let xType;
  let xMismatch;
  let columnSummary;
  let baseConfig;
  let seriesConfig;
  let chartOverrides;
  let $props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Line", slots, []);
  let props = getContext(propKey);
  validate_store(props, "props");
  component_subscribe($$self, props, (value) => $$invalidate(23, $props = value));
  let config = getContext(configKey);
  let { y = void 0 } = $$props;
  const ySet = y ? true : false;
  let { series = void 0 } = $$props;
  const seriesSet = series ? true : false;
  let { options = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { lineColor = void 0 } = $$props;
  let { lineWidth = 2 } = $$props;
  let { lineType = "solid" } = $$props;
  let { lineOpacity = void 0 } = $$props;
  let { markers = false } = $$props;
  let { markerShape = "circle" } = $$props;
  let { markerSize = 8 } = $$props;
  let { handleMissing = "gap" } = $$props;
  let { step = false } = $$props;
  let { stepPosition = "end" } = $$props;
  beforeUpdate(() => {
    config.update((d) => {
      if (swapXY) {
        d.yAxis = { ...d.yAxis, ...chartOverrides.xAxis };
        d.xAxis = { ...d.xAxis, ...chartOverrides.yAxis };
      } else {
        d.yAxis = { ...d.yAxis, ...chartOverrides.yAxis };
        d.xAxis = { ...d.xAxis, ...chartOverrides.xAxis };
      }
      return d;
    });
  });
  const writable_props = [
    "y",
    "series",
    "options",
    "name",
    "lineColor",
    "lineWidth",
    "lineType",
    "lineOpacity",
    "markers",
    "markerShape",
    "markerSize",
    "handleMissing",
    "step",
    "stepPosition"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Line> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(2, series = $$props2.series);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
    if ("name" in $$props2)
      $$invalidate(3, name = $$props2.name);
    if ("lineColor" in $$props2)
      $$invalidate(7, lineColor = $$props2.lineColor);
    if ("lineWidth" in $$props2)
      $$invalidate(8, lineWidth = $$props2.lineWidth);
    if ("lineType" in $$props2)
      $$invalidate(9, lineType = $$props2.lineType);
    if ("lineOpacity" in $$props2)
      $$invalidate(10, lineOpacity = $$props2.lineOpacity);
    if ("markers" in $$props2)
      $$invalidate(4, markers = $$props2.markers);
    if ("markerShape" in $$props2)
      $$invalidate(11, markerShape = $$props2.markerShape);
    if ("markerSize" in $$props2)
      $$invalidate(12, markerSize = $$props2.markerSize);
    if ("handleMissing" in $$props2)
      $$invalidate(13, handleMissing = $$props2.handleMissing);
    if ("step" in $$props2)
      $$invalidate(5, step = $$props2.step);
    if ("stepPosition" in $$props2)
      $$invalidate(14, stepPosition = $$props2.stepPosition);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude84,
    getContext,
    beforeUpdate,
    propKey,
    configKey,
    props,
    config,
    getSeriesConfig,
    formatTitle,
    getCompletedData,
    y,
    ySet,
    series,
    seriesSet,
    options,
    name,
    lineColor,
    lineWidth,
    lineType,
    lineOpacity,
    markers,
    markerShape,
    markerSize,
    handleMissing,
    step,
    stepPosition,
    chartOverrides,
    swapXY,
    xType,
    seriesConfig,
    columnSummary,
    xMismatch,
    baseConfig,
    x,
    data,
    $props
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("config" in $$props2)
      $$invalidate(25, config = $$props2.config);
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(2, series = $$props2.series);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
    if ("name" in $$props2)
      $$invalidate(3, name = $$props2.name);
    if ("lineColor" in $$props2)
      $$invalidate(7, lineColor = $$props2.lineColor);
    if ("lineWidth" in $$props2)
      $$invalidate(8, lineWidth = $$props2.lineWidth);
    if ("lineType" in $$props2)
      $$invalidate(9, lineType = $$props2.lineType);
    if ("lineOpacity" in $$props2)
      $$invalidate(10, lineOpacity = $$props2.lineOpacity);
    if ("markers" in $$props2)
      $$invalidate(4, markers = $$props2.markers);
    if ("markerShape" in $$props2)
      $$invalidate(11, markerShape = $$props2.markerShape);
    if ("markerSize" in $$props2)
      $$invalidate(12, markerSize = $$props2.markerSize);
    if ("handleMissing" in $$props2)
      $$invalidate(13, handleMissing = $$props2.handleMissing);
    if ("step" in $$props2)
      $$invalidate(5, step = $$props2.step);
    if ("stepPosition" in $$props2)
      $$invalidate(14, stepPosition = $$props2.stepPosition);
    if ("chartOverrides" in $$props2)
      chartOverrides = $$props2.chartOverrides;
    if ("swapXY" in $$props2)
      $$invalidate(15, swapXY = $$props2.swapXY);
    if ("xType" in $$props2)
      $$invalidate(16, xType = $$props2.xType);
    if ("seriesConfig" in $$props2)
      $$invalidate(17, seriesConfig = $$props2.seriesConfig);
    if ("columnSummary" in $$props2)
      $$invalidate(18, columnSummary = $$props2.columnSummary);
    if ("xMismatch" in $$props2)
      $$invalidate(19, xMismatch = $$props2.xMismatch);
    if ("baseConfig" in $$props2)
      $$invalidate(20, baseConfig = $$props2.baseConfig);
    if ("x" in $$props2)
      $$invalidate(21, x = $$props2.x);
    if ("data" in $$props2)
      $$invalidate(22, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*markers*/
    16) {
      $:
        $$invalidate(4, markers = markers === "true" || markers === true);
    }
    if ($$self.$$.dirty & /*step*/
    32) {
      $:
        $$invalidate(5, step = step === "true" || step === true);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(22, data = $props.data);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(21, x = $props.x);
    }
    if ($$self.$$.dirty & /*y, $props*/
    8388610) {
      $:
        $$invalidate(1, y = ySet ? y : $props.y);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(15, swapXY = $props.swapXY);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(16, xType = $props.xType);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(19, xMismatch = $props.xMismatch);
    }
    if ($$self.$$.dirty & /*$props*/
    8388608) {
      $:
        $$invalidate(18, columnSummary = $props.columnSummary);
    }
    if ($$self.$$.dirty & /*series, $props*/
    8388612) {
      $:
        $$invalidate(2, series = seriesSet ? series : $props.series);
    }
    if ($$self.$$.dirty & /*series, y, name, columnSummary, data, x*/
    6553614) {
      $:
        if (!series && typeof y !== "object") {
          $$invalidate(3, name = name ?? formatTitle(y, columnSummary[y].title));
        } else {
          $$invalidate(22, data = getCompletedData(data, x, y, series));
        }
    }
    if ($$self.$$.dirty & /*handleMissing, data, x, y, series*/
    6299654) {
      $:
        if (handleMissing === "zero") {
          $$invalidate(22, data = getCompletedData(data, x, y, series, true));
        }
    }
    if ($$self.$$.dirty & /*handleMissing, lineWidth, lineType, lineColor, lineOpacity, markers, markerShape, markerSize, step, stepPosition*/
    32688) {
      $:
        $$invalidate(20, baseConfig = {
          type: "line",
          label: { show: false },
          connectNulls: handleMissing === "connect",
          labelLayout: { hideOverlap: true },
          emphasis: {
            focus: "series",
            endLabel: { show: false },
            lineStyle: { opacity: 1, width: 3 }
          },
          lineStyle: {
            width: parseInt(lineWidth),
            type: lineType
          },
          itemStyle: { color: lineColor, opacity: lineOpacity },
          showSymbol: markers,
          symbol: markerShape,
          symbolSize: markerSize,
          step: step ? stepPosition : false
        });
    }
    if ($$self.$$.dirty & /*data, x, y, series, swapXY, baseConfig, name, xMismatch, columnSummary*/
    8159246) {
      $:
        $$invalidate(17, seriesConfig = getSeriesConfig(data, x, y, series, swapXY, baseConfig, name, xMismatch, columnSummary));
    }
    if ($$self.$$.dirty & /*seriesConfig*/
    131072) {
      $:
        config.update((d) => {
          d.series.push(...seriesConfig);
          return d;
        });
    }
    if ($$self.$$.dirty & /*options*/
    64) {
      $:
        if (options) {
          config.update((d) => {
            return { ...d, ...options };
          });
        }
    }
    if ($$self.$$.dirty & /*xType*/
    65536) {
      $:
        chartOverrides = {
          yAxis: { boundaryGap: ["0%", "1%"] },
          xAxis: {
            boundaryGap: [xType === "time" ? "2%" : "0%", "2%"]
          }
        };
    }
  };
  return [
    props,
    y,
    series,
    name,
    markers,
    step,
    options,
    lineColor,
    lineWidth,
    lineType,
    lineOpacity,
    markerShape,
    markerSize,
    handleMissing,
    stepPosition,
    swapXY,
    xType,
    seriesConfig,
    columnSummary,
    xMismatch,
    baseConfig,
    x,
    data,
    $props
  ];
}
var Line = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance88, create_fragment88, safe_not_equal, {
      y: 1,
      series: 2,
      options: 6,
      name: 3,
      lineColor: 7,
      lineWidth: 8,
      lineType: 9,
      lineOpacity: 10,
      markers: 4,
      markerShape: 11,
      markerSize: 12,
      handleMissing: 13,
      step: 5,
      stepPosition: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Line",
      options,
      id: create_fragment88.name
    });
  }
  get y() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get series() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set series(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineColor() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineColor(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineType() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineType(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineOpacity() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineOpacity(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markers() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markers(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerShape() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerShape(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerSize() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerSize(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleMissing() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handleMissing(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepPosition() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepPosition(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Line_default = Line;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/LineChart.svelte
function create_default_slot11(ctx) {
  let line;
  let t;
  let current;
  line = new Line_default({
    props: {
      lineColor: (
        /*lineColor*/
        ctx[22]
      ),
      lineWidth: (
        /*lineWidth*/
        ctx[25]
      ),
      lineOpacity: (
        /*lineOpacity*/
        ctx[24]
      ),
      lineType: (
        /*lineType*/
        ctx[23]
      ),
      markers: (
        /*markers*/
        ctx[27]
      ),
      markerShape: (
        /*markerShape*/
        ctx[28]
      ),
      markerSize: (
        /*markerSize*/
        ctx[29]
      ),
      handleMissing: (
        /*handleMissing*/
        ctx[30]
      ),
      step: (
        /*step*/
        ctx[31]
      ),
      stepPosition: (
        /*stepPosition*/
        ctx[32]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[34].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    null
  );
  const block = {
    c: function create() {
      create_component(line.$$.fragment);
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(line.$$.fragment, nodes);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(line, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const line_changes = {};
      if (dirty[0] & /*lineColor*/
      4194304)
        line_changes.lineColor = /*lineColor*/
        ctx2[22];
      if (dirty[0] & /*lineWidth*/
      33554432)
        line_changes.lineWidth = /*lineWidth*/
        ctx2[25];
      if (dirty[0] & /*lineOpacity*/
      16777216)
        line_changes.lineOpacity = /*lineOpacity*/
        ctx2[24];
      if (dirty[0] & /*lineType*/
      8388608)
        line_changes.lineType = /*lineType*/
        ctx2[23];
      if (dirty[0] & /*markers*/
      134217728)
        line_changes.markers = /*markers*/
        ctx2[27];
      if (dirty[0] & /*markerShape*/
      268435456)
        line_changes.markerShape = /*markerShape*/
        ctx2[28];
      if (dirty[0] & /*markerSize*/
      536870912)
        line_changes.markerSize = /*markerSize*/
        ctx2[29];
      if (dirty[0] & /*handleMissing*/
      1073741824)
        line_changes.handleMissing = /*handleMissing*/
        ctx2[30];
      if (dirty[1] & /*step*/
      1)
        line_changes.step = /*step*/
        ctx2[31];
      if (dirty[1] & /*stepPosition*/
      2)
        line_changes.stepPosition = /*stepPosition*/
        ctx2[32];
      line.$set(line_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(line.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(line.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(line, detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: '(52:0) <Chart  {data}  {x}  {y}  {xFmt}  {yFmt}  {series}  {xType}  {legend}  {xAxisTitle}  {yAxisTitle}  {xGridlines}  {yGridlines}  {xAxisLabels}  {yAxisLabels}  {xBaseline}  {yBaseline}  {xTickMarks}  {yTickMarks}  {yMin}  {yMax}  {title}  {subtitle}  chartType=\\"Line Chart\\"  {sort}  {chartAreaHeight} >',
    ctx
  });
  return block;
}
function create_fragment89(ctx) {
  let chart;
  let current;
  chart = new Chart_default({
    props: {
      data: (
        /*data*/
        ctx[0]
      ),
      x: (
        /*x*/
        ctx[1]
      ),
      y: (
        /*y*/
        ctx[2]
      ),
      xFmt: (
        /*xFmt*/
        ctx[6]
      ),
      yFmt: (
        /*yFmt*/
        ctx[5]
      ),
      series: (
        /*series*/
        ctx[3]
      ),
      xType: (
        /*xType*/
        ctx[4]
      ),
      legend: (
        /*legend*/
        ctx[9]
      ),
      xAxisTitle: (
        /*xAxisTitle*/
        ctx[10]
      ),
      yAxisTitle: (
        /*yAxisTitle*/
        ctx[11]
      ),
      xGridlines: (
        /*xGridlines*/
        ctx[12]
      ),
      yGridlines: (
        /*yGridlines*/
        ctx[13]
      ),
      xAxisLabels: (
        /*xAxisLabels*/
        ctx[14]
      ),
      yAxisLabels: (
        /*yAxisLabels*/
        ctx[15]
      ),
      xBaseline: (
        /*xBaseline*/
        ctx[16]
      ),
      yBaseline: (
        /*yBaseline*/
        ctx[17]
      ),
      xTickMarks: (
        /*xTickMarks*/
        ctx[18]
      ),
      yTickMarks: (
        /*yTickMarks*/
        ctx[19]
      ),
      yMin: (
        /*yMin*/
        ctx[20]
      ),
      yMax: (
        /*yMax*/
        ctx[21]
      ),
      title: (
        /*title*/
        ctx[7]
      ),
      subtitle: (
        /*subtitle*/
        ctx[8]
      ),
      chartType: "Line Chart",
      sort: (
        /*sort*/
        ctx[33]
      ),
      chartAreaHeight: (
        /*chartAreaHeight*/
        ctx[26]
      ),
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chart, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chart_changes = {};
      if (dirty[0] & /*data*/
      1)
        chart_changes.data = /*data*/
        ctx2[0];
      if (dirty[0] & /*x*/
      2)
        chart_changes.x = /*x*/
        ctx2[1];
      if (dirty[0] & /*y*/
      4)
        chart_changes.y = /*y*/
        ctx2[2];
      if (dirty[0] & /*xFmt*/
      64)
        chart_changes.xFmt = /*xFmt*/
        ctx2[6];
      if (dirty[0] & /*yFmt*/
      32)
        chart_changes.yFmt = /*yFmt*/
        ctx2[5];
      if (dirty[0] & /*series*/
      8)
        chart_changes.series = /*series*/
        ctx2[3];
      if (dirty[0] & /*xType*/
      16)
        chart_changes.xType = /*xType*/
        ctx2[4];
      if (dirty[0] & /*legend*/
      512)
        chart_changes.legend = /*legend*/
        ctx2[9];
      if (dirty[0] & /*xAxisTitle*/
      1024)
        chart_changes.xAxisTitle = /*xAxisTitle*/
        ctx2[10];
      if (dirty[0] & /*yAxisTitle*/
      2048)
        chart_changes.yAxisTitle = /*yAxisTitle*/
        ctx2[11];
      if (dirty[0] & /*xGridlines*/
      4096)
        chart_changes.xGridlines = /*xGridlines*/
        ctx2[12];
      if (dirty[0] & /*yGridlines*/
      8192)
        chart_changes.yGridlines = /*yGridlines*/
        ctx2[13];
      if (dirty[0] & /*xAxisLabels*/
      16384)
        chart_changes.xAxisLabels = /*xAxisLabels*/
        ctx2[14];
      if (dirty[0] & /*yAxisLabels*/
      32768)
        chart_changes.yAxisLabels = /*yAxisLabels*/
        ctx2[15];
      if (dirty[0] & /*xBaseline*/
      65536)
        chart_changes.xBaseline = /*xBaseline*/
        ctx2[16];
      if (dirty[0] & /*yBaseline*/
      131072)
        chart_changes.yBaseline = /*yBaseline*/
        ctx2[17];
      if (dirty[0] & /*xTickMarks*/
      262144)
        chart_changes.xTickMarks = /*xTickMarks*/
        ctx2[18];
      if (dirty[0] & /*yTickMarks*/
      524288)
        chart_changes.yTickMarks = /*yTickMarks*/
        ctx2[19];
      if (dirty[0] & /*yMin*/
      1048576)
        chart_changes.yMin = /*yMin*/
        ctx2[20];
      if (dirty[0] & /*yMax*/
      2097152)
        chart_changes.yMax = /*yMax*/
        ctx2[21];
      if (dirty[0] & /*title*/
      128)
        chart_changes.title = /*title*/
        ctx2[7];
      if (dirty[0] & /*subtitle*/
      256)
        chart_changes.subtitle = /*subtitle*/
        ctx2[8];
      if (dirty[1] & /*sort*/
      4)
        chart_changes.sort = /*sort*/
        ctx2[33];
      if (dirty[0] & /*chartAreaHeight*/
      67108864)
        chart_changes.chartAreaHeight = /*chartAreaHeight*/
        ctx2[26];
      if (dirty[0] & /*lineColor, lineWidth, lineOpacity, lineType, markers, markerShape, markerSize, handleMissing*/
      2076180480 | dirty[1] & /*$$scope, step, stepPosition*/
      19) {
        chart_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chart.$set(chart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude85 = true;
function instance89($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineChart", slots, ["default"]);
  let { data = void 0 } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { series = void 0 } = $$props;
  let { xType = void 0 } = $$props;
  let { yFmt = void 0 } = $$props;
  let { xFmt = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { legend = void 0 } = $$props;
  let { xAxisTitle = void 0 } = $$props;
  let { yAxisTitle = void 0 } = $$props;
  let { xGridlines = void 0 } = $$props;
  let { yGridlines = void 0 } = $$props;
  let { xAxisLabels = void 0 } = $$props;
  let { yAxisLabels = void 0 } = $$props;
  let { xBaseline = void 0 } = $$props;
  let { yBaseline = void 0 } = $$props;
  let { xTickMarks = void 0 } = $$props;
  let { yTickMarks = void 0 } = $$props;
  let { yMin = void 0 } = $$props;
  let { yMax = void 0 } = $$props;
  let { lineColor = void 0 } = $$props;
  let { lineType = void 0 } = $$props;
  let { lineOpacity = void 0 } = $$props;
  let { lineWidth = void 0 } = $$props;
  let { chartAreaHeight = void 0 } = $$props;
  let { markers = void 0 } = $$props;
  let { markerShape = void 0 } = $$props;
  let { markerSize = void 0 } = $$props;
  let { handleMissing = void 0 } = $$props;
  let { step = void 0 } = $$props;
  let { stepPosition = void 0 } = $$props;
  let { sort = void 0 } = $$props;
  const writable_props = [
    "data",
    "x",
    "y",
    "series",
    "xType",
    "yFmt",
    "xFmt",
    "title",
    "subtitle",
    "legend",
    "xAxisTitle",
    "yAxisTitle",
    "xGridlines",
    "yGridlines",
    "xAxisLabels",
    "yAxisLabels",
    "xBaseline",
    "yBaseline",
    "xTickMarks",
    "yTickMarks",
    "yMin",
    "yMax",
    "lineColor",
    "lineType",
    "lineOpacity",
    "lineWidth",
    "chartAreaHeight",
    "markers",
    "markerShape",
    "markerSize",
    "handleMissing",
    "step",
    "stepPosition",
    "sort"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LineChart> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(3, series = $$props2.series);
    if ("xType" in $$props2)
      $$invalidate(4, xType = $$props2.xType);
    if ("yFmt" in $$props2)
      $$invalidate(5, yFmt = $$props2.yFmt);
    if ("xFmt" in $$props2)
      $$invalidate(6, xFmt = $$props2.xFmt);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(8, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(9, legend = $$props2.legend);
    if ("xAxisTitle" in $$props2)
      $$invalidate(10, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(11, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(12, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(13, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(14, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(15, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(16, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(17, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(18, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(19, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(20, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(21, yMax = $$props2.yMax);
    if ("lineColor" in $$props2)
      $$invalidate(22, lineColor = $$props2.lineColor);
    if ("lineType" in $$props2)
      $$invalidate(23, lineType = $$props2.lineType);
    if ("lineOpacity" in $$props2)
      $$invalidate(24, lineOpacity = $$props2.lineOpacity);
    if ("lineWidth" in $$props2)
      $$invalidate(25, lineWidth = $$props2.lineWidth);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(26, chartAreaHeight = $$props2.chartAreaHeight);
    if ("markers" in $$props2)
      $$invalidate(27, markers = $$props2.markers);
    if ("markerShape" in $$props2)
      $$invalidate(28, markerShape = $$props2.markerShape);
    if ("markerSize" in $$props2)
      $$invalidate(29, markerSize = $$props2.markerSize);
    if ("handleMissing" in $$props2)
      $$invalidate(30, handleMissing = $$props2.handleMissing);
    if ("step" in $$props2)
      $$invalidate(31, step = $$props2.step);
    if ("stepPosition" in $$props2)
      $$invalidate(32, stepPosition = $$props2.stepPosition);
    if ("sort" in $$props2)
      $$invalidate(33, sort = $$props2.sort);
    if ("$$scope" in $$props2)
      $$invalidate(35, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude85,
    Chart: Chart_default,
    Line: Line_default,
    data,
    x,
    y,
    series,
    xType,
    yFmt,
    xFmt,
    title,
    subtitle,
    legend,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    lineColor,
    lineType,
    lineOpacity,
    lineWidth,
    chartAreaHeight,
    markers,
    markerShape,
    markerSize,
    handleMissing,
    step,
    stepPosition,
    sort
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(3, series = $$props2.series);
    if ("xType" in $$props2)
      $$invalidate(4, xType = $$props2.xType);
    if ("yFmt" in $$props2)
      $$invalidate(5, yFmt = $$props2.yFmt);
    if ("xFmt" in $$props2)
      $$invalidate(6, xFmt = $$props2.xFmt);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(8, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(9, legend = $$props2.legend);
    if ("xAxisTitle" in $$props2)
      $$invalidate(10, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(11, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(12, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(13, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(14, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(15, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(16, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(17, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(18, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(19, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(20, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(21, yMax = $$props2.yMax);
    if ("lineColor" in $$props2)
      $$invalidate(22, lineColor = $$props2.lineColor);
    if ("lineType" in $$props2)
      $$invalidate(23, lineType = $$props2.lineType);
    if ("lineOpacity" in $$props2)
      $$invalidate(24, lineOpacity = $$props2.lineOpacity);
    if ("lineWidth" in $$props2)
      $$invalidate(25, lineWidth = $$props2.lineWidth);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(26, chartAreaHeight = $$props2.chartAreaHeight);
    if ("markers" in $$props2)
      $$invalidate(27, markers = $$props2.markers);
    if ("markerShape" in $$props2)
      $$invalidate(28, markerShape = $$props2.markerShape);
    if ("markerSize" in $$props2)
      $$invalidate(29, markerSize = $$props2.markerSize);
    if ("handleMissing" in $$props2)
      $$invalidate(30, handleMissing = $$props2.handleMissing);
    if ("step" in $$props2)
      $$invalidate(31, step = $$props2.step);
    if ("stepPosition" in $$props2)
      $$invalidate(32, stepPosition = $$props2.stepPosition);
    if ("sort" in $$props2)
      $$invalidate(33, sort = $$props2.sort);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    data,
    x,
    y,
    series,
    xType,
    yFmt,
    xFmt,
    title,
    subtitle,
    legend,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    lineColor,
    lineType,
    lineOpacity,
    lineWidth,
    chartAreaHeight,
    markers,
    markerShape,
    markerSize,
    handleMissing,
    step,
    stepPosition,
    sort,
    slots,
    $$scope
  ];
}
var LineChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance89,
      create_fragment89,
      safe_not_equal,
      {
        data: 0,
        x: 1,
        y: 2,
        series: 3,
        xType: 4,
        yFmt: 5,
        xFmt: 6,
        title: 7,
        subtitle: 8,
        legend: 9,
        xAxisTitle: 10,
        yAxisTitle: 11,
        xGridlines: 12,
        yGridlines: 13,
        xAxisLabels: 14,
        yAxisLabels: 15,
        xBaseline: 16,
        yBaseline: 17,
        xTickMarks: 18,
        yTickMarks: 19,
        yMin: 20,
        yMax: 21,
        lineColor: 22,
        lineType: 23,
        lineOpacity: 24,
        lineWidth: 25,
        chartAreaHeight: 26,
        markers: 27,
        markerShape: 28,
        markerSize: 29,
        handleMissing: 30,
        step: 31,
        stepPosition: 32,
        sort: 33
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineChart",
      options,
      id: create_fragment89.name
    });
  }
  get data() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get series() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set series(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xType() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xType(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yFmt() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yFmt(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xFmt() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xFmt(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisTitle() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisTitle(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisTitle() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisTitle(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xGridlines() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xGridlines(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yGridlines() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yGridlines(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisLabels() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisLabels(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisLabels() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisLabels(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xBaseline() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xBaseline(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yBaseline() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yBaseline(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xTickMarks() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xTickMarks(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yTickMarks() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yTickMarks(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMin() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMin(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMax() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMax(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineColor() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineColor(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineType() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineType(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineOpacity() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineOpacity(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chartAreaHeight() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chartAreaHeight(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markers() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markers(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerShape() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerShape(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerSize() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerSize(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleMissing() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handleMissing(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepPosition() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepPosition(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sort() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sort(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineChart_default = LineChart;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/SankeyChart.svelte
function create_fragment90(ctx) {
  let echarts;
  let current;
  echarts = new ECharts_default({
    props: {
      config: (
        /*config*/
        ctx[2]
      ),
      width: (
        /*width*/
        ctx[0]
      ),
      height: (
        /*height*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(echarts.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(echarts.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(echarts, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const echarts_changes = {};
      if (dirty[0] & /*config*/
      4)
        echarts_changes.config = /*config*/
        ctx2[2];
      if (dirty[0] & /*width*/
      1)
        echarts_changes.width = /*width*/
        ctx2[0];
      if (dirty[0] & /*height*/
      2)
        echarts_changes.height = /*height*/
        ctx2[1];
      echarts.$set(echarts_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(echarts.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(echarts.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(echarts, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude86 = true;
function instance90($$self, $$props, $$invalidate) {
  let format_object;
  let config;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SankeyChart", slots, []);
  let { data = void 0 } = $$props;
  let { sourceCol = "source" } = $$props;
  let { targetCol = "target" } = $$props;
  let { valueCol = "value" } = $$props;
  let { valueFmt = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { legend = false } = $$props;
  let { outlineColor = void 0 } = $$props;
  let { outlineWidth = void 0 } = $$props;
  let { nodeAlign = "justify" } = $$props;
  let { nodeGap = 8 } = $$props;
  let { nodeWidth = 20 } = $$props;
  let { orient = "horizontal" } = $$props;
  let names = [];
  let links;
  data.map((link) => names.push(link[sourceCol], link[targetCol]));
  let nameData = [...new Set(names)].map((node) => ({ name: node }));
  let chartAreaHeight;
  let hasTitle;
  let hasSubtitle;
  let hasLegend;
  let titleFontSize;
  let subtitleFontSize;
  let titleBoxPadding;
  let titleBoxHeight;
  let chartAreaPaddingTop;
  let chartAreaPaddingBottom;
  let legendHeight;
  let legendPaddingTop;
  let legendTop;
  let chartTop;
  let chartBottom;
  let chartContainerHeight;
  let height = "400px";
  let width = "100%";
  chartAreaHeight = 300;
  hasTitle = title ? true : false;
  hasSubtitle = subtitle ? true : false;
  hasLegend = legend;
  titleFontSize = 15;
  subtitleFontSize = 13;
  titleBoxPadding = 10 * hasSubtitle;
  titleBoxHeight = hasTitle * titleFontSize + hasSubtitle * subtitleFontSize + titleBoxPadding * Math.max(hasTitle, hasSubtitle);
  chartAreaPaddingTop = 10;
  chartAreaPaddingBottom = 8;
  legendHeight = 15;
  legendHeight = legendHeight * hasLegend;
  legendPaddingTop = 7;
  legendPaddingTop = legendPaddingTop * Math.max(hasTitle, hasSubtitle);
  legendTop = titleBoxHeight + legendPaddingTop;
  chartTop = legendTop + legendHeight + chartAreaPaddingTop;
  chartBottom = chartAreaPaddingBottom;
  chartContainerHeight = chartAreaHeight + chartTop + chartBottom;
  height = chartContainerHeight + "px";
  width = "100%";
  let seriesConfig;
  const writable_props = [
    "data",
    "sourceCol",
    "targetCol",
    "valueCol",
    "valueFmt",
    "title",
    "subtitle",
    "legend",
    "outlineColor",
    "outlineWidth",
    "nodeAlign",
    "nodeGap",
    "nodeWidth",
    "orient"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SankeyChart> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("sourceCol" in $$props2)
      $$invalidate(4, sourceCol = $$props2.sourceCol);
    if ("targetCol" in $$props2)
      $$invalidate(5, targetCol = $$props2.targetCol);
    if ("valueCol" in $$props2)
      $$invalidate(6, valueCol = $$props2.valueCol);
    if ("valueFmt" in $$props2)
      $$invalidate(7, valueFmt = $$props2.valueFmt);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(9, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(10, legend = $$props2.legend);
    if ("outlineColor" in $$props2)
      $$invalidate(11, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(12, outlineWidth = $$props2.outlineWidth);
    if ("nodeAlign" in $$props2)
      $$invalidate(13, nodeAlign = $$props2.nodeAlign);
    if ("nodeGap" in $$props2)
      $$invalidate(14, nodeGap = $$props2.nodeGap);
    if ("nodeWidth" in $$props2)
      $$invalidate(15, nodeWidth = $$props2.nodeWidth);
    if ("orient" in $$props2)
      $$invalidate(16, orient = $$props2.orient);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude86,
    ECharts: ECharts_default,
    colours,
    formatValue,
    getFormatObjectFromString,
    data,
    sourceCol,
    targetCol,
    valueCol,
    valueFmt,
    title,
    subtitle,
    legend,
    outlineColor,
    outlineWidth,
    nodeAlign,
    nodeGap,
    nodeWidth,
    orient,
    names,
    links,
    nameData,
    chartAreaHeight,
    hasTitle,
    hasSubtitle,
    hasLegend,
    titleFontSize,
    subtitleFontSize,
    titleBoxPadding,
    titleBoxHeight,
    chartAreaPaddingTop,
    chartAreaPaddingBottom,
    legendHeight,
    legendPaddingTop,
    legendTop,
    chartTop,
    chartBottom,
    chartContainerHeight,
    height,
    width,
    seriesConfig,
    config,
    format_object
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("sourceCol" in $$props2)
      $$invalidate(4, sourceCol = $$props2.sourceCol);
    if ("targetCol" in $$props2)
      $$invalidate(5, targetCol = $$props2.targetCol);
    if ("valueCol" in $$props2)
      $$invalidate(6, valueCol = $$props2.valueCol);
    if ("valueFmt" in $$props2)
      $$invalidate(7, valueFmt = $$props2.valueFmt);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(9, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(10, legend = $$props2.legend);
    if ("outlineColor" in $$props2)
      $$invalidate(11, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(12, outlineWidth = $$props2.outlineWidth);
    if ("nodeAlign" in $$props2)
      $$invalidate(13, nodeAlign = $$props2.nodeAlign);
    if ("nodeGap" in $$props2)
      $$invalidate(14, nodeGap = $$props2.nodeGap);
    if ("nodeWidth" in $$props2)
      $$invalidate(15, nodeWidth = $$props2.nodeWidth);
    if ("orient" in $$props2)
      $$invalidate(16, orient = $$props2.orient);
    if ("names" in $$props2)
      names = $$props2.names;
    if ("links" in $$props2)
      $$invalidate(17, links = $$props2.links);
    if ("nameData" in $$props2)
      $$invalidate(37, nameData = $$props2.nameData);
    if ("chartAreaHeight" in $$props2)
      chartAreaHeight = $$props2.chartAreaHeight;
    if ("hasTitle" in $$props2)
      hasTitle = $$props2.hasTitle;
    if ("hasSubtitle" in $$props2)
      hasSubtitle = $$props2.hasSubtitle;
    if ("hasLegend" in $$props2)
      hasLegend = $$props2.hasLegend;
    if ("titleFontSize" in $$props2)
      titleFontSize = $$props2.titleFontSize;
    if ("subtitleFontSize" in $$props2)
      subtitleFontSize = $$props2.subtitleFontSize;
    if ("titleBoxPadding" in $$props2)
      titleBoxPadding = $$props2.titleBoxPadding;
    if ("titleBoxHeight" in $$props2)
      titleBoxHeight = $$props2.titleBoxHeight;
    if ("chartAreaPaddingTop" in $$props2)
      chartAreaPaddingTop = $$props2.chartAreaPaddingTop;
    if ("chartAreaPaddingBottom" in $$props2)
      chartAreaPaddingBottom = $$props2.chartAreaPaddingBottom;
    if ("legendHeight" in $$props2)
      legendHeight = $$props2.legendHeight;
    if ("legendPaddingTop" in $$props2)
      legendPaddingTop = $$props2.legendPaddingTop;
    if ("legendTop" in $$props2)
      $$invalidate(18, legendTop = $$props2.legendTop);
    if ("chartTop" in $$props2)
      chartTop = $$props2.chartTop;
    if ("chartBottom" in $$props2)
      chartBottom = $$props2.chartBottom;
    if ("chartContainerHeight" in $$props2)
      chartContainerHeight = $$props2.chartContainerHeight;
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("seriesConfig" in $$props2)
      $$invalidate(19, seriesConfig = $$props2.seriesConfig);
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
    if ("format_object" in $$props2)
      $$invalidate(20, format_object = $$props2.format_object);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*valueFmt*/
    128) {
      $:
        $$invalidate(20, format_object = valueFmt ? getFormatObjectFromString(valueFmt) : void 0);
    }
    if ($$self.$$.dirty[0] & /*data, sourceCol, targetCol, valueCol*/
    120) {
      $:
        $$invalidate(17, links = data.map((link) => {
          return {
            source: link[sourceCol],
            target: link[targetCol],
            value: link[valueCol]
          };
        }));
    }
    if ($$self.$$.dirty[0] & /*orient, nodeGap, nodeWidth, nodeAlign, outlineColor, outlineWidth, sourceCol, format_object, links*/
    1308688) {
      $:
        $$invalidate(19, seriesConfig = {
          type: "sankey",
          layout: "none",
          left: "10%",
          top: orient === "vertical" ? 80 : 60,
          bottom: orient === "vertical" ? 0 : 10,
          width: "70%",
          nodeGap,
          nodeWidth,
          nodeAlign,
          orient,
          emphasis: { focus: "adjacency" },
          label: {
            show: true,
            position: orient === "vertical" ? "top" : "right",
            fontSize: 12
          },
          itemStyle: {
            borderColor: outlineColor,
            borderWidth: outlineWidth
          },
          tooltip: {
            formatter(params) {
              return params.data.name ? `${formatValue(params.data.name)}` : `${formatValue(params.data[sourceCol])} to ${formatValue(params.data.target)}: ${formatValue(params.data.value, format_object)}`;
            },
            padding: 6,
            borderRadius: 4,
            borderWidth: 1,
            borderColor: colours.grey400,
            backgroundColor: "white",
            extraCssText: "box-shadow: 0 3px 6px rgba(0,0,0,.15); box-shadow: 0 2px 4px rgba(0,0,0,.12); z-index: 1;",
            textStyle: {
              color: colours.grey900,
              fontSize: 12,
              fontWeight: 400
            },
            order: "valueDesc"
          },
          data: nameData,
          links,
          animationDuration: 500
        });
    }
    if ($$self.$$.dirty[0] & /*title, subtitle, width, legend, legendTop, seriesConfig*/
    788225) {
      $:
        $$invalidate(2, config = {
          title: {
            text: title,
            subtext: subtitle,
            subtextStyle: { width }
          },
          tooltip: { trigger: "item" },
          legend: {
            show: legend,
            type: "scroll",
            top: legendTop,
            padding: [0, 0, 0, 0]
          },
          series: [seriesConfig]
        });
    }
  };
  return [
    width,
    height,
    config,
    data,
    sourceCol,
    targetCol,
    valueCol,
    valueFmt,
    title,
    subtitle,
    legend,
    outlineColor,
    outlineWidth,
    nodeAlign,
    nodeGap,
    nodeWidth,
    orient,
    links,
    legendTop,
    seriesConfig,
    format_object
  ];
}
var SankeyChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance90,
      create_fragment90,
      safe_not_equal,
      {
        data: 3,
        sourceCol: 4,
        targetCol: 5,
        valueCol: 6,
        valueFmt: 7,
        title: 8,
        subtitle: 9,
        legend: 10,
        outlineColor: 11,
        outlineWidth: 12,
        nodeAlign: 13,
        nodeGap: 14,
        nodeWidth: 15,
        orient: 16
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SankeyChart",
      options,
      id: create_fragment90.name
    });
  }
  get data() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceCol() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceCol(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetCol() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetCol(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueCol() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueCol(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueFmt() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueFmt(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineColor() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineColor(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineWidth() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineWidth(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeAlign() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeAlign(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeGap() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeGap(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeWidth() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeWidth(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orient() {
    throw new Error("<SankeyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orient(value) {
    throw new Error("<SankeyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SankeyChart_default = SankeyChart;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/Scatter.svelte
function create_fragment91(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment91.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude87 = true;
function instance91($$self, $$props, $$invalidate) {
  let data;
  let x;
  let swapXY;
  let xType;
  let xFormat;
  let yFormat;
  let xMismatch;
  let columnSummary;
  let size;
  let seriesConfig;
  let chartOverrides;
  let $props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Scatter", slots, []);
  let props = getContext(propKey);
  validate_store(props, "props");
  component_subscribe($$self, props, (value) => $$invalidate(22, $props = value));
  let config = getContext(configKey);
  let { y = void 0 } = $$props;
  const ySet = y ? true : false;
  let { series = void 0 } = $$props;
  const seriesSet = series ? true : false;
  let { options = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { shape = "circle" } = $$props;
  let { fillColor = void 0 } = $$props;
  let { opacity = 0.7 } = $$props;
  let { outlineColor = void 0 } = $$props;
  let { outlineWidth = void 0 } = $$props;
  let { pointSize = 10 } = $$props;
  let { useTooltip = false } = $$props;
  let { tooltipTitle } = $$props;
  let multiSeries;
  let tooltipOutput;
  let baseConfig = {
    type: "scatter",
    label: { show: false },
    labelLayout: { hideOverlap: true },
    emphasis: { focus: "series" },
    symbol: shape,
    symbolSize: pointSize,
    itemStyle: {
      color: fillColor,
      opacity,
      borderColor: outlineColor,
      borderWidth: outlineWidth
    }
  };
  let tooltipOpts;
  let tooltipOverride;
  if (useTooltip) {
    tooltipOpts = {
      tooltip: {
        formatter(params) {
          if (multiSeries) {
            if (tooltipTitle) {
              tooltipOutput = `<span id="tooltip" style='font-weight:600'>${formatValue(params.value[2], "0")}</span><br/>
                            ${formatTitle(series)}: <span style='float:right; margin-left: 15px;'>${formatValue(params.seriesName)}</span><br/>
                            ${formatTitle(x, xFormat)}: <span style='float:right; margin-left: 15px;'>${formatValue(params.value[0], xFormat)}</span><br/>
                            ${formatTitle(typeof y === "object" ? params.seriesName : y, yFormat)}: <span style='float:right; margin-left: 15px;'>${formatValue(params.value[1], yFormat)}</span>`;
            } else {
              tooltipOutput = `<span id="tooltip" style='font-weight:600'>${formatValue(params.seriesName)}</span><br/>
                            ${formatTitle(x, xFormat)}: <span style='float:right; margin-left: 15px;'>${formatValue(params.value[0], xFormat)}</span><br/>
                            ${formatTitle(typeof y === "object" ? params.seriesName : y, yFormat)}: <span style='float:right; margin-left: 15px;'>${formatValue(params.value[1], yFormat)}</span>`;
            }
          } else {
            if (tooltipTitle) {
              tooltipOutput = `<span id="tooltip" style='font-weight:600;'>${formatValue(params.value[2], "0")}</span><br/>
                            <span style='font-weight: 400;'>${formatTitle(x, xFormat)}:</span> <span style='float:right; margin-left: 15px;'>${formatValue(params.value[0], xFormat)}</span><br/>
                            <span style='font-weight: 400;'>${formatTitle(y, yFormat)}:</span> <span style='float:right; margin-left: 15px;'>${formatValue(params.value[1], yFormat)}</span>`;
            } else {
              tooltipOutput = `<span id="tooltip" style='font-weight: 600;'>${formatTitle(x, xFormat)}:</span> <span style='float:right; margin-left: 15px;'>${formatValue(params.value[0], xFormat)}</span><br/>
                            <span style='font-weight: 600;'>${formatTitle(y, yFormat)}:</span> <span style='float:right; margin-left: 15px;'>${formatValue(params.value[1], yFormat)}</span>`;
            }
          }
          return tooltipOutput;
        }
      }
    };
    baseConfig = { ...baseConfig, ...tooltipOpts };
    tooltipOverride = { tooltip: { trigger: "item" } };
  }
  beforeUpdate(() => {
    config.update((d) => {
      if (swapXY) {
        d.yAxis = { ...d.yAxis, ...chartOverrides.xAxis };
        d.xAxis = { ...d.xAxis, ...chartOverrides.yAxis };
      } else {
        d.yAxis = { ...d.yAxis, ...chartOverrides.yAxis };
        d.xAxis = { ...d.xAxis, ...chartOverrides.xAxis };
      }
      if (useTooltip) {
        d.tooltip = { ...d.tooltip, ...tooltipOverride.tooltip };
      }
      return d;
    });
  });
  $$self.$$.on_mount.push(function() {
    if (tooltipTitle === void 0 && !("tooltipTitle" in $$props || $$self.$$.bound[$$self.$$.props["tooltipTitle"]])) {
      console.warn("<Scatter> was created without expected prop 'tooltipTitle'");
    }
  });
  const writable_props = [
    "y",
    "series",
    "options",
    "name",
    "shape",
    "fillColor",
    "opacity",
    "outlineColor",
    "outlineWidth",
    "pointSize",
    "useTooltip",
    "tooltipTitle"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Scatter> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(2, series = $$props2.series);
    if ("options" in $$props2)
      $$invalidate(5, options = $$props2.options);
    if ("name" in $$props2)
      $$invalidate(3, name = $$props2.name);
    if ("shape" in $$props2)
      $$invalidate(6, shape = $$props2.shape);
    if ("fillColor" in $$props2)
      $$invalidate(7, fillColor = $$props2.fillColor);
    if ("opacity" in $$props2)
      $$invalidate(8, opacity = $$props2.opacity);
    if ("outlineColor" in $$props2)
      $$invalidate(9, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(10, outlineWidth = $$props2.outlineWidth);
    if ("pointSize" in $$props2)
      $$invalidate(11, pointSize = $$props2.pointSize);
    if ("useTooltip" in $$props2)
      $$invalidate(12, useTooltip = $$props2.useTooltip);
    if ("tooltipTitle" in $$props2)
      $$invalidate(4, tooltipTitle = $$props2.tooltipTitle);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude87,
    getContext,
    beforeUpdate,
    propKey,
    configKey,
    props,
    config,
    getSeriesConfig,
    formatTitle,
    formatValue,
    getCompletedData,
    y,
    ySet,
    series,
    seriesSet,
    options,
    name,
    shape,
    fillColor,
    opacity,
    outlineColor,
    outlineWidth,
    pointSize,
    useTooltip,
    tooltipTitle,
    multiSeries,
    tooltipOutput,
    baseConfig,
    tooltipOpts,
    tooltipOverride,
    chartOverrides,
    swapXY,
    xType,
    seriesConfig,
    columnSummary,
    xMismatch,
    x,
    data,
    yFormat,
    xFormat,
    size,
    $props
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("config" in $$props2)
      $$invalidate(30, config = $$props2.config);
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(2, series = $$props2.series);
    if ("options" in $$props2)
      $$invalidate(5, options = $$props2.options);
    if ("name" in $$props2)
      $$invalidate(3, name = $$props2.name);
    if ("shape" in $$props2)
      $$invalidate(6, shape = $$props2.shape);
    if ("fillColor" in $$props2)
      $$invalidate(7, fillColor = $$props2.fillColor);
    if ("opacity" in $$props2)
      $$invalidate(8, opacity = $$props2.opacity);
    if ("outlineColor" in $$props2)
      $$invalidate(9, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(10, outlineWidth = $$props2.outlineWidth);
    if ("pointSize" in $$props2)
      $$invalidate(11, pointSize = $$props2.pointSize);
    if ("useTooltip" in $$props2)
      $$invalidate(12, useTooltip = $$props2.useTooltip);
    if ("tooltipTitle" in $$props2)
      $$invalidate(4, tooltipTitle = $$props2.tooltipTitle);
    if ("multiSeries" in $$props2)
      multiSeries = $$props2.multiSeries;
    if ("tooltipOutput" in $$props2)
      tooltipOutput = $$props2.tooltipOutput;
    if ("baseConfig" in $$props2)
      $$invalidate(13, baseConfig = $$props2.baseConfig);
    if ("tooltipOpts" in $$props2)
      tooltipOpts = $$props2.tooltipOpts;
    if ("tooltipOverride" in $$props2)
      tooltipOverride = $$props2.tooltipOverride;
    if ("chartOverrides" in $$props2)
      chartOverrides = $$props2.chartOverrides;
    if ("swapXY" in $$props2)
      $$invalidate(14, swapXY = $$props2.swapXY);
    if ("xType" in $$props2)
      $$invalidate(15, xType = $$props2.xType);
    if ("seriesConfig" in $$props2)
      $$invalidate(16, seriesConfig = $$props2.seriesConfig);
    if ("columnSummary" in $$props2)
      $$invalidate(17, columnSummary = $$props2.columnSummary);
    if ("xMismatch" in $$props2)
      $$invalidate(18, xMismatch = $$props2.xMismatch);
    if ("x" in $$props2)
      $$invalidate(19, x = $$props2.x);
    if ("data" in $$props2)
      $$invalidate(20, data = $$props2.data);
    if ("yFormat" in $$props2)
      yFormat = $$props2.yFormat;
    if ("xFormat" in $$props2)
      xFormat = $$props2.xFormat;
    if ("size" in $$props2)
      $$invalidate(21, size = $$props2.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$props*/
    4194304) {
      $:
        $$invalidate(20, data = $props.data);
    }
    if ($$self.$$.dirty[0] & /*$props*/
    4194304) {
      $:
        $$invalidate(19, x = $props.x);
    }
    if ($$self.$$.dirty[0] & /*$props*/
    4194304) {
      $:
        $$invalidate(14, swapXY = $props.swapXY);
    }
    if ($$self.$$.dirty[0] & /*$props*/
    4194304) {
      $:
        $$invalidate(15, xType = $props.xType);
    }
    if ($$self.$$.dirty[0] & /*$props*/
    4194304) {
      $:
        xFormat = $props.xFormat;
    }
    if ($$self.$$.dirty[0] & /*$props*/
    4194304) {
      $:
        yFormat = $props.yFormat;
    }
    if ($$self.$$.dirty[0] & /*$props*/
    4194304) {
      $:
        $$invalidate(18, xMismatch = $props.xMismatch);
    }
    if ($$self.$$.dirty[0] & /*$props*/
    4194304) {
      $:
        $$invalidate(17, columnSummary = $props.columnSummary);
    }
    if ($$self.$$.dirty[0] & /*y, $props*/
    4194306) {
      $:
        $$invalidate(1, y = ySet ? y : $props.y);
    }
    if ($$self.$$.dirty[0] & /*series, $props*/
    4194308) {
      $:
        $$invalidate(2, series = seriesSet ? series : $props.series);
    }
    if ($$self.$$.dirty[0] & /*size, $props*/
    6291456) {
      $:
        $$invalidate(21, size = size ?? $props.size);
    }
    if ($$self.$$.dirty[0] & /*tooltipTitle, $props*/
    4194320) {
      $:
        $$invalidate(4, tooltipTitle = tooltipTitle ?? $props.tooltipTitle);
    }
    if ($$self.$$.dirty[0] & /*series, y, name, columnSummary, data, x*/
    1703950) {
      $:
        if (!series && typeof y !== "object") {
          $$invalidate(3, name = name ?? formatTitle(y, columnSummary[y].title));
          multiSeries = false;
        } else {
          $$invalidate(20, data = getCompletedData(data, x, y, series));
          multiSeries = true;
        }
    }
    if ($$self.$$.dirty[0] & /*options, baseConfig*/
    8224) {
      $:
        if (options) {
          $$invalidate(13, baseConfig = { ...baseConfig, ...options });
        }
    }
    if ($$self.$$.dirty[0] & /*data, x, y, series, swapXY, baseConfig, name, xMismatch, columnSummary, tooltipTitle*/
    1990686) {
      $:
        $$invalidate(16, seriesConfig = getSeriesConfig(data, x, y, series, swapXY, baseConfig, name, xMismatch, columnSummary, void 0, tooltipTitle));
    }
    if ($$self.$$.dirty[0] & /*seriesConfig*/
    65536) {
      $:
        config.update((d) => {
          d.series.push(...seriesConfig);
          return d;
        });
    }
    if ($$self.$$.dirty[0] & /*xType*/
    32768) {
      $:
        chartOverrides = {
          yAxis: { scale: true, boundaryGap: ["1%", "1%"] },
          xAxis: {
            boundaryGap: [xType === "time" ? "2%" : "1%", "2%"]
          }
        };
    }
  };
  return [
    props,
    y,
    series,
    name,
    tooltipTitle,
    options,
    shape,
    fillColor,
    opacity,
    outlineColor,
    outlineWidth,
    pointSize,
    useTooltip,
    baseConfig,
    swapXY,
    xType,
    seriesConfig,
    columnSummary,
    xMismatch,
    x,
    data,
    size,
    $props
  ];
}
var Scatter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance91,
      create_fragment91,
      safe_not_equal,
      {
        y: 1,
        series: 2,
        options: 5,
        name: 3,
        shape: 6,
        fillColor: 7,
        opacity: 8,
        outlineColor: 9,
        outlineWidth: 10,
        pointSize: 11,
        useTooltip: 12,
        tooltipTitle: 4
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Scatter",
      options,
      id: create_fragment91.name
    });
  }
  get y() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get series() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set series(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shape() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shape(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillColor() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillColor(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineColor() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineColor(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineWidth() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineWidth(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointSize() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointSize(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useTooltip() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useTooltip(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTitle() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTitle(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Scatter_default = Scatter;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/ScatterPlot.svelte
function create_default_slot12(ctx) {
  let scatter;
  let t;
  let current;
  scatter = new Scatter_default({
    props: {
      shape: (
        /*shape*/
        ctx[22]
      ),
      fillColor: (
        /*fillColor*/
        ctx[23]
      ),
      opacity: (
        /*opacity*/
        ctx[24]
      ),
      outlineColor: (
        /*outlineColor*/
        ctx[25]
      ),
      outlineWidth: (
        /*outlineWidth*/
        ctx[26]
      ),
      pointSize: (
        /*pointSize*/
        ctx[27]
      ),
      useTooltip: (
        /*useTooltip*/
        ctx[32]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[33].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[34],
    null
  );
  const block = {
    c: function create() {
      create_component(scatter.$$.fragment);
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(scatter.$$.fragment, nodes);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scatter, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const scatter_changes = {};
      if (dirty[0] & /*shape*/
      4194304)
        scatter_changes.shape = /*shape*/
        ctx2[22];
      if (dirty[0] & /*fillColor*/
      8388608)
        scatter_changes.fillColor = /*fillColor*/
        ctx2[23];
      if (dirty[0] & /*opacity*/
      16777216)
        scatter_changes.opacity = /*opacity*/
        ctx2[24];
      if (dirty[0] & /*outlineColor*/
      33554432)
        scatter_changes.outlineColor = /*outlineColor*/
        ctx2[25];
      if (dirty[0] & /*outlineWidth*/
      67108864)
        scatter_changes.outlineWidth = /*outlineWidth*/
        ctx2[26];
      if (dirty[0] & /*pointSize*/
      134217728)
        scatter_changes.pointSize = /*pointSize*/
        ctx2[27];
      scatter.$set(scatter_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[34],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[34]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[34],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scatter.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scatter.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scatter, detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(51:0) <Chart  {data}  {x}  {y}  {xFmt}  {yFmt}  {series}  {tooltipTitle}  {xType}  {legend}  {xAxisTitle}  {yAxisTitle}  {xGridlines}  {yGridlines}  {xAxisLabels}  {yAxisLabels}  {xBaseline}  {yBaseline}  {xTickMarks}  {yTickMarks}  {yMin}  {yMax}  {title}  {subtitle}  {chartType}  {sort}  {chartAreaHeight} >",
    ctx
  });
  return block;
}
function create_fragment92(ctx) {
  let chart;
  let current;
  chart = new Chart_default({
    props: {
      data: (
        /*data*/
        ctx[0]
      ),
      x: (
        /*x*/
        ctx[1]
      ),
      y: (
        /*y*/
        ctx[2]
      ),
      xFmt: (
        /*xFmt*/
        ctx[6]
      ),
      yFmt: (
        /*yFmt*/
        ctx[5]
      ),
      series: (
        /*series*/
        ctx[3]
      ),
      tooltipTitle: (
        /*tooltipTitle*/
        ctx[30]
      ),
      xType: (
        /*xType*/
        ctx[4]
      ),
      legend: (
        /*legend*/
        ctx[9]
      ),
      xAxisTitle: (
        /*xAxisTitle*/
        ctx[10]
      ),
      yAxisTitle: (
        /*yAxisTitle*/
        ctx[11]
      ),
      xGridlines: (
        /*xGridlines*/
        ctx[12]
      ),
      yGridlines: (
        /*yGridlines*/
        ctx[13]
      ),
      xAxisLabels: (
        /*xAxisLabels*/
        ctx[14]
      ),
      yAxisLabels: (
        /*yAxisLabels*/
        ctx[15]
      ),
      xBaseline: (
        /*xBaseline*/
        ctx[16]
      ),
      yBaseline: (
        /*yBaseline*/
        ctx[17]
      ),
      xTickMarks: (
        /*xTickMarks*/
        ctx[18]
      ),
      yTickMarks: (
        /*yTickMarks*/
        ctx[19]
      ),
      yMin: (
        /*yMin*/
        ctx[20]
      ),
      yMax: (
        /*yMax*/
        ctx[21]
      ),
      title: (
        /*title*/
        ctx[7]
      ),
      subtitle: (
        /*subtitle*/
        ctx[8]
      ),
      chartType: (
        /*chartType*/
        ctx[31]
      ),
      sort: (
        /*sort*/
        ctx[29]
      ),
      chartAreaHeight: (
        /*chartAreaHeight*/
        ctx[28]
      ),
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chart, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chart_changes = {};
      if (dirty[0] & /*data*/
      1)
        chart_changes.data = /*data*/
        ctx2[0];
      if (dirty[0] & /*x*/
      2)
        chart_changes.x = /*x*/
        ctx2[1];
      if (dirty[0] & /*y*/
      4)
        chart_changes.y = /*y*/
        ctx2[2];
      if (dirty[0] & /*xFmt*/
      64)
        chart_changes.xFmt = /*xFmt*/
        ctx2[6];
      if (dirty[0] & /*yFmt*/
      32)
        chart_changes.yFmt = /*yFmt*/
        ctx2[5];
      if (dirty[0] & /*series*/
      8)
        chart_changes.series = /*series*/
        ctx2[3];
      if (dirty[0] & /*tooltipTitle*/
      1073741824)
        chart_changes.tooltipTitle = /*tooltipTitle*/
        ctx2[30];
      if (dirty[0] & /*xType*/
      16)
        chart_changes.xType = /*xType*/
        ctx2[4];
      if (dirty[0] & /*legend*/
      512)
        chart_changes.legend = /*legend*/
        ctx2[9];
      if (dirty[0] & /*xAxisTitle*/
      1024)
        chart_changes.xAxisTitle = /*xAxisTitle*/
        ctx2[10];
      if (dirty[0] & /*yAxisTitle*/
      2048)
        chart_changes.yAxisTitle = /*yAxisTitle*/
        ctx2[11];
      if (dirty[0] & /*xGridlines*/
      4096)
        chart_changes.xGridlines = /*xGridlines*/
        ctx2[12];
      if (dirty[0] & /*yGridlines*/
      8192)
        chart_changes.yGridlines = /*yGridlines*/
        ctx2[13];
      if (dirty[0] & /*xAxisLabels*/
      16384)
        chart_changes.xAxisLabels = /*xAxisLabels*/
        ctx2[14];
      if (dirty[0] & /*yAxisLabels*/
      32768)
        chart_changes.yAxisLabels = /*yAxisLabels*/
        ctx2[15];
      if (dirty[0] & /*xBaseline*/
      65536)
        chart_changes.xBaseline = /*xBaseline*/
        ctx2[16];
      if (dirty[0] & /*yBaseline*/
      131072)
        chart_changes.yBaseline = /*yBaseline*/
        ctx2[17];
      if (dirty[0] & /*xTickMarks*/
      262144)
        chart_changes.xTickMarks = /*xTickMarks*/
        ctx2[18];
      if (dirty[0] & /*yTickMarks*/
      524288)
        chart_changes.yTickMarks = /*yTickMarks*/
        ctx2[19];
      if (dirty[0] & /*yMin*/
      1048576)
        chart_changes.yMin = /*yMin*/
        ctx2[20];
      if (dirty[0] & /*yMax*/
      2097152)
        chart_changes.yMax = /*yMax*/
        ctx2[21];
      if (dirty[0] & /*title*/
      128)
        chart_changes.title = /*title*/
        ctx2[7];
      if (dirty[0] & /*subtitle*/
      256)
        chart_changes.subtitle = /*subtitle*/
        ctx2[8];
      if (dirty[0] & /*sort*/
      536870912)
        chart_changes.sort = /*sort*/
        ctx2[29];
      if (dirty[0] & /*chartAreaHeight*/
      268435456)
        chart_changes.chartAreaHeight = /*chartAreaHeight*/
        ctx2[28];
      if (dirty[0] & /*shape, fillColor, opacity, outlineColor, outlineWidth, pointSize*/
      264241152 | dirty[1] & /*$$scope*/
      8) {
        chart_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chart.$set(chart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment92.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude88 = true;
function instance92($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScatterPlot", slots, ["default"]);
  let { data = void 0 } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { series = void 0 } = $$props;
  let { xType = void 0 } = $$props;
  let { yFmt = void 0 } = $$props;
  let { xFmt = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { legend = void 0 } = $$props;
  let { xAxisTitle = "true" } = $$props;
  let { yAxisTitle = "true" } = $$props;
  let { xGridlines = void 0 } = $$props;
  let { yGridlines = void 0 } = $$props;
  let { xAxisLabels = void 0 } = $$props;
  let { yAxisLabels = void 0 } = $$props;
  let { xBaseline = void 0 } = $$props;
  let { yBaseline = void 0 } = $$props;
  let { xTickMarks = void 0 } = $$props;
  let { yTickMarks = void 0 } = $$props;
  let { yMin = void 0 } = $$props;
  let { yMax = void 0 } = $$props;
  let { shape = void 0 } = $$props;
  let { fillColor = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { outlineColor = void 0 } = $$props;
  let { outlineWidth = void 0 } = $$props;
  let { pointSize = void 0 } = $$props;
  let { chartAreaHeight = void 0 } = $$props;
  let { sort = void 0 } = $$props;
  let { tooltipTitle = void 0 } = $$props;
  let chartType = "Scatter Plot";
  let useTooltip = true;
  const writable_props = [
    "data",
    "x",
    "y",
    "series",
    "xType",
    "yFmt",
    "xFmt",
    "title",
    "subtitle",
    "legend",
    "xAxisTitle",
    "yAxisTitle",
    "xGridlines",
    "yGridlines",
    "xAxisLabels",
    "yAxisLabels",
    "xBaseline",
    "yBaseline",
    "xTickMarks",
    "yTickMarks",
    "yMin",
    "yMax",
    "shape",
    "fillColor",
    "opacity",
    "outlineColor",
    "outlineWidth",
    "pointSize",
    "chartAreaHeight",
    "sort",
    "tooltipTitle"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScatterPlot> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(3, series = $$props2.series);
    if ("xType" in $$props2)
      $$invalidate(4, xType = $$props2.xType);
    if ("yFmt" in $$props2)
      $$invalidate(5, yFmt = $$props2.yFmt);
    if ("xFmt" in $$props2)
      $$invalidate(6, xFmt = $$props2.xFmt);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(8, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(9, legend = $$props2.legend);
    if ("xAxisTitle" in $$props2)
      $$invalidate(10, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(11, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(12, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(13, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(14, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(15, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(16, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(17, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(18, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(19, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(20, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(21, yMax = $$props2.yMax);
    if ("shape" in $$props2)
      $$invalidate(22, shape = $$props2.shape);
    if ("fillColor" in $$props2)
      $$invalidate(23, fillColor = $$props2.fillColor);
    if ("opacity" in $$props2)
      $$invalidate(24, opacity = $$props2.opacity);
    if ("outlineColor" in $$props2)
      $$invalidate(25, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(26, outlineWidth = $$props2.outlineWidth);
    if ("pointSize" in $$props2)
      $$invalidate(27, pointSize = $$props2.pointSize);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(28, chartAreaHeight = $$props2.chartAreaHeight);
    if ("sort" in $$props2)
      $$invalidate(29, sort = $$props2.sort);
    if ("tooltipTitle" in $$props2)
      $$invalidate(30, tooltipTitle = $$props2.tooltipTitle);
    if ("$$scope" in $$props2)
      $$invalidate(34, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude88,
    Chart: Chart_default,
    Scatter: Scatter_default,
    data,
    x,
    y,
    series,
    xType,
    yFmt,
    xFmt,
    title,
    subtitle,
    legend,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    shape,
    fillColor,
    opacity,
    outlineColor,
    outlineWidth,
    pointSize,
    chartAreaHeight,
    sort,
    tooltipTitle,
    chartType,
    useTooltip
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y = $$props2.y);
    if ("series" in $$props2)
      $$invalidate(3, series = $$props2.series);
    if ("xType" in $$props2)
      $$invalidate(4, xType = $$props2.xType);
    if ("yFmt" in $$props2)
      $$invalidate(5, yFmt = $$props2.yFmt);
    if ("xFmt" in $$props2)
      $$invalidate(6, xFmt = $$props2.xFmt);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(8, subtitle = $$props2.subtitle);
    if ("legend" in $$props2)
      $$invalidate(9, legend = $$props2.legend);
    if ("xAxisTitle" in $$props2)
      $$invalidate(10, xAxisTitle = $$props2.xAxisTitle);
    if ("yAxisTitle" in $$props2)
      $$invalidate(11, yAxisTitle = $$props2.yAxisTitle);
    if ("xGridlines" in $$props2)
      $$invalidate(12, xGridlines = $$props2.xGridlines);
    if ("yGridlines" in $$props2)
      $$invalidate(13, yGridlines = $$props2.yGridlines);
    if ("xAxisLabels" in $$props2)
      $$invalidate(14, xAxisLabels = $$props2.xAxisLabels);
    if ("yAxisLabels" in $$props2)
      $$invalidate(15, yAxisLabels = $$props2.yAxisLabels);
    if ("xBaseline" in $$props2)
      $$invalidate(16, xBaseline = $$props2.xBaseline);
    if ("yBaseline" in $$props2)
      $$invalidate(17, yBaseline = $$props2.yBaseline);
    if ("xTickMarks" in $$props2)
      $$invalidate(18, xTickMarks = $$props2.xTickMarks);
    if ("yTickMarks" in $$props2)
      $$invalidate(19, yTickMarks = $$props2.yTickMarks);
    if ("yMin" in $$props2)
      $$invalidate(20, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(21, yMax = $$props2.yMax);
    if ("shape" in $$props2)
      $$invalidate(22, shape = $$props2.shape);
    if ("fillColor" in $$props2)
      $$invalidate(23, fillColor = $$props2.fillColor);
    if ("opacity" in $$props2)
      $$invalidate(24, opacity = $$props2.opacity);
    if ("outlineColor" in $$props2)
      $$invalidate(25, outlineColor = $$props2.outlineColor);
    if ("outlineWidth" in $$props2)
      $$invalidate(26, outlineWidth = $$props2.outlineWidth);
    if ("pointSize" in $$props2)
      $$invalidate(27, pointSize = $$props2.pointSize);
    if ("chartAreaHeight" in $$props2)
      $$invalidate(28, chartAreaHeight = $$props2.chartAreaHeight);
    if ("sort" in $$props2)
      $$invalidate(29, sort = $$props2.sort);
    if ("tooltipTitle" in $$props2)
      $$invalidate(30, tooltipTitle = $$props2.tooltipTitle);
    if ("chartType" in $$props2)
      $$invalidate(31, chartType = $$props2.chartType);
    if ("useTooltip" in $$props2)
      $$invalidate(32, useTooltip = $$props2.useTooltip);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    data,
    x,
    y,
    series,
    xType,
    yFmt,
    xFmt,
    title,
    subtitle,
    legend,
    xAxisTitle,
    yAxisTitle,
    xGridlines,
    yGridlines,
    xAxisLabels,
    yAxisLabels,
    xBaseline,
    yBaseline,
    xTickMarks,
    yTickMarks,
    yMin,
    yMax,
    shape,
    fillColor,
    opacity,
    outlineColor,
    outlineWidth,
    pointSize,
    chartAreaHeight,
    sort,
    tooltipTitle,
    chartType,
    useTooltip,
    slots,
    $$scope
  ];
}
var ScatterPlot = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance92,
      create_fragment92,
      safe_not_equal,
      {
        data: 0,
        x: 1,
        y: 2,
        series: 3,
        xType: 4,
        yFmt: 5,
        xFmt: 6,
        title: 7,
        subtitle: 8,
        legend: 9,
        xAxisTitle: 10,
        yAxisTitle: 11,
        xGridlines: 12,
        yGridlines: 13,
        xAxisLabels: 14,
        yAxisLabels: 15,
        xBaseline: 16,
        yBaseline: 17,
        xTickMarks: 18,
        yTickMarks: 19,
        yMin: 20,
        yMax: 21,
        shape: 22,
        fillColor: 23,
        opacity: 24,
        outlineColor: 25,
        outlineWidth: 26,
        pointSize: 27,
        chartAreaHeight: 28,
        sort: 29,
        tooltipTitle: 30
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScatterPlot",
      options,
      id: create_fragment92.name
    });
  }
  get data() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get series() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set series(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xType() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xType(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yFmt() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yFmt(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xFmt() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xFmt(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisTitle() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisTitle(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisTitle() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisTitle(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xGridlines() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xGridlines(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yGridlines() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yGridlines(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAxisLabels() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAxisLabels(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAxisLabels() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAxisLabels(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xBaseline() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xBaseline(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yBaseline() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yBaseline(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xTickMarks() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xTickMarks(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yTickMarks() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yTickMarks(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMin() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMin(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMax() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMax(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shape() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shape(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillColor() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillColor(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineColor() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineColor(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineWidth() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineWidth(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointSize() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointSize(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chartAreaHeight() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chartAreaHeight(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sort() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sort(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTitle() {
    throw new Error("<ScatterPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTitle(value) {
    throw new Error("<ScatterPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScatterPlot_default = ScatterPlot;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/ReferenceLine.svelte
var { Object: Object_17 } = globals;
function create_if_block51(ctx) {
  let errorchart;
  let current;
  errorchart = new ErrorChart_default({
    props: {
      error: (
        /*error*/
        ctx[0]
      ),
      chartType: (
        /*chartType*/
        ctx[1] === "Reference Line" ? (
          /*chartType*/
          ctx[1]
        ) : `${/*chartType*/
        ctx[1]}: Reference Line`
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(errorchart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(errorchart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(errorchart, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const errorchart_changes = {};
      if (dirty & /*error*/
      1)
        errorchart_changes.error = /*error*/
        ctx2[0];
      if (dirty & /*chartType*/
      2)
        errorchart_changes.chartType = /*chartType*/
        ctx2[1] === "Reference Line" ? (
          /*chartType*/
          ctx2[1]
        ) : `${/*chartType*/
        ctx2[1]}: Reference Line`;
      errorchart.$set(errorchart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(errorchart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(errorchart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(errorchart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block51.name,
    type: "if",
    source: "(216:0) {#if error}",
    ctx
  });
  return block;
}
function create_fragment93(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*error*/
    ctx[0] && create_if_block51(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*error*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*error*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block51(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment93.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude89 = true;
function instance93($$self, $$props, $$invalidate) {
  let $props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ReferenceLine", slots, []);
  let props = getContext(propKey);
  validate_store(props, "props");
  component_subscribe($$self, props, (value) => $$invalidate(21, $props = value));
  let config = getContext(configKey);
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { lineColor = void 0 } = $$props;
  let { labelColor = void 0 } = $$props;
  let { lineWidth = void 0 } = $$props;
  let { lineType = "dashed" } = $$props;
  let { labelPosition = "aboveEnd" } = $$props;
  let { labelTextOutline = false } = $$props;
  let { labelBackground = true } = $$props;
  let { hideValue = false } = $$props;
  let colorList = {
    red: {
      lineColor: "#b04646",
      labelColor: "#b04646"
    },
    green: {
      lineColor: colours.green700,
      labelColor: colours.green700
    },
    yellow: {
      lineColor: colours.yellow600,
      labelColor: colours.yellow700
    },
    grey: {
      lineColor: colours.grey500,
      labelColor: colours.grey600
    },
    blue: {
      lineColor: colours.blue500,
      labelColor: colours.blue500
    }
  };
  let defaultColor = "grey";
  let error;
  let chartType;
  let xFormat;
  let yFormat;
  let swapXY;
  const labelPositions = {
    aboveEnd: "insideEndTop",
    aboveStart: "insideStartTop",
    aboveCenter: "insideMiddleTop",
    aboveCentre: "insideMiddleTop",
    belowEnd: "insideEndBottom",
    belowStart: "insideStartBottom",
    belowCenter: "insideMiddleBottom",
    belowCentre: "insideMiddleBottom"
  };
  let configData = [];
  const identifier = String(Math.random());
  let baseConfig;
  const writable_props = [
    "x",
    "y",
    "data",
    "label",
    "color",
    "lineColor",
    "labelColor",
    "lineWidth",
    "lineType",
    "labelPosition",
    "labelTextOutline",
    "labelBackground",
    "hideValue"
  ];
  Object_17.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ReferenceLine> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(3, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(4, y = $$props2.y);
    if ("data" in $$props2)
      $$invalidate(11, data = $$props2.data);
    if ("label" in $$props2)
      $$invalidate(12, label = $$props2.label);
    if ("color" in $$props2)
      $$invalidate(13, color = $$props2.color);
    if ("lineColor" in $$props2)
      $$invalidate(5, lineColor = $$props2.lineColor);
    if ("labelColor" in $$props2)
      $$invalidate(6, labelColor = $$props2.labelColor);
    if ("lineWidth" in $$props2)
      $$invalidate(14, lineWidth = $$props2.lineWidth);
    if ("lineType" in $$props2)
      $$invalidate(15, lineType = $$props2.lineType);
    if ("labelPosition" in $$props2)
      $$invalidate(7, labelPosition = $$props2.labelPosition);
    if ("labelTextOutline" in $$props2)
      $$invalidate(8, labelTextOutline = $$props2.labelTextOutline);
    if ("labelBackground" in $$props2)
      $$invalidate(9, labelBackground = $$props2.labelBackground);
    if ("hideValue" in $$props2)
      $$invalidate(10, hideValue = $$props2.hideValue);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude89,
    getContext,
    propKey,
    configKey,
    formatValue,
    checkInputs,
    ErrorChart: ErrorChart_default,
    colours,
    props,
    config,
    x,
    y,
    data,
    label,
    color,
    lineColor,
    labelColor,
    lineWidth,
    lineType,
    labelPosition,
    labelTextOutline,
    labelBackground,
    hideValue,
    colorList,
    defaultColor,
    error,
    chartType,
    xFormat,
    yFormat,
    swapXY,
    labelPositions,
    configData,
    identifier,
    baseConfig,
    $props
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("config" in $$props2)
      $$invalidate(22, config = $$props2.config);
    if ("x" in $$props2)
      $$invalidate(3, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(4, y = $$props2.y);
    if ("data" in $$props2)
      $$invalidate(11, data = $$props2.data);
    if ("label" in $$props2)
      $$invalidate(12, label = $$props2.label);
    if ("color" in $$props2)
      $$invalidate(13, color = $$props2.color);
    if ("lineColor" in $$props2)
      $$invalidate(5, lineColor = $$props2.lineColor);
    if ("labelColor" in $$props2)
      $$invalidate(6, labelColor = $$props2.labelColor);
    if ("lineWidth" in $$props2)
      $$invalidate(14, lineWidth = $$props2.lineWidth);
    if ("lineType" in $$props2)
      $$invalidate(15, lineType = $$props2.lineType);
    if ("labelPosition" in $$props2)
      $$invalidate(7, labelPosition = $$props2.labelPosition);
    if ("labelTextOutline" in $$props2)
      $$invalidate(8, labelTextOutline = $$props2.labelTextOutline);
    if ("labelBackground" in $$props2)
      $$invalidate(9, labelBackground = $$props2.labelBackground);
    if ("hideValue" in $$props2)
      $$invalidate(10, hideValue = $$props2.hideValue);
    if ("colorList" in $$props2)
      $$invalidate(23, colorList = $$props2.colorList);
    if ("defaultColor" in $$props2)
      $$invalidate(24, defaultColor = $$props2.defaultColor);
    if ("error" in $$props2)
      $$invalidate(0, error = $$props2.error);
    if ("chartType" in $$props2)
      $$invalidate(1, chartType = $$props2.chartType);
    if ("xFormat" in $$props2)
      $$invalidate(16, xFormat = $$props2.xFormat);
    if ("yFormat" in $$props2)
      $$invalidate(17, yFormat = $$props2.yFormat);
    if ("swapXY" in $$props2)
      $$invalidate(18, swapXY = $$props2.swapXY);
    if ("configData" in $$props2)
      $$invalidate(19, configData = $$props2.configData);
    if ("baseConfig" in $$props2)
      $$invalidate(20, baseConfig = $$props2.baseConfig);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*labelTextOutline*/
    256) {
      $:
        $$invalidate(8, labelTextOutline = labelTextOutline === "true" || labelTextOutline === true);
    }
    if ($$self.$$.dirty & /*labelBackground*/
    512) {
      $:
        $$invalidate(9, labelBackground = labelBackground === "true" || labelBackground === true);
    }
    if ($$self.$$.dirty & /*hideValue*/
    1024) {
      $:
        $$invalidate(10, hideValue = hideValue === "true" || hideValue === true);
    }
    if ($$self.$$.dirty & /*labelColor*/
    64) {
      $:
        if (labelColor) {
          if (Object.keys(colorList).includes(labelColor)) {
            $$invalidate(6, labelColor = colorList[labelColor].labelColor);
          }
        }
    }
    if ($$self.$$.dirty & /*lineColor*/
    32) {
      $:
        if (lineColor) {
          if (Object.keys(colorList).includes(lineColor)) {
            $$invalidate(5, lineColor = colorList[lineColor].lineColor);
          }
        }
    }
    if ($$self.$$.dirty & /*color, lineColor, labelColor*/
    8288) {
      $:
        if (Object.keys(colorList).includes(color)) {
          $$invalidate(5, lineColor = lineColor ?? colorList[color].lineColor);
          $$invalidate(6, labelColor = labelColor ?? colorList[color].labelColor);
        } else {
          $$invalidate(5, lineColor = lineColor ?? color ?? colorList[defaultColor].lineColor);
          $$invalidate(6, labelColor = labelColor ?? color ?? colorList[defaultColor].labelColor);
        }
    }
    if ($$self.$$.dirty & /*$props*/
    2097152) {
      $:
        try {
          $$invalidate(1, chartType = $props.chartType);
        } catch (e) {
          $$invalidate(1, chartType = "Reference Line");
          $$invalidate(0, error = "Reference Line cannot be used outside of a chart component");
        }
    }
    if ($$self.$$.dirty & /*error, $props, swapXY, y, x, yFormat, xFormat*/
    2555929) {
      $:
        if (!error) {
          try {
            $$invalidate(16, xFormat = $props.xFormat);
            $$invalidate(17, yFormat = $props.yFormat);
            $$invalidate(18, swapXY = $props.swapXY);
            if (swapXY) {
              $$invalidate(3, [x, y] = [y, x], x, ($$invalidate(4, y), $$invalidate(0, error), $$invalidate(21, $props), $$invalidate(18, swapXY), $$invalidate(3, x), $$invalidate(17, yFormat), $$invalidate(16, xFormat), $$invalidate(11, data), $$invalidate(19, configData), $$invalidate(12, label)));
              $$invalidate(16, [xFormat, yFormat] = [yFormat, xFormat], xFormat, ($$invalidate(17, yFormat), $$invalidate(0, error), $$invalidate(21, $props), $$invalidate(18, swapXY), $$invalidate(4, y), $$invalidate(3, x), $$invalidate(16, xFormat), $$invalidate(11, data), $$invalidate(19, configData), $$invalidate(12, label)));
            }
          } catch (e) {
            $$invalidate(0, error = e);
          }
        }
    }
    if ($$self.$$.dirty & /*labelPosition*/
    128) {
      $:
        $$invalidate(7, labelPosition = labelPositions[labelPosition] ?? "insideEndTop");
    }
    if ($$self.$$.dirty & /*data, error, x, configData, label, y*/
    530457) {
      $:
        if (data && !error) {
          try {
            $$invalidate(19, configData = []);
            if (x) {
              checkInputs(data, [x]);
              for (let i = 0; i < data.length; i++) {
                if (data[i][x] !== null) {
                  configData.push({ name: data[i][label], xAxis: data[i][x] });
                }
              }
            } else if (y) {
              checkInputs(data, [y]);
              for (let i = 0; i < data.length; i++) {
                if (data[i][y] !== null) {
                  configData.push({ name: data[i][label], yAxis: data[i][y] });
                }
              }
            }
          } catch (e) {
            $$invalidate(0, error = e);
          }
        } else {
          if (x) {
            configData.push({ name: label, xAxis: x });
          } else if (y) {
            configData.push({ name: label, yAxis: y });
          }
        }
    }
    if ($$self.$$.dirty & /*error, configData, labelPosition, hideValue, y, x, yFormat, xFormat, labelColor, labelTextOutline, labelBackground, lineColor, lineWidth, lineType, baseConfig*/
    1820665) {
      $:
        if (!error) {
          $$invalidate(20, baseConfig = {
            id: identifier,
            type: "line",
            markLine: {
              data: configData,
              silent: true,
              label: {
                show: true,
                position: labelPosition,
                formatter(params) {
                  let result;
                  if (params.name === "") {
                    result = !hideValue ? `${formatValue(
                      y ? params.data.yAxis : x ? params.data.xAxis : params.value,
                      y ? yFormat : x ? xFormat : "string"
                    )}` : "";
                  } else {
                    result = !hideValue ? `${params.name} (${formatValue(
                      y ? params.data.yAxis : x ? params.data.xAxis : params.value,
                      y ? yFormat : x ? xFormat : "string"
                    )})` : `${params.name}`;
                  }
                  return result;
                },
                color: labelColor,
                fontWeight: "medium",
                textBorderColor: "white",
                textBorderWidth: labelTextOutline ? 1.5 : 0,
                backgroundColor: labelBackground ? "hsla(360, 100%, 100%, 0.7)" : "",
                padding: 1,
                borderRadius: 1.5
              },
              animation: false,
              symbol: "none",
              emphasis: { disabled: true },
              lineStyle: {
                color: lineColor,
                width: lineWidth ? parseInt(lineWidth) : 1.3,
                type: lineType
              }
            }
          });
          config.update((d) => {
            const existingIndex = d.series.findIndex((e) => e.id === identifier);
            if (existingIndex > -1) {
              d.series[existingIndex] = baseConfig;
            } else {
              d.series.push(baseConfig);
            }
            return d;
          });
        }
    }
  };
  return [
    error,
    chartType,
    props,
    x,
    y,
    lineColor,
    labelColor,
    labelPosition,
    labelTextOutline,
    labelBackground,
    hideValue,
    data,
    label,
    color,
    lineWidth,
    lineType,
    xFormat,
    yFormat,
    swapXY,
    configData,
    baseConfig,
    $props
  ];
}
var ReferenceLine = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance93, create_fragment93, safe_not_equal, {
      x: 3,
      y: 4,
      data: 11,
      label: 12,
      color: 13,
      lineColor: 5,
      labelColor: 6,
      lineWidth: 14,
      lineType: 15,
      labelPosition: 7,
      labelTextOutline: 8,
      labelBackground: 9,
      hideValue: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ReferenceLine",
      options,
      id: create_fragment93.name
    });
  }
  get x() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineColor() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineColor(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelColor() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelColor(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineType() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineType(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPosition() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPosition(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelTextOutline() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelTextOutline(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelBackground() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelBackground(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideValue() {
    throw new Error("<ReferenceLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideValue(value) {
    throw new Error("<ReferenceLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ReferenceLine_default = ReferenceLine;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/ReferenceArea.svelte
var { Object: Object_18 } = globals;
function create_if_block52(ctx) {
  let errorchart;
  let current;
  errorchart = new ErrorChart_default({
    props: {
      error: (
        /*error*/
        ctx[1]
      ),
      chartType: (
        /*chartType*/
        ctx[0] === "Reference Area" ? (
          /*chartType*/
          ctx[0]
        ) : `${/*chartType*/
        ctx[0]}: Reference Area`
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(errorchart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(errorchart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(errorchart, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const errorchart_changes = {};
      if (dirty & /*error*/
      2)
        errorchart_changes.error = /*error*/
        ctx2[1];
      if (dirty & /*chartType*/
      1)
        errorchart_changes.chartType = /*chartType*/
        ctx2[0] === "Reference Area" ? (
          /*chartType*/
          ctx2[0]
        ) : `${/*chartType*/
        ctx2[0]}: Reference Area`;
      errorchart.$set(errorchart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(errorchart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(errorchart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(errorchart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block52.name,
    type: "if",
    source: "(234:0) {#if error}",
    ctx
  });
  return block;
}
function create_fragment94(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*error*/
    ctx[1] && create_if_block52(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*error*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*error*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block52(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment94.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude90 = true;
function instance94($$self, $$props, $$invalidate) {
  let chartOverrides;
  let $props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ReferenceArea", slots, []);
  let props = getContext(propKey);
  validate_store(props, "props");
  component_subscribe($$self, props, (value) => $$invalidate(22, $props = value));
  let config = getContext(configKey);
  let { xMin = void 0 } = $$props;
  let { xMax = void 0 } = $$props;
  let { yMin = void 0 } = $$props;
  let { yMax = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { areaColor = void 0 } = $$props;
  let { opacity = 1 } = $$props;
  let { labelColor = void 0 } = $$props;
  let { border = false } = $$props;
  let { borderColor = void 0 } = $$props;
  let { borderType = void 0 } = $$props;
  let { borderWidth = void 0 } = $$props;
  let { labelPosition = void 0 } = $$props;
  let defaultColor = "blue";
  let colorList = {
    red: {
      areaColor: "#fceeed",
      labelColor: "#b04646",
      borderColor: "#b04646"
    },
    green: {
      areaColor: "#e6f5e6",
      labelColor: "#65a665",
      borderColor: "#65a665"
    },
    yellow: {
      areaColor: "#fff9e0",
      labelColor: "#edb131",
      borderColor: "#edb131"
    },
    grey: {
      areaColor: "hsl(217, 33%, 97%)",
      labelColor: "hsl(212, 10%, 53%)",
      borderColor: "hsl(212, 10%, 53%)"
    },
    blue: {
      areaColor: "#EDF6FD",
      labelColor: "#51a2e0",
      borderColor: "#51a2e0"
    }
  };
  let chartType;
  let error;
  let swapXY;
  const labelPositions = {
    topLeft: "insideTopLeft",
    top: "insideTop",
    topRight: "insideTopRight",
    bottomLeft: "insideBottomLeft",
    bottom: "insideBottom",
    bottomRight: "insideBottomRight",
    left: "insideLeft",
    center: "inside",
    centre: "inside",
    right: "insideRight"
  };
  let configData = [];
  let inputs = [xMin, xMax, yMin, yMax, label];
  let reqCols = [];
  const identifier = String(Math.random());
  let baseConfig;
  beforeUpdate(() => {
    if (chartOverrides) {
      config.update((d) => {
        if (swapXY) {
          d.yAxis = { ...d.yAxis, ...chartOverrides.xAxis };
          d.xAxis = { ...d.xAxis, ...chartOverrides.yAxis };
        } else {
          d.yAxis = { ...d.yAxis, ...chartOverrides.yAxis };
          d.xAxis = { ...d.xAxis, ...chartOverrides.xAxis };
        }
        return d;
      });
    }
  });
  const writable_props = [
    "xMin",
    "xMax",
    "yMin",
    "yMax",
    "label",
    "data",
    "color",
    "areaColor",
    "opacity",
    "labelColor",
    "border",
    "borderColor",
    "borderType",
    "borderWidth",
    "labelPosition"
  ];
  Object_18.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ReferenceArea> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("xMin" in $$props2)
      $$invalidate(3, xMin = $$props2.xMin);
    if ("xMax" in $$props2)
      $$invalidate(4, xMax = $$props2.xMax);
    if ("yMin" in $$props2)
      $$invalidate(5, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(6, yMax = $$props2.yMax);
    if ("label" in $$props2)
      $$invalidate(12, label = $$props2.label);
    if ("data" in $$props2)
      $$invalidate(13, data = $$props2.data);
    if ("color" in $$props2)
      $$invalidate(14, color = $$props2.color);
    if ("areaColor" in $$props2)
      $$invalidate(7, areaColor = $$props2.areaColor);
    if ("opacity" in $$props2)
      $$invalidate(15, opacity = $$props2.opacity);
    if ("labelColor" in $$props2)
      $$invalidate(8, labelColor = $$props2.labelColor);
    if ("border" in $$props2)
      $$invalidate(9, border = $$props2.border);
    if ("borderColor" in $$props2)
      $$invalidate(10, borderColor = $$props2.borderColor);
    if ("borderType" in $$props2)
      $$invalidate(16, borderType = $$props2.borderType);
    if ("borderWidth" in $$props2)
      $$invalidate(17, borderWidth = $$props2.borderWidth);
    if ("labelPosition" in $$props2)
      $$invalidate(11, labelPosition = $$props2.labelPosition);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude90,
    getContext,
    beforeUpdate,
    propKey,
    configKey,
    checkInputs,
    ErrorChart: ErrorChart_default,
    props,
    config,
    xMin,
    xMax,
    yMin,
    yMax,
    label,
    data,
    color,
    areaColor,
    opacity,
    labelColor,
    border,
    borderColor,
    borderType,
    borderWidth,
    labelPosition,
    defaultColor,
    colorList,
    chartType,
    error,
    swapXY,
    labelPositions,
    configData,
    inputs,
    reqCols,
    identifier,
    baseConfig,
    chartOverrides,
    $props
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("config" in $$props2)
      $$invalidate(24, config = $$props2.config);
    if ("xMin" in $$props2)
      $$invalidate(3, xMin = $$props2.xMin);
    if ("xMax" in $$props2)
      $$invalidate(4, xMax = $$props2.xMax);
    if ("yMin" in $$props2)
      $$invalidate(5, yMin = $$props2.yMin);
    if ("yMax" in $$props2)
      $$invalidate(6, yMax = $$props2.yMax);
    if ("label" in $$props2)
      $$invalidate(12, label = $$props2.label);
    if ("data" in $$props2)
      $$invalidate(13, data = $$props2.data);
    if ("color" in $$props2)
      $$invalidate(14, color = $$props2.color);
    if ("areaColor" in $$props2)
      $$invalidate(7, areaColor = $$props2.areaColor);
    if ("opacity" in $$props2)
      $$invalidate(15, opacity = $$props2.opacity);
    if ("labelColor" in $$props2)
      $$invalidate(8, labelColor = $$props2.labelColor);
    if ("border" in $$props2)
      $$invalidate(9, border = $$props2.border);
    if ("borderColor" in $$props2)
      $$invalidate(10, borderColor = $$props2.borderColor);
    if ("borderType" in $$props2)
      $$invalidate(16, borderType = $$props2.borderType);
    if ("borderWidth" in $$props2)
      $$invalidate(17, borderWidth = $$props2.borderWidth);
    if ("labelPosition" in $$props2)
      $$invalidate(11, labelPosition = $$props2.labelPosition);
    if ("defaultColor" in $$props2)
      $$invalidate(25, defaultColor = $$props2.defaultColor);
    if ("colorList" in $$props2)
      $$invalidate(26, colorList = $$props2.colorList);
    if ("chartType" in $$props2)
      $$invalidate(0, chartType = $$props2.chartType);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("swapXY" in $$props2)
      $$invalidate(18, swapXY = $$props2.swapXY);
    if ("configData" in $$props2)
      $$invalidate(19, configData = $$props2.configData);
    if ("inputs" in $$props2)
      $$invalidate(28, inputs = $$props2.inputs);
    if ("reqCols" in $$props2)
      $$invalidate(20, reqCols = $$props2.reqCols);
    if ("baseConfig" in $$props2)
      $$invalidate(21, baseConfig = $$props2.baseConfig);
    if ("chartOverrides" in $$props2)
      chartOverrides = $$props2.chartOverrides;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*border*/
    512) {
      $:
        $$invalidate(9, border = border === "true" || border === true);
    }
    if ($$self.$$.dirty & /*labelColor*/
    256) {
      $:
        if (labelColor) {
          if (Object.keys(colorList).includes(labelColor)) {
            $$invalidate(8, labelColor = colorList[labelColor].labelColor);
          }
        }
    }
    if ($$self.$$.dirty & /*borderColor*/
    1024) {
      $:
        if (borderColor) {
          if (Object.keys(colorList).includes(borderColor)) {
            $$invalidate(10, borderColor = colorList[borderColor].borderColor);
          }
        }
    }
    if ($$self.$$.dirty & /*areaColor*/
    128) {
      $:
        if (areaColor) {
          if (Object.keys(colorList).includes(areaColor)) {
            $$invalidate(7, areaColor = colorList[areaColor].areaColor);
          }
        }
    }
    if ($$self.$$.dirty & /*color, areaColor, labelColor, borderColor*/
    17792) {
      $:
        if (Object.keys(colorList).includes(color)) {
          $$invalidate(7, areaColor = areaColor ?? colorList[color].areaColor);
          $$invalidate(8, labelColor = labelColor ?? colorList[color].labelColor);
          $$invalidate(10, borderColor = borderColor ?? colorList[color].borderColor);
        } else {
          $$invalidate(7, areaColor = areaColor ?? color ?? colorList[defaultColor].areaColor);
          $$invalidate(8, labelColor = labelColor ?? color ?? colorList[defaultColor].labelColor);
          $$invalidate(10, borderColor = borderColor ?? color ?? colorList[defaultColor].borderColor);
        }
    }
    if ($$self.$$.dirty & /*$props*/
    4194304) {
      $:
        try {
          $$invalidate(0, chartType = $props.chartType);
        } catch (e) {
          $$invalidate(0, chartType = "Reference Area");
          $$invalidate(1, error = "Reference Area cannot be used outside of a chart component");
        }
    }
    if ($$self.$$.dirty & /*error, $props, swapXY, yMin, yMax, xMin, xMax, labelPosition*/
    4458618) {
      $:
        if (!error) {
          try {
            $$invalidate(18, swapXY = $props.swapXY);
            if (swapXY) {
              $$invalidate(3, [xMin, xMax, yMin, yMax] = [yMin, yMax, xMin, xMax], xMin, ($$invalidate(4, xMax), $$invalidate(1, error), $$invalidate(22, $props), $$invalidate(18, swapXY), $$invalidate(5, yMin), $$invalidate(6, yMax), $$invalidate(3, xMin), $$invalidate(11, labelPosition), $$invalidate(13, data), $$invalidate(20, reqCols), $$invalidate(19, configData), $$invalidate(12, label), $$invalidate(28, inputs)), ($$invalidate(5, yMin), $$invalidate(1, error), $$invalidate(22, $props), $$invalidate(18, swapXY), $$invalidate(6, yMax), $$invalidate(3, xMin), $$invalidate(4, xMax), $$invalidate(11, labelPosition), $$invalidate(13, data), $$invalidate(20, reqCols), $$invalidate(19, configData), $$invalidate(12, label), $$invalidate(28, inputs)), ($$invalidate(6, yMax), $$invalidate(1, error), $$invalidate(22, $props), $$invalidate(18, swapXY), $$invalidate(5, yMin), $$invalidate(3, xMin), $$invalidate(4, xMax), $$invalidate(11, labelPosition), $$invalidate(13, data), $$invalidate(20, reqCols), $$invalidate(19, configData), $$invalidate(12, label), $$invalidate(28, inputs)));
              $$invalidate(11, labelPosition = labelPosition ?? "topRight");
            } else {
              if (yMin && yMax && xMin && xMax) {
                $$invalidate(11, labelPosition = labelPosition ?? "topLeft");
              } else if (yMin || yMax) {
                $$invalidate(11, labelPosition = labelPosition ?? "right");
              } else {
                $$invalidate(11, labelPosition = labelPosition ?? "top");
              }
            }
          } catch (e) {
            $$invalidate(1, error = e);
          }
        }
    }
    if ($$self.$$.dirty & /*labelPosition*/
    2048) {
      $:
        $$invalidate(11, labelPosition = labelPositions[labelPosition] ?? "insideEndTop");
    }
    if ($$self.$$.dirty & /*reqCols*/
    1048576) {
      $:
        for (let i = 0; i < inputs.length; i++) {
          $$invalidate(20, reqCols = []);
          if (inputs[i] !== void 0) {
            reqCols.push(inputs[i]);
          }
        }
    }
    if ($$self.$$.dirty & /*data, error, reqCols, configData, label, xMin, yMin, xMax, yMax*/
    1585274) {
      $:
        if (data && !error) {
          try {
            checkInputs(data, reqCols);
            $$invalidate(19, configData = []);
            for (let i = 0; i < data.length; i++) {
              configData.push([
                {
                  name: data[i][label],
                  xAxis: data[i][xMin],
                  yAxis: data[i][yMin]
                },
                {
                  xAxis: data[i][xMax],
                  yAxis: data[i][yMax]
                }
              ]);
            }
          } catch (e) {
            $$invalidate(1, error = e);
          }
        } else {
          configData.push([{ name: label, xAxis: xMin, yAxis: yMin }, { xAxis: xMax, yAxis: yMax }]);
        }
    }
    if ($$self.$$.dirty & /*error, chartType, configData, areaColor, opacity, border, borderWidth, borderColor, borderType, labelPosition, labelColor, baseConfig*/
    2854787) {
      $:
        if (!error) {
          $$invalidate(21, baseConfig = {
            id: identifier,
            type: chartType === "Bar Chart" ? "bar" : "line",
            stack: "stack1",
            markArea: {
              data: configData,
              silent: true,
              animation: false,
              emphasis: { disabled: true },
              itemStyle: {
                color: areaColor,
                opacity,
                borderWidth: border ? borderWidth ?? 1 : null,
                borderColor,
                borderType: borderType ?? "dashed"
              },
              label: {
                show: true,
                position: labelPosition,
                color: labelColor
              }
            },
            zlevel: 0
          });
          config.update((d) => {
            const existingIndex = d.series.findIndex((e) => e.id === identifier);
            if (existingIndex > -1) {
              d.series[existingIndex] = baseConfig;
            } else {
              d.series.push(baseConfig);
            }
            return d;
          });
        }
    }
  };
  $:
    chartOverrides = {
      // Evidence definition of axes (yAxis = dependent, xAxis = independent)
      xAxis: { axisTick: { alignWithLabel: false } }
    };
  return [
    chartType,
    error,
    props,
    xMin,
    xMax,
    yMin,
    yMax,
    areaColor,
    labelColor,
    border,
    borderColor,
    labelPosition,
    label,
    data,
    color,
    opacity,
    borderType,
    borderWidth,
    swapXY,
    configData,
    reqCols,
    baseConfig,
    $props
  ];
}
var ReferenceArea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance94, create_fragment94, safe_not_equal, {
      xMin: 3,
      xMax: 4,
      yMin: 5,
      yMax: 6,
      label: 12,
      data: 13,
      color: 14,
      areaColor: 7,
      opacity: 15,
      labelColor: 8,
      border: 9,
      borderColor: 10,
      borderType: 16,
      borderWidth: 17,
      labelPosition: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ReferenceArea",
      options,
      id: create_fragment94.name
    });
  }
  get xMin() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xMin(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xMax() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xMax(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMin() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMin(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yMax() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yMax(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get areaColor() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set areaColor(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelColor() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelColor(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderType() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderType(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPosition() {
    throw new Error("<ReferenceArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPosition(value) {
    throw new Error("<ReferenceArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ReferenceArea_default = ReferenceArea;

// ../../node_modules/@evidence-dev/core-components/dist/unsorted/viz/USMap.svelte
var { Error: Error_19 } = globals;
function create_else_block24(ctx) {
  let errorchart;
  let current;
  errorchart = new ErrorChart_default({
    props: {
      error: (
        /*error*/
        ctx[2]
      ),
      chartType: (
        /*chartType*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(errorchart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(errorchart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(errorchart, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const errorchart_changes = {};
      if (dirty & /*error*/
      4)
        errorchart_changes.error = /*error*/
        ctx2[2];
      errorchart.$set(errorchart_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(errorchart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(errorchart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(errorchart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block24.name,
    type: "else",
    source: "(270:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block53(ctx) {
  let echartsmap;
  let t;
  let if_block_anchor;
  let current;
  echartsmap = new EChartsMap_default({
    props: {
      config: (
        /*config*/
        ctx[3]
      ),
      data: (
        /*data*/
        ctx[0]
      ),
      hasLink: (
        /*hasLink*/
        ctx[4]
      )
    },
    $$inline: true
  });
  let if_block = (
    /*link*/
    ctx[1] && create_if_block_127(ctx)
  );
  const block = {
    c: function create() {
      create_component(echartsmap.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(echartsmap.$$.fragment, nodes);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(echartsmap, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const echartsmap_changes = {};
      if (dirty & /*config*/
      8)
        echartsmap_changes.config = /*config*/
        ctx2[3];
      if (dirty & /*data*/
      1)
        echartsmap_changes.data = /*data*/
        ctx2[0];
      echartsmap.$set(echartsmap_changes);
      if (
        /*link*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*link*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_127(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(echartsmap.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(echartsmap.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(echartsmap, detaching);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block53.name,
    type: "if",
    source: "(264:0) {#if !error}",
    ctx
  });
  return block;
}
function create_if_block_127(ctx) {
  let invisiblelinks;
  let current;
  invisiblelinks = new InvisibleLinks_default({
    props: {
      data: (
        /*data*/
        ctx[0]
      ),
      link: (
        /*link*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(invisiblelinks.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(invisiblelinks.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(invisiblelinks, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const invisiblelinks_changes = {};
      if (dirty & /*data*/
      1)
        invisiblelinks_changes.data = /*data*/
        ctx2[0];
      if (dirty & /*link*/
      2)
        invisiblelinks_changes.link = /*link*/
        ctx2[1];
      invisiblelinks.$set(invisiblelinks_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(invisiblelinks.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(invisiblelinks.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(invisiblelinks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_127.name,
    type: "if",
    source: "(267:1) {#if link}",
    ctx
  });
  return block;
}
function create_fragment95(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block53, create_else_block24];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*error*/
    ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment95.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var evidenceInclude91 = true;
function instance95($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("USMap", slots, []);
  let { data = void 0 } = $$props;
  let { state = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { min: min2 = void 0 } = $$props;
  let { max: max2 = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { fmt = void 0 } = $$props;
  let { link = void 0 } = $$props;
  let hasLink = link !== void 0;
  let chartType = "US State Map";
  let error;
  let config;
  let { colorScale = "blue" } = $$props;
  let colorArray;
  let { abbreviations = false } = $$props;
  abbreviations = abbreviations === "true" || abbreviations === true;
  let nameProperty = abbreviations ? "abbrev" : "name";
  let columnSummary;
  let format_object;
  const writable_props = [
    "data",
    "state",
    "value",
    "min",
    "max",
    "title",
    "subtitle",
    "fmt",
    "link",
    "colorScale",
    "abbreviations"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<USMap> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("state" in $$props2)
      $$invalidate(7, state = $$props2.state);
    if ("value" in $$props2)
      $$invalidate(8, value = $$props2.value);
    if ("min" in $$props2)
      $$invalidate(9, min2 = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(10, max2 = $$props2.max);
    if ("title" in $$props2)
      $$invalidate(11, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(12, subtitle = $$props2.subtitle);
    if ("fmt" in $$props2)
      $$invalidate(13, fmt = $$props2.fmt);
    if ("link" in $$props2)
      $$invalidate(1, link = $$props2.link);
    if ("colorScale" in $$props2)
      $$invalidate(14, colorScale = $$props2.colorScale);
    if ("abbreviations" in $$props2)
      $$invalidate(6, abbreviations = $$props2.abbreviations);
  };
  $$self.$capture_state = () => ({
    evidenceInclude: evidenceInclude91,
    EChartsMap: EChartsMap_default,
    ErrorChart: ErrorChart_default,
    strictBuild,
    checkInputs,
    formatTitle,
    getColumnSummary,
    colours,
    formatValue,
    getFormatObjectFromString,
    InvisibleLinks: InvisibleLinks_default,
    data,
    state,
    value,
    min: min2,
    max: max2,
    title,
    subtitle,
    fmt,
    link,
    hasLink,
    chartType,
    error,
    config,
    colorScale,
    colorArray,
    abbreviations,
    nameProperty,
    columnSummary,
    format_object
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("state" in $$props2)
      $$invalidate(7, state = $$props2.state);
    if ("value" in $$props2)
      $$invalidate(8, value = $$props2.value);
    if ("min" in $$props2)
      $$invalidate(9, min2 = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(10, max2 = $$props2.max);
    if ("title" in $$props2)
      $$invalidate(11, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(12, subtitle = $$props2.subtitle);
    if ("fmt" in $$props2)
      $$invalidate(13, fmt = $$props2.fmt);
    if ("link" in $$props2)
      $$invalidate(1, link = $$props2.link);
    if ("hasLink" in $$props2)
      $$invalidate(4, hasLink = $$props2.hasLink);
    if ("chartType" in $$props2)
      $$invalidate(5, chartType = $$props2.chartType);
    if ("error" in $$props2)
      $$invalidate(2, error = $$props2.error);
    if ("config" in $$props2)
      $$invalidate(3, config = $$props2.config);
    if ("colorScale" in $$props2)
      $$invalidate(14, colorScale = $$props2.colorScale);
    if ("colorArray" in $$props2)
      $$invalidate(15, colorArray = $$props2.colorArray);
    if ("abbreviations" in $$props2)
      $$invalidate(6, abbreviations = $$props2.abbreviations);
    if ("nameProperty" in $$props2)
      $$invalidate(18, nameProperty = $$props2.nameProperty);
    if ("columnSummary" in $$props2)
      $$invalidate(16, columnSummary = $$props2.columnSummary);
    if ("format_object" in $$props2)
      $$invalidate(17, format_object = $$props2.format_object);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorScale*/
    16384) {
      $:
        if (colorScale === "green") {
          $$invalidate(15, colorArray = [
            "#f7fcfd",
            "#e5f5f9",
            "#ccece6",
            "#99d8c9",
            "#66c2a4",
            "#41ae76",
            "#238b45",
            "#006d2c",
            "#00441b"
          ]);
        } else if (colorScale === "blue") {
          $$invalidate(15, colorArray = [
            "#f7fbff",
            "#deebf7",
            "#c6dbef",
            "#9ecae1",
            "#6baed6",
            "#4292c6",
            "#2171b5",
            "#08519c",
            "#08306b"
          ]);
        } else if (colorScale === "red") {
          $$invalidate(15, colorArray = [
            "#fff5f0",
            "#fee0d2",
            "#fcbba1",
            "#fc9272",
            "#fb6a4a",
            "#ef3b2c",
            "#cb181d",
            "#a50f15",
            "#67000d"
          ]);
        } else if (colorScale === "bluegreen") {
          $$invalidate(15, colorArray = [
            "#f7fcf0",
            "#e0f3db",
            "#ccebc5",
            "#a8ddb5",
            "#7bccc4",
            "#4eb3d3",
            "#2b8cbe",
            "#0868ac",
            "#084081"
          ]);
        }
    }
    if ($$self.$$.dirty & /*state, value, data, min, max, fmt, columnSummary, link, title, subtitle, format_object, colorArray, error*/
    245639) {
      $:
        try {
          $$invalidate(2, error = void 0);
          if (!state) {
            throw new Error("state is required");
          } else if (!value) {
            throw new Error("value is required");
          }
          checkInputs(data, [state, value]);
          let minValue = min2 ?? Math.min(...data.map((d) => d[value]));
          let maxValue = max2 ?? Math.max(...data.map((d) => d[value]));
          $$invalidate(16, columnSummary = getColumnSummary(data));
          if (fmt) {
            $$invalidate(17, format_object = getFormatObjectFromString(fmt, columnSummary[value].format));
          }
          let mapData = JSON.parse(JSON.stringify(data));
          for (let i = 0; i < data.length; i++) {
            mapData[i].name = data[i][state];
            mapData[i].value = data[i][value];
            if (link) {
              mapData[i].link = data[i][link];
            }
          }
          $$invalidate(3, config = {
            title: {
              text: title,
              subtext: subtitle,
              padding: 0,
              itemGap: 7,
              textStyle: { fontSize: 14, color: colours.grey700 },
              subtextStyle: {
                fontSize: 13,
                color: colours.grey600,
                overflow: "break"
              },
              top: "0%"
            },
            textStyle: { fontFamily: "sans-serif" },
            tooltip: {
              trigger: "item",
              showDelay: 0,
              transitionDuration: 0.2,
              confine: true,
              axisPointer: {
                // Use axis to trigger tooltip
                type: "shadow"
                // 'shadow' as default; can also be 'line' or 'shadow'
              },
              formatter(params) {
                let tooltipOutput = `
						<span id="tooltip" style='font-weight: 600;'>${params.name}</span>
						<br/>
						<span>${formatTitle(value, format_object)}: </span>
							<span style='float:right; margin-left: 10px;'>${formatValue(params.value, format_object)}</span>`;
                return tooltipOutput;
              },
              padding: 6,
              borderRadius: 4,
              borderWidth: 1,
              borderColor: colours.grey400,
              backgroundColor: "white",
              extraCssText: "box-shadow: 0 3px 6px rgba(0,0,0,.15); box-shadow: 0 2px 4px rgba(0,0,0,.12); z-index: 1;",
              textStyle: {
                color: colours.grey900,
                fontSize: 12,
                fontWeight: 400
              },
              order: "valueDesc"
            },
            visualMap: {
              top: "middle",
              min: minValue,
              max: maxValue,
              itemWidth: 15,
              show: false,
              inRange: { color: colorArray },
              text: ["High", "Low"],
              calculable: false,
              inverse: false
            },
            series: [
              {
                name: formatTitle(value, columnSummary[value].format),
                type: "map",
                zoom: 1.1,
                top: 45,
                roam: false,
                map: "US",
                nameProperty,
                itemStyle: {
                  borderColor: colours.grey400,
                  areaColor: colours.grey100
                },
                emphasis: {
                  itemStyle: { areaColor: colours.grey300 },
                  label: { show: true, color: colours.grey900 }
                },
                select: {
                  disabled: false,
                  itemStyle: { areaColor: colours.grey300 },
                  label: { color: colours.grey900 }
                },
                data: mapData
              }
            ],
            media: [
              {
                query: { maxWidth: 500 },
                option: {
                  series: [
                    {
                      top: title ? subtitle ? 48 : 32 : 25,
                      zoom: title ? subtitle ? 0.9 : 1.1 : 1.1
                    }
                  ]
                }
              },
              {
                option: {
                  series: [
                    {
                      top: title ? subtitle ? 53 : 45 : 35,
                      zoom: title ? subtitle ? 1.1 : 1.1 : 1.1
                    }
                  ]
                }
              }
            ]
          });
        } catch (e) {
          $$invalidate(2, error = e.message);
          if (strictBuild) {
            throw error;
          }
        }
    }
    if ($$self.$$.dirty & /*data, config*/
    9) {
      $:
        data, config;
    }
  };
  return [
    data,
    link,
    error,
    config,
    hasLink,
    chartType,
    abbreviations,
    state,
    value,
    min2,
    max2,
    title,
    subtitle,
    fmt,
    colorScale,
    colorArray,
    columnSummary,
    format_object
  ];
}
var USMap = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance95, create_fragment95, safe_not_equal, {
      data: 0,
      state: 7,
      value: 8,
      min: 9,
      max: 10,
      title: 11,
      subtitle: 12,
      fmt: 13,
      link: 1,
      colorScale: 14,
      abbreviations: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "USMap",
      options,
      id: create_fragment95.name
    });
  }
  get data() {
    throw new Error_19("<USMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error_19("<USMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get state() {
    throw new Error_19("<USMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set state(value) {
    throw new Error_19("<USMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error_19("<USMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error_19("<USMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error_19("<USMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error_19("<USMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error_19("<USMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error_19("<USMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error_19("<USMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error_19("<USMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error_19("<USMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error_19("<USMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fmt() {
    throw new Error_19("<USMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fmt(value) {
    throw new Error_19("<USMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error_19("<USMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error_19("<USMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorScale() {
    throw new Error_19("<USMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorScale(value) {
    throw new Error_19("<USMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get abbreviations() {
    throw new Error_19("<USMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set abbreviations(value) {
    throw new Error_19("<USMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var USMap_default = USMap;
export {
  Accordion_default as Accordion,
  AccordionItem_default as AccordionItem,
  Alert_default as Alert,
  Area_default as Area,
  AreaChart_default as AreaChart,
  Bar_default as Bar,
  BarChart_default as BarChart,
  BigLink_default as BigLink,
  BigValue_default as BigValue,
  BigqueryForm_default as BigqueryForm,
  BreadCrumbs_default as BreadCrumbs,
  Bubble_default as Bubble,
  BubbleChart_default as BubbleChart,
  BuiltInFormatGrid_default as BuiltInFormatGrid,
  CSVForm_default as CSVForm,
  Chart_default as Chart,
  ChevronToggle_default as ChevronToggle,
  CodeBlock_default as CodeBlock,
  CollapsibleSection_default as CollapsibleSection,
  CollapsibleTableSection_default as CollapsibleTableSection,
  Column_default as Column,
  CompilerToggle_default as CompilerToggle,
  ContentsList_default as ContentsList,
  CopyButton_default as CopyButton,
  CopyIcon_default as CopyIcon,
  CopySuccessIcon_default as CopySuccessIcon,
  CurrencyFormatGrid_default as CurrencyFormatGrid,
  CustomFormatGrid_default as CustomFormatGrid,
  CustomFormatsSection_default as CustomFormatsSection,
  DataTable_default as DataTable,
  DatabaseSettingsPanel_default as DatabaseSettingsPanel,
  DeploySettingsPanel_default as DeploySettingsPanel,
  Details_default as Details,
  DownloadData_default as DownloadData,
  DuckdbForm_default as DuckdbForm,
  ECharts_default as ECharts,
  EChartsMap_default as EChartsMap,
  EchartsCopyTarget_default as EchartsCopyTarget,
  EmailSignup_default as EmailSignup,
  EnvironmentVarListing_default as EnvironmentVarListing,
  ErrorChart_default as ErrorChart,
  EvidenceDeploy_default as EvidenceDeploy,
  FormattingSettingsPanel_default as FormattingSettingsPanel,
  FunnelChart_default as FunnelChart,
  GenericForm_default as GenericForm,
  Hamburger_default as Hamburger,
  Header_default as Header,
  Hist_default as Hist,
  Histogram_default as Histogram,
  InfoIcon_default as InfoIcon,
  Line_default as Line,
  LineChart_default as LineChart,
  LinkButton_default as LinkButton,
  LoadingIndicator_default as LoadingIndicator,
  Logo_default as Logo,
  MSSQLForm_default as MSSQLForm,
  Modal_default as Modal,
  MysqlForm_default as MysqlForm,
  Nav_default as Nav,
  NetlifyDeploy_default as NetlifyDeploy,
  OtherDeploy_default as OtherDeploy,
  PageMenu_default as PageMenu,
  Portal_default as Portal,
  PostgresForm_default as PostgresForm,
  Prismjs_default as Prismjs,
  PulseNumber_default as PulseNumber,
  QueryDataTable_default as QueryDataTable,
  QueryStatus_default as QueryStatus,
  QueryToast_default as QueryToast,
  QueryViewer_default as QueryViewer,
  RedshiftForm_default as RedshiftForm,
  ReferenceArea_default as ReferenceArea,
  ReferenceLine_default as ReferenceLine,
  SankeyChart_default as SankeyChart,
  SankeyDiagram_default as SankeyDiagram,
  Scatter_default as Scatter,
  ScatterPlot_default as ScatterPlot,
  SearchBar_default as SearchBar,
  Sidebar_default as Sidebar,
  SnowflakeForm_default as SnowflakeForm,
  SortIcon_default as SortIcon,
  SqliteForm_default as SqliteForm,
  Tab_default as Tab,
  TableOfContents_default as TableOfContents,
  Tabs_default as Tabs,
  TelemetrySettingsPanel_default as TelemetrySettingsPanel,
  USMap_default as USMap,
  Value_default as Value,
  VariableCopy_default as VariableCopy,
  VennDiagram_default as VennDiagram,
  VercelDeploy_default as VercelDeploy,
  VersionControlPanel_default as VersionControlPanel
};
//# sourceMappingURL=@evidence-dev_core-components.js.map
