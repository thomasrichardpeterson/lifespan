{"compilerOptions":{"css":"external","dev":true,"hydratable":true},"configFile":false,"extensions":[".svelte",".md"],"preprocess":[{"markup":"({ content: content , filename: filename  })=>{\n        if (typeof filename === \"undefined\") return;\n        if (!filename.endsWith(\"+page.md\")) return;\n        return {\n            code: $28ab45793104ed3a$var$injectPartials(content)\n        };\n    }","injectPartials":"function $28ab45793104ed3a$var$injectPartials(originalString) {\n    const r = /\\{@partial\\s+\"(.*?)\"\\s*\\}/g;\n    for (const match of originalString.matchAll(r) ?? []){\n        const filename = match[1];\n        // There is an error with parcel that prevents the use of the \"path\" library.\n        const content = $4VHRJ$readFileSync(`./partials/${filename}`).toString();\n        originalString = originalString.replace(match[0], content);\n    }\n    return originalString;\n}"},{"markup":"markup ({ content: content , filename: filename  }) {\n            if (filename.endsWith(\".md\")) {\n                let fileQueries = $adf980c58814743b$require$extractQueries(content);\n                queryIdsByFile[$adf980c58814743b$require$getRouteHash(filename)] = fileQueries.map((q)=>q.id);\n                const externalQueryViews = \"\\n\\n\\n\" + fileQueries.filter((q)=>!q.inline).map((q)=>{\n                    return $adf980c58814743b$require$highlighter(q.compiledQueryString, q.id.toLowerCase());\n                }).join(\"\\n\");\n                // Page contains frontmatter\n                const frontmatter = $adf980c58814743b$require$containsFrontmatter(content);\n                if (frontmatter) {\n                    const contentWithoutFrontmatter = content.substring(frontmatter.length + 6);\n                    const output = `---\\n${frontmatter}\\n---` + externalQueryViews + contentWithoutFrontmatter;\n                    return {\n                        code: output\n                    };\n                }\n                return {\n                    code: externalQueryViews + content\n                };\n            }\n        }","script":"script ({ content: content , filename: filename , attributes: attributes  }) {\n            if (filename.endsWith(\".md\")) {\n                if (attributes.context != \"module\") {\n                    let queryIds = queryIdsByFile[$adf980c58814743b$require$getRouteHash(filename)];\n                    return {\n                        code: $adf980c58814743b$var$createDefaultProps(filename, componentDevelopmentMode, queryIds) + content\n                    };\n                }\n            }\n        }"},{"markup":"async ({ content: content , filename: filename  })=>{\n            const extensionsParts = (extensions || [\n                extension\n            ]).map((ext)=>ext.split(\".\").pop());\n            if (!extensionsParts.includes(filename.split(\".\").pop())) return;\n            const parsed = await parser.process({\n                contents: content,\n                filename: filename\n            });\n            return {\n                code: parsed.contents,\n                data: parsed.data,\n                map: \"\"\n            };\n        }"},{"markup":"markup ({ content: content , filename: filename  }) {\n        if (filename.endsWith(\".md\")) {\n            if (!content.match(/\\<script(.*)\\>/)) return {\n                code: '<script context=\"module\"> </script><script> </script>' + content\n            };\n            if (!content.match(/\\<script(.*)context\\=\\\"module\\\"(.*)\\>/)) return {\n                code: '<script context=\"module\"> </script>' + content\n            };\n            if (!content.match(/\\<script\\>/)) return {\n                code: \"<script> </script>\" + content\n            };\n        }\n    }"},{"markup":"({ content: content , filename: filename  })=>{\n            if (typeof filename === \"undefined\") return;\n            if (!filename.endsWith(\"+page.md\")) return;\n            if (!handleOgContent) handleOgContent = (parcelRequire(\"dHrn8\"));\n            return {\n                code: handleOgContent + content\n            };\n        }","script":"({ content: content , filename: filename , attributes: attributes  })=>{\n            if (typeof filename === \"undefined\") return;\n            if (attributes.context !== \"module\") return;\n            if (!filename.endsWith(\"+page.md\")) return;\n            if (!content.includes(\"export const metadata =\")) // There is no frontmatter, and we want to make sure that it as at least defined.\n            // Technically this won't _break_ things, just spam the logs with a vite warning.\n            return {\n                code: content + \";const metadata = undefined;\"\n            };\n            else // exporting makes tailwind break HMR\n            return {\n                code: content.replace(\"export const metadata =\", \"const metadata =\")\n            };\n        }"},{"markup":"async ({ content: content , filename: filename  })=>{\n            const components = await componentPlugins.catch(()=>false);\n            if (!components) return;\n            const { markup: autoimport_process_markup  } = await autoImporter;\n            return autoimport_process_markup({\n                content: content,\n                filename: filename\n            });\n        }","style":"async ()=>{}","script":"async ()=>{}"},{"markup":"async ({ content, filename }) => {\n        if (transformers.replace) {\n            const transformed = await (0, exports.transform)('replace', transformers.replace, {\n                content,\n                markup: content,\n                filename,\n            });\n            content = transformed.code;\n        }\n        return (0, markup_1.transformMarkup)({ content, filename }, markupTransformer, {\n            // we only pass the markupTagName because the rest of options\n            // is fetched internally by the `markupTransformer`\n            markupTagName,\n        });\n    }","script":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await scriptTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies, diagnostics } = transformResult;\n        if (transformers.babel) {\n            const transformed = await (0, exports.transform)('babel', getTransformerOptions('babel'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n            dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            diagnostics = (0, utils_1.concat)(diagnostics, transformed.diagnostics);\n        }\n        return { code, map, dependencies, diagnostics };\n    }","style":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await cssTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies } = transformResult;\n        const hasPostcss = await (0, utils_1.hasDepInstalled)('postcss');\n        // istanbul ignore else\n        if (hasPostcss) {\n            if (transformers.postcss) {\n                const { alias, lang } = (0, language_1.getLanguage)(attributes);\n                const postcssOptions = getTransformerOptions('postcss', (0, language_1.isAliasOf)(alias, lang) ? alias : null, \n                // todo: this seems wrong and ugly\n                { ignoreAliasOverride: true });\n                const transformed = await (0, exports.transform)('postcss', postcssOptions, {\n                    content: code,\n                    markup: fullMarkup,\n                    map,\n                    filename,\n                    attributes,\n                });\n                code = transformed.code;\n                map = transformed.map;\n                dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            }\n            const transformed = await (0, exports.transform)('globalStyle', getTransformerOptions('globalStyle'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n        }\n        else if ('global' in attributes) {\n            console.warn(`[svelte-preprocess] 'global' attribute found, but 'postcss' is not installed. 'postcss' is used to walk through the CSS and transform any necessary selector.`);\n        }\n        return { code, map, dependencies };\n    }"},{"script":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+page.') || basename.startsWith('+layout.')) {\n\t\t\tconst match = content.match(options_regex);\n\t\t\tif (match) {\n\t\t\t\tconst fixed = basename.replace('.svelte', '(.server).js/ts');\n\n\t\t\t\tconst message =\n\t\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t\t`\\`${match[1]}\\` will be ignored — move it to ${fixed} instead. See https://kit.svelte.dev/docs/page-options for more information.`;\n\n\t\t\t\tif (!warned.has(message)) {\n\t\t\t\t\tconsole.log(message);\n\t\t\t\t\twarned.add(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","markup":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+layout.') && !content.includes('<slot')) {\n\t\t\tconst message =\n\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t'`<slot />` missing — inner content will not be rendered';\n\n\t\t\tif (!warned.has(message)) {\n\t\t\t\tconsole.log(message);\n\t\t\t\twarned.add(message);\n\t\t\t}\n\t\t}\n\t}"}]}