{"mappings":"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","sources":["src/index.js","src/build-plugins/preprocess.js","src/component-resolution/get-plugin-components.js","src/plugin-discovery/index.js","src/plugin-discovery/get-root-modules.js","src/plugin-discovery/resolve-evidence-config.js","src/plugin-discovery/schemas/evidence-config.schema.js","src/plugin-discovery/is-valid-package.js","src/plugin-discovery/schemas/evidence-package.schema.js","src/lib/clean-zod-errors.js","src/component-resolution/get-components-for-package.js","src/component-resolution/loaders/manifest-loader.js","src/component-resolution/schemas/component-manifest.schema.js","src/component-resolution/loaders/file-loader.js","src/build-plugins/rollup.js"],"sourcesContent":["export * from './build-plugins/preprocess';\nexport * from './build-plugins/rollup';\n","import { getPluginComponents } from '../component-resolution/get-plugin-components';\nimport autoImport from 'sveltekit-autoimport';\n\n/**\n * @type {() => import(\"svelte/types/compiler/preprocess\").PreprocessorGroup}\n */\nexport const evidencePlugins = () => {\n\tconst componentPlugins = getPluginComponents();\n\n\tconst packages = componentPlugins.then((components) => {\n\t\t/** @type {Record<string,string[]>} */\n\t\tconst packages = {};\n\t\tfor (const [component, data] of Object.entries(components)) {\n\t\t\tif (!packages[data.package]) packages[data.package] = [];\n\t\t\tconst import_name = data.aliasOf ? `${data.aliasOf} as ${component}` : component;\n\t\t\tpackages[data.package].push(import_name);\n\t\t}\n\t\treturn packages;\n\t});\n\n\tconst autoImporter = packages.then((packages) =>\n\t\tautoImport({\n\t\t\tinclude: ['**/*.(svelte|md)'],\n\t\t\tmodule: packages,\n\t\t\tcomponents: [{ directory: '../../components', flat: true }]\n\t\t})\n\t);\n\n\treturn {\n\t\t/** @type {import(\"svelte/types/compiler/preprocess\").MarkupPreprocessor}} */\n\t\tmarkup: async ({ content, filename }) => {\n\t\t\tconst components = await componentPlugins.catch(() => false);\n\t\t\tif (!components) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { markup: autoimport_process_markup } = await autoImporter;\n\n\t\t\treturn autoimport_process_markup({ content, filename });\n\t\t},\n\t\t/** @type {import(\"svelte/types/compiler/preprocess\").Preprocessor}} */\n\t\tstyle: async () => {},\n\t\t/** @type {import(\"svelte/types/compiler/preprocess\").Preprocessor}} */\n\t\tscript: async () => {}\n\t};\n};\n","import { discoverEvidencePlugins } from '../plugin-discovery';\nimport { getComponentsForPackage } from './get-components-for-package';\nimport { loadConfig } from '../plugin-discovery/resolve-evidence-config';\nimport { getRootModules } from '../plugin-discovery/get-root-modules';\nimport chalk from 'chalk';\nimport { findSvelteComponents } from './loaders/file-loader';\nimport fs from 'fs';\nimport path from 'path';\n\n/**\n * @param {EvidenceConfig} [cfg]\n * @param {PackageDiscoveryResult} [discoveries] Optional: Pass in already discovered plugins\n * @returns {Promise<PluginComponents>}\n */\nexport async function getPluginComponents(cfg, discoveries) {\n\tconst rootDir = await getRootModules();\n\n\tconst config = cfg ?? (await loadConfig(rootDir));\n\n\tconst pluginDiscoveries = discoveries ?? (await discoverEvidencePlugins());\n\n\tObject.values(config.components).reduce(\n\t\t/**\n\t\t * @param {Set<string>} acc\n\t\t * @param {EvidenceComponentConfig} v\n\t\t */\n\t\t(acc, v) => {\n\t\t\tfor (const override of v.overrides) {\n\t\t\t\tif (acc.has(override)) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\tchalk.red(\n\t\t\t\t\t\t\t`[!] ${override} is overriden more than once. Please ensure that a component is overriden only once.`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tthrow new Error('Invalid evidence.plugins.yaml');\n\t\t\t\t}\n\t\t\t\tacc.add(override);\n\t\t\t}\n\t\t\treturn acc;\n\t\t},\n\t\tnew Set()\n\t);\n\n\t// Load all the components\n\tconst components = await Promise.all(\n\t\tpluginDiscoveries.components.map(\n\t\t\t/**\n\t\t\t * @param {EvidencePluginPackage<ValidPackage>} pluginPackage\n\t\t\t * @returns {Promise<[string, Set<string>]>}\n\t\t\t */\n\t\t\tasync (pluginPackage) => [\n\t\t\t\tpluginPackage.package.name,\n\t\t\t\tawait getComponentsForPackage(\n\t\t\t\t\trootDir,\n\t\t\t\t\tpluginPackage.path,\n\t\t\t\t\tconfig.components[pluginPackage.package.name]\n\t\t\t\t)\n\t\t\t]\n\t\t)\n\t);\n\n\t// Now we will smush all of this into Record<ComponentName, PackageName>\n\tconst componentMap = components.reduce(\n\t\t/**\n\t\t * @param {PluginComponents} acc\n\t\t * @param {[string, Set<string>]} p\n\t\t */\n\t\t(acc, [packageName, components]) => {\n\t\t\t/** @type {EvidenceComponentConfig} */\n\t\t\tconst packageConfig = config.components[packageName];\n\t\t\tfor (const component of components) {\n\t\t\t\t/** @type {PluginComponent} */\n\t\t\t\tconst componentObj = { package: packageName };\n\n\t\t\t\tconst alias = packageConfig.aliases[component];\n\n\t\t\t\tif (alias) {\n\t\t\t\t\tcomponentObj.aliasOf = component;\n\t\t\t\t}\n\n\t\t\t\tconst componentOutputName = alias ?? component;\n\n\t\t\t\tif (acc[componentOutputName] && !packageConfig.overrides.includes(componentOutputName)) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\tchalk.yellow(\n\t\t\t\t\t\t\t`[!] ${packageName} and ${acc[componentOutputName].package} both provide ${componentOutputName}. ${acc[componentOutputName].package} will be used, to use ${packageName}, specify an alias or explicit override. (https://docs.evidence.dev/plugins#component-aliases)`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\treturn acc;\n\t\t\t\t}\n\n\t\t\t\tif (packageConfig.overrides?.includes(componentOutputName)) {\n\t\t\t\t\tif (!acc[componentOutputName]) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\tchalk.yellow(\n\t\t\t\t\t\t\t\t`[!] ${packageName} cannot override it's own component ${componentOutputName}`\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomponentObj.overriden = {\n\t\t\t\t\t\t\tpackage: acc[componentOutputName].package\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tacc[componentOutputName] = componentObj;\n\t\t\t}\n\t\t\treturn acc;\n\t\t},\n\t\t{}\n\t);\n\n\tif (fs.existsSync(`${rootDir}/components`)) {\n\t\tconst user_components = await findSvelteComponents(`${rootDir}/components`);\n\t\tfor (const component_file of user_components) {\n\t\t\tconst component = path.basename(component_file, '.svelte');\n\t\t\tif (componentMap[component]) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\tchalk.yellow(\n\t\t\t\t\t\t`[!] The components folder and ${componentMap[component].package} both provide ${component}. The component from the components folder will be used. To use the component from ${componentMap[component].package}, specify an alias (https://docs.evidence.dev/plugins/using-plugins/#component-aliases) or explicitly import the component.`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tdelete componentMap[component];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn componentMap;\n}\n","import { getRootModules } from './get-root-modules';\nimport { resolveEvidencePackages } from './resolve-evidence-config';\n\n/**\n * @returns {Promise<PackageDiscoveryResult>}\n * @this {void}\n */\nexport async function discoverEvidencePlugins() {\n\tconst rootDir = await getRootModules();\n\n\treturn await resolveEvidencePackages(rootDir);\n}\n","import path from 'path';\nimport fs from 'fs/promises';\n\n/**\n * @param {string} p\n * @returns {Promise<boolean>}\n */\nconst hasNodeModules = async (p) => {\n\tconst directoryItems = await fs.readdir(p);\n\treturn directoryItems.includes('node_modules');\n};\n\n/**\n * Attempts to find the highest, project-scoped node_modules filepath.\n * Note that this behavior _should_ remain the same regardless of where this is run from\n * Locally installed (\"linked\") packages and regularly installed packages should return the same value.\n * @param {string | undefined} [startingPoint]\n * @returns {Promise<string>}\n */\nexport const getRootModules = async (startingPoint) => {\n\t// Either use the entry file or a specific startingPoint\n\tconst entryFile = startingPoint ?? process.cwd();\n\t// Split the entryfile path on \"node_modules\", this will help if the main file is nested\n\t// e.g. if sveltekit, main file will be node_modules/@sveltejs/kit/node_modules\n\t// node_modules/.pnpm/vite@4.0.4/node_modules/vite/bin/vite.js\n\tconst parsedPath = path.parse(entryFile.split('/node_modules')[0]);\n\tlet p = `${parsedPath.dir}/${parsedPath.base}`;\n\tconst initP = p;\n\tconst stat = await fs.stat(p);\n\tif (stat.isFile()) p = path.parse(p).dir;\n\n\twhile (!(await hasNodeModules(p))) {\n\t\tif (p === path.parse(p).root) {\n\t\t\tthrow new Error(`Could not locate node_modules! ${JSON.stringify({ startingPoint, initP })}`);\n\t\t}\n\t\tp = path.parse(p).dir;\n\t}\n\n\treturn p;\n};\n","import chalk from 'chalk';\nimport fs from 'fs/promises';\nimport yaml from 'yaml';\nimport { EvidenceConfigSchema } from './schemas/evidence-config.schema';\nimport { isValidPackage } from './is-valid-package';\nimport { cleanZodErrors } from '../lib/clean-zod-errors';\nimport path from 'path';\n\n/**\n *\n * @param {string} rootDir\n * @returns {Promise<EvidenceConfig>}\n */\nexport const loadConfig = async (rootDir) => {\n\tconst configPath = `${rootDir}/evidence.plugins.yaml`;\n\ttry {\n\t\tconst configFileContent = await fs.readFile(configPath, 'utf8').then((r) => r.toString());\n\t\t// Surround all YAML key that begin with \"@\" in quotes\n\t\t// Skipping keys that are already quoted (e.g. beginning of line or whitespace)\n\t\tconst rawConfig = yaml.parse(configFileContent.replaceAll(/($|\\s)(@.+):/g, '$1\"$2\":'));\n\n\t\tconst configResult = EvidenceConfigSchema.safeParse(rawConfig);\n\t\tif (!configResult.success) {\n\t\t\tconsole.error(\n\t\t\t\tchalk.bold.red(\n\t\t\t\t\t`[!] evidence.plugins.yaml does not contain a valid configuration. \\n    Plugins will not be loaded. This may lead to unexpected behavior.`\n\t\t\t\t)\n\t\t\t);\n\t\t\tconst formattedError = cleanZodErrors(configResult.error.format());\n\t\t\tconsole.error(chalk.red('|   Discovered Errors:'));\n\t\t\tconst redPipe = chalk.red('|');\n\t\t\tconsole.error(\n\t\t\t\t`${redPipe}   ${yaml.stringify(formattedError).replace(/\\n/g, `\\n${redPipe}   `)}`\n\t\t\t);\n\t\t\tthrow new Error('Invalid evidence.plugins.yaml');\n\t\t}\n\n\t\treturn configResult.data;\n\t} catch (e) {\n\t\tif (!(e instanceof Error)) throw e;\n\t\tif (e.message.startsWith('ENOENT')) {\n\t\t\tconsole.warn('Could not find evidence plugins file. Using defaults.');\n\t\t\treturn EvidenceConfigSchema.parse({\n\t\t\t\tcomponents: {\n\t\t\t\t\t'@evidence-dev/core-components': {}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthrow e;\n\t}\n};\n\n/**\n * Leverages evidence.plugins.yaml to resolve plugins\n * @param {string} rootDir\n * @returns {Promise<PackageDiscoveryResult>}\n */\nexport const resolveEvidencePackages = async (rootDir) => {\n\t/** @type {EvidenceConfig} */\n\tconst configContent = await loadConfig(rootDir);\n\n\t/** @type {EvidencePluginPackage<ValidPackage>[]} */\n\tconst componentPackages = await Promise.all(\n\t\tObject.keys(configContent.components).map(\n\t\t\t/**\n\t\t\t * @param {string} packageName\n\t\t\t * @returns {Promise<EvidencePluginPackage<ValidPackage> | false>}\n\t\t\t */\n\t\t\tasync (packageName) => {\n\t\t\t\tconst packagePath = path.resolve(rootDir, 'node_modules', packageName);\n\t\t\t\tconst validPackage = await isValidPackage(packagePath);\n\t\t\t\tif (!validPackage) return false;\n\t\t\t\treturn {\n\t\t\t\t\tpackage: validPackage,\n\t\t\t\t\tpath: packagePath\n\t\t\t\t};\n\t\t\t}\n\t\t)\n\t).then((pack) => /** @type {Exclude<typeof pack[number], false>[]} */ (pack.filter(Boolean)));\n\n\treturn {\n\t\tcomponents: componentPackages,\n\t\tdatabases: []\n\t};\n};\n","import { z } from 'zod';\n\nexport const EvidenceComponentConfigSchema = z.object({\n\toverrides: z.array(z.string()).default([]),\n\taliases: z\n\t\t.record(\n\t\t\tz.string({ description: 'Component Name' }),\n\t\t\tz.string({ description: 'Alias to apply' })\n\t\t)\n\t\t.default({}),\n\n\tprovides: z.array(z.string()).default([])\n});\n\nexport const EvidenceConfigSchema = z\n\t.object({\n\t\tcomponents: z.record(z.string(), EvidenceComponentConfigSchema)\n\t})\n\t.nonstrict();\n","import chalk from 'chalk';\nimport { ValidPackageSchema } from './schemas/evidence-package.schema';\nimport fs from 'fs/promises';\n/**\n * Checks a directory to see if it is a package\n * and if it is a package, if it includes\n * the evidence block that marks it as a plugin\n * @param {string} path\n * @returns {Promise<false | ValidPackage>}\n */\nexport const isValidPackage = async (path) => {\n\ttry {\n\t\tconst s = await fs.stat(path);\n\t\tif (!s.isDirectory()) return false;\n\t} catch (e) {\n\t\tif (e instanceof Error && /** @type{NodeJS.ErrnoException} */ (e).code !== 'ENOENT') {\n\t\t\tconsole.warn(\n\t\t\t\tchalk.yellow(\n\t\t\t\t\t`[!] An error occured while loading ${chalk.bold(\n\t\t\t\t\t\t`\"${path.split('node_modules/')[1]}\"`\n\t\t\t\t\t)}: ${e}.`\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\tchalk.yellow(\n\t\t\t\t\t`[!] ${chalk.bold(\n\t\t\t\t\t\t`\"${path.split('node_modules/')[1]}\"`\n\t\t\t\t\t)} could not be found in your node_modules. Check for spelling errors or try running npm install.`\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\n\tconst c = await fs.readdir(path);\n\tif (!c.includes('package.json')) return false;\n\n\tconst packageContent = await fs.readFile(`${path}/package.json`).then(\n\t\t/** @param {Buffer} fileContent */\n\t\t(fileContent) => JSON.parse(fileContent.toString())\n\t);\n\tconst zodResult = ValidPackageSchema.safeParse(packageContent);\n\tif (zodResult.success) return zodResult.data;\n\telse {\n\t\tconsole.warn(\n\t\t\tchalk.yellow(\n\t\t\t\t`[!] ${chalk.bold(\n\t\t\t\t\t`\"${path.split('node_modules/')[1]}\"`\n\t\t\t\t)} could not be loaded as a plugin, it is missing a name or main field.`\n\t\t\t)\n\t\t);\n\t\treturn false;\n\t}\n};\n","import { z } from 'zod';\n\nconst PackageExportSchema = z.union([\n\tz.object({ main: z.string() }, { description: 'Use the main field of the package.json' }),\n\tz.object(\n\t\t{ exports: z.object({ '.': z.string() }) },\n\t\t{ description: 'Use the exports field of the package.json' }\n\t),\n\tz.object({ svelte: z.string() }, { description: 'Use the svelte field of the package.json' })\n]);\n\nconst BasePackageSchema = z.object({\n\tname: z.string(),\n\tevidence: z.undefined()\n});\n\nexport const GenericPackageSchema = z.intersection(BasePackageSchema, PackageExportSchema);\n\nexport const EvidencePackageSchema = z.intersection(\n\tBasePackageSchema.extend({\n\t\tevidence: z.object({\n\t\t\tcomponents: z.boolean().optional(),\n\t\t\tdatabases: z.array(z.string()).optional()\n\t\t})\n\t}),\n\tPackageExportSchema\n);\n\nexport const ValidPackageSchema = z.union([GenericPackageSchema, EvidencePackageSchema]);\n","/**\n * Renames the '_errors' property to 'errors' in the given object and its nested objects recursively.\n * It also removes any empty errors arrays\n *\n * @param {any} obj - The object to rename the '_errors' property in.\n * @return {Object} The object with the renamed property.\n */\nexport function cleanZodErrors(obj) {\n\tfor (const key in obj) {\n\t\tif (typeof obj[key] === 'object') {\n\t\t\tcleanZodErrors(obj[key]); // recursively traverse nested objects\n\t\t}\n\t\tif (key === '_errors') {\n\t\t\tif (obj['_errors'].length) {\n\t\t\t\tobj['errors'] = obj['_errors'];\n\t\t\t}\n\t\t\tdelete obj['_errors'];\n\t\t}\n\t}\n\treturn obj;\n}\n","import fs from 'fs/promises';\nimport chalk from 'chalk';\nimport path from 'path';\nimport { isValidPackage } from '../plugin-discovery/is-valid-package';\nimport { manifestLoader } from './loaders/manifest-loader';\nimport { fileLoader } from './loaders/file-loader';\n\n/**\n * Loads components from a package, given a root directory, package name, and configuration.\n *\n * @param {string} rootDir - The root directory for the package.\n * @param {string} packagePath\n * @param {EvidenceComponentConfig} config\n * @return {Promise<Set<string>>} An array containing the package name and a set of component names.\n */\nexport const getComponentsForPackage = async (rootDir, packagePath, config) => {\n\tconst validEvidencePackage = await isValidPackage(packagePath);\n\n\t/** @type {Set<string>} */\n\tconst providedComponents = new Set();\n\n\t// This doesn't have the required metadata\n\tif (!validEvidencePackage) return providedComponents;\n\n\t// This is a database connector, not a component lib\n\tif (validEvidencePackage.evidence && !validEvidencePackage.evidence.components) {\n\t\tconsole.warn(\n\t\t\tchalk.yellow(\n\t\t\t\t`[!] ${validEvidencePackage.name} is being used as a component plugin, but does not contain components.`\n\t\t\t)\n\t\t);\n\t\treturn providedComponents;\n\t}\n\n\tif (config.provides.length) {\n\t\t// Use this value as the first truth\n\t\tconfig.provides.forEach((c) => providedComponents.add(c));\n\t} else if (!validEvidencePackage.evidence) {\n\t\t// This is probably an external component library that doesn't have any provides statements\n\t\tconsole.warn(\n\t\t\tchalk.yellow(\n\t\t\t\t`[!] ${validEvidencePackage.name} is being used as a component plugin, but does not contain plugins. You may need to add a provides statement to your manifest.`\n\t\t\t)\n\t\t);\n\t\treturn providedComponents;\n\t} else {\n\t\tconst manifestPath = path.resolve(packagePath, 'evidence.manifest.yaml');\n\t\tconst manifestExists = await fs\n\t\t\t.access(manifestPath)\n\t\t\t.then(() => true)\n\t\t\t.catch(() => false);\n\n\t\tif (manifestExists) {\n\t\t\t// Use manifest\n\t\t\tconst manifestComponents = await manifestLoader(packagePath, rootDir);\n\t\t\tmanifestComponents.forEach((c) => providedComponents.add(c));\n\t\t} else {\n\t\t\t// Use file discovery\n\n\t\t\t// Attempt to extract the folder that contains built assets\n\t\t\tconst mainFilePath = path.parse(\n\t\t\t\t'main' in validEvidencePackage\n\t\t\t\t\t? path.resolve(packagePath, validEvidencePackage.main)\n\t\t\t\t\t: 'svelte' in validEvidencePackage\n\t\t\t\t\t? path.resolve(packagePath, validEvidencePackage.svelte)\n\t\t\t\t\t: path.resolve(packagePath, validEvidencePackage.exports['.'])\n\t\t\t).dir;\n\n\t\t\tconst fileComponents = await fileLoader(mainFilePath);\n\t\t\tfileComponents.forEach((c) => providedComponents.add(c));\n\t\t}\n\t}\n\n\treturn providedComponents;\n};\n","import fs from 'fs/promises';\nimport chalk from 'chalk';\nimport path from 'path';\nimport yaml from 'yaml';\nimport { cleanZodErrors } from '../../lib/clean-zod-errors';\nimport { ComponentManifestSchema } from '../schemas/component-manifest.schema';\n\n/**\n * @param {string} packagePath\n * @param {string} rootDir\n *\n * @returns {Promise<string[]>}\n */\nexport async function manifestLoader(packagePath, rootDir) {\n\ttry {\n\t\t// Load Config\n\t\tconst manifestContent = await fs\n\t\t\t.readFile(path.resolve(packagePath, 'evidence.manifest.yaml'))\n\t\t\t.then((r) => r.toString());\n\t\t// Parse YAML, then validate data\n\t\tconst manifest = yaml.parse(manifestContent);\n\t\tconst parsedManifest = ComponentManifestSchema.safeParse(manifest);\n\n\t\tif (!parsedManifest.success) {\n\t\t\t// Shape is wrong\n\t\t\tconsole.error(chalk.bold.red(`[!] evidence.manifest.yaml has errors`));\n\t\t\tconst formattedError = cleanZodErrors(parsedManifest.error.format());\n\t\t\tconsole.error(chalk.red('|   Discovered Errors:'));\n\t\t\tconst redPipe = chalk.red('|');\n\t\t\tconsole.error(\n\t\t\t\t`${redPipe}   ${yaml.stringify(formattedError).replace(/\\n/g, `\\n${redPipe}   `)}`\n\t\t\t);\n\n\t\t\t// TODO: How do we stop here? Do we need to throw here?\n\t\t\tthrow new Error('Unable to load evidence manifest');\n\t\t}\n\n\t\treturn parsedManifest.data.components;\n\t} catch (e) {\n\t\tif (!(e instanceof Error)) throw e;\n\t\tif (e.message === 'ENOENT') {\n\t\t\tconsole.error(\n\t\t\t\tchalk.red.bold(\n\t\t\t\t\t`[!] evidence.manifest.yaml file not found in ${rootDir}.\\n    This is probably a bug in Evidence; please file a report at https://github.com/evidence-dev/evidence/issues/new?assignees=&labels=bug%2C+to-review&projects=&template=bug_report.md`\n\t\t\t\t)\n\t\t\t);\n\t\t\tthrow e;\n\t\t}\n\t\tthrow e;\n\t}\n}\n","import { z } from 'zod';\n\nexport const ComponentManifestSchema = z.object({\n\tcomponents: z.array(z.string())\n});\n","import fs from 'fs/promises';\nimport path from 'path';\nimport { parse as svelteParse } from 'svelte/compiler';\n\n/**\n * Searches recursively within a directory for svelte files\n * Ignores anything beginning with . (hidden) or + (special sveltekit files)\n *\n * @param {string} root\n * @returns {Promise<string[]>}\n */\nexport const findSvelteComponents = async (root) => {\n\t/**\n\t * @type {string[]}\n\t */\n\tconst output = [];\n\t// Scan & iterate directory\n\tconst directoryContents = await fs.readdir(root, { withFileTypes: true });\n\tfor (const item of directoryContents) {\n\t\t// Ignore these cases\n\t\tif (item.name === 'node_modules') continue; // Don't touch any dependencies\n\t\tif (item.name.startsWith('.')) continue; // Don't touch hidden files\n\t\tif (item.name.startsWith('+')) continue; // Don't touch sveltekit files\n\n\t\t// Build path; get item stats\n\t\tconst itemPath = path.resolve(root, item.name);\n\n\t\tif (item.isDirectory()) {\n\t\t\t// Recurse on directories\n\t\t\toutput.push(...(await findSvelteComponents(itemPath)));\n\t\t} else if (item.name.endsWith('.svelte')) {\n\t\t\t// Keep track of svelte components\n\t\t\toutput.push(itemPath);\n\t\t}\n\t}\n\n\t// Return relative filepaths\n\treturn output.map((p) => path.relative('.', p));\n};\n\n/**\n * Reduce function to run on a svelte AST.\n * Searches for the evidenceInclude declaration.\n * @example\n *  <script context=\"module\">\n *      export const evidenceInclude = true\n *  </script>\n *\n * @param {import(\"estree\").Node} currentNode\n * @returns {boolean}\n */\nconst nodeIsEvidenceDeclaration = (currentNode) => {\n\t// If this isn't the right kind of declaration, ignore it\n\tif (currentNode.type !== 'ExportNamedDeclaration') return false;\n\n\tconst rootDeclaration = currentNode.declaration;\n\n\tif (rootDeclaration?.type !== 'VariableDeclaration') return false;\n\n\t// const only, this is somewhat inline with sveltekit's patterns\n\tif (rootDeclaration.kind !== 'const') return false;\n\n\t// This shouldn't be hit, but type safety\n\tif (!rootDeclaration?.declarations) return false;\n\n\t// Iterate through sub-declarations, I've only ever seen 1 here\n\tfor (const declaration of rootDeclaration.declarations) {\n\t\tconst { id, init } = declaration;\n\t\t// Check to see if this is a declaration for evidenceInclude\n\t\tif (id.type !== 'Identifier') continue;\n\t\tif (id.name !== 'evidenceInclude') continue;\n\t\t// Check to see if the value it is declared with is a true constant\n\t\t// We could shorten this; but this reads better\n\t\tif (init?.type !== 'Literal') continue;\n\t\tif (init.value !== true) continue;\n\t\t// We found what we want!\n\t\treturn true;\n\t}\n\t// We never found the right declaration; continue the reduction\n\treturn false;\n};\n\n/**\n * Generates an AST and searches it for the special declaration\n * @param {string} fileContent\n */\nexport const isLibraryComponent = async (fileContent) => {\n\tlet result = false;\n\n\t// remove style tags, postcss can screw this up\n\tfileContent = fileContent.replace(/<style.*>(.|[\\s])*<\\/style>/g, '');\n\t// First parse the passed in file\n\tconst parseResult = svelteParse(fileContent);\n\t// If there is a <script> tag, check there\n\tif (parseResult.instance) {\n\t\tresult = result || Boolean(parseResult.instance.content.body.find(nodeIsEvidenceDeclaration));\n\t}\n\t// If there is a <script context=\"module\"> tag, check there\n\tif (parseResult.module) {\n\t\tresult = result || Boolean(parseResult.module.content.body.find(nodeIsEvidenceDeclaration));\n\t}\n\treturn result;\n};\n\n/**\n * @param {string} rootDir\n *\n * @returns {Promise<string[]>}\n */\nexport async function fileLoader(rootDir) {\n\tconst componentPaths = await findSvelteComponents(rootDir);\n\tconst results = await Promise.all(\n\t\tcomponentPaths.map(async (componentPath) => ({\n\t\t\tinclude: await isLibraryComponent(\n\t\t\t\tawait fs.readFile(componentPath).then((p) => p.toString())\n\t\t\t).catch((e) => {\n\t\t\t\tthrow new Error(`Error while identifying ${componentPath}`, { cause: e });\n\t\t\t}),\n\t\t\t// Get the name of the component, takes the last part of the path and removes the file extension\n\t\t\tcomponentName: path.basename(componentPath, path.extname(componentPath))\n\t\t}))\n\t);\n\n\treturn results.filter((r) => r.include).map((r) => r.componentName);\n}\n","/**\n *\n */\nexport function evidenceRollup() {\n\tthrow new Error('Evidence Rollup Plugin not implemented');\n}\n"],"names":[],"version":3,"file":"index.mjs.map","sourceRoot":"../"}