var $7jHWQ$sveltekitautoimport = require("sveltekit-autoimport");
var $7jHWQ$chalk = require("chalk");
var $7jHWQ$fs = require("fs");
var $7jHWQ$path = require("path");
var $7jHWQ$fspromises = require("fs/promises");
var $7jHWQ$yaml = require("yaml");
var $7jHWQ$zod = require("zod");
var $7jHWQ$sveltecompiler = require("svelte/compiler");

function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $47ed4bd10d97bb7e$exports = {};

$parcel$export($47ed4bd10d97bb7e$exports, "evidencePlugins", () => $47ed4bd10d97bb7e$export$4afb816e967c52c1);


/**
 * @param {string} p
 * @returns {Promise<boolean>}
 */ const $3c04bbba5863cd35$var$hasNodeModules = async (p)=>{
    const directoryItems = await (0, ($parcel$interopDefault($7jHWQ$fspromises))).readdir(p);
    return directoryItems.includes("node_modules");
};
const $3c04bbba5863cd35$export$6de9f17ef8a8b7d7 = async (startingPoint)=>{
    // Either use the entry file or a specific startingPoint
    const entryFile = startingPoint ?? process.cwd();
    // Split the entryfile path on "node_modules", this will help if the main file is nested
    // e.g. if sveltekit, main file will be node_modules/@sveltejs/kit/node_modules
    // node_modules/.pnpm/vite@4.0.4/node_modules/vite/bin/vite.js
    const parsedPath = (0, ($parcel$interopDefault($7jHWQ$path))).parse(entryFile.split("/node_modules")[0]);
    let p = `${parsedPath.dir}/${parsedPath.base}`;
    const initP = p;
    const stat = await (0, ($parcel$interopDefault($7jHWQ$fspromises))).stat(p);
    if (stat.isFile()) p = (0, ($parcel$interopDefault($7jHWQ$path))).parse(p).dir;
    while(!await $3c04bbba5863cd35$var$hasNodeModules(p)){
        if (p === (0, ($parcel$interopDefault($7jHWQ$path))).parse(p).root) throw new Error(`Could not locate node_modules! ${JSON.stringify({
            startingPoint: startingPoint,
            initP: initP
        })}`);
        p = (0, ($parcel$interopDefault($7jHWQ$path))).parse(p).dir;
    }
    return p;
};






const $42ff7a256bb4288a$export$797917169e2ec068 = (0, $7jHWQ$zod.z).object({
    overrides: (0, $7jHWQ$zod.z).array((0, $7jHWQ$zod.z).string()).default([]),
    aliases: (0, $7jHWQ$zod.z).record((0, $7jHWQ$zod.z).string({
        description: "Component Name"
    }), (0, $7jHWQ$zod.z).string({
        description: "Alias to apply"
    })).default({}),
    provides: (0, $7jHWQ$zod.z).array((0, $7jHWQ$zod.z).string()).default([])
});
const $42ff7a256bb4288a$export$e691085fbd9bf5be = (0, $7jHWQ$zod.z).object({
    components: (0, $7jHWQ$zod.z).record((0, $7jHWQ$zod.z).string(), $42ff7a256bb4288a$export$797917169e2ec068)
}).nonstrict();




const $23df05604d36dcc5$var$PackageExportSchema = (0, $7jHWQ$zod.z).union([
    (0, $7jHWQ$zod.z).object({
        main: (0, $7jHWQ$zod.z).string()
    }, {
        description: "Use the main field of the package.json"
    }),
    (0, $7jHWQ$zod.z).object({
        exports: (0, $7jHWQ$zod.z).object({
            ".": (0, $7jHWQ$zod.z).string()
        })
    }, {
        description: "Use the exports field of the package.json"
    }),
    (0, $7jHWQ$zod.z).object({
        svelte: (0, $7jHWQ$zod.z).string()
    }, {
        description: "Use the svelte field of the package.json"
    })
]);
const $23df05604d36dcc5$var$BasePackageSchema = (0, $7jHWQ$zod.z).object({
    name: (0, $7jHWQ$zod.z).string(),
    evidence: (0, $7jHWQ$zod.z).undefined()
});
const $23df05604d36dcc5$export$a14d030d75ef573c = (0, $7jHWQ$zod.z).intersection($23df05604d36dcc5$var$BasePackageSchema, $23df05604d36dcc5$var$PackageExportSchema);
const $23df05604d36dcc5$export$bca9d2c38fe4cf42 = (0, $7jHWQ$zod.z).intersection($23df05604d36dcc5$var$BasePackageSchema.extend({
    evidence: (0, $7jHWQ$zod.z).object({
        components: (0, $7jHWQ$zod.z).boolean().optional(),
        databases: (0, $7jHWQ$zod.z).array((0, $7jHWQ$zod.z).string()).optional()
    })
}), $23df05604d36dcc5$var$PackageExportSchema);
const $23df05604d36dcc5$export$ac6197b8a56da2df = (0, $7jHWQ$zod.z).union([
    $23df05604d36dcc5$export$a14d030d75ef573c,
    $23df05604d36dcc5$export$bca9d2c38fe4cf42
]);



const $29b8d81193b2fd55$export$f8dc70b6d32541e2 = async (path)=>{
    try {
        const s = await (0, ($parcel$interopDefault($7jHWQ$fspromises))).stat(path);
        if (!s.isDirectory()) return false;
    } catch (e) {
        if (e instanceof Error && /** @type{NodeJS.ErrnoException} */ e.code !== "ENOENT") console.warn((0, ($parcel$interopDefault($7jHWQ$chalk))).yellow(`[!] An error occured while loading ${(0, ($parcel$interopDefault($7jHWQ$chalk))).bold(`"${path.split("node_modules/")[1]}"`)}: ${e}.`));
        else console.warn((0, ($parcel$interopDefault($7jHWQ$chalk))).yellow(`[!] ${(0, ($parcel$interopDefault($7jHWQ$chalk))).bold(`"${path.split("node_modules/")[1]}"`)} could not be found in your node_modules. Check for spelling errors or try running npm install.`));
        return false;
    }
    const c = await (0, ($parcel$interopDefault($7jHWQ$fspromises))).readdir(path);
    if (!c.includes("package.json")) return false;
    const packageContent = await (0, ($parcel$interopDefault($7jHWQ$fspromises))).readFile(`${path}/package.json`).then(/** @param {Buffer} fileContent */ (fileContent)=>JSON.parse(fileContent.toString()));
    const zodResult = (0, $23df05604d36dcc5$export$ac6197b8a56da2df).safeParse(packageContent);
    if (zodResult.success) return zodResult.data;
    else {
        console.warn((0, ($parcel$interopDefault($7jHWQ$chalk))).yellow(`[!] ${(0, ($parcel$interopDefault($7jHWQ$chalk))).bold(`"${path.split("node_modules/")[1]}"`)} could not be loaded as a plugin, it is missing a name or main field.`));
        return false;
    }
};


/**
 * Renames the '_errors' property to 'errors' in the given object and its nested objects recursively.
 * It also removes any empty errors arrays
 *
 * @param {any} obj - The object to rename the '_errors' property in.
 * @return {Object} The object with the renamed property.
 */ function $7e50c985e65305f3$export$71e7d3deffa0730b(obj) {
    for(const key in obj){
        if (typeof obj[key] === "object") $7e50c985e65305f3$export$71e7d3deffa0730b(obj[key]); // recursively traverse nested objects
        if (key === "_errors") {
            if (obj["_errors"].length) obj["errors"] = obj["_errors"];
            delete obj["_errors"];
        }
    }
    return obj;
}



const $36840fd94f7ff9d7$export$c1a4367d4847eb06 = async (rootDir)=>{
    const configPath = `${rootDir}/evidence.plugins.yaml`;
    try {
        const configFileContent = await (0, ($parcel$interopDefault($7jHWQ$fspromises))).readFile(configPath, "utf8").then((r)=>r.toString());
        // Surround all YAML key that begin with "@" in quotes
        // Skipping keys that are already quoted (e.g. beginning of line or whitespace)
        const rawConfig = (0, ($parcel$interopDefault($7jHWQ$yaml))).parse(configFileContent.replaceAll(/($|\s)(@.+):/g, '$1"$2":'));
        const configResult = (0, $42ff7a256bb4288a$export$e691085fbd9bf5be).safeParse(rawConfig);
        if (!configResult.success) {
            console.error((0, ($parcel$interopDefault($7jHWQ$chalk))).bold.red(`[!] evidence.plugins.yaml does not contain a valid configuration. \n    Plugins will not be loaded. This may lead to unexpected behavior.`));
            const formattedError = (0, $7e50c985e65305f3$export$71e7d3deffa0730b)(configResult.error.format());
            console.error((0, ($parcel$interopDefault($7jHWQ$chalk))).red("|   Discovered Errors:"));
            const redPipe = (0, ($parcel$interopDefault($7jHWQ$chalk))).red("|");
            console.error(`${redPipe}   ${(0, ($parcel$interopDefault($7jHWQ$yaml))).stringify(formattedError).replace(/\n/g, `\n${redPipe}   `)}`);
            throw new Error("Invalid evidence.plugins.yaml");
        }
        return configResult.data;
    } catch (e) {
        if (!(e instanceof Error)) throw e;
        if (e.message.startsWith("ENOENT")) {
            console.warn("Could not find evidence plugins file. Using defaults.");
            return (0, $42ff7a256bb4288a$export$e691085fbd9bf5be).parse({
                components: {
                    "@evidence-dev/core-components": {}
                }
            });
        }
        throw e;
    }
};
const $36840fd94f7ff9d7$export$4b0a2a49a61b15e5 = async (rootDir)=>{
    /** @type {EvidenceConfig} */ const configContent = await $36840fd94f7ff9d7$export$c1a4367d4847eb06(rootDir);
    /** @type {EvidencePluginPackage<ValidPackage>[]} */ const componentPackages = await Promise.all(Object.keys(configContent.components).map(/**
			 * @param {string} packageName
			 * @returns {Promise<EvidencePluginPackage<ValidPackage> | false>}
			 */ async (packageName)=>{
        const packagePath = (0, ($parcel$interopDefault($7jHWQ$path))).resolve(rootDir, "node_modules", packageName);
        const validPackage = await (0, $29b8d81193b2fd55$export$f8dc70b6d32541e2)(packagePath);
        if (!validPackage) return false;
        return {
            package: validPackage,
            path: packagePath
        };
    })).then((pack)=>/** @type {Exclude<typeof pack[number], false>[]} */ pack.filter(Boolean));
    return {
        components: componentPackages,
        databases: []
    };
};


async function $fbf5192c2c54e5f3$export$9418d811d68624a6() {
    const rootDir = await (0, $3c04bbba5863cd35$export$6de9f17ef8a8b7d7)();
    return await (0, $36840fd94f7ff9d7$export$4b0a2a49a61b15e5)(rootDir);
}












const $839afacb00ca7c88$export$71597f00c2fddf45 = (0, $7jHWQ$zod.z).object({
    components: (0, $7jHWQ$zod.z).array((0, $7jHWQ$zod.z).string())
});


async function $ed47e08a60ac6a0d$export$e709f8c5abf983ef(packagePath, rootDir) {
    try {
        // Load Config
        const manifestContent = await (0, ($parcel$interopDefault($7jHWQ$fspromises))).readFile((0, ($parcel$interopDefault($7jHWQ$path))).resolve(packagePath, "evidence.manifest.yaml")).then((r)=>r.toString());
        // Parse YAML, then validate data
        const manifest = (0, ($parcel$interopDefault($7jHWQ$yaml))).parse(manifestContent);
        const parsedManifest = (0, $839afacb00ca7c88$export$71597f00c2fddf45).safeParse(manifest);
        if (!parsedManifest.success) {
            // Shape is wrong
            console.error((0, ($parcel$interopDefault($7jHWQ$chalk))).bold.red(`[!] evidence.manifest.yaml has errors`));
            const formattedError = (0, $7e50c985e65305f3$export$71e7d3deffa0730b)(parsedManifest.error.format());
            console.error((0, ($parcel$interopDefault($7jHWQ$chalk))).red("|   Discovered Errors:"));
            const redPipe = (0, ($parcel$interopDefault($7jHWQ$chalk))).red("|");
            console.error(`${redPipe}   ${(0, ($parcel$interopDefault($7jHWQ$yaml))).stringify(formattedError).replace(/\n/g, `\n${redPipe}   `)}`);
            // TODO: How do we stop here? Do we need to throw here?
            throw new Error("Unable to load evidence manifest");
        }
        return parsedManifest.data.components;
    } catch (e) {
        if (!(e instanceof Error)) throw e;
        if (e.message === "ENOENT") {
            console.error((0, ($parcel$interopDefault($7jHWQ$chalk))).red.bold(`[!] evidence.manifest.yaml file not found in ${rootDir}.\n    This is probably a bug in Evidence; please file a report at https://github.com/evidence-dev/evidence/issues/new?assignees=&labels=bug%2C+to-review&projects=&template=bug_report.md`));
            throw e;
        }
        throw e;
    }
}





const $e53231b133114db9$export$65544fe6bfff3b3e = async (root)=>{
    /**
	 * @type {string[]}
	 */ const output = [];
    // Scan & iterate directory
    const directoryContents = await (0, ($parcel$interopDefault($7jHWQ$fspromises))).readdir(root, {
        withFileTypes: true
    });
    for (const item of directoryContents){
        // Ignore these cases
        if (item.name === "node_modules") continue; // Don't touch any dependencies
        if (item.name.startsWith(".")) continue; // Don't touch hidden files
        if (item.name.startsWith("+")) continue; // Don't touch sveltekit files
        // Build path; get item stats
        const itemPath = (0, ($parcel$interopDefault($7jHWQ$path))).resolve(root, item.name);
        if (item.isDirectory()) // Recurse on directories
        output.push(...await $e53231b133114db9$export$65544fe6bfff3b3e(itemPath));
        else if (item.name.endsWith(".svelte")) // Keep track of svelte components
        output.push(itemPath);
    }
    // Return relative filepaths
    return output.map((p)=>(0, ($parcel$interopDefault($7jHWQ$path))).relative(".", p));
};
/**
 * Reduce function to run on a svelte AST.
 * Searches for the evidenceInclude declaration.
 * @example
 *  <script context="module">
 *      export const evidenceInclude = true
 *  </script>
 *
 * @param {import("estree").Node} currentNode
 * @returns {boolean}
 */ const $e53231b133114db9$var$nodeIsEvidenceDeclaration = (currentNode)=>{
    // If this isn't the right kind of declaration, ignore it
    if (currentNode.type !== "ExportNamedDeclaration") return false;
    const rootDeclaration = currentNode.declaration;
    if (rootDeclaration?.type !== "VariableDeclaration") return false;
    // const only, this is somewhat inline with sveltekit's patterns
    if (rootDeclaration.kind !== "const") return false;
    // This shouldn't be hit, but type safety
    if (!rootDeclaration?.declarations) return false;
    // Iterate through sub-declarations, I've only ever seen 1 here
    for (const declaration of rootDeclaration.declarations){
        const { id: id , init: init  } = declaration;
        // Check to see if this is a declaration for evidenceInclude
        if (id.type !== "Identifier") continue;
        if (id.name !== "evidenceInclude") continue;
        // Check to see if the value it is declared with is a true constant
        // We could shorten this; but this reads better
        if (init?.type !== "Literal") continue;
        if (init.value !== true) continue;
        // We found what we want!
        return true;
    }
    // We never found the right declaration; continue the reduction
    return false;
};
const $e53231b133114db9$export$61e568c7425e25b1 = async (fileContent)=>{
    let result = false;
    // remove style tags, postcss can screw this up
    fileContent = fileContent.replace(/<style.*>(.|[\s])*<\/style>/g, "");
    // First parse the passed in file
    const parseResult = (0, $7jHWQ$sveltecompiler.parse)(fileContent);
    // If there is a <script> tag, check there
    if (parseResult.instance) result = result || Boolean(parseResult.instance.content.body.find($e53231b133114db9$var$nodeIsEvidenceDeclaration));
    // If there is a <script context="module"> tag, check there
    if (parseResult.module) result = result || Boolean(parseResult.module.content.body.find($e53231b133114db9$var$nodeIsEvidenceDeclaration));
    return result;
};
async function $e53231b133114db9$export$c1b3dffdfac3a83b(rootDir) {
    const componentPaths = await $e53231b133114db9$export$65544fe6bfff3b3e(rootDir);
    const results = await Promise.all(componentPaths.map(async (componentPath)=>({
            include: await $e53231b133114db9$export$61e568c7425e25b1(await (0, ($parcel$interopDefault($7jHWQ$fspromises))).readFile(componentPath).then((p)=>p.toString())).catch((e)=>{
                throw new Error(`Error while identifying ${componentPath}`, {
                    cause: e
                });
            }),
            // Get the name of the component, takes the last part of the path and removes the file extension
            componentName: (0, ($parcel$interopDefault($7jHWQ$path))).basename(componentPath, (0, ($parcel$interopDefault($7jHWQ$path))).extname(componentPath))
        })));
    return results.filter((r)=>r.include).map((r)=>r.componentName);
}


const $ded764ca0a3a5671$export$eda82cc3112dee4c = async (rootDir, packagePath, config)=>{
    const validEvidencePackage = await (0, $29b8d81193b2fd55$export$f8dc70b6d32541e2)(packagePath);
    /** @type {Set<string>} */ const providedComponents = new Set();
    // This doesn't have the required metadata
    if (!validEvidencePackage) return providedComponents;
    // This is a database connector, not a component lib
    if (validEvidencePackage.evidence && !validEvidencePackage.evidence.components) {
        console.warn((0, ($parcel$interopDefault($7jHWQ$chalk))).yellow(`[!] ${validEvidencePackage.name} is being used as a component plugin, but does not contain components.`));
        return providedComponents;
    }
    if (config.provides.length) // Use this value as the first truth
    config.provides.forEach((c)=>providedComponents.add(c));
    else if (!validEvidencePackage.evidence) {
        // This is probably an external component library that doesn't have any provides statements
        console.warn((0, ($parcel$interopDefault($7jHWQ$chalk))).yellow(`[!] ${validEvidencePackage.name} is being used as a component plugin, but does not contain plugins. You may need to add a provides statement to your manifest.`));
        return providedComponents;
    } else {
        const manifestPath = (0, ($parcel$interopDefault($7jHWQ$path))).resolve(packagePath, "evidence.manifest.yaml");
        const manifestExists = await (0, ($parcel$interopDefault($7jHWQ$fspromises))).access(manifestPath).then(()=>true).catch(()=>false);
        if (manifestExists) {
            // Use manifest
            const manifestComponents = await (0, $ed47e08a60ac6a0d$export$e709f8c5abf983ef)(packagePath, rootDir);
            manifestComponents.forEach((c)=>providedComponents.add(c));
        } else {
            // Use file discovery
            // Attempt to extract the folder that contains built assets
            const mainFilePath = (0, ($parcel$interopDefault($7jHWQ$path))).parse("main" in validEvidencePackage ? (0, ($parcel$interopDefault($7jHWQ$path))).resolve(packagePath, validEvidencePackage.main) : "svelte" in validEvidencePackage ? (0, ($parcel$interopDefault($7jHWQ$path))).resolve(packagePath, validEvidencePackage.svelte) : (0, ($parcel$interopDefault($7jHWQ$path))).resolve(packagePath, validEvidencePackage.exports["."])).dir;
            const fileComponents = await (0, $e53231b133114db9$export$c1b3dffdfac3a83b)(mainFilePath);
            fileComponents.forEach((c)=>providedComponents.add(c));
        }
    }
    return providedComponents;
};








async function $4310064352c775c0$export$757b8ee912e1a1ac(cfg, discoveries) {
    const rootDir = await (0, $3c04bbba5863cd35$export$6de9f17ef8a8b7d7)();
    const config = cfg ?? await (0, $36840fd94f7ff9d7$export$c1a4367d4847eb06)(rootDir);
    const pluginDiscoveries = discoveries ?? await (0, $fbf5192c2c54e5f3$export$9418d811d68624a6)();
    Object.values(config.components).reduce(/**
		 * @param {Set<string>} acc
		 * @param {EvidenceComponentConfig} v
		 */ (acc, v)=>{
        for (const override of v.overrides){
            if (acc.has(override)) {
                console.error((0, ($parcel$interopDefault($7jHWQ$chalk))).red(`[!] ${override} is overriden more than once. Please ensure that a component is overriden only once.`));
                throw new Error("Invalid evidence.plugins.yaml");
            }
            acc.add(override);
        }
        return acc;
    }, new Set());
    // Load all the components
    const components = await Promise.all(pluginDiscoveries.components.map(/**
			 * @param {EvidencePluginPackage<ValidPackage>} pluginPackage
			 * @returns {Promise<[string, Set<string>]>}
			 */ async (pluginPackage)=>[
            pluginPackage.package.name,
            await (0, $ded764ca0a3a5671$export$eda82cc3112dee4c)(rootDir, pluginPackage.path, config.components[pluginPackage.package.name])
        ]));
    // Now we will smush all of this into Record<ComponentName, PackageName>
    const componentMap = components.reduce(/**
		 * @param {PluginComponents} acc
		 * @param {[string, Set<string>]} p
		 */ (acc, [packageName, components])=>{
        /** @type {EvidenceComponentConfig} */ const packageConfig = config.components[packageName];
        for (const component of components){
            /** @type {PluginComponent} */ const componentObj = {
                package: packageName
            };
            const alias = packageConfig.aliases[component];
            if (alias) componentObj.aliasOf = component;
            const componentOutputName = alias ?? component;
            if (acc[componentOutputName] && !packageConfig.overrides.includes(componentOutputName)) {
                console.warn((0, ($parcel$interopDefault($7jHWQ$chalk))).yellow(`[!] ${packageName} and ${acc[componentOutputName].package} both provide ${componentOutputName}. ${acc[componentOutputName].package} will be used, to use ${packageName}, specify an alias or explicit override. (https://docs.evidence.dev/plugins#component-aliases)`));
                return acc;
            }
            if (packageConfig.overrides?.includes(componentOutputName)) {
                if (!acc[componentOutputName]) console.warn((0, ($parcel$interopDefault($7jHWQ$chalk))).yellow(`[!] ${packageName} cannot override it's own component ${componentOutputName}`));
                else componentObj.overriden = {
                    package: acc[componentOutputName].package
                };
            }
            acc[componentOutputName] = componentObj;
        }
        return acc;
    }, {});
    if ((0, ($parcel$interopDefault($7jHWQ$fs))).existsSync(`${rootDir}/components`)) {
        const user_components = await (0, $e53231b133114db9$export$65544fe6bfff3b3e)(`${rootDir}/components`);
        for (const component_file of user_components){
            const component = (0, ($parcel$interopDefault($7jHWQ$path))).basename(component_file, ".svelte");
            if (componentMap[component]) {
                console.warn((0, ($parcel$interopDefault($7jHWQ$chalk))).yellow(`[!] The components folder and ${componentMap[component].package} both provide ${component}. The component from the components folder will be used. To use the component from ${componentMap[component].package}, specify an alias (https://docs.evidence.dev/plugins/using-plugins/#component-aliases) or explicitly import the component.`));
                delete componentMap[component];
            }
        }
    }
    return componentMap;
}



const $47ed4bd10d97bb7e$export$4afb816e967c52c1 = ()=>{
    const componentPlugins = (0, $4310064352c775c0$export$757b8ee912e1a1ac)();
    const packages = componentPlugins.then((components)=>{
        /** @type {Record<string,string[]>} */ const packages = {};
        for (const [component, data] of Object.entries(components)){
            if (!packages[data.package]) packages[data.package] = [];
            const import_name = data.aliasOf ? `${data.aliasOf} as ${component}` : component;
            packages[data.package].push(import_name);
        }
        return packages;
    });
    const autoImporter = packages.then((packages)=>(0, ($parcel$interopDefault($7jHWQ$sveltekitautoimport)))({
            include: [
                "**/*.(svelte|md)"
            ],
            module: packages,
            components: [
                {
                    directory: "../../components",
                    flat: true
                }
            ]
        }));
    return {
        /** @type {import("svelte/types/compiler/preprocess").MarkupPreprocessor}} */ markup: async ({ content: content , filename: filename  })=>{
            const components = await componentPlugins.catch(()=>false);
            if (!components) return;
            const { markup: autoimport_process_markup  } = await autoImporter;
            return autoimport_process_markup({
                content: content,
                filename: filename
            });
        },
        /** @type {import("svelte/types/compiler/preprocess").Preprocessor}} */ style: async ()=>{},
        /** @type {import("svelte/types/compiler/preprocess").Preprocessor}} */ script: async ()=>{}
    };
};


var $767e256a365d28dc$exports = {};

$parcel$export($767e256a365d28dc$exports, "evidenceRollup", () => $767e256a365d28dc$export$1337da85e733ac15);
/**
 *
 */ function $767e256a365d28dc$export$1337da85e733ac15() {
    throw new Error("Evidence Rollup Plugin not implemented");
}


$parcel$exportWildcard(module.exports, $47ed4bd10d97bb7e$exports);
$parcel$exportWildcard(module.exports, $767e256a365d28dc$exports);


//# sourceMappingURL=index.cjs.map
